var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _Matrix_instances, initData_fn, _a, _matrix;
import { g as getDefaultExportFromCjs, a as getAugmentedNamespace, c as commonjsGlobal } from "./element-plus-DavumCtP.js";
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function toPrimitive(t3, r2) {
  if ("object" != _typeof(t3) || !t3) return t3;
  var e3 = t3[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t3, r2);
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t3);
}
function toPropertyKey(t3) {
  var i2 = toPrimitive(t3, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _defineProperty$1(e3, r2, t3) {
  return (r2 = toPropertyKey(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t3,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t3, e3;
}
function ownKeys(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o2);
  }
  return t3;
}
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t3), true).forEach(function(r3) {
      _defineProperty$1(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
function _classCallCheck(a2, n2) {
  if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e3, r2) {
  for (var t3 = 0; t3 < r2.length; t3++) {
    var o2 = r2[t3];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, toPropertyKey(o2.key), o2);
  }
}
function _createClass(e3, r2, t3) {
  return r2 && _defineProperties(e3.prototype, r2), t3 && _defineProperties(e3, t3), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e3 = 0, n2 = Array(a2); e3 < a2; e3++) n2[e3] = r2[e3];
  return n2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
    var t3 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t3 && r2.constructor && (t3 = r2.constructor.name), "Map" === t3 || "Set" === t3 ? Array.from(r2) : "Arguments" === t3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _getPrototypeOf(t3) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf(t3);
}
function _isNativeReflectConstruct() {
  try {
    var t3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t3;
  })();
}
function _assertThisInitialized(e3) {
  if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}
function _possibleConstructorReturn(t3, e3) {
  if (e3 && ("object" == _typeof(e3) || "function" == typeof e3)) return e3;
  if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t3);
}
function _callSuper(t3, o2, e3) {
  return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t3, _isNativeReflectConstruct() ? Reflect.construct(o2, e3 || [], _getPrototypeOf(t3).constructor) : o2.apply(t3, e3));
}
function _setPrototypeOf(t3, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
    return t4.__proto__ = e4, t4;
  }, _setPrototypeOf(t3, e3);
}
function _inherits(t3, e3) {
  if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
  t3.prototype = Object.create(e3 && e3.prototype, {
    constructor: {
      value: t3,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t3, "prototype", {
    writable: false
  }), e3 && _setPrototypeOf(t3, e3);
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _iterableToArrayLimit(r2, l2) {
  var t3 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t3) {
    var e3, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t3 = t3.call(r2)).next, 0 === l2) {
        if (Object(t3) !== t3) return;
        f2 = false;
      } else for (; !(f2 = (e3 = i2.call(t3)).done) && (a2.push(e3.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t3["return"] && (u2 = t3["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r2, e3) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e3) || _unsupportedIterableToArray(r2, e3) || _nonIterableRest();
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var EPSILON$2 = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var ANGLE_ORDER = "zyx";
function create$6() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[4];
  out[4] = a2[5];
  out[5] = a2[6];
  out[6] = a2[8];
  out[7] = a2[9];
  out[8] = a2[10];
  return out;
}
function fromValues$4(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function create$5() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone$3(a2) {
  var out = new ARRAY_TYPE(16);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function copy$4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function fromValues$3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set$6(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity$1(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose$1(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a12 = a2[6], a13 = a2[7];
    var a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert$1(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant$1(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b0 = a00 * a11 - a01 * a10;
  var b1 = a00 * a12 - a02 * a10;
  var b2 = a01 * a12 - a02 * a11;
  var b3 = a20 * a31 - a21 * a30;
  var b4 = a20 * a32 - a22 * a30;
  var b5 = a21 * a32 - a22 * a31;
  var b6 = a00 * b5 - a01 * b4 + a02 * b3;
  var b7 = a10 * b5 - a11 * b4 + a12 * b3;
  var b8 = a20 * b2 - a21 * b1 + a22 * b0;
  var b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply$3(out, a2, b2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[4];
  b1 = b2[5];
  b22 = b2[6];
  b3 = b2[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[8];
  b1 = b2[9];
  b22 = b2[10];
  b3 = b2[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[12];
  b1 = b2[13];
  b22 = b2[14];
  b3 = b2[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  return out;
}
function translate(out, a2, v2) {
  var x2 = v2[0], y2 = v2[1], z2 = v2[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a2 === out) {
    out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z2 + a2[12];
    out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z2 + a2[13];
    out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z2 + a2[14];
    out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z2 + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z2 + a2[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z2 + a2[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z2 + a2[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z2 + a2[15];
  }
  return out;
}
function scale$3(out, a2, v2) {
  var x2 = v2[0], y2 = v2[1], z2 = v2[2];
  out[0] = a2[0] * x2;
  out[1] = a2[1] * x2;
  out[2] = a2[2] * x2;
  out[3] = a2[3] * x2;
  out[4] = a2[4] * y2;
  out[5] = a2[5] * y2;
  out[6] = a2[6] * y2;
  out[7] = a2[7] * y2;
  out[8] = a2[8] * z2;
  out[9] = a2[9] * z2;
  out[10] = a2[10] * z2;
  out[11] = a2[11] * z2;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate$1(out, a2, rad3, axis) {
  var x2 = axis[0], y2 = axis[1], z2 = axis[2];
  var len2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  var s3, c2, t3;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len2 < EPSILON$2) {
    return null;
  }
  len2 = 1 / len2;
  x2 *= len2;
  y2 *= len2;
  z2 *= len2;
  s3 = Math.sin(rad3);
  c2 = Math.cos(rad3);
  t3 = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x2 * x2 * t3 + c2;
  b01 = y2 * x2 * t3 + z2 * s3;
  b02 = z2 * x2 * t3 - y2 * s3;
  b10 = x2 * y2 * t3 - z2 * s3;
  b11 = y2 * y2 * t3 + c2;
  b12 = z2 * y2 * t3 + x2 * s3;
  b20 = x2 * z2 * t3 + y2 * s3;
  b21 = y2 * z2 * t3 - x2 * s3;
  b22 = z2 * z2 * t3 + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX(out, a2, rad3) {
  var s3 = Math.sin(rad3);
  var c2 = Math.cos(rad3);
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s3;
  out[5] = a11 * c2 + a21 * s3;
  out[6] = a12 * c2 + a22 * s3;
  out[7] = a13 * c2 + a23 * s3;
  out[8] = a20 * c2 - a10 * s3;
  out[9] = a21 * c2 - a11 * s3;
  out[10] = a22 * c2 - a12 * s3;
  out[11] = a23 * c2 - a13 * s3;
  return out;
}
function rotateY(out, a2, rad3) {
  var s3 = Math.sin(rad3);
  var c2 = Math.cos(rad3);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s3;
  out[1] = a01 * c2 - a21 * s3;
  out[2] = a02 * c2 - a22 * s3;
  out[3] = a03 * c2 - a23 * s3;
  out[8] = a00 * s3 + a20 * c2;
  out[9] = a01 * s3 + a21 * c2;
  out[10] = a02 * s3 + a22 * c2;
  out[11] = a03 * s3 + a23 * c2;
  return out;
}
function rotateZ(out, a2, rad3) {
  var s3 = Math.sin(rad3);
  var c2 = Math.cos(rad3);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s3;
  out[1] = a01 * c2 + a11 * s3;
  out[2] = a02 * c2 + a12 * s3;
  out[3] = a03 * c2 + a13 * s3;
  out[4] = a10 * c2 - a00 * s3;
  out[5] = a11 * c2 - a01 * s3;
  out[6] = a12 * c2 - a02 * s3;
  out[7] = a13 * c2 - a03 * s3;
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad3, axis) {
  var x2 = axis[0], y2 = axis[1], z2 = axis[2];
  var len2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  var s3, c2, t3;
  if (len2 < EPSILON$2) {
    return null;
  }
  len2 = 1 / len2;
  x2 *= len2;
  y2 *= len2;
  z2 *= len2;
  s3 = Math.sin(rad3);
  c2 = Math.cos(rad3);
  t3 = 1 - c2;
  out[0] = x2 * x2 * t3 + c2;
  out[1] = y2 * x2 * t3 + z2 * s3;
  out[2] = z2 * x2 * t3 - y2 * s3;
  out[3] = 0;
  out[4] = x2 * y2 * t3 - z2 * s3;
  out[5] = y2 * y2 * t3 + c2;
  out[6] = z2 * y2 * t3 + x2 * s3;
  out[7] = 0;
  out[8] = x2 * z2 * t3 + y2 * s3;
  out[9] = y2 * z2 * t3 - x2 * s3;
  out[10] = z2 * z2 * t3 + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad3) {
  var s3 = Math.sin(rad3);
  var c2 = Math.cos(rad3);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c2;
  out[6] = s3;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s3;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad3) {
  var s3 = Math.sin(rad3);
  var c2 = Math.cos(rad3);
  out[0] = c2;
  out[1] = 0;
  out[2] = -s3;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s3;
  out[9] = 0;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad3) {
  var s3 = Math.sin(rad3);
  var c2 = Math.cos(rad3);
  out[0] = c2;
  out[1] = s3;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s3;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v2) {
  var x2 = q[0], y2 = q[1], z2 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y2 * y22;
  var yz = y2 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a2) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a2, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function decompose$1(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  var is1 = 1 / out_s[0];
  var is2 = 1 / out_s[1];
  var is3 = 1 / out_s[2];
  var sm11 = m11 * is1;
  var sm12 = m12 * is2;
  var sm13 = m13 * is3;
  var sm21 = m21 * is1;
  var sm22 = m22 * is2;
  var sm23 = m23 * is3;
  var sm31 = m31 * is1;
  var sm32 = m32 * is2;
  var sm33 = m33 * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S2;
    out_r[0] = (sm23 - sm32) / S2;
    out_r[1] = (sm31 - sm13) / S2;
    out_r[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S2;
    out_r[0] = 0.25 * S2;
    out_r[1] = (sm12 + sm21) / S2;
    out_r[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S2;
    out_r[0] = (sm12 + sm21) / S2;
    out_r[1] = 0.25 * S2;
    out_r[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S2;
    out_r[0] = (sm31 + sm13) / S2;
    out_r[1] = (sm23 + sm32) / S2;
    out_r[2] = 0.25 * S2;
  }
  return out_r;
}
function fromRotationTranslationScale$1(out, q, v2, s3) {
  var x2 = q[0], y2 = q[1], z2 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y2 * y22;
  var yz = y2 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s3[0];
  var sy = s3[1];
  var sz = s3[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v2, s3, o2) {
  var x2 = q[0], y2 = q[1], z2 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y2 * y22;
  var yz = y2 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s3[0];
  var sy = s3[1];
  var sz = s3[2];
  var ox = o2[0];
  var oy = o2[1];
  var oz = o2[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x2 = q[0], y2 = q[1], z2 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var yx = y2 * x22;
  var yy = y2 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON$2 && Math.abs(eyey - centery) < EPSILON$2 && Math.abs(eyez - centerz) < EPSILON$2) {
    return identity$1(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len2 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len2;
  z1 *= len2;
  z2 *= len2;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len2 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len2) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len2 = 1 / len2;
    x0 *= len2;
    x1 *= len2;
    x2 *= len2;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len2 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len2) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len2 = 1 / len2;
    y0 *= len2;
    y1 *= len2;
    y2 *= len2;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len2 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
    z0 *= len2;
    z1 *= len2;
    z2 *= len2;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len2 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
    x0 *= len2;
    x1 *= len2;
    x2 *= len2;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str(a2) {
  return "mat4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ", " + a2[9] + ", " + a2[10] + ", " + a2[11] + ", " + a2[12] + ", " + a2[13] + ", " + a2[14] + ", " + a2[15] + ")";
}
function frob(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8] + a2[9] * a2[9] + a2[10] * a2[10] + a2[11] * a2[11] + a2[12] * a2[12] + a2[13] * a2[13] + a2[14] * a2[14] + a2[15] * a2[15]);
}
function add$6(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  out[4] = a2[4] + b2[4];
  out[5] = a2[5] + b2[5];
  out[6] = a2[6] + b2[6];
  out[7] = a2[7] + b2[7];
  out[8] = a2[8] + b2[8];
  out[9] = a2[9] + b2[9];
  out[10] = a2[10] + b2[10];
  out[11] = a2[11] + b2[11];
  out[12] = a2[12] + b2[12];
  out[13] = a2[13] + b2[13];
  out[14] = a2[14] + b2[14];
  out[15] = a2[15] + b2[15];
  return out;
}
function subtract$2(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  out[4] = a2[4] - b2[4];
  out[5] = a2[5] - b2[5];
  out[6] = a2[6] - b2[6];
  out[7] = a2[7] - b2[7];
  out[8] = a2[8] - b2[8];
  out[9] = a2[9] - b2[9];
  out[10] = a2[10] - b2[10];
  out[11] = a2[11] - b2[11];
  out[12] = a2[12] - b2[12];
  out[13] = a2[13] - b2[13];
  out[14] = a2[14] - b2[14];
  out[15] = a2[15] - b2[15];
  return out;
}
function multiplyScalar(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  out[4] = a2[4] * b2;
  out[5] = a2[5] * b2;
  out[6] = a2[6] * b2;
  out[7] = a2[7] * b2;
  out[8] = a2[8] * b2;
  out[9] = a2[9] * b2;
  out[10] = a2[10] * b2;
  out[11] = a2[11] * b2;
  out[12] = a2[12] * b2;
  out[13] = a2[13] * b2;
  out[14] = a2[14] * b2;
  out[15] = a2[15] * b2;
  return out;
}
function multiplyScalarAndAdd(out, a2, b2, scale3) {
  out[0] = a2[0] + b2[0] * scale3;
  out[1] = a2[1] + b2[1] * scale3;
  out[2] = a2[2] + b2[2] * scale3;
  out[3] = a2[3] + b2[3] * scale3;
  out[4] = a2[4] + b2[4] * scale3;
  out[5] = a2[5] + b2[5] * scale3;
  out[6] = a2[6] + b2[6] * scale3;
  out[7] = a2[7] + b2[7] * scale3;
  out[8] = a2[8] + b2[8] * scale3;
  out[9] = a2[9] + b2[9] * scale3;
  out[10] = a2[10] + b2[10] * scale3;
  out[11] = a2[11] + b2[11] * scale3;
  out[12] = a2[12] + b2[12] * scale3;
  out[13] = a2[13] + b2[13] * scale3;
  out[14] = a2[14] + b2[14] * scale3;
  out[15] = a2[15] + b2[15] * scale3;
  return out;
}
function exactEquals$1(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3] && a2[4] === b2[4] && a2[5] === b2[5] && a2[6] === b2[6] && a2[7] === b2[7] && a2[8] === b2[8] && a2[9] === b2[9] && a2[10] === b2[10] && a2[11] === b2[11] && a2[12] === b2[12] && a2[13] === b2[13] && a2[14] === b2[14] && a2[15] === b2[15];
}
function equals$1(a2, b2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7];
  var a8 = a2[8], a9 = a2[9], a10 = a2[10], a11 = a2[11];
  var a12 = a2[12], a13 = a2[13], a14 = a2[14], a15 = a2[15];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  var b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7];
  var b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11];
  var b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
  return Math.abs(a0 - b0) <= EPSILON$2 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$2 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON$2 * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON$2 * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$2 * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$2 * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON$2 * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON$2 * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON$2 * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON$2 * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON$2 * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON$2 * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON$2 * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON$2 * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON$2 * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON$2 * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul$1 = multiply$3;
var sub$2 = subtract$2;
const mat4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: add$6,
  adjoint,
  clone: clone$3,
  copy: copy$4,
  create: create$5,
  decompose: decompose$1,
  determinant: determinant$1,
  equals: equals$1,
  exactEquals: exactEquals$1,
  frob,
  fromQuat,
  fromQuat2,
  fromRotation,
  fromRotationTranslation,
  fromRotationTranslationScale: fromRotationTranslationScale$1,
  fromRotationTranslationScaleOrigin,
  fromScaling,
  fromTranslation,
  fromValues: fromValues$3,
  fromXRotation,
  fromYRotation,
  fromZRotation,
  frustum,
  getRotation,
  getScaling,
  getTranslation,
  identity: identity$1,
  invert: invert$1,
  lookAt,
  mul: mul$1,
  multiply: multiply$3,
  multiplyScalar,
  multiplyScalarAndAdd,
  ortho,
  orthoNO,
  orthoZO,
  perspective,
  perspectiveFromFieldOfView,
  perspectiveNO,
  perspectiveZO,
  rotate: rotate$1,
  rotateX,
  rotateY,
  rotateZ,
  scale: scale$3,
  set: set$6,
  str,
  sub: sub$2,
  subtract: subtract$2,
  targetTo,
  translate,
  transpose: transpose$1
}, Symbol.toStringTag, { value: "Module" }));
function create$4() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone$2(a2) {
  var out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length(a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function fromValues$2(x2, y2, z2) {
  var out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function copy$3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set$5(out, x2, y2, z2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function add$5(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  return out;
}
function subtract$1(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  return out;
}
function multiply$2(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  return out;
}
function min$3(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  return out;
}
function max$3(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  return out;
}
function scale$2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  return out;
}
function distance$6(a2, b2) {
  var x2 = b2[0] - a2[0];
  var y2 = b2[1] - a2[1];
  var z2 = b2[2] - a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function normalize$9(out, a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  var len2 = x2 * x2 + y2 * y2 + z2 * z2;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a2[0] * len2;
  out[1] = a2[1] * len2;
  out[2] = a2[2] * len2;
  return out;
}
function dot$4(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cross$2(out, a2, b2) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b2[0], by = b2[1], bz = b2[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp$1(out, a2, b2, t3) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t3 * (b2[0] - ax);
  out[1] = ay + t3 * (b2[1] - ay);
  out[2] = az + t3 * (b2[2] - az);
  return out;
}
function transformMat4$1(out, a2, m3) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  var w2 = m3[3] * x2 + m3[7] * y2 + m3[11] * z2 + m3[15];
  w2 = w2 || 1;
  out[0] = (m3[0] * x2 + m3[4] * y2 + m3[8] * z2 + m3[12]) / w2;
  out[1] = (m3[1] * x2 + m3[5] * y2 + m3[9] * z2 + m3[13]) / w2;
  out[2] = (m3[2] * x2 + m3[6] * y2 + m3[10] * z2 + m3[14]) / w2;
  return out;
}
function transformMat3(out, a2, m3) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  out[0] = x2 * m3[0] + y2 * m3[3] + z2 * m3[6];
  out[1] = x2 * m3[1] + y2 * m3[4] + z2 * m3[7];
  out[2] = x2 * m3[2] + y2 * m3[5] + z2 * m3[8];
  return out;
}
function transformQuat(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a2[0], vy = a2[1], vz = a2[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function equals(a2, b2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2];
  return Math.abs(a0 - b0) <= EPSILON$2 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$2 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON$2 * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub$1 = subtract$1;
var dist = distance$6;
var len = length;
(function() {
  var vec = create$4();
  return function(a2, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
    }
    return a2;
  };
})();
function create$3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function fromValues$1(x2, y2, z2, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function copy$2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set$4(out, x2, y2, z2, w2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function normalize$8(out, a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  var w2 = a2[3];
  var len2 = x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x2 * len2;
  out[1] = y2 * len2;
  out[2] = z2 * len2;
  out[3] = w2 * len2;
  return out;
}
function transformMat4(out, a2, m3) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2], w2 = a2[3];
  out[0] = m3[0] * x2 + m3[4] * y2 + m3[8] * z2 + m3[12] * w2;
  out[1] = m3[1] * x2 + m3[5] * y2 + m3[9] * z2 + m3[13] * w2;
  out[2] = m3[2] * x2 + m3[6] * y2 + m3[10] * z2 + m3[14] * w2;
  out[3] = m3[3] * x2 + m3[7] * y2 + m3[11] * z2 + m3[15] * w2;
  return out;
}
(function() {
  var vec = create$3();
  return function(a2, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      vec[3] = a2[i2 + 3];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
      a2[i2 + 3] = vec[3];
    }
    return a2;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad3) {
  rad3 = rad3 * 0.5;
  var s3 = Math.sin(rad3);
  out[0] = s3 * axis[0];
  out[1] = s3 * axis[1];
  out[2] = s3 * axis[2];
  out[3] = Math.cos(rad3);
  return out;
}
function multiply$1(out, a2, b2) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b2[0], by = b2[1], bz = b2[2], bw = b2[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function slerp(out, a2, b2, t3) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b2[0], by = b2[1], bz = b2[2], bw = b2[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON$2) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t3) * omega) / sinom;
    scale1 = Math.sin(t3 * omega) / sinom;
  } else {
    scale0 = 1 - t3;
    scale1 = t3;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert(out, a2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var dot2 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  var invDot = dot2 ? 1 / dot2 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function fromMat3(out, m3) {
  var fTrace = m3[0] + m3[4] + m3[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m3[5] - m3[7]) * fRoot;
    out[1] = (m3[6] - m3[2]) * fRoot;
    out[2] = (m3[1] - m3[3]) * fRoot;
  } else {
    var i2 = 0;
    if (m3[4] > m3[0]) i2 = 1;
    if (m3[8] > m3[i2 * 3 + i2]) i2 = 2;
    var j = (i2 + 1) % 3;
    var k = (i2 + 2) % 3;
    fRoot = Math.sqrt(m3[i2 * 3 + i2] - m3[j * 3 + j] - m3[k * 3 + k] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m3[j * 3 + k] - m3[k * 3 + j]) * fRoot;
    out[j] = (m3[j * 3 + i2] + m3[i2 * 3 + j]) * fRoot;
    out[k] = (m3[k * 3 + i2] + m3[i2 * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x2, y2, z2) {
  var order2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ANGLE_ORDER;
  var halfToRad = Math.PI / 360;
  x2 *= halfToRad;
  z2 *= halfToRad;
  y2 *= halfToRad;
  var sx = Math.sin(x2);
  var cx = Math.cos(x2);
  var sy = Math.sin(y2);
  var cy = Math.cos(y2);
  var sz = Math.sin(z2);
  var cz = Math.cos(z2);
  switch (order2) {
    case "xyz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "xzy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yxz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yzx":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zxy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zyx":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error("Unknown angle order " + order2);
  }
  return out;
}
var fromValues = fromValues$1;
var copy$1 = copy$2;
var set$3 = set$4;
var mul = multiply$1;
var normalize$7 = normalize$8;
(function() {
  var tmpvec3 = create$4();
  var xUnitVec3 = fromValues$2(1, 0, 0);
  var yUnitVec3 = fromValues$2(0, 1, 0);
  return function(out, a2, b2) {
    var dot2 = dot$4(a2, b2);
    if (dot2 < -0.999999) {
      cross$2(tmpvec3, xUnitVec3, a2);
      if (len(tmpvec3) < 1e-6) cross$2(tmpvec3, yUnitVec3, a2);
      normalize$9(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot2 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross$2(tmpvec3, a2, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot2;
      return normalize$7(out, out);
    }
  };
})();
(function() {
  var temp1 = create$2();
  var temp2 = create$2();
  return function(out, a2, b2, c2, d3, t3) {
    slerp(temp1, a2, d3, t3);
    slerp(temp2, b2, c2, t3);
    slerp(out, temp1, temp2, 2 * t3 * (1 - t3));
    return out;
  };
})();
(function() {
  var matr = create$6();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$7(out, fromMat3(out, matr));
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set$2(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
}
function normalize$6(out, a2) {
  var x2 = a2[0], y2 = a2[1];
  var len2 = x2 * x2 + y2 * y2;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a2[0] * len2;
  out[1] = a2[1] * len2;
  return out;
}
function dot$3(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
}
function exactEquals(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1];
}
(function() {
  var vec = create$1();
  return function(a2, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
    }
    return a2;
  };
})();
var isArrayLike = function(value) {
  return value !== null && typeof value !== "function" && isFinite(value.length);
};
var contains$1 = function(arr, value) {
  if (!isArrayLike(arr)) {
    return false;
  }
  return arr.indexOf(value) > -1;
};
var filter = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value = arr[index2];
    if (func(value, index2)) {
      result.push(value);
    }
  }
  return result;
};
var difference = function(arr, values2) {
  if (values2 === void 0) {
    values2 = [];
  }
  return filter(arr, function(value) {
    return !contains$1(values2, value);
  });
};
function isFunction$1(value) {
  return typeof value === "function";
}
function isNil(value) {
  return value === null || value === void 0;
}
function isArray$2(value) {
  return Array.isArray(value);
}
const isObject$2 = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};
function each$2(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray$2(elements)) {
    for (var i2 = 0, len2 = elements.length; i2 < len2; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject$2(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
var toString$4 = {}.toString;
var isType$1 = function(value, type) {
  return toString$4.call(value) === "[object " + type + "]";
};
var isPlainObject = function(value) {
  if (!isObjectLike(value) || !isType$1(value, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var flatten = function(arr) {
  if (!isArray$2(arr)) {
    return [];
  }
  var rst = [];
  for (var i2 = 0; i2 < arr.length; i2++) {
    rst = rst.concat(arr[i2]);
  }
  return rst;
};
function max$2(arr) {
  if (!Array.isArray(arr))
    return -Infinity;
  var length2 = arr.length;
  if (!length2)
    return -Infinity;
  var max2 = arr[0];
  for (var i2 = 1; i2 < length2; i2++) {
    max2 = Math.max(max2, arr[i2]);
  }
  return max2;
}
const min$2 = function(arr) {
  if (!isArray$2(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};
var reduce = function(arr, fn, init) {
  if (!isArray$2(arr) && !isPlainObject(arr)) {
    return arr;
  }
  var result = init;
  each$2(arr, function(data2, i2) {
    result = fn(result, data2, i2);
  });
  return result;
};
function isString$1(value) {
  return typeof value === "string";
}
function uniq(arr, cache) {
  if (cache === void 0) {
    cache = /* @__PURE__ */ new Map();
  }
  var r2 = [];
  if (Array.isArray(arr)) {
    for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      var item = arr[i2];
      if (!cache.has(item)) {
        r2.push(item);
        cache.set(item, true);
      }
    }
  }
  return r2;
}
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
function groupBy$1(data2, condition) {
  if (!condition || !isArray$2(data2)) {
    return {};
  }
  var result = {};
  var predicate = isFunction$1(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i2 = 0; i2 < data2.length; i2++) {
    var item = data2[i2];
    key = predicate(item);
    if (hasOwnProperty$3.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var clamp$1 = function(a2, min2, max2) {
  if (a2 < min2) {
    return min2;
  } else if (a2 > max2) {
    return max2;
  }
  return a2;
};
function isNumber(value) {
  return typeof value === "number";
}
var PRECISION = 1e-5;
function isNumberEqual(a2, b2, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return a2 === b2 || Math.abs(a2 - b2) < precision;
}
const maxBy = function(arr, fn) {
  if (!isArray$2(arr)) {
    return void 0;
  }
  var maxItem;
  var max2 = -Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var item = arr[i2];
    var v2 = isFunction$1(fn) ? fn(item) : item[fn];
    if (v2 > max2) {
      maxItem = item;
      max2 = v2;
    }
  }
  return maxItem;
};
const minBy$1 = function(arr, fn) {
  if (!isArray$2(arr)) {
    return void 0;
  }
  var minItem;
  var min2 = Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var item = arr[i2];
    var v2 = isFunction$1(fn) ? fn(item) : item[fn];
    if (v2 < min2) {
      minItem = item;
      min2 = v2;
    }
  }
  return minItem;
};
var mod$1 = function(n2, m3) {
  return (n2 % m3 + m3) % m3;
};
const toString$3 = function(value) {
  if (isNil(value))
    return "";
  return value.toString();
};
var lowerFirst = function(value) {
  var str2 = toString$3(value);
  return str2.charAt(0).toLowerCase() + str2.substring(1);
};
function substitute(str2, o2) {
  if (!str2 || !o2) {
    return str2;
  }
  return str2.replace(/\\?\{([^{}]+)\}/g, function(match2, name) {
    if (match2.charAt(0) === "\\") {
      return match2.slice(1);
    }
    return o2[name] === void 0 ? "" : o2[name];
  });
}
var upperFirst = function(value) {
  var str2 = toString$3(value);
  return str2.charAt(0).toUpperCase() + str2.substring(1);
};
var toString$2 = {}.toString;
var getType$1 = function(value) {
  return toString$2.call(value).replace(/^\[object /, "").replace(/]$/, "");
};
var isBoolean = function(value) {
  return isType$1(value, "Boolean");
};
function isDate(value) {
  return value instanceof Date;
}
function isNull(value) {
  return value === null;
}
var objectProto = Object.prototype;
var isPrototype = function(value) {
  var Ctor = value && value.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value === proto;
};
var isUndefined = function(value) {
  return value === void 0;
};
function isElement$2(value) {
  return value instanceof Element || value instanceof Document;
}
function _mix(dist2, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist2[key] = obj[key];
    }
  }
}
function mix(dist2, src1, src2, src3) {
  if (src1)
    _mix(dist2, src1);
  if (src2)
    _mix(dist2, src2);
  return dist2;
}
var clone$1 = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray$2(obj)) {
    rst = [];
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (typeof obj[i2] === "object" && obj[i2] != null) {
        rst[i2] = clone$1(obj[i2]);
      } else {
        rst[i2] = obj[i2];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (typeof obj[k] === "object" && obj[k] != null) {
        rst[k] = clone$1(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }
  return rst;
};
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      {
        func.apply(context, args);
      }
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
  };
}
function flru(max2) {
  var num, curr, prev;
  var limit = max2 || 1;
  function keep(key, value) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}
var CacheMap = /* @__PURE__ */ new Map();
function memoize$2(fn, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn))
      CacheMap.set(fn, flru(maxSize));
    var cache = CacheMap.get(fn);
    if (cache.has(key))
      return cache.get(key);
    var result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
  return memoized;
}
var MAX_MIX_LEVEL$1 = 5;
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix(dist2, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL$1;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value = src[key];
      if (value !== null && isPlainObject(value)) {
        if (!isPlainObject(dist2[key])) {
          dist2[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist2[key], value, level + 1, maxLevel);
        } else {
          dist2[key] = src[key];
        }
      } else if (isArray$2(value)) {
        dist2[key] = [];
        dist2[key] = dist2[key].concat(value);
      } else if (value !== void 0) {
        dist2[key] = value;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    _deepMix(rst, args[i2]);
  }
  return rst;
};
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function isEmpty(value) {
  if (isNil(value)) {
    return true;
  }
  if (isArrayLike(value)) {
    return !value.length;
  }
  var type = getType$1(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEqual$1 = function(value, other) {
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  if (isString$1(value) || isString$1(other)) {
    return false;
  }
  if (isArrayLike(value) || isArrayLike(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < value.length; i2++) {
      rst = isEqual$1(value[i2], other[i2]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (isObjectLike(value) || isObjectLike(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < valueKeys.length; i2++) {
      rst = isEqual$1(value[valueKeys[i2]], other[valueKeys[i2]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
const get$1 = function(obj, key, defaultValue) {
  var p2 = 0;
  var keyArr = isString$1(key) ? key.split(".") : key;
  while (obj && p2 < keyArr.length) {
    obj = obj[keyArr[p2++]];
  }
  return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
};
const set$1 = function(obj, path, value) {
  var o2 = obj;
  var keyArr = isString$1(path) ? path.split(".") : path;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!isObject$2(o2[key])) {
        o2[key] = isNumber(keyArr[idx + 1]) ? [] : {};
      }
      o2 = o2[key];
    } else {
      o2[key] = value;
    }
  });
  return obj;
};
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const pick = function(object, keys) {
  if (object === null || !isPlainObject(object)) {
    return {};
  }
  var result = {};
  each$2(keys, function(key) {
    if (hasOwnProperty$1.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};
const omit$1 = function(obj, keys) {
  return reduce(obj, function(r2, curr, key) {
    if (!keys.includes(key)) {
      r2[key] = curr;
    }
    return r2;
  }, {});
};
const throttle = function(func, wait, options) {
  var timeout2, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now2 = Date.now();
    if (!previous && options.leading === false)
      previous = now2;
    var remaining = wait - (now2 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now2;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};
var map = {};
const uniqueId$1 = function(prefix) {
  prefix = prefix || "g";
  if (!map[prefix]) {
    map[prefix] = 1;
  } else {
    map[prefix] += 1;
  }
  return prefix + map[prefix];
};
const noop$1 = function() {
};
const identity = function(v2) {
  return v2;
};
var extendStatics$1 = function(d3, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
  };
  return extendStatics$1(d3, b2);
};
function __extends$1(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2)) t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest$m(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
}
function __awaiter$r(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s3 += arguments[i2].length;
  for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
      r2[k] = a2[j];
  return r2;
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e3 = new Error(message);
  return e3.name = "SuppressedError", e3.error = error2, e3.suppressed = suppressed, e3;
};
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};
function fixArc(pathArray, allPathCommands, i2) {
  if (pathArray[i2].length > 7) {
    pathArray[i2].shift();
    var pi = pathArray[i2];
    var ni = i2;
    while (pi.length) {
      allPathCommands[i2] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi.splice(0, 6)));
    }
    pathArray.splice(i2, 1);
  }
}
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};
function isPathArray(path) {
  return Array.isArray(path) && path.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}
function isAbsoluteArray(path) {
  return isPathArray(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path.every(function(_a3) {
    var x2 = _a3[0];
    return x2 === x2.toUpperCase();
  });
}
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(function(_a3) {
    var pc = _a3[0];
    return "ACLMQZ".includes(pc);
  });
}
function finalizeSegment(path) {
  var pathCommand = path.pathValue[path.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}
function scanFlag(path) {
  var index2 = path.index, pathValue = path.pathValue;
  var code = pathValue.charCodeAt(index2);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index2], '", expecting 0 or 1 at index ').concat(index2);
}
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit$1(code) {
  return code >= 48 && code <= 57;
}
function scanParam(path) {
  var max2 = path.max, pathValue = path.pathValue, start = path.index;
  var index2 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch;
  if (index2 >= max2) {
    path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "pathValue" is missing param');
    return;
  }
  ch = pathValue.charCodeAt(index2);
  if (ch === 43 || ch === 45) {
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
  }
  if (!isDigit$1(ch) && ch !== 46) {
    path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" is not a number');
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (zeroFirst && index2 < max2) {
      if (ch && isDigit$1(ch)) {
        path.err = "[path-util]: Invalid path value at index ".concat(start, ', "').concat(pathValue[start], '" illegal number');
        return;
      }
    }
    while (index2 < max2 && isDigit$1(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 46) {
    hasDot = true;
    index2 += 1;
    while (isDigit$1(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid float exponent');
      return;
    }
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (ch === 43 || ch === 45) {
      index2 += 1;
    }
    if (index2 < max2 && isDigit$1(pathValue.charCodeAt(index2))) {
      while (index2 < max2 && isDigit$1(pathValue.charCodeAt(index2))) {
        index2 += 1;
      }
    } else {
      path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid integer exponent');
      return;
    }
  }
  path.index = index2;
  path.param = +path.pathValue.slice(start, index2);
}
function isSpace(ch) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
  // White spaces
  ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}
function skipSpaces(path) {
  var pathValue = path.pathValue, max2 = path.max;
  while (path.index < max2 && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}
function isArcCommand(code) {
  return (code | 32) === 97;
}
function scanSegment(path) {
  var max2 = path.max, pathValue = path.pathValue, index2 = path.index;
  var cmdCode = pathValue.charCodeAt(index2);
  var reqParams = paramsCount[pathValue[index2].toLowerCase()];
  path.segmentStart = index2;
  if (!isPathCommand(cmdCode)) {
    path.err = '[path-util]: Invalid path value "'.concat(pathValue[index2], '" is not a path command');
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (var i2 = reqParams; i2 > 0; i2 -= 1) {
      if (isArcCommand(cmdCode) && (i2 === 3 || i2 === 4))
        scanFlag(path);
      else
        scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max2 && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}
var PathParser = (
  /** @class */
  /* @__PURE__ */ function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = parsePathString(pathInput);
  var x2 = 0;
  var y2 = 0;
  var mx = 0;
  var my = 0;
  return path.map(function(segment) {
    var values2 = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x2 = values2[0], y2 = values2[1];
      mx = x2;
      my = y2;
      return ["M", x2, y2];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values2[0],
            values2[1],
            values2[2],
            values2[3],
            values2[4],
            values2[5] + x2,
            values2[6] + y2
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values2[0] + y2];
          break;
        case "H":
          absoluteSegment = [absCommand, values2[0] + x2];
          break;
        default: {
          var absValues = values2.map(function(n2, j) {
            return n2 + (j % 2 ? y2 : x2);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values2);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x2 = mx;
        y2 = my;
        break;
      case "H":
        x2 = absoluteSegment[1];
        break;
      case "V":
        y2 = absoluteSegment[1];
        break;
      default:
        x2 = absoluteSegment[segLength - 2];
        y2 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x2;
          my = y2;
        }
    }
    return absoluteSegment;
  });
}
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values2 = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x1 = px1 * 2 - px2;
    var y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1].concat(values2);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values2);
  } else if (pathCommand === "Q") {
    var nqx = values2[0], nqy = values2[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i2 = 0; i2 < path.length; i2 += 1) {
    path[i2] = normalizeSegment(path[i2], params);
    var segment = path[i2];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(function(_a3) {
    var pc = _a3[0];
    return "MC".includes(pc);
  });
}
function rotateVector(x2, y2, rad3) {
  var X = x2 * Math.cos(rad3) - y2 * Math.sin(rad3);
  var Y2 = x2 * Math.sin(rad3) + y2 * Math.cos(rad3);
  return { x: X, y: Y2 };
}
function arcToCubic(X1, Y1, RX, RY, angle2, LAF, SF, X2, Y2, recursive) {
  var x1 = X1;
  var y1 = Y1;
  var rx = RX;
  var ry = RY;
  var x2 = X2;
  var y2 = Y2;
  var d120 = Math.PI * 120 / 180;
  var rad3 = Math.PI / 180 * (+angle2 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad3);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x2, y2, -rad3);
    x2 = xy.x;
    y2 = xy.y;
    var x3 = (x1 - x2) / 2;
    var y3 = (y1 - y2) / 2;
    var h2 = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx *= h2;
      ry *= h2;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
    cx = k * rx * y3 / ry + (x1 + x2) / 2;
    cy = k * -ry * x3 / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y2 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = arcToCubic(x2, y2, rx, ry, angle2, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s22 = Math.sin(f2);
  var t3 = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t3;
  var hy = 4 / 3 * ry * t3;
  var m1 = [x1, y1];
  var m22 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s22, y2 - hy * c2];
  var m4 = [x2, y2];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return m22.concat(m3, m4, res);
  }
  res = m22.concat(m3, m4, res);
  var newres = [];
  for (var i2 = 0, ii = res.length; i2 < ii; i2 += 1) {
    newres[i2] = i2 % 2 ? rotateVector(res[i2 - 1], res[i2], rad3).y : rotateVector(res[i2], res[i2 + 1], rad3).x;
  }
  return newres;
}
function quadToCubic(x1, y1, qx, qy, x2, y2) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    // cpx1
    r13 * y1 + r23 * qy,
    // cpy1
    r13 * x2 + r23 * qx,
    // cpx2
    r13 * y2 + r23 * qy,
    // cpy2
    x2,
    y2
    // x,y
  ];
}
function midPoint(a2, b2, t3) {
  var ax = a2[0];
  var ay = a2[1];
  var bx = b2[0];
  var by = b2[1];
  return [ax + (bx - ax) * t3, ay + (by - ay) * t3];
}
var lineToCubic = function(x1, y1, x2, y2) {
  var t3 = 0.5;
  var mid = midPoint([x1, y1], [x2, y2], t3);
  return __spreadArray(__spreadArray([], mid, true), [x2, y2, x2, y2], false);
};
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values2 = segment.slice(1).map(Number);
  var x2 = values2[0], y2 = values2[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x2;
      params.y = y2;
      return segment;
    case "A":
      args = [px1, py1].concat(values2);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x2;
      params.qy = y2;
      args = [px1, py1].concat(values2);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x2, y2));
    case "Z":
      if (px1 === px2 && py1 === py) {
        return ["C", px1, py1, px2, py, px2, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px2, py));
  }
  return segment;
}
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i2 = 0; i2 < ii; i2 += 1) {
    if (path[i2])
      pathCommand = path[i2][0];
    allPathCommands[i2] = pathCommand;
    var curveSegment = segmentToCubic(path[i2], params);
    path[i2] = curveSegment;
    fixArc(path, allPathCommands, i2);
    ii = path.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i2);
    }
    segment = path[i2];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path, zCommandIndexes];
  } else {
    return path;
  }
}
function clonePath(path) {
  return path.map(function(x2) {
    return Array.isArray(x2) ? [].concat(x2) : x2;
  });
}
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x2, i2, curveOnly) {
    return !i2 ? pathArray[0].slice(1).concat(x2.slice(1)) : curveOnly[i2 - 1].slice(-2).concat(x2.slice(1));
  }).map(function(x2) {
    return x2.map(function(y2, i2) {
      return x2[x2.length - i2 - 2 * (1 - i2 % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x2) {
    return ["C"].concat(x2.slice(2));
  }));
}
function distanceSquareRoot(a2, b2) {
  return Math.sqrt((a2[0] - b2[0]) * (a2[0] - b2[0]) + (a2[1] - b2[1]) * (a2[1] - b2[1]));
}
function segmentLineFactory(x1, y1, x2, y2, distance2) {
  var length2 = distanceSquareRoot([x1, y1], [x2, y2]);
  var point2 = { x: 0, y: 0 };
  if (typeof distance2 === "number") {
    if (distance2 <= 0) {
      point2 = { x: x1, y: y1 };
    } else if (distance2 >= length2) {
      point2 = { x: x2, y: y2 };
    } else {
      var _a3 = midPoint([x1, y1], [x2, y2], distance2 / length2), x3 = _a3[0], y3 = _a3[1];
      point2 = { x: x3, y: y3 };
    }
  }
  return {
    length: length2,
    point: point2,
    min: {
      x: Math.min(x1, x2),
      y: Math.min(y1, y2)
    },
    max: {
      x: Math.max(x1, x2),
      y: Math.max(y1, y2)
    }
  };
}
function angleBetween$1(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p2 = v0x * v1x + v0y * v1y;
  var n2 = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle2 = sign * Math.acos(p2 / n2);
  return angle2;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle2, LAF, SF, x2, y2, t3) {
  var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt2 = Math.sqrt, PI3 = Math.PI;
  var rx = abs(RX);
  var ry = abs(RY);
  var xRot = (angle2 % 360 + 360) % 360;
  var xRotRad = xRot * (PI3 / 180);
  if (x1 === x2 && y1 === y2) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x2, y2, t3).point;
  }
  var dx = (x1 - x2) / 2;
  var dy = (y1 - y2) / 2;
  var transformedPoint = {
    x: cos(xRotRad) * dx + sin(xRotRad) * dy,
    y: -sin(xRotRad) * dx + cos(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt2(radiiCheck);
    ry *= sqrt2(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt2(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x2) / 2,
    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y2) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween$1({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween$1(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI3;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI3;
  }
  sweepAngle %= 2 * PI3;
  var alpha = startAngle + sweepAngle * t3;
  var ellipseComponentX = rx * cos(alpha);
  var ellipseComponentY = ry * sin(alpha);
  var point2 = {
    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y
  };
  return point2;
}
function segmentArcFactory(X1, Y1, RX, RY, angle2, LAF, SF, X2, Y2, distance2, options) {
  var _a3;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length2 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance2 === "number";
  var x2 = X1;
  var y2 = Y1;
  var LENGTH = 0;
  var prev = [x2, y2, LENGTH];
  var cur = [x2, y2];
  var t3 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x2, y: y2 }];
  if (distanceIsNumber && distance2 <= 0) {
    POINT = { x: x2, y: y2 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t3 = j / sampleSize;
    _a3 = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle2, LAF, SF, X2, Y2, t3), x2 = _a3.x, y2 = _a3.y;
    if (bbox) {
      POINTS.push({ x: x2, y: y2 });
    }
    if (length2) {
      LENGTH += distanceSquareRoot(cur, [x2, y2]);
    }
    cur = [x2, y2];
    if (distanceIsNumber && LENGTH >= distance2 && distance2 > prev[2]) {
      var dv = (LENGTH - distance2) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x2, y2, LENGTH];
  }
  if (distanceIsNumber && distance2 >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t3) {
  var t1 = 1 - t3;
  return {
    x: Math.pow(t1, 3) * x1 + 3 * Math.pow(t1, 2) * t3 * c1x + 3 * t1 * Math.pow(t3, 2) * c2x + Math.pow(t3, 3) * x2,
    y: Math.pow(t1, 3) * y1 + 3 * Math.pow(t1, 2) * t3 * c1y + 3 * t1 * Math.pow(t3, 2) * c2y + Math.pow(t3, 3) * y2
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance2, options) {
  var _a3;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length2 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance2 === "number";
  var x3 = x1;
  var y3 = y1;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t3 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance2 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t3 = j / sampleSize;
    _a3 = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t3), x3 = _a3.x, y3 = _a3.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length2) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance2 && distance2 > prev[2]) {
      var dv = (LENGTH - distance2) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance2 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t3) {
  var t1 = 1 - t3;
  return {
    x: Math.pow(t1, 2) * x1 + 2 * t1 * t3 * cx + Math.pow(t3, 2) * x2,
    y: Math.pow(t1, 2) * y1 + 2 * t1 * t3 * cy + Math.pow(t3, 2) * y2
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance2, options) {
  var _a3;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length2 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance2 === "number";
  var x3 = x1;
  var y3 = y1;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t3 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance2 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t3 = j / sampleSize;
    _a3 = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t3), x3 = _a3.x, y3 = _a3.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length2) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance2 && distance2 > prev[2]) {
      var dv = (LENGTH - distance2) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance2 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
function pathLengthFactory(pathInput, distance2, options) {
  var _a3, _b, _c, _d, _e, _f;
  var path = normalizePath(pathInput);
  var distanceIsNumber = typeof distance2 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x2 = 0;
  var y2 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length2 = 0;
  var min2 = { x: 0, y: 0 };
  var max2 = min2;
  var point2 = min2;
  var POINT = min2;
  var LENGTH = 0;
  for (var i2 = 0, ll = path.length; i2 < ll; i2 += 1) {
    seg = path[i2];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x2, y2].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min2 = { x: mx, y: my };
      max2 = min2;
      length2 = 0;
      if (distanceIsNumber && distance2 < 1e-3) {
        POINT = min2;
      }
    } else if (pathCommand === "L") {
      _a3 = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance2 || 0) - LENGTH), length2 = _a3.length, min2 = _a3.min, max2 = _a3.max, point2 = _a3.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance2 || 0) - LENGTH, options || {}), length2 = _b.length, min2 = _b.min, max2 = _b.max, point2 = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance2 || 0) - LENGTH, options || {}), length2 = _c.length, min2 = _c.min, max2 = _c.max, point2 = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance2 || 0) - LENGTH, options || {}), length2 = _d.length, min2 = _d.min, max2 = _d.max, point2 = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x2, y2, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance2 || 0) - LENGTH), length2 = _e.length, min2 = _e.min, max2 = _e.max, point2 = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance2 && LENGTH + length2 >= distance2) {
      POINT = point2;
    }
    MAX.push(max2);
    MIN.push(min2);
    LENGTH += length2;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x2 = _f[0], y2 = _f[1];
  }
  if (distanceIsNumber && distance2 >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}
function getRotations(a2) {
  var segCount = a2.length;
  var pointCount = segCount - 1;
  return a2.map(function(f2, idx) {
    return a2.map(function(p2, i2) {
      var oldSegIdx = idx + i2;
      var seg;
      if (i2 === 0 || a2[oldSegIdx] && a2[oldSegIdx][0] === "M") {
        seg = a2[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a2[oldSegIdx];
    });
  });
}
function getRotatedCurve(a2, b2) {
  var segCount = a2.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a2);
  rotations.forEach(function(r2, i2) {
    a2.slice(1).forEach(function(s3, j) {
      sumLensSqrd += distanceSquareRoot(a2[(i2 + j) % segCount].slice(-2), b2[j % segCount].slice(-2));
    });
    lineLengths[i2] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}
function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x2, y2) {
  return 3 * ((y2 - y1) * (c1x + c2x) - (x2 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y2 * (c2x + x1 / 3) - x2 * (c2y + y1 / 3)) / 20;
}
function getPathArea(path) {
  var x2 = 0;
  var y2 = 0;
  var len2 = 0;
  return path2Curve(path).map(function(seg) {
    var _a3;
    switch (seg[0]) {
      case "M":
        x2 = seg[1], y2 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len2 = getCubicSegArea(x2, y2, c1x, c1y, c2x, c2y, x22, y22);
        _a3 = seg.slice(-2), x2 = _a3[0], y2 = _a3[1];
        return len2;
    }
  }).reduce(function(a2, b2) {
    return a2 + b2;
  }, 0);
}
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}
function getPointAtLength(pathInput, distance2, options) {
  return pathLengthFactory(pathInput, distance2, __assign(__assign({}, options), { bbox: false, length: true })).point;
}
var MAX_RECURSION_DEPTH = 50;
function splitCubic(pts, t3) {
  if (t3 === void 0) {
    t3 = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t3);
  var p5 = midPoint(p1, p2, t3);
  var p6 = midPoint(p2, p3, t3);
  var p7 = midPoint(p4, p5, t3);
  var p8 = midPoint(p5, p6, t3);
  var p9 = midPoint(p7, p8, t3);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i2, pathArray) {
    var segmentData = i2 && pathArray[i2 - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i2 ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i2) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL, depth) {
  if (depth === void 0) {
    depth = 0;
  }
  if (depth > MAX_RECURSION_DEPTH) {
    console.warn("Maximum recursion depth reached in equalizeSegments");
    return [path1, path2];
  }
  var c1 = getCurveArray(path1);
  var c2 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c2.length;
  var l1 = c1.filter(function(x2) {
    return x2.l;
  }).length;
  var l2 = c2.filter(function(x2) {
    return x2.l;
  }).length;
  var m1 = c1.filter(function(x2) {
    return x2.l;
  }).reduce(function(a2, _a3) {
    var l3 = _a3.l;
    return a2 + l3;
  }, 0) / l1 || 0;
  var m22 = c2.filter(function(x2) {
    return x2.l;
  }).reduce(function(a2, _a3) {
    var l3 = _a3.l;
    return a2 + l3;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m22];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c2].map(function(x2, i2) {
    return x2.l === tl ? x2.map(function(y2) {
      return y2.s;
    }) : x2.map(function(y2, j) {
      canSplit = j && dif[i2] && y2.l >= mm[i2];
      dif[i2] -= canSplit ? 1 : 0;
      return canSplit ? y2.ss : [y2.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl, depth + 1);
}
function createDOM(str2) {
  var container = document.createElement("div");
  container.innerHTML = str2;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}
function _superPropBase(t3, o2) {
  for (; !{}.hasOwnProperty.call(t3, o2) && null !== (t3 = _getPrototypeOf(t3)); ) ;
  return t3;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e3, t3, r2) {
    var p2 = _superPropBase(e3, t3);
    if (p2) {
      var n2 = Object.getOwnPropertyDescriptor(p2, t3);
      return n2.get ? n2.get.call(arguments.length < 3 ? e3 : r2) : n2.value;
    }
  }, _get.apply(null, arguments);
}
function _superPropGet(t3, o2, e3, r2) {
  var p2 = _get(_getPrototypeOf(t3.prototype), o2, e3);
  return "function" == typeof p2 ? function(t4) {
    return p2.apply(e3, t4);
  } : p2;
}
/*!
 * @antv/g-math
 * @description Geometry util
 * @version 3.1.0
 * @date 12/22/2025, 3:02:36 AM
 * @author AntVis
 * @docs https://g.antv.antgroup.com/
 */
function distance$5(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, _toConsumableArray(xArr));
  var minY = Math.min.apply(Math, _toConsumableArray(yArr));
  var maxX = Math.max.apply(Math, _toConsumableArray(xArr));
  var maxY = Math.max.apply(Math, _toConsumableArray(yArr));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
}
function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  var xDim = xExtrema(rx, ry, xRotation);
  var minX = Infinity;
  var maxX = -Infinity;
  var xs = [startAngle, endAngle];
  for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
    var xAngle = xDim + i2;
    if (startAngle < endAngle) {
      if (startAngle < xAngle && xAngle < endAngle) {
        xs.push(xAngle);
      }
    } else if (endAngle < xAngle && xAngle < startAngle) {
      xs.push(xAngle);
    }
  }
  for (var _i = 0; _i < xs.length; _i++) {
    var x2 = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
    if (x2 < minX) {
      minX = x2;
    }
    if (x2 > maxX) {
      maxX = x2;
    }
  }
  var yDim = yExtrema(rx, ry, xRotation);
  var minY = Infinity;
  var maxY = -Infinity;
  var ys = [startAngle, endAngle];
  for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
    var yAngle = yDim + _i2;
    if (startAngle < endAngle) {
      if (startAngle < yAngle && yAngle < endAngle) {
        ys.push(yAngle);
      }
    } else if (endAngle < yAngle && yAngle < startAngle) {
      ys.push(yAngle);
    }
  }
  for (var _i3 = 0; _i3 < ys.length; _i3++) {
    var y2 = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
    if (y2 < minY) {
      minY = y2;
    }
    if (y2 > maxY) {
      maxY = y2;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
var EPSILON$1 = 1e-4;
function nearestPoint$2(xArr, yArr, x2, y2, tCallback, length2) {
  var t3 = -1;
  var d3 = Infinity;
  var v0 = [x2, y2];
  var segNum = 20;
  if (length2 && length2 > 200) {
    segNum = length2 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i2 = 0; i2 <= segNum; i2++) {
    var _t = i2 * increaseRate;
    var v1 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([_t])))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d3) {
      t3 = _t;
      d3 = d1;
    }
  }
  if (t3 === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t3 === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d3 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval2 < EPSILON$1) {
      break;
    }
    var prev = t3 - interval2;
    var next = t3 + interval2;
    var _v = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([prev])))];
    var _d = distance$5(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d3) {
      t3 = prev;
      d3 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([next])))];
      var d22 = distance$5(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d3) {
        t3 = next;
        d3 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, _toConsumableArray(xArr.concat([t3]))),
    y: tCallback.apply(void 0, _toConsumableArray(yArr.concat([t3])))
  };
}
function length$4(x1, y1, x2, y2) {
  return distance$5(x1, y1, x2, y2);
}
function pointAt$3(x1, y1, x2, y2, t3) {
  return {
    x: (1 - t3) * x1 + t3 * x2,
    y: (1 - t3) * y1 + t3 * y2
  };
}
function pointToLine(x1, y1, x2, y2, x3, y3) {
  var d3 = [x2 - x1, y2 - y1];
  if (exactEquals(d3, [0, 0])) {
    return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
  }
  var u2 = [-d3[1], d3[0]];
  normalize$6(u2, u2);
  var a2 = [x3 - x1, y3 - y1];
  return Math.abs(dot$3(a2, u2));
}
function cubicAt(p0, p1, p2, p3, t3) {
  var onet = 1 - t3;
  return onet * onet * onet * p0 + 3 * p1 * t3 * onet * onet + 3 * p2 * t3 * t3 * onet + p3 * t3 * t3 * t3;
}
function extrema$1(p0, p1, p2, p3) {
  var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b2 = 6 * p0 - 12 * p1 + 6 * p2;
  var c2 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t1;
  var t22;
  var discSqrt;
  if (isNumberEqual(a2, 0)) {
    if (!isNumberEqual(b2, 0)) {
      t1 = -c2 / b2;
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
    }
  } else {
    var disc = b2 * b2 - 4 * a2 * c2;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b2 / (2 * a2));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b2 + discSqrt) / (2 * a2);
      t22 = (-b2 - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function box$3(x1, y1, x2, y2, x3, y3, x4, y4) {
  var xArr = [x1, x4];
  var yArr = [y1, y4];
  var xExtrema2 = extrema$1(x1, x2, x3, x4);
  var yExtrema2 = extrema$1(y1, y2, y3, y4);
  for (var i2 = 0; i2 < xExtrema2.length; i2++) {
    xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i2]));
  }
  for (var _i = 0; _i < yExtrema2.length; _i++) {
    yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[_i]));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
  return nearestPoint$2([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length2);
}
function pointDistance$3(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
  var point2 = nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2);
  return distance$5(point2.x, point2.y, x0, y0);
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to = points[i2 + 1];
    totalLength += distance$5(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function length$2(points) {
  return lengthOfSegment(points);
}
function quadraticAt(p0, p1, p2, t3) {
  var onet = 1 - t3;
  return onet * onet * p0 + 2 * t3 * onet * p1 + t3 * t3 * p2;
}
function extrema(p0, p1, p2) {
  var a2 = p0 + p2 - 2 * p1;
  if (isNumberEqual(a2, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a2;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function box(x1, y1, x2, y2, x3, y3) {
  var xExtrema2 = extrema(x1, x2, x3)[0];
  var yExtrema2 = extrema(y1, y2, y3)[0];
  var xArr = [x1, x3];
  var yArr = [y1, y3];
  if (xExtrema2 !== void 0) {
    xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
  }
  if (yExtrema2 !== void 0) {
    yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0) {
  return nearestPoint$2([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
}
function pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {
  var point2 = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
  return distance$5(point2.x, point2.y, x0, y0);
}
function _OverloadYield(e3, d3) {
  this.v = e3, this.k = d3;
}
function _regeneratorDefine(e3, r2, n2, t3) {
  var i2 = Object.defineProperty;
  try {
    i2({}, "", {});
  } catch (e4) {
    i2 = 0;
  }
  _regeneratorDefine = function regeneratorDefine(e4, r3, n3, t4) {
    function o2(r4, n4) {
      _regeneratorDefine(e4, r4, function(e6) {
        return this._invoke(r4, n4, e6);
      });
    }
    r3 ? i2 ? i2(e4, r3, {
      value: n3,
      enumerable: !t4,
      configurable: !t4,
      writable: !t4
    }) : e4[r3] = n3 : (o2("next", 0), o2("throw", 1), o2("return", 2));
  }, _regeneratorDefine(e3, r2, n2, t3);
}
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e3, t3, r2 = "function" == typeof Symbol ? Symbol : {}, n2 = r2.iterator || "@@iterator", o2 = r2.toStringTag || "@@toStringTag";
  function i2(r3, n3, o3, i3) {
    var c3 = n3 && n3.prototype instanceof Generator ? n3 : Generator, u3 = Object.create(c3.prototype);
    return _regeneratorDefine(u3, "_invoke", function(r4, n4, o4) {
      var i4, c4, u4, f3 = 0, p2 = o4 || [], y2 = false, G2 = {
        p: 0,
        n: 0,
        v: e3,
        a: d3,
        f: d3.bind(e3, 4),
        d: function d4(t4, r5) {
          return i4 = t4, c4 = 0, u4 = e3, G2.n = r5, a2;
        }
      };
      function d3(r5, n5) {
        for (c4 = r5, u4 = n5, t3 = 0; !y2 && f3 && !o5 && t3 < p2.length; t3++) {
          var o5, i5 = p2[t3], d4 = G2.p, l2 = i5[2];
          r5 > 3 ? (o5 = l2 === n5) && (u4 = i5[(c4 = i5[4]) ? 5 : (c4 = 3, 3)], i5[4] = i5[5] = e3) : i5[0] <= d4 && ((o5 = r5 < 2 && d4 < i5[1]) ? (c4 = 0, G2.v = n5, G2.n = i5[1]) : d4 < l2 && (o5 = r5 < 3 || i5[0] > n5 || n5 > l2) && (i5[4] = r5, i5[5] = n5, G2.n = l2, c4 = 0));
        }
        if (o5 || r5 > 1) return a2;
        throw y2 = true, n5;
      }
      return function(o5, p3, l2) {
        if (f3 > 1) throw TypeError("Generator is already running");
        for (y2 && 1 === p3 && d3(p3, l2), c4 = p3, u4 = l2; (t3 = c4 < 2 ? e3 : u4) || !y2; ) {
          i4 || (c4 ? c4 < 3 ? (c4 > 1 && (G2.n = -1), d3(c4, u4)) : G2.n = u4 : G2.v = u4);
          try {
            if (f3 = 2, i4) {
              if (c4 || (o5 = "next"), t3 = i4[o5]) {
                if (!(t3 = t3.call(i4, u4))) throw TypeError("iterator result is not an object");
                if (!t3.done) return t3;
                u4 = t3.value, c4 < 2 && (c4 = 0);
              } else 1 === c4 && (t3 = i4["return"]) && t3.call(i4), c4 < 2 && (u4 = TypeError("The iterator does not provide a '" + o5 + "' method"), c4 = 1);
              i4 = e3;
            } else if ((t3 = (y2 = G2.n < 0) ? u4 : r4.call(n4, G2)) !== a2) break;
          } catch (t4) {
            i4 = e3, c4 = 1, u4 = t4;
          } finally {
            f3 = 1;
          }
        }
        return {
          value: t3,
          done: y2
        };
      };
    }(r3, o3, i3), true), u3;
  }
  var a2 = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  t3 = Object.getPrototypeOf;
  var c2 = [][n2] ? t3(t3([][n2]())) : (_regeneratorDefine(t3 = {}, n2, function() {
    return this;
  }), t3), u2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c2);
  function f2(e4) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e4, GeneratorFunctionPrototype) : (e4.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e4, o2, "GeneratorFunction")), e4.prototype = Object.create(u2), e4;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u2, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o2, "GeneratorFunction"), _regeneratorDefine(u2), _regeneratorDefine(u2, o2, "Generator"), _regeneratorDefine(u2, n2, function() {
    return this;
  }), _regeneratorDefine(u2, "toString", function() {
    return "[object Generator]";
  }), (_regenerator = function _regenerator2() {
    return {
      w: i2,
      m: f2
    };
  })();
}
function AsyncIterator(t3, e3) {
  function n2(r3, o2, i2, f2) {
    try {
      var c2 = t3[r3](o2), u2 = c2.value;
      return u2 instanceof _OverloadYield ? e3.resolve(u2.v).then(function(t4) {
        n2("next", t4, i2, f2);
      }, function(t4) {
        n2("throw", t4, i2, f2);
      }) : e3.resolve(u2).then(function(t4) {
        c2.value = t4, i2(c2);
      }, function(t4) {
        return n2("throw", t4, i2, f2);
      });
    } catch (t4) {
      f2(t4);
    }
  }
  var r2;
  this.next || (_regeneratorDefine(AsyncIterator.prototype), _regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
    return this;
  })), _regeneratorDefine(this, "_invoke", function(t4, o2, i2) {
    function f2() {
      return new e3(function(e4, r3) {
        n2(t4, i2, e4, r3);
      });
    }
    return r2 = r2 ? r2.then(f2, f2) : f2();
  }, true);
}
function _regeneratorAsyncGen(r2, e3, t3, o2, n2) {
  return new AsyncIterator(_regenerator().w(r2, e3, t3, o2), n2 || Promise);
}
function _regeneratorAsync(n2, e3, r2, t3, o2) {
  var a2 = _regeneratorAsyncGen(n2, e3, r2, t3, o2);
  return a2.next().then(function(n3) {
    return n3.done ? n3.value : a2.next();
  });
}
function _regeneratorKeys(e3) {
  var n2 = Object(e3), r2 = [];
  for (var t3 in n2) r2.unshift(t3);
  return function e4() {
    for (; r2.length; ) if ((t3 = r2.pop()) in n2) return e4.value = t3, e4.done = false, e4;
    return e4.done = true, e4;
  };
}
function _regeneratorValues(e3) {
  if (null != e3) {
    var t3 = e3["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r2 = 0;
    if (t3) return t3.call(e3);
    if ("function" == typeof e3.next) return e3;
    if (!isNaN(e3.length)) return {
      next: function next() {
        return e3 && r2 >= e3.length && (e3 = void 0), {
          value: e3 && e3[r2++],
          done: !e3
        };
      }
    };
  }
  throw new TypeError(_typeof(e3) + " is not iterable");
}
function _regeneratorRuntime() {
  var r2 = _regenerator(), e3 = r2.m(_regeneratorRuntime), t3 = (Object.getPrototypeOf ? Object.getPrototypeOf(e3) : e3.__proto__).constructor;
  function n2(r3) {
    var e4 = "function" == typeof r3 && r3.constructor;
    return !!e4 && (e4 === t3 || "GeneratorFunction" === (e4.displayName || e4.name));
  }
  var o2 = {
    "throw": 1,
    "return": 2,
    "break": 3,
    "continue": 3
  };
  function a2(r3) {
    var e4, t4;
    return function(n3) {
      e4 || (e4 = {
        stop: function stop() {
          return t4(n3.a, 2);
        },
        "catch": function _catch() {
          return n3.v;
        },
        abrupt: function abrupt(r4, e6) {
          return t4(n3.a, o2[r4], e6);
        },
        delegateYield: function delegateYield(r4, o3, a3) {
          return e4.resultName = o3, t4(n3.d, _regeneratorValues(r4), a3);
        },
        finish: function finish(r4) {
          return t4(n3.f, r4);
        }
      }, t4 = function t5(r4, _t, o3) {
        n3.p = e4.prev, n3.n = e4.next;
        try {
          return r4(_t, o3);
        } finally {
          e4.next = n3.n;
        }
      }), e4.resultName && (e4[e4.resultName] = n3.v, e4.resultName = void 0), e4.sent = n3.v, e4.next = n3.n;
      try {
        return r3.call(this, e4);
      } finally {
        n3.p = e4.prev, n3.n = e4.next;
      }
    };
  }
  return (_regeneratorRuntime = function _regeneratorRuntime2() {
    return {
      wrap: function wrap2(e4, t4, n3, o3) {
        return r2.w(a2(e4), t4, n3, o3 && o3.reverse());
      },
      isGeneratorFunction: n2,
      mark: r2.m,
      awrap: function awrap(r3, e4) {
        return new _OverloadYield(r3, e4);
      },
      AsyncIterator,
      async: function async(r3, e4, t4, o3, u2) {
        return (n2(e4) ? _regeneratorAsyncGen : _regeneratorAsync)(a2(r3), e4, t4, o3, u2);
      },
      keys: _regeneratorKeys,
      values: _regeneratorValues
    };
  })();
}
function asyncGeneratorStep(n2, t3, e3, r2, o2, a2, c2) {
  try {
    var i2 = n2[a2](c2), u2 = i2.value;
  } catch (n3) {
    return void e3(n3);
  }
  i2.done ? t3(u2) : Promise.resolve(u2).then(r2, o2);
}
function _asyncToGenerator(n2) {
  return function() {
    var t3 = this, e3 = arguments;
    return new Promise(function(r2, o2) {
      var a2 = n2.apply(t3, e3);
      function _next(n3) {
        asyncGeneratorStep(a2, r2, o2, _next, _throw, "next", n3);
      }
      function _throw(n3) {
        asyncGeneratorStep(a2, r2, o2, _next, _throw, "throw", n3);
      }
      _next(void 0);
    });
  };
}
function _createForOfIteratorHelper(r2, e3) {
  var t3 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t3) {
    if (Array.isArray(r2) || (t3 = _unsupportedIterableToArray(r2)) || e3) {
      t3 && (r2 = t3);
      var _n = 0, F2 = function F3() {
      };
      return {
        s: F2,
        n: function n2() {
          return _n >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[_n++]
          };
        },
        e: function e4(r3) {
          throw r3;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a2 = true, u2 = false;
  return {
    s: function s3() {
      t3 = t3.call(r2);
    },
    n: function n2() {
      var r3 = t3.next();
      return a2 = r3.done, r3;
    },
    e: function e4(r3) {
      u2 = true, o2 = r3;
    },
    f: function f2() {
      try {
        a2 || null == t3["return"] || t3["return"]();
      } finally {
        if (u2) throw o2;
      }
    }
  };
}
function _objectWithoutPropertiesLoose(r2, e3) {
  if (null == r2) return {};
  var t3 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t3[n2] = r2[n2];
  }
  return t3;
}
function _objectWithoutProperties(e3, t3) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose(e3, t3);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t3.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
/*!
 * @antv/g-lite
 * @description A core module for rendering engine implements DOM API.
 * @version 2.7.0
 * @date 12/24/2025, 11:55:20 AM
 * @author AntVis
 * @docs https://g.antv.antgroup.com/
 */
var Shape = /* @__PURE__ */ function(Shape2) {
  Shape2["GROUP"] = "g";
  Shape2["FRAGMENT"] = "fragment";
  Shape2["CIRCLE"] = "circle";
  Shape2["ELLIPSE"] = "ellipse";
  Shape2["IMAGE"] = "image";
  Shape2["RECT"] = "rect";
  Shape2["LINE"] = "line";
  Shape2["POLYLINE"] = "polyline";
  Shape2["POLYGON"] = "polygon";
  Shape2["TEXT"] = "text";
  Shape2["PATH"] = "path";
  Shape2["HTML"] = "html";
  Shape2["MESH"] = "mesh";
  return Shape2;
}({});
var ClipSpaceNearZ = /* @__PURE__ */ function(ClipSpaceNearZ2) {
  ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
  ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
  return ClipSpaceNearZ2;
}({});
var AbstractRendererPlugin = /* @__PURE__ */ function() {
  function AbstractRendererPlugin2() {
    _classCallCheck(this, AbstractRendererPlugin2);
    this.plugins = [];
  }
  return _createClass(AbstractRendererPlugin2, [{
    key: "addRenderingPlugin",
    value: function addRenderingPlugin(plugin) {
      this.plugins.push(plugin);
      this.context.renderingPlugins.push(plugin);
    }
  }, {
    key: "removeAllRenderingPlugins",
    value: function removeAllRenderingPlugins() {
      var _this2 = this;
      this.plugins.forEach(function(plugin) {
        var index2 = _this2.context.renderingPlugins.indexOf(plugin);
        if (index2 >= 0) {
          _this2.context.renderingPlugins.splice(index2, 1);
        }
      });
    }
  }]);
}();
var AbstractRenderer = /* @__PURE__ */ function() {
  function AbstractRenderer2(config) {
    _classCallCheck(this, AbstractRenderer2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.plugins = [];
    this.config = _objectSpread2({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false,
      enableSizeAttenuation: true,
      enableRenderingOptimization: false
    }, config);
  }
  return _createClass(AbstractRenderer2, [{
    key: "registerPlugin",
    value: function registerPlugin(plugin) {
      var index2 = this.plugins.findIndex(function(p2) {
        return p2 === plugin;
      });
      if (index2 === -1) {
        this.plugins.push(plugin);
      }
    }
  }, {
    key: "unregisterPlugin",
    value: function unregisterPlugin(plugin) {
      var index2 = this.plugins.findIndex(function(p2) {
        return p2 === plugin;
      });
      if (index2 > -1) {
        this.plugins.splice(index2, 1);
      }
    }
  }, {
    key: "getPlugins",
    value: function getPlugins() {
      return this.plugins;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return this.plugins.find(function(plugin) {
        return plugin.name === name;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      Object.assign(this.config, config);
    }
  }]);
}();
var addVec3 = add$5, copyVec3 = copy$3, maxVec3 = max$3, minVec3 = min$3, scaleVec3 = scale$2, subVec3 = sub$1;
var AABB = /* @__PURE__ */ function() {
  function AABB2() {
    _classCallCheck(this, AABB2);
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
  }
  return _createClass(AABB2, [{
    key: "update",
    value: function update(center, halfExtents) {
      copyVec3(this.center, center);
      copyVec3(this.halfExtents, halfExtents);
      subVec3(this.min, this.center, this.halfExtents);
      addVec3(this.max, this.center, this.halfExtents);
    }
  }, {
    key: "setMinMax",
    value: function setMinMax(min2, max2) {
      addVec3(this.center, max2, min2);
      scaleVec3(this.center, this.center, 0.5);
      subVec3(this.halfExtents, max2, min2);
      scaleVec3(this.halfExtents, this.halfExtents, 0.5);
      copyVec3(this.min, min2);
      copyVec3(this.max, max2);
    }
  }, {
    key: "getMin",
    value: function getMin() {
      return this.min;
    }
  }, {
    key: "getMax",
    value: function getMax() {
      return this.max;
    }
  }, {
    key: "add",
    value: function add2(aabb) {
      if (AABB2.isEmpty(aabb)) {
        return;
      }
      if (AABB2.isEmpty(this)) {
        this.setMinMax(aabb.getMin(), aabb.getMax());
        return;
      }
      var tc = this.center;
      var tcx = tc[0];
      var tcy = tc[1];
      var tcz = tc[2];
      var th = this.halfExtents;
      var thx = th[0];
      var thy = th[1];
      var thz = th[2];
      var tminx = tcx - thx;
      var tmaxx = tcx + thx;
      var tminy = tcy - thy;
      var tmaxy = tcy + thy;
      var tminz = tcz - thz;
      var tmaxz = tcz + thz;
      var oc = aabb.center;
      var ocx = oc[0];
      var ocy = oc[1];
      var ocz = oc[2];
      var oh = aabb.halfExtents;
      var ohx = oh[0];
      var ohy = oh[1];
      var ohz = oh[2];
      var ominx = ocx - ohx;
      var omaxx = ocx + ohx;
      var ominy = ocy - ohy;
      var omaxy = ocy + ohy;
      var ominz = ocz - ohz;
      var omaxz = ocz + ohz;
      if (ominx < tminx) {
        tminx = ominx;
      }
      if (omaxx > tmaxx) {
        tmaxx = omaxx;
      }
      if (ominy < tminy) {
        tminy = ominy;
      }
      if (omaxy > tmaxy) {
        tmaxy = omaxy;
      }
      if (ominz < tminz) {
        tminz = ominz;
      }
      if (omaxz > tmaxz) {
        tmaxz = omaxz;
      }
      tc[0] = (tminx + tmaxx) * 0.5;
      tc[1] = (tminy + tmaxy) * 0.5;
      tc[2] = (tminz + tmaxz) * 0.5;
      th[0] = (tmaxx - tminx) * 0.5;
      th[1] = (tmaxy - tminy) * 0.5;
      th[2] = (tmaxz - tminz) * 0.5;
      this.min[0] = tminx;
      this.min[1] = tminy;
      this.min[2] = tminz;
      this.max[0] = tmaxx;
      this.max[1] = tmaxy;
      this.max[2] = tmaxz;
    }
  }, {
    key: "setFromTransformedAABB",
    value: function setFromTransformedAABB(aabb, m3) {
      var bc = this.center;
      var br = this.halfExtents;
      var ac = aabb.center;
      var ar = aabb.halfExtents;
      var mx0 = m3[0];
      var mx1 = m3[4];
      var mx2 = m3[8];
      var my0 = m3[1];
      var my1 = m3[5];
      var my2 = m3[9];
      var mz0 = m3[2];
      var mz1 = m3[6];
      var mz2 = m3[10];
      var mx0a = Math.abs(mx0);
      var mx1a = Math.abs(mx1);
      var mx2a = Math.abs(mx2);
      var my0a = Math.abs(my0);
      var my1a = Math.abs(my1);
      var my2a = Math.abs(my2);
      var mz0a = Math.abs(mz0);
      var mz1a = Math.abs(mz1);
      var mz2a = Math.abs(mz2);
      bc[0] = m3[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
      bc[1] = m3[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
      bc[2] = m3[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
      br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
      br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
      br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
      subVec3(this.min, bc, br);
      addVec3(this.max, bc, br);
    }
  }, {
    key: "intersects",
    value: function intersects(aabb) {
      var aMax = this.getMax();
      var aMin = this.getMin();
      var bMax = aabb.getMax();
      var bMin = aabb.getMin();
      return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
    }
  }, {
    key: "intersection",
    value: function intersection(aabb) {
      if (!this.intersects(aabb)) {
        return null;
      }
      var intersection2 = new AABB2();
      var min2 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
      var max2 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
      intersection2.setMinMax(min2, max2);
      return intersection2;
    }
    /**
     * get n-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getNegativeFarPoint",
    value: function getNegativeFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.min);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      return [this.max[0], this.max[1], this.max[2]];
    }
    /**
     * get p-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getPositiveFarPoint",
    value: function getPositiveFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.max);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      return [this.min[0], this.min[1], this.min[2]];
    }
  }], [{
    key: "isEmpty",
    value: function isEmpty2(aabb) {
      return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
    }
  }]);
}();
var Plane = /* @__PURE__ */ function() {
  function Plane2(distance2, normal) {
    _classCallCheck(this, Plane2);
    this.distance = distance2 || 0;
    this.normal = normal || fromValues$2(0, 1, 0);
    this.updatePNVertexFlag();
  }
  return _createClass(Plane2, [{
    key: "updatePNVertexFlag",
    value: function updatePNVertexFlag() {
      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point2) {
      return dot$4(point2, this.normal) - this.distance;
    }
  }, {
    key: "normalize",
    value: function normalize2() {
      var invLen = 1 / len(this.normal);
      scale$2(this.normal, this.normal, invLen);
      this.distance *= invLen;
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine2(start, end, point2) {
      var d0 = this.distanceToPoint(start);
      var d1 = this.distanceToPoint(end);
      var t3 = d0 / (d0 - d1);
      var intersects = t3 >= 0 && t3 <= 1;
      if (intersects && point2) {
        lerp$1(point2, start, end, t3);
      }
      return intersects;
    }
  }]);
}();
var Mask = /* @__PURE__ */ function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
  return Mask2;
}({});
var Frustum = /* @__PURE__ */ function() {
  function Frustum2(planes) {
    _classCallCheck(this, Frustum2);
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i2 = 0; i2 < 6; i2++) {
        this.planes.push(new Plane());
      }
    }
  }
  return _createClass(Frustum2, [{
    key: "extractFromVPMatrix",
    value: function extractFromVPMatrix(projectionMatrix) {
      var _projectionMatrix = _slicedToArray(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m22 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
      set$5(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
      this.planes[0].distance = m15 - m12;
      set$5(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
      this.planes[1].distance = m15 + m12;
      set$5(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
      this.planes[2].distance = m15 + m13;
      set$5(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
      this.planes[3].distance = m15 - m13;
      set$5(this.planes[4].normal, m3 - m22, m7 - m6, m11 - m10);
      this.planes[4].distance = m15 - m14;
      set$5(this.planes[5].normal, m3 + m22, m7 + m6, m11 + m10);
      this.planes[5].distance = m15 + m14;
      this.planes.forEach(function(plane) {
        plane.normalize();
        plane.updatePNVertexFlag();
      });
    }
  }]);
}();
var Point = /* @__PURE__ */ function() {
  function Point2() {
    var x2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classCallCheck(this, Point2);
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  return _createClass(Point2, [{
    key: "clone",
    value: function clone2() {
      return new Point2(this.x, this.y);
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(p2) {
      this.x = p2.x;
      this.y = p2.y;
    }
  }]);
}();
var Rectangle$1 = /* @__PURE__ */ function() {
  function Rectangle2(x2, y2, width2, height) {
    _classCallCheck(this, Rectangle2);
    this.x = x2;
    this.y = y2;
    this.width = width2;
    this.height = height;
    this.left = x2;
    this.right = x2 + width2;
    this.top = y2;
    this.bottom = y2 + height;
  }
  return _createClass(Rectangle2, [{
    key: "toJSON",
    value: function toJSON() {
    }
  }], [{
    key: "fromRect",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
       */
      function fromRect(rect2) {
        return new Rectangle2(rect2.x, rect2.y, rect2.width, rect2.height);
      }
    )
    /**
     * will return a new rect instance
     */
  }, {
    key: "applyTransform",
    value: function applyTransform2(rect2, matrix3) {
      var topLeft = fromValues$1(rect2.x, rect2.y, 0, 1);
      var topRight = fromValues$1(rect2.x + rect2.width, rect2.y, 0, 1);
      var bottomLeft = fromValues$1(rect2.x, rect2.y + rect2.height, 0, 1);
      var bottomRight = fromValues$1(rect2.x + rect2.width, rect2.y + rect2.height, 0, 1);
      var transformedTopLeft = create$3();
      var transformedTopRight = create$3();
      var transformedBottomLeft = create$3();
      var transformedBottomRight = create$3();
      transformMat4(transformedTopLeft, topLeft, matrix3);
      transformMat4(transformedTopRight, topRight, matrix3);
      transformMat4(transformedBottomLeft, bottomLeft, matrix3);
      transformMat4(transformedBottomRight, bottomRight, matrix3);
      var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var maxY = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      return Rectangle2.fromRect({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      });
    }
  }]);
}();
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
function getAngle$1(angle2) {
  if (angle2 === void 0) {
    return 0;
  }
  if (angle2 > 360 || angle2 < -360) {
    return angle2 % 360;
  }
  return angle2;
}
var $vec3$3 = create$4();
function createVec3(x2) {
  var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var clone2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  if (Array.isArray(x2) && x2.length === 3) {
    return clone2 ? clone$2(x2) : copy$3($vec3$3, x2);
  }
  if (isNumber(x2)) {
    return clone2 ? fromValues$2(x2, y2, z2) : set$5($vec3$3, x2, y2, z2);
  }
  return clone2 ? fromValues$2(x2[0], x2[1] || y2, x2[2] || z2) : set$5($vec3$3, x2[0], x2[1] || y2, x2[2] || z2);
}
var DEG_RAD = Math.PI / 180;
function deg2rad(deg3) {
  return deg3 * DEG_RAD;
}
var RAD_DEG = 180 / Math.PI;
function rad2deg(rad3) {
  return rad3 * RAD_DEG;
}
function turn2deg(turn2) {
  return 360 * turn2;
}
var HALF_PI = Math.PI / 2;
function getEulerFromQuat(out, quat2) {
  var x2 = quat2[0];
  var y2 = quat2[1];
  var z2 = quat2[2];
  var w2 = quat2[3];
  var x22 = x2 * x2;
  var y22 = y2 * y2;
  var z22 = z2 * z2;
  var w22 = w2 * w2;
  var unit = x22 + y22 + z22 + w22;
  var test = x2 * w2 - y2 * z2;
  if (test > 0.499995 * unit) {
    out[0] = HALF_PI;
    out[1] = 2 * Math.atan2(y2, x2);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -HALF_PI;
    out[1] = 2 * Math.atan2(y2, x2);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x2 * z2 - w2 * y2));
    out[1] = Math.atan2(2 * (x2 * w2 + y2 * z2), 1 - 2 * (z22 + w22));
    out[2] = Math.atan2(2 * (x2 * y2 + z2 * w2), 1 - 2 * (y22 + z22));
  }
  return out;
}
function getEulerFromMat4(out, m3) {
  var x2;
  var z2;
  var _mat4$getScaling = getScaling(create$4(), m3), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
  var y2 = Math.asin(-m3[2] / sx);
  if (y2 < HALF_PI) {
    if (y2 > -HALF_PI) {
      x2 = Math.atan2(m3[6] / sy, m3[10] / sz);
      z2 = Math.atan2(m3[1] / sx, m3[0] / sx);
    } else {
      z2 = 0;
      x2 = -Math.atan2(m3[4] / sy, m3[5] / sy);
    }
  } else {
    z2 = 0;
    x2 = Math.atan2(m3[4] / sy, m3[5] / sy);
  }
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  }
  return getEulerFromQuat(out, quat2);
}
function fromRotationTranslationScale(rotation, x2, y2, scaleX2, scaleY2) {
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  return fromValues$4(scaleX2 * cos, scaleY2 * sin, 0, -scaleX2 * sin, scaleY2 * cos, 0, x2, y2, 1);
}
function makePerspective(out, left, right, top, bottom, near, far) {
  var zero = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var twoNear = 2 * near;
  var rightMinusLeft = right - left;
  var topMinusBottom = top - bottom;
  var x2 = twoNear / rightMinusLeft;
  var y2 = twoNear / topMinusBottom;
  var a2 = (right + left) / rightMinusLeft;
  var b2 = (top + bottom) / topMinusBottom;
  var c2;
  var d3;
  var farMinusNear = far - near;
  var farMulNear = far * near;
  if (zero) {
    c2 = -far / farMinusNear;
    d3 = -farMulNear / farMinusNear;
  } else {
    c2 = -(far + near) / farMinusNear;
    d3 = -2 * farMulNear / farMinusNear;
  }
  out[0] = x2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y2;
  out[6] = 0;
  out[7] = 0;
  out[8] = a2;
  out[9] = b2;
  out[10] = c2;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d3;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant2 = row0x * row1y - row0y * row1x;
  if (determinant2 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    var invScalingX = 1 / scalingX;
    row0x *= invScalingX;
    row0y *= invScalingX;
  }
  if (scalingY) {
    var invScalingY = 1 / scalingY;
    row1x *= invScalingY;
    row1y *= invScalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle2 = rad2deg(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle2];
}
var tmp = create$5();
var perspectiveMatrix = create$5();
var tmpVec4 = create$3();
var row = [create$4(), create$4(), create$4()];
var pdum3 = create$4();
function decomposeMat4(matrix3, translation, scale3, skew2, perspective2, quaternion) {
  if (!normalize$5(tmp, matrix3)) return false;
  copy$4(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(determinant$1(perspectiveMatrix)) < 1e-8) return false;
  var a03 = tmp[3];
  var a13 = tmp[7];
  var a23 = tmp[11];
  var a30 = tmp[12];
  var a31 = tmp[13];
  var a32 = tmp[14];
  var a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = invert$1(perspectiveMatrix, perspectiveMatrix);
    if (!ret) return false;
    transpose$1(perspectiveMatrix, perspectiveMatrix);
    transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale3[0] = length(row[0]);
  normalize$9(row[0], row[0]);
  skew2[0] = dot$4(row[0], row[1]);
  combine(row[1], row[1], row[0], 1, -skew2[0]);
  scale3[1] = length(row[1]);
  normalize$9(row[1], row[1]);
  skew2[0] /= scale3[1];
  skew2[1] = dot$4(row[0], row[2]);
  combine(row[2], row[2], row[0], 1, -skew2[1]);
  skew2[2] = dot$4(row[1], row[2]);
  combine(row[2], row[2], row[1], 1, -skew2[2]);
  scale3[2] = length(row[2]);
  normalize$9(row[2], row[2]);
  skew2[1] /= scale3[2];
  skew2[2] /= scale3[2];
  cross$2(pdum3, row[1], row[2]);
  if (dot$4(row[0], pdum3) < 0) {
    for (var i2 = 0; i2 < 3; i2++) {
      scale3[i2] *= -1;
      row[i2][0] *= -1;
      row[i2][1] *= -1;
      row[i2][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
  return true;
}
function normalize$5(out, mat) {
  var m44 = mat[15];
  if (m44 === 0) return false;
  var scale3 = 1 / m44;
  for (var i2 = 0; i2 < 16; i2++) out[i2] = mat[i2] * scale3;
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine(out, a2, b2, scale1, scale22) {
  out[0] = a2[0] * scale1 + b2[0] * scale22;
  out[1] = a2[1] * scale1 + b2[1] * scale22;
  out[2] = a2[2] * scale1 + b2[2] * scale22;
}
var CameraType = /* @__PURE__ */ function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
  return CameraType2;
}({});
var CameraTrackingMode = /* @__PURE__ */ function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
  return CameraTrackingMode2;
}({});
var CameraProjectionMode = /* @__PURE__ */ function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
  return CameraProjectionMode2;
}({});
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = /* @__PURE__ */ function() {
  function Camera2() {
    _classCallCheck(this, Camera2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.eventEmitter = new EventEmitter$1();
    this.matrix = create$5();
    this.right = fromValues$2(1, 0, 0);
    this.up = fromValues$2(0, 1, 0);
    this.forward = fromValues$2(0, 0, 1);
    this.position = fromValues$2(0, 0, 1);
    this.focalPoint = fromValues$2(0, 0, 0);
    this.distanceVector = fromValues$2(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1e3;
    this.aspect = 1;
    this.projectionMatrix = create$5();
    this.projectionMatrixInverse = create$5();
    this.jitteredProjectionMatrix = void 0;
    this.enableUpdate = true;
    this.type = CameraType.EXPLORING;
    this.trackingMode = CameraTrackingMode.DEFAULT;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = create$5();
  }
  return _createClass(Camera2, [{
    key: "isOrtho",
    value: (
      // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
      //   this.setType(type, trackingMode);
      // }
      function isOrtho() {
        return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
      }
    )
  }, {
    key: "getProjectionMode",
    value: function getProjectionMode() {
      return this.projectionMode;
    }
  }, {
    key: "getPerspective",
    value: function getPerspective() {
      return this.jitteredProjectionMatrix || this.projectionMatrix;
    }
  }, {
    key: "getPerspectiveInverse",
    value: function getPerspectiveInverse() {
      return this.projectionMatrixInverse;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this.frustum;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getFocalPoint",
    value: function getFocalPoint() {
      return this.focalPoint;
    }
  }, {
    key: "getDollyingStep",
    value: function getDollyingStep() {
      return this.dollyingStep;
    }
  }, {
    key: "getNear",
    value: function getNear() {
      return this.near;
    }
  }, {
    key: "getFar",
    value: function getFar() {
      return this.far;
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.zoom;
    }
  }, {
    key: "getOrthoMatrix",
    value: function getOrthoMatrix() {
      return this.orthoMatrix;
    }
  }, {
    key: "getView",
    value: function getView() {
      return this.view;
    }
  }, {
    key: "setEnableUpdate",
    value: function setEnableUpdate(enabled) {
      this.enableUpdate = enabled;
    }
  }, {
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;
      if (this.type === CameraType.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
        this.setTrackingMode(trackingMode);
      }
      return this;
    }
  }, {
    key: "setProjectionMode",
    value: function setProjectionMode(projectionMode) {
      this.projectionMode = projectionMode;
      return this;
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CameraType.TRACKING) {
        throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
      }
      this.trackingMode = trackingMode;
      return this;
    }
    /**
     * If flag is true, it reverses the azimuth and elevation angles.
     * Subsequent calls to rotate, setAzimuth, setElevation,
     * changeAzimuth or changeElevation will cause the inverted effect.
     * setRoll or changeRoll is not affected by this method.
     *
     * This inversion is useful when one wants to simulate that the world
     * is moving, instead of the camera.
     *
     * By default the camera angles are not reversed.
     * @param {Boolean} flag the boolean flag to reverse the angles.
     */
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;
      this._getAngles();
      return this;
    }
    /**
     *  MV 
     */
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return invert$1(create$5(), this.matrix);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return this.matrix;
    }
  }, {
    key: "jitterProjectionMatrix",
    value: function jitterProjectionMatrix(x2, y2) {
      var translation = fromTranslation(create$5(), [x2, y2, 0]);
      this.jitteredProjectionMatrix = multiply$3(create$5(), translation, this.projectionMatrix);
    }
  }, {
    key: "clearJitterProjectionMatrix",
    value: function clearJitterProjectionMatrix() {
      this.jitteredProjectionMatrix = void 0;
    }
    /**
     * 
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix3) {
      this.matrix = matrix3;
      this._update();
      return this;
    }
    /**
     * Set projection matrix manually.
     */
  }, {
    key: "setProjectionMatrix",
    value: function setProjectionMatrix(matrix3) {
      this.projectionMatrix = matrix3;
    }
  }, {
    key: "setFov",
    value: function setFov(fov) {
      this.setPerspective(this.near, this.far, fov, this.aspect);
      return this;
    }
  }, {
    key: "setAspect",
    value: function setAspect(aspect) {
      this.setPerspective(this.near, this.far, this.fov, aspect);
      return this;
    }
  }, {
    key: "setNear",
    value: function setNear(near) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
      }
      return this;
    }
  }, {
    key: "setFar",
    value: function setFar(far) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
      }
      return this;
    }
    /**
     * Sets an offset in a larger frustum, used in PixelPicking
     */
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x2, y2, width2, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === void 0) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x2;
      this.view.offsetY = y2;
      this.view.width = width2;
      this.view.height = height;
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== void 0) {
        this.view.enabled = false;
      }
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.zoom = zoom;
      if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      }
      return this;
    }
    /**
     * Zoom by specified point in viewport coordinates.
     */
  }, {
    key: "setZoomByViewportPoint",
    value: function setZoomByViewportPoint(zoom, viewportPoint) {
      var _this$canvas$viewport = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
      var roll = this.roll;
      this.rotate(0, 0, -roll);
      this.setPosition(ox, oy);
      this.setFocalPoint(ox, oy);
      this.setZoom(zoom);
      this.rotate(0, 0, roll);
      var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
      var dvec = fromValues$2(cx - ox, cy - oy, 0);
      var dx = dot$4(dvec, this.right) / length(this.right);
      var dy = dot$4(dvec, this.up) / length(this.up);
      var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray(_this$getPosition, 2), px2 = _this$getPosition2[0], py = _this$getPosition2[1];
      var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
      this.setPosition(px2 - dx, py - dy);
      this.setFocalPoint(fx - dx, fy - dy);
      return this;
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, fov, aspect) {
      var _this$view;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.fov = fov;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
      var height = 2 * top;
      var width2 = this.aspect * height;
      var left = -0.5 * width2;
      if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
        var fullWidth = this.view.fullWidth;
        var fullHeight = this.view.fullHeight;
        left += this.view.offsetX * width2 / fullWidth;
        top -= this.view.offsetY * height / fullHeight;
        width2 *= this.view.width / fullWidth;
        height *= this.view.height / fullHeight;
      }
      makePerspective(this.projectionMatrix, left, left + width2, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
      invert$1(this.projectionMatrixInverse, this.projectionMatrix);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setOrthographic",
    value: function setOrthographic(l2, r2, t3, b2, near, far) {
      var _this$view2;
      this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
      this.rright = r2;
      this.left = l2;
      this.top = t3;
      this.bottom = b2;
      this.near = near;
      this.far = far;
      var dx = (this.rright - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.rright + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
        ortho(this.projectionMatrix, left, right, top, bottom, near, far);
      } else {
        orthoZO(this.projectionMatrix, left, right, top, bottom, near, far);
      }
      invert$1(this.projectionMatrixInverse, this.projectionMatrix);
      this._getOrthoMatrix();
      this.triggerUpdate();
      return this;
    }
    /**
     * Move the camera in world coordinates.
     * It will keep looking at the current focal point.
     *
     * support scalars or vectors.
     * @example
     * setPosition(1, 2, 3);
     * setPosition([1, 2, 3]);
     */
  }, {
    key: "setPosition",
    value: function setPosition(x2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
      var position2 = createVec3(x2, y2, z2);
      this._setPosition(position2);
      this.setFocalPoint(this.focalPoint);
      this.triggerUpdate();
      return this;
    }
    /**
     * Sets the focal point of this camera in world coordinates.
     *
     * support scalars or vectors.
     * @example
     * setFocalPoint(1, 2, 3);
     * setFocalPoint([1, 2, 3]);
     */
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
      var up = fromValues$2(0, 1, 0);
      this.focalPoint = createVec3(x2, y2, z2);
      if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
        var d3 = subtract$1(create$4(), this.focalPoint, this.position);
        x2 = d3[0];
        y2 = d3[1];
        z2 = d3[2];
        var r2 = length(d3);
        var el = rad2deg(Math.asin(y2 / r2));
        var az = 90 + rad2deg(Math.atan2(z2, x2));
        var m3 = create$5();
        rotateY(m3, m3, deg2rad(az));
        rotateX(m3, m3, deg2rad(el));
        up = transformMat4$1(create$4(), [0, 1, 0], m3);
      }
      invert$1(this.matrix, lookAt(create$5(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getDistance",
    value: function getDistance() {
      return this.distance;
    }
  }, {
    key: "getDistanceVector",
    value: function getDistanceVector() {
      return this.distanceVector;
    }
    /**
     * Moves the camera towards/from the focal point.
     */
  }, {
    key: "setDistance",
    value: function setDistance(d3) {
      if (this.distance === d3 || d3 < 0) {
        return this;
      }
      this.distance = d3;
      if (this.distance < MIN_DISTANCE) {
        this.distance = MIN_DISTANCE;
      }
      this.dollyingStep = this.distance / 100;
      var pos = create$4();
      d3 = this.distance;
      var n2 = this.forward;
      var f2 = this.focalPoint;
      pos[0] = d3 * n2[0] + f2[0];
      pos[1] = d3 * n2[1] + f2[1];
      pos[2] = d3 * n2[2] + f2[2];
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(d3) {
      this.maxDistance = d3;
      return this;
    }
  }, {
    key: "setMinDistance",
    value: function setMinDistance(d3) {
      this.minDistance = d3;
      return this;
    }
    /**
     * 
     * the azimuth in degrees
     */
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = getAngle$1(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }
    /**
     * 
     */
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = getAngle$1(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getElevation",
    value: function getElevation() {
      return this.elevation;
    }
    /**
     * 
     */
  }, {
    key: "setRoll",
    value: function setRoll(angle2) {
      this.roll = getAngle$1(angle2);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getRoll",
    value: function getRoll() {
      return this.roll;
    }
    /**
     * 
     */
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
      this._getOrthoMatrix();
      this.triggerUpdate();
    }
    /**
     * 
     */
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      var rotZ = setAxisAngle(create$2(), [0, 0, 1], deg2rad(this.roll));
      identity$1(this.matrix);
      var rotX = setAxisAngle(create$2(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
      var rotY = setAxisAngle(create$2(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
      var rotQ = multiply$1(create$2(), rotY, rotX);
      rotQ = multiply$1(create$2(), rotQ, rotZ);
      var rotMatrix = fromQuat(create$5(), rotQ);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        translate(this.matrix, this.matrix, this.focalPoint);
        multiply$3(this.matrix, this.matrix, rotMatrix);
        translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CameraType.TRACKING) {
        translate(this.matrix, this.matrix, this.position);
        multiply$3(this.matrix, this.matrix, rotMatrix);
      }
    }
    /**
     * Sets the camera position in the camera matrix
     */
  }, {
    key: "_setPosition",
    value: function _setPosition(x2, y2, z2) {
      this.position = createVec3(x2, y2, z2);
      var m3 = this.matrix;
      m3[12] = this.position[0];
      m3[13] = this.position[1];
      m3[14] = this.position[2];
      m3[15] = 1;
      this._getOrthoMatrix();
    }
    /**
     * Recalculates axes based on the current matrix
     */
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      copy$3(this.right, createVec3(transformMat4(create$3(), [1, 0, 0, 0], this.matrix)));
      copy$3(this.up, createVec3(transformMat4(create$3(), [0, 1, 0, 0], this.matrix)));
      copy$3(this.forward, createVec3(transformMat4(create$3(), [0, 0, 1, 0], this.matrix)));
      normalize$9(this.right, this.right);
      normalize$9(this.up, this.up);
      normalize$9(this.forward, this.forward);
    }
    /**
     * Recalculates euler angles based on the current state
     */
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      var x2 = this.distanceVector[0];
      var y2 = this.distanceVector[1];
      var z2 = this.distanceVector[2];
      var r2 = length(this.distanceVector);
      if (r2 === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CameraType.TRACKING) {
        this.elevation = rad2deg(Math.asin(y2 / r2));
        this.azimuth = rad2deg(Math.atan2(-x2, -z2));
      } else if (this.rotateWorld) {
        this.elevation = rad2deg(Math.asin(y2 / r2));
        this.azimuth = rad2deg(Math.atan2(-x2, -z2));
      } else {
        this.elevation = -rad2deg(Math.asin(y2 / r2));
        this.azimuth = -rad2deg(Math.atan2(-x2, -z2));
      }
    }
    /**
     *  ORBITING 
     */
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      copy$3(this.position, createVec3(transformMat4(create$3(), [0, 0, 0, 1], this.matrix)));
      this._getDistance();
    }
    /**
     *  TRACKING 
     */
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      transformMat3(this.distanceVector, [0, 0, -this.distance], fromMat4(create$6(), this.matrix));
      add$5(this.focalPoint, this.position, this.distanceVector);
      this._getDistance();
    }
    /**
     * 
     */
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = subtract$1(create$4(), this.focalPoint, this.position);
      this.distance = length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }, {
    key: "_getOrthoMatrix",
    value: function _getOrthoMatrix() {
      if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
        return;
      }
      var position2 = this.position;
      var rotZ = setAxisAngle(create$2(), [0, 0, 1], -this.roll * Math.PI / 180);
      fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, fromValues$2((this.rright - this.left) / 2 - position2[0], (this.top - this.bottom) / 2 - position2[1], 0), fromValues$2(this.zoom, this.zoom, 1), position2);
    }
  }, {
    key: "triggerUpdate",
    value: function triggerUpdate() {
      if (this.enableUpdate) {
        var viewMatrix = this.getViewTransform();
        var vpMatrix = multiply$3(create$5(), this.getPerspective(), viewMatrix);
        this.getFrustum().extractFromVPMatrix(vpMatrix);
        this.eventEmitter.emit(CameraEvent.UPDATED);
      }
    }
  }, {
    key: "rotate",
    value: function rotate3(azimuth, elevation, roll) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dolly",
    value: function dolly(value) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name, params) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var Strategy = /* @__PURE__ */ function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
  return Strategy2;
}({});
var SortReason = /* @__PURE__ */ function(SortReason2) {
  SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
  SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
  SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
  return SortReason2;
}({});
var $vec3$2 = create$4();
var $mat4$1 = create$5();
var $quat$2 = create$2();
function updateLocalTransform(transform2) {
  if (!transform2.localDirtyFlag) {
    return;
  }
  var hasSkew = transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0;
  if (hasSkew) {
    fromRotationTranslationScaleOrigin(transform2.localTransform, transform2.localRotation, transform2.localPosition, fromValues$2(1, 1, 1), transform2.origin);
    if (transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0) {
      identity$1($mat4$1);
      $mat4$1[4] = Math.tan(transform2.localSkew[0]);
      $mat4$1[1] = Math.tan(transform2.localSkew[1]);
      multiply$3(transform2.localTransform, transform2.localTransform, $mat4$1);
    }
    var scaling = fromRotationTranslationScaleOrigin($mat4$1, set$3($quat$2, 0, 0, 0, 1), set$5($vec3$2, 1, 1, 1), transform2.localScale, transform2.origin);
    multiply$3(transform2.localTransform, transform2.localTransform, scaling);
  } else {
    var localTransform = transform2.localTransform, localPosition = transform2.localPosition, localRotation = transform2.localRotation, localScale = transform2.localScale, origin = transform2.origin;
    var hasPosition2 = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
    var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
    var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
    var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
    if (!hasRotation && !hasScale && !hasOrigin) {
      if (hasPosition2) {
        fromTranslation(localTransform, localPosition);
      } else {
        identity$1(localTransform);
      }
    } else {
      fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
    }
  }
  transform2.localDirtyFlag = false;
}
function updateWorldTransform(transform2, parentTransform) {
  if (!transform2.dirtyFlag) {
    return;
  }
  if (!parentTransform) {
    copy$4(transform2.worldTransform, transform2.localTransform);
  } else {
    multiply$3(transform2.worldTransform, parentTransform.worldTransform, transform2.localTransform);
  }
  transform2.dirtyFlag = false;
}
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle$1(0, 0, 0, 0)
};
var PropertySyntax = /* @__PURE__ */ function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
  return PropertySyntax2;
}({});
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$2, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$2(format2) {
  var m3, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format2)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn(m3) : l2 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format2)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format2)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format2)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format2)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format2)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format2)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b2, a2) {
  if (a2 <= 0) r2 = g2 = b2 = NaN;
  return new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color$2(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb$1(r2, g2, b2, opacity2) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity2 == null ? 1 : opacity2);
}
function Rgb(r2, g2, b2, opacity2) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity2;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s3, l2, a2) {
  if (a2 <= 0) h2 = s3 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s3 = NaN;
  else if (s3 <= 0) h2 = NaN;
  return new Hsl(h2, s3, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color$2(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s3 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s3) {
    if (r2 === max2) h2 = (g2 - b2) / s3 + (g2 < b2) * 6;
    else if (g2 === max2) h2 = (b2 - r2) / s3 + 2;
    else h2 = (r2 - g2) / s3 + 4;
    s3 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s3 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s3, l2, o2.opacity);
}
function hsl$1(h2, s3, l2, opacity2) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s3, l2, opacity2 == null ? 1 : opacity2);
}
function Hsl(h2, s3, l2, opacity2) {
  this.h = +h2;
  this.s = +s3;
  this.l = +l2;
  this.opacity = +opacity2;
}
define(Hsl, hsl$1, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s3, m1 = 2 * l2 - m22;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
      hsl2rgb(h2, m1, m22),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}
function memoize$1(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var _memoized = function memoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = _memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    _memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  _memoized.cache = new (memoize$1.Cache || Map)();
  memoize$1.cacheList.push(_memoized.cache);
  return _memoized;
}
memoize$1.Cache = Map;
memoize$1.cacheList = [];
memoize$1.clearCache = function() {
  memoize$1.cacheList.forEach(function(cache) {
    return cache.clear();
  });
};
var UnitType = /* @__PURE__ */ function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
  return UnitType2;
}({});
var UnitCategory = /* @__PURE__ */ function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
  return UnitCategory2;
}({});
var Nested = /* @__PURE__ */ function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
  return Nested2;
}({});
var ParenLess = /* @__PURE__ */ function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
  return ParenLess2;
}({});
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType = /* @__PURE__ */ function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
  return CSSStyleValueType2;
}({});
var stringToUnitType = function stringToUnitType2(name) {
  return data.find(function(item) {
    return item.name === name;
  }).unit_type;
};
var unitFromName = function unitFromName2(name) {
  if (!name) {
    return UnitType.kUnknown;
  }
  if (name === "number") {
    return UnitType.kNumber;
  }
  if (name === "percent" || name === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = /* @__PURE__ */ function() {
  function CSSStyleValue2() {
    _classCallCheck(this, CSSStyleValue2);
  }
  return _createClass(CSSStyleValue2, [{
    key: "toString",
    value: (
      // protected abstract toCSSValue(): CSSValue;
      function toString2() {
        return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
      }
    )
  }, {
    key: "isNumericValue",
    value: function isNumericValue() {
      return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
    }
  }], [{
    key: "isAngle",
    value: (
      // static parse(propertyName: string, value: string): CSSStyleValue {
      //   return parseCSSStyleValue(propertyName, value)[0];
      // }
      // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
      //   return parseCSSStyleValue(propertyName, value);
      // }
      function isAngle2(unit) {
        return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
      }
    )
    // static isViewportPercentageLength(type: UnitType) {
    //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
    // }
    // static isContainerPercentageLength(type: UnitType) {
    //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
    // }
  }, {
    key: "isLength",
    value: function isLength2(type) {
      return type >= UnitType.kEms && type < UnitType.kDegrees;
    }
  }, {
    key: "isRelativeUnit",
    value: function isRelativeUnit(type) {
      return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
      type === UnitType.kRems;
    }
  }, {
    key: "isTime",
    value: function isTime(unit) {
      return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
    }
    // static isFrequency(unit: UnitType) {
    //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
    // }
    // static isResolution(type: UnitType) {
    //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
    // }
    // static isFlex(unit: UnitType) {
    //   return unit === UnitType.kFraction;
    // }
  }]);
}();
var CSSColorValue = /* @__PURE__ */ function(_CSSStyleValue) {
  function CSSColorValue2(colorSpace) {
    var _this2;
    _classCallCheck(this, CSSColorValue2);
    _this2 = _callSuper(this, CSSColorValue2);
    _this2.colorSpace = colorSpace;
    return _this2;
  }
  _inherits(CSSColorValue2, _CSSStyleValue);
  return _createClass(CSSColorValue2, [{
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kColorType;
    }
    /**
     * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
     */
  }, {
    key: "to",
    value: function to(colorSpace) {
      return this;
    }
  }]);
}(CSSStyleValue);
var GradientType = /* @__PURE__ */ function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
  return GradientType2;
}({});
var CSSGradientValue = /* @__PURE__ */ function(_CSSStyleValue) {
  function CSSGradientValue2(type, value) {
    var _this2;
    _classCallCheck(this, CSSGradientValue2);
    _this2 = _callSuper(this, CSSGradientValue2);
    _this2.type = type;
    _this2.value = value;
    return _this2;
  }
  _inherits(CSSGradientValue2, _CSSStyleValue);
  return _createClass(CSSGradientValue2, [{
    key: "clone",
    value: function clone2() {
      return new CSSGradientValue2(this.type, this.value);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p2, result) {
      return result;
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kColorType;
    }
  }]);
}(CSSStyleValue);
var CSSKeywordValue = /* @__PURE__ */ function(_CSSStyleValue) {
  function CSSKeywordValue2(value) {
    var _this2;
    _classCallCheck(this, CSSKeywordValue2);
    _this2 = _callSuper(this, CSSKeywordValue2);
    _this2.value = value;
    return _this2;
  }
  _inherits(CSSKeywordValue2, _CSSStyleValue);
  return _createClass(CSSKeywordValue2, [{
    key: "clone",
    value: function clone2() {
      return new CSSKeywordValue2(this.value);
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kKeywordType;
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p2, result) {
      return result + this.value;
    }
  }]);
}(CSSStyleValue);
var formatInfinityOrNaN = function formatInfinityOrNaN2(number2) {
  var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var result = "";
  if (!Number.isFinite(number2)) {
    if (number2 > 0) result = "infinity";
    else result = "-infinity";
  } else {
    result = "NaN";
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit2(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = /* @__PURE__ */ function(_CSSStyleValue) {
  function CSSUnitValue2(value) {
    var _this2;
    var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
    _classCallCheck(this, CSSUnitValue2);
    _this2 = _callSuper(this, CSSUnitValue2);
    var unit;
    if (typeof unitOrName === "string") {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this2.unit = unit;
    _this2.value = value;
    return _this2;
  }
  _inherits(CSSUnitValue2, _CSSStyleValue);
  return _createClass(CSSUnitValue2, [{
    key: "clone",
    value: function clone2() {
      return new CSSUnitValue2(this.value, this.unit);
    }
  }, {
    key: "equals",
    value: function equals2(other) {
      var other_unit_value = other;
      return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kUnitType;
    }
  }, {
    key: "convertTo",
    value: function convertTo(target_unit) {
      if (this.unit === target_unit) {
        return new CSSUnitValue2(this.value, this.unit);
      }
      var canonical_unit = toCanonicalUnit(this.unit);
      if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
        return null;
      }
      var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
      return new CSSUnitValue2(this.value * scale_factor, target_unit);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p2, result) {
      var text;
      switch (this.unit) {
        case UnitType.kUnknown:
          break;
        case UnitType.kInteger:
          text = Number(this.value).toFixed(0);
          break;
        case UnitType.kNumber:
        case UnitType.kPercentage:
        case UnitType.kEms:
        case UnitType.kRems:
        case UnitType.kPixels:
        case UnitType.kDegrees:
        case UnitType.kRadians:
        case UnitType.kGradians:
        case UnitType.kMilliseconds:
        case UnitType.kSeconds:
        case UnitType.kTurns: {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value = this.value;
          var unit = unitTypeToString(this.unit);
          if (value < kMinInteger || value > kMaxInteger) {
            var _unit = unitTypeToString(this.unit);
            if (!Number.isFinite(value) || Number.isNaN(value)) {
              text = formatInfinityOrNaN(value, _unit);
            } else {
              text = value + (_unit || "");
            }
          } else {
            text = "".concat(value).concat(unit);
          }
        }
      }
      result += text;
      return result;
    }
  }]);
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, "px");
new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = /* @__PURE__ */ function(_CSSColorValue) {
  function CSSRGB2(r2, g2, b2) {
    var _this2;
    var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    _classCallCheck(this, CSSRGB2);
    _this2 = _callSuper(this, CSSRGB2, ["rgb"]);
    _this2.r = r2;
    _this2.g = g2;
    _this2.b = b2;
    _this2.alpha = alpha;
    _this2.isNone = isNone;
    return _this2;
  }
  _inherits(CSSRGB2, _CSSColorValue);
  return _createClass(CSSRGB2, [{
    key: "clone",
    value: function clone2() {
      return new CSSRGB2(this.r, this.g, this.b, this.alpha);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p2, result) {
      return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
    }
  }]);
}(CSSColorValue);
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword2(name) {
  if (!keywordCache[name]) {
    keywordCache[name] = new CSSKeywordValue(name);
  }
  return keywordCache[name];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize$1(function(r2, g2, b2, a2) {
  return new CSSRGB(r2, g2, b2, a2);
}, function(r2, g2, b2, a2) {
  return "rgba(".concat(r2, ",").concat(g2, ",").concat(b2, ",").concat(a2, ")");
});
var getOrCreateUnitValue = function getOrCreateUnitValue2(value) {
  var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
  return new CSSUnitValue(value, unitOrName);
};
new CSSUnitValue(50, "%");
function colorStopToString(colorStop) {
  var type = colorStop.type, value = colorStop.value;
  if (type === "hex") {
    return "#".concat(value);
  }
  if (type === "literal") {
    return value;
  }
  if (type === "rgb") {
    return "rgb(".concat(value.join(","), ")");
  }
  return "rgba(".concat(value.join(","), ")");
}
var parseGradient$1 = /* @__PURE__ */ function() {
  var tokens2 = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error2(msg) {
    throw new Error("".concat(input, ": ").concat(msg));
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error2("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens2.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens2.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens2.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens2.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens2.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation5 = orientationMatcher();
      if (orientation5) {
        if (!scan(tokens2.comma)) {
          error2("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation: orientation5,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens2.startCall)) {
        error2("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens2.endCall)) {
        error2("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match2("directional", tokens2.sideOrCorner, 1);
  }
  function matchAngle() {
    return match2("angular", tokens2.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations;
    var radialOrientation = matchRadialOrientation();
    var lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens2.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle2 = match2("shape", /^(circle)/i, 0);
    if (circle2) {
      circle2.style = matchLength() || matchExtentKeyword();
    }
    return circle2;
  }
  function matchEllipse() {
    var ellipse = match2("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match2("extent-keyword", tokens2.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match2("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error2("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens2.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error2("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color2 = matchColor();
    if (!color2) {
      error2("Expected color definition");
    }
    color2.length = matchDistance();
    return color2;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match2("literal", tokens2.literalColor, 0);
  }
  function matchHexColor() {
    return match2("hex", tokens2.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens2.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens2.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens2.number)[1];
  }
  function matchDistance() {
    return match2("%", tokens2.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match2("position-keyword", tokens2.positionKeywords, 1);
  }
  function matchLength() {
    return match2("px", tokens2.pixelValue, 1) || match2("em", tokens2.emValue, 1);
  }
  function match2(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size) {
    input = input.substring(size);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(min2, width2, height, angle2) {
  var rad3 = deg2rad(angle2.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width2 / 2;
  var rcy = ry + height / 2;
  var length2 = Math.abs(width2 * Math.cos(rad3)) + Math.abs(height * Math.sin(rad3));
  var x1 = min2[0] + rcx - Math.cos(rad3) * length2 / 2;
  var y1 = min2[1] + rcy - Math.sin(rad3) * length2 / 2;
  var x2 = min2[0] + rcx + Math.cos(rad3) * length2 / 2;
  var y2 = min2[1] + rcy + Math.sin(rad3) * length2 / 2;
  return {
    x1,
    y1,
    x2,
    y2
  };
}
function computeRadialGradient(min2, width2, height, cx, cy, size) {
  var x2 = cx.value;
  var y2 = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x2 = cx.value / 100 * width2;
  }
  if (cy.unit === UnitType.kPercentage) {
    y2 = cy.value / 100 * height;
  }
  var r2 = Math.max(distanceSquareRoot([0, 0], [x2, y2]), distanceSquareRoot([0, height], [x2, y2]), distanceSquareRoot([width2, height], [x2, y2]), distanceSquareRoot([width2, 0], [x2, y2]));
  if (size) {
    if (size instanceof CSSUnitValue) {
      r2 = size.value;
    } else if (size instanceof CSSKeywordValue) {
      if (size.value === "closest-side") {
        r2 = Math.min(x2, width2 - x2, y2, height - y2);
      } else if (size.value === "farthest-side") {
        r2 = Math.max(x2, width2 - x2, y2, height - y2);
      } else if (size.value === "closest-corner") {
        r2 = Math.min(distanceSquareRoot([0, 0], [x2, y2]), distanceSquareRoot([0, height], [x2, y2]), distanceSquareRoot([width2, height], [x2, y2]), distanceSquareRoot([width2, 0], [x2, y2]));
      }
    }
  }
  return {
    x: x2 + min2[0],
    y: y2 + min2[1],
    r: r2
  };
}
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length2 = colorStops.length;
  colorStops[length2 - 1].length = (_colorStops$length = colorStops[length2 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: "%",
    value: "100"
  };
  if (length2 > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i2 = 1; i2 < length2; i2++) {
    var _colorStops$i$length;
    var offset = (_colorStops$i$length = colorStops[i2].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!isNil(offset) && !isNil(previousOffset)) {
      for (var j = 1; j < i2 - previousIndex; j++) colorStops[previousIndex + j].length = {
        type: "%",
        value: "".concat(previousOffset + (Number(offset) - previousOffset) * j / (i2 - previousIndex))
      };
      previousIndex = i2;
      previousOffset = Number(offset);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize$1(function(orientation5) {
  var angle2;
  if (orientation5.type === "angular") {
    angle2 = Number(orientation5.value);
  } else {
    angle2 = SideOrCornerToDegMap[orientation5.value] || 0;
  }
  return getOrCreateUnitValue(angle2, "deg");
});
var positonToCSSUnitValue = memoize$1(function(position2) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position2 === null || position2 === void 0 ? void 0 : position2.type) === "position") {
    var _position$value = position2.value, x2 = _position$value.x, y2 = _position$value.y;
    if ((x2 === null || x2 === void 0 ? void 0 : x2.type) === "position-keyword") {
      if (x2.value === "left") {
        cx = 0;
      } else if (x2.value === "center") {
        cx = 50;
      } else if (x2.value === "right") {
        cx = 100;
      } else if (x2.value === "top") {
        cy = 0;
      } else if (x2.value === "bottom") {
        cy = 100;
      }
    }
    if ((y2 === null || y2 === void 0 ? void 0 : y2.type) === "position-keyword") {
      if (y2.value === "left") {
        cx = 0;
      } else if (y2.value === "center") {
        cy = 50;
      } else if (y2.value === "right") {
        cx = 100;
      } else if (y2.value === "top") {
        cy = 0;
      } else if (y2.value === "bottom") {
        cy = 100;
      }
    }
    if ((x2 === null || x2 === void 0 ? void 0 : x2.type) === "px" || (x2 === null || x2 === void 0 ? void 0 : x2.type) === "%" || (x2 === null || x2 === void 0 ? void 0 : x2.type) === "em") {
      unitX = x2 === null || x2 === void 0 ? void 0 : x2.type;
      cx = Number(x2.value);
    }
    if ((y2 === null || y2 === void 0 ? void 0 : y2.type) === "px" || (y2 === null || y2 === void 0 ? void 0 : y2.type) === "%" || (y2 === null || y2 === void 0 ? void 0 : y2.type) === "em") {
      unitY = y2 === null || y2 === void 0 ? void 0 : y2.type;
      cy = Number(y2.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient = memoize$1(function(colorStr) {
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient$1(colorStr);
    return ast.map(function(_ref) {
      var type2 = _ref.type, orientation5 = _ref.orientation, colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation5 ? angleToDeg(orientation5) : Odeg,
          steps: steps2
        });
      }
      if (type2 === "radial-gradient") {
        if (!orientation5) {
          orientation5 = [{
            type: "shape",
            value: "circle"
          }];
        }
        if (orientation5[0].type === "shape" && orientation5[0].value === "circle") {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation5[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
          var size;
          if (orientation5[0].style) {
            var _orientation$0$style = orientation5[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;
            if (_type === "extent-keyword") {
              size = getOrCreateKeyword(value);
            } else {
              size = getOrCreateUnitValue(value, _type);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size,
            steps: steps2
          });
        }
      }
      return void 0;
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [new CSSGradientValue(GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
          steps: steps.map(function(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2), offset = _ref3[0], color2 = _ref3[1];
            return {
              offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
              color: color2
            };
          })
        })];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (isString$1(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2), offset = _ref5[0], color2 = _ref5[1];
        return {
          offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
          color: color2
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return object && !!object.image;
}
function isCSSRGB(object) {
  return object && !isNil(object.r) && !isNil(object.g) && !isNil(object.b);
}
var parseColor$1 = memoize$1(function(colorStr) {
  if (isPattern(colorStr)) {
    return _objectSpread2({
      repetition: "repeat"
    }, colorStr);
  }
  if (isNil(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  }
  if (colorStr === "currentColor") {
    colorStr = "black";
  } else if (colorStr === "none") {
    return noneColor;
  }
  var g2 = parseGradient(colorStr);
  if (g2) {
    return g2;
  }
  var color$12 = color$2(colorStr);
  var rgba2 = [0, 0, 0, 0];
  if (color$12 !== null) {
    rgba2[0] = color$12.r || 0;
    rgba2[1] = color$12.g || 0;
    rgba2[2] = color$12.b || 0;
    rgba2[3] = color$12.opacity;
  }
  return getOrCreateRGBA.apply(void 0, rgba2);
});
function mergeColors(left, right) {
  if (!isCSSRGB(left) || !isCSSRGB(right)) {
    return;
  }
  return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function(color2) {
    var rgba2 = color2.slice();
    if (rgba2[3]) {
      for (var i2 = 0; i2 < 3; i2++) rgba2[i2] = Math.round(clamp$1(rgba2[i2], 0, 255));
    }
    rgba2[3] = clamp$1(rgba2[3], 0, 1);
    return "rgba(".concat(rgba2.join(","), ")");
  }];
}
function parseDimension(unitRegExp, string) {
  if (isNil(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = "".concat(string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    }
    if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match2) {
    matchedUnits.push(match2);
    return "U".concat(match2);
  });
  var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLengthUnmemoize = function parseLengthUnmemoize2(css) {
  return parseDimension(new RegExp("px", "g"), css);
};
var parseLength = memoize$1(parseLengthUnmemoize);
var parserPercentageUnmemoize = function parserPercentageUnmemoize2(css) {
  return parseDimension(new RegExp("%", "g"), css);
};
memoize$1(parserPercentageUnmemoize);
var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize2(css) {
  if (isNumber(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css) || 0, "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseLengthOrPercentage = memoize$1(parseLengthOrPercentageUnmemoize);
var parseAngleUnmemoize = function parseAngleUnmemoize2(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
};
var parseAngle = memoize$1(parseAngleUnmemoize);
function mergeDimensions(left, right, target, nonNegative) {
  var index2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var unit = "";
  var leftValue = left.value || 0;
  var rightValue = right.value || 0;
  var canonicalUnit = toCanonicalUnit(left.unit);
  var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left.unit);
  } else if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
    leftValue = convertPercentUnit(left, index2, target);
    rightValue = convertPercentUnit(right, index2, target);
    unit = "px";
  }
  return [leftValue, rightValue, function(value) {
    return value + unit;
  }];
}
function convertAngleUnit(value) {
  var deg3 = 0;
  if (value.unit === UnitType.kDegrees) {
    deg3 = value.value;
  } else if (value.unit === UnitType.kRadians) {
    deg3 = rad2deg(Number(value.value));
  } else if (value.unit === UnitType.kTurns) {
    deg3 = turn2deg(Number(value.value));
  } else if (value.value) {
    deg3 = value.value;
  }
  return deg3;
}
function parseDimensionArrayFormat(string, size) {
  var parsed;
  if (Array.isArray(string)) {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  } else if (isString$1(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (isNumber(string)) {
    parsed = [string];
  }
  if (size === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    }
    return [parsed[0], parsed[1]];
  }
  if (size === 4) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    }
    if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    }
    if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    }
    return [parsed[0], parsed[1], parsed[2], parsed[3]];
  }
  if (size === "even" && parsed.length % 2 === 1) {
    return [].concat(_toConsumableArray(parsed), _toConsumableArray(parsed));
  }
  return parsed;
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  }
  if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
    return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
  }
  return 0;
}
var parseParam = function parseParam2(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
function parseFilter() {
  var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match2;
  var prevLastIndex = 0;
  while (match2 = filterRegExp.exec(filterStr)) {
    if (match2.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match2.index + match2[0].length;
    if (supportedFilters.indexOf(match2[1]) > -1) {
      result.push({
        name: match2[1],
        params: match2[2].split(" ").map(function(p2) {
          return parseParam(p2) || parseColor$1(p2);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}
function numberToString(x2) {
  return x2.toString();
}
var parseNumberUnmemoize = function parseNumberUnmemoize2(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  }
  return getOrCreateUnitValue(0);
};
var parseNumber = memoize$1(parseNumberUnmemoize);
memoize$1(function(string) {
  if (isString$1(string)) {
    return string.split(" ").map(parseNumber);
  }
  return string.map(parseNumber);
});
function mergeNumbers(left, right) {
  return [left, right, numberToString];
}
function clampedMergeNumbers(min2, max2) {
  return function(left, right) {
    return [left, right, function(x2) {
      return numberToString(clamp$1(x2, min2, max2));
    }];
  };
}
function mergeNumberLists(left, right) {
  if (left.length !== right.length) {
    return;
  }
  return [left, right, function(numberList) {
    return numberList;
  }];
}
function getOrCalculatePathTotalLength(path) {
  if (path.parsedStyle.d.totalLength === 0) {
    path.parsedStyle.d.totalLength = getTotalLength(path.parsedStyle.d.absolutePath);
  }
  return path.parsedStyle.d.totalLength;
}
function getOrCalculatePolylineTotalLength(polyline) {
  if (polyline.parsedStyle.points.totalLength === 0) {
    polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
  }
  return polyline.parsedStyle.points.totalLength;
}
function removeRedundantMCommand(path) {
  for (var i2 = 0; i2 < path.length; i2++) {
    var prevSegment = path[i2 - 1];
    var segment = path[i2];
    var cmd = segment[0];
    if (cmd === "M") {
      if (prevSegment) {
        var prevCmd = prevSegment[0];
        var srcPoint = [segment[1], segment[2]];
        var destPoint = void 0;
        if (prevCmd === "L" || prevCmd === "M") {
          destPoint = [prevSegment[1], prevSegment[2]];
        } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
          destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
        }
        if (destPoint && isSamePoint(srcPoint, destPoint)) {
          path.splice(i2, 1);
          i2--;
        }
      }
    }
  }
}
function hasArcOrBezier(path) {
  var hasArc = false;
  var count = path.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i2 = 0; i2 < pathArray.length; i2++) {
    var params = pathArray[i2];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getPathBBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box$1 = void 0;
    switch (segment.command) {
      case "Q":
        box$1 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box$1 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box$1 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box$1) {
      segment.box = box$1;
      xArr.push(box$1.x, box$1.x + box$1.width);
      yArr.push(box$1.y, box$1.y + box$1.height);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min$2(xArr);
  var minY = min$2(yArr);
  var maxX = max$2(xArr);
  var maxY = max$2(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX -= extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX += extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY -= extra.yExtra;
    } else if (_currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY += extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point2, center) {
  return [center[0] + (center[0] - point2[0]), center[1] + (center[1] - point2[1])];
}
var angleBetween = function angleBetween2(v0, v1) {
  var p2 = v0.x * v1.x + v0.y * v1.y;
  var n2 = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle2 = sign * Math.acos(p2 / n2);
  return angle2;
};
var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t3) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod$1(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    };
  }
  if (rx === 0 || ry === 0) {
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= Math.sqrt(radiiCheck);
    ry *= Math.sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle2 = startAngle + sweepAngle * t3;
  var ellipseComponentX = rx * Math.cos(angle2);
  var ellipseComponentY = ry * Math.sin(angle2);
  var point2 = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle2,
    ellipticalArcCenter: center,
    resultantRx: rx,
    resultantRy: ry
  };
  return point2;
};
function path2Segments(path) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    nextParams = path[i2 + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i2;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len2 = params.length;
      currentPoint = [params[len2 - 2], params[len2 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i2 - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var _preSegment = segments[i2 - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === "A") {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio) {
  var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p2 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist2 = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist2,
    y: -yDist / dist2
  };
}
function vMag(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio(u2, v2) {
  return vMag(u2) * vMag(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2)) : 1;
}
function vAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(deg2rad(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u2);
  var dTheta = vAngle(u2, v2);
  if (vRatio(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta -= 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta += 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
var internalParsePath = function internalParsePath2(path) {
  if (path === "" || Array.isArray(path) && path.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path);
  } catch (_unused) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: ".concat(path));
  }
  removeRedundantMCommand(absolutePath);
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
  var segments = path2Segments(absolutePath);
  var _getPathBBox = getPathBBox(segments, 0), x2 = _getPathBBox.x, y2 = _getPathBBox.y, width2 = _getPathBBox.width, height = _getPathBBox.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x2) ? x2 : 0,
      y: Number.isFinite(y2) ? y2 : 0,
      width: Number.isFinite(width2) ? width2 : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize$1(internalParsePath);
function parsePath$1(path) {
  return isString$1(path) ? memoizedParsePath(path) : internalParsePath(path);
}
function mergePaths(left, right, object) {
  var curve1 = left.curve;
  var curve2 = right.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left.absolutePath, false);
    left.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right.absolutePath, false);
    right.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
    return pathArray;
  }];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (isString$1(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray(_pointStr$split, 2), x2 = _pointStr$split2[0], y2 = _pointStr$split2[1];
      return [Number(x2), Number(y2)];
    });
  } else {
    points = pointsOrStr;
  }
  return {
    points,
    totalLength: 0,
    segments: []
  };
}
function mergePoints(left, right) {
  return [left.points, right.points, function(points) {
    return points;
  }];
}
var _$o = null;
var TRANSFORM_REGEXP = /\s*(\w+)\(([^)]*)\)/g;
function cast(pattern) {
  return function(contents) {
    var i2 = 0;
    return pattern.map(function(x2) {
      return x2 === _$o ? contents[i2++] : x2;
    });
  };
}
function id$1(x2) {
  return x2;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_$o, _$o, 0, 0, _$o, _$o, 0, 0, 0, 0, 1, 0, _$o, _$o, 0, 1], id$1],
  matrix3d: ["NNNNNNNNNNNNNNNN", id$1],
  rotate: ["A"],
  rotateX: ["A"],
  rotateY: ["A"],
  rotateZ: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_$o, _$o, new CSSUnitValue(1)]), id$1],
  scaleX: ["N", cast([_$o, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_$o, new CSSUnitValue(1)])],
  scaleY: ["N", cast([new CSSUnitValue(1), _$o, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _$o])],
  scaleZ: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _$o])],
  scale3d: ["NNN", id$1],
  skew: ["Aa", null, id$1],
  skewX: ["A", null, cast([_$o, Odeg])],
  skewY: ["A", null, cast([Odeg, _$o])],
  translate: ["Tt", cast([_$o, _$o, Opx]), id$1],
  translateX: ["T", cast([_$o, Opx, Opx]), cast([_$o, Opx])],
  translateY: ["T", cast([Opx, _$o, Opx]), cast([Opx, _$o])],
  translateZ: ["L", cast([Opx, Opx, _$o])],
  translate3d: ["TTL", id$1]
};
function parseArrayTransform(transform2) {
  var result = [];
  var length2 = transform2.length;
  for (var i2 = 0; i2 < length2; i2++) {
    var item = transform2[i2];
    var name = item[0];
    var args = item.slice(1);
    if (name === "translate" || name === "skew") {
      if (args.length === 1) args.push(0);
    } else if (name === "scale") {
      if (args.length === 1) args.push(args[0]);
    }
    var functionData = transformFunctions[name];
    if (!functionData) return [];
    var parsedArgs = args.map(function(value) {
      return getOrCreateUnitValue(value);
    });
    result.push({
      t: name,
      d: parsedArgs
    });
  }
  return result;
}
function parseTransform(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match2;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match2 = TRANSFORM_REGEXP.exec(transform2)) {
    if (match2.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match2.index + match2[0].length;
    var functionName = match2[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match2[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i2 = 0; i2 < argTypes.length; i2++) {
      var arg = args[i2];
      var type = argTypes[i2];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A3(s3) {
            return s3.trim() === "0" ? Odeg : parseAngle(s3);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function parseTransformUnmemoize(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match2;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match2 = TRANSFORM_REGEXP.exec(transform2)) {
    if (match2.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match2.index + match2[0].length;
    var functionName = match2[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match2[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i2 = 0; i2 < argTypes.length; i2++) {
      var arg = args[i2];
      var type = argTypes[i2];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A3(s3) {
            return s3.trim() === "0" ? Odeg : parseAngleUnmemoize(s3);
          },
          N: parseNumberUnmemoize,
          T: parseLengthOrPercentageUnmemoize,
          L: parseLengthUnmemoize
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x2;
  var y2;
  var z2;
  var angle2;
  switch (item.t) {
    case "rotateX":
      angle2 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle2), Math.sin(angle2), 0, 0, -Math.sin(angle2), Math.cos(angle2), 0, 0, 0, 0, 1];
    case "rotateY":
      angle2 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle2), 0, -Math.sin(angle2), 0, 0, 1, 0, 0, Math.sin(angle2), 0, Math.cos(angle2), 0, 0, 0, 0, 1];
    case "rotate":
    case "rotateZ":
      angle2 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle2), Math.sin(angle2), 0, 0, -Math.sin(angle2), Math.cos(angle2), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "rotate3d":
      x2 = item.d[0].value;
      y2 = item.d[1].value;
      z2 = item.d[2].value;
      angle2 = deg2rad(convertAngleUnit(item.d[3]));
      var sqrLength = x2 * x2 + y2 * y2 + z2 * z2;
      if (sqrLength === 0) {
        x2 = 1;
        y2 = 0;
        z2 = 0;
      } else if (sqrLength !== 1) {
        var length2 = Math.sqrt(sqrLength);
        x2 /= length2;
        y2 /= length2;
        z2 /= length2;
      }
      var s3 = Math.sin(angle2 / 2);
      var sc = s3 * Math.cos(angle2 / 2);
      var sq = s3 * s3;
      return [1 - 2 * (y2 * y2 + z2 * z2) * sq, 2 * (x2 * y2 * sq + z2 * sc), 2 * (x2 * z2 * sq - y2 * sc), 0, 2 * (x2 * y2 * sq - z2 * sc), 1 - 2 * (x2 * x2 + z2 * z2) * sq, 2 * (y2 * z2 * sq + x2 * sc), 0, 2 * (x2 * z2 * sq + y2 * sc), 2 * (y2 * z2 * sq - x2 * sc), 1 - 2 * (x2 * x2 + y2 * y2) * sq, 0, 0, 0, 0, 1];
    case "scale":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleX":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleY":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleZ":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case "skew":
      var xAngle = deg2rad(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewX":
      angle2 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle2), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewY":
      angle2 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle2), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x2 = convertPercentUnit(item.d[0], 0, null) || 0;
      y2 = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x2, y2, 0, 1];
    case "translateX":
      x2 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x2, 0, 0, 1];
    case "translateY":
      y2 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y2, 0, 1];
    case "translateZ":
      z2 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z2, 1];
    case "translate3d":
      x2 = convertPercentUnit(item.d[0], 0, null) || 0;
      y2 = convertPercentUnit(item.d[1], 0, null) || 0;
      z2 = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x2, y2, z2, 1];
    case "perspective":
      var t3 = convertPercentUnit(item.d[0], 0, null) || 0;
      var p2 = t3 ? -1 / t3 : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p2, 0, 0, 0, 1];
    case "matrix":
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case "matrix3d":
      return item.d.map(function(d3) {
        return d3.value;
      });
  }
}
function multiplyMatrices(a2, b2) {
  return [a2[0] * b2[0] + a2[4] * b2[1] + a2[8] * b2[2] + a2[12] * b2[3], a2[1] * b2[0] + a2[5] * b2[1] + a2[9] * b2[2] + a2[13] * b2[3], a2[2] * b2[0] + a2[6] * b2[1] + a2[10] * b2[2] + a2[14] * b2[3], a2[3] * b2[0] + a2[7] * b2[1] + a2[11] * b2[2] + a2[15] * b2[3], a2[0] * b2[4] + a2[4] * b2[5] + a2[8] * b2[6] + a2[12] * b2[7], a2[1] * b2[4] + a2[5] * b2[5] + a2[9] * b2[6] + a2[13] * b2[7], a2[2] * b2[4] + a2[6] * b2[5] + a2[10] * b2[6] + a2[14] * b2[7], a2[3] * b2[4] + a2[7] * b2[5] + a2[11] * b2[6] + a2[15] * b2[7], a2[0] * b2[8] + a2[4] * b2[9] + a2[8] * b2[10] + a2[12] * b2[11], a2[1] * b2[8] + a2[5] * b2[9] + a2[9] * b2[10] + a2[13] * b2[11], a2[2] * b2[8] + a2[6] * b2[9] + a2[10] * b2[10] + a2[14] * b2[11], a2[3] * b2[8] + a2[7] * b2[9] + a2[11] * b2[10] + a2[15] * b2[11], a2[0] * b2[12] + a2[4] * b2[13] + a2[8] * b2[14] + a2[12] * b2[15], a2[1] * b2[12] + a2[5] * b2[13] + a2[9] * b2[14] + a2[13] * b2[15], a2[2] * b2[12] + a2[6] * b2[13] + a2[10] * b2[14] + a2[14] * b2[15], a2[3] * b2[12] + a2[7] * b2[13] + a2[11] * b2[14] + a2[15] * b2[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate4 = [0, 0, 0];
  var scale3 = [1, 1, 1];
  var skew2 = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(
    // @ts-ignore
    convertToMatrix(transformList),
    translate4,
    scale3,
    skew2,
    perspective2,
    quaternion
  );
  return [[translate4, scale3, skew2, quaternion, perspective2]];
}
var composeMatrix = /* @__PURE__ */ function() {
  function multiply2(a2, b2) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i2 = 0; i2 < 4; i2++) {
      for (var j = 0; j < 4; j++) {
        for (var k = 0; k < 4; k++) {
          result[i2][j] += b2[i2][k] * a2[k][j];
        }
      }
    }
    return result;
  }
  function is2D(m3) {
    return m3[0][2] === 0 && m3[0][3] === 0 && m3[1][2] === 0 && m3[1][3] === 0 && m3[2][0] === 0 && m3[2][1] === 0 && m3[2][2] === 1 && m3[2][3] === 0 && m3[3][2] === 0 && m3[3][3] === 1;
  }
  function composeMatrix2(translate4, scale3, skew2, quat2, perspective2) {
    var matrix3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i2 = 0; i2 < 4; i2++) {
      matrix3[i2][3] = perspective2[i2];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix3[3][_i] += translate4[j] * matrix3[j][_i];
      }
    }
    var x2 = quat2[0];
    var y2 = quat2[1];
    var z2 = quat2[2];
    var w2 = quat2[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y2 * y2 + z2 * z2);
    rotMatrix[0][1] = 2 * (x2 * y2 - z2 * w2);
    rotMatrix[0][2] = 2 * (x2 * z2 + y2 * w2);
    rotMatrix[1][0] = 2 * (x2 * y2 + z2 * w2);
    rotMatrix[1][1] = 1 - 2 * (x2 * x2 + z2 * z2);
    rotMatrix[1][2] = 2 * (y2 * z2 - x2 * w2);
    rotMatrix[2][0] = 2 * (x2 * z2 - y2 * w2);
    rotMatrix[2][1] = 2 * (y2 * z2 + x2 * w2);
    rotMatrix[2][2] = 1 - 2 * (x2 * x2 + y2 * y2);
    matrix3 = multiply2(matrix3, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew2[2]) {
      temp[2][1] = skew2[2];
      matrix3 = multiply2(matrix3, temp);
    }
    if (skew2[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew2[0];
      matrix3 = multiply2(matrix3, temp);
    }
    if (skew2[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew2[0];
      matrix3 = multiply2(matrix3, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix3[_i2][_j] *= scale3[_i2];
      }
    }
    if (is2D(matrix3)) {
      return [matrix3[0][0], matrix3[0][1], matrix3[1][0], matrix3[1][1], matrix3[3][0], matrix3[3][1]];
    }
    return matrix3[0].concat(matrix3[1], matrix3[2], matrix3[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x2) {
  return x2.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left, right) {
  var leftArgs;
  var rightArgs;
  if (left.decompositionPair !== right) {
    left.decompositionPair = right;
    leftArgs = makeMatrixDecomposition(left);
  }
  if (right.decompositionPair !== left) {
    right.decompositionPair = left;
    rightArgs = makeMatrixDecomposition(right);
  }
  if (leftArgs[0] === null || rightArgs[0] === null) return [
    // @ts-ignore
    [false],
    // @ts-ignore
    [true],
    // @ts-ignore
    function(x2) {
      return x2 ? right[0].d : left[0].d;
    }
  ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list2) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list2[5]);
      var mat = composeMatrix(list2[0], list2[1], list2[2], q, list2[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot$2(v1, v2) {
  var result = 0;
  for (var i2 = 0; i2 < v1.length; i2++) {
    result += v1[i2] * v2[i2];
  }
  return result;
}
function quat(fromQ, toQ, f2) {
  var product = dot$2(fromQ, toQ);
  product = clamp$1(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w2 = Math.sin(f2 * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i2 = 0; i2 < 4; i2++) {
      quat2.push(fromQ[i2] * (Math.cos(f2 * theta) - product * w2) + toQ[i2] * w2);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[XY]/, "");
}
function typeTo3D(type) {
  return type.replace(/(X|Y|Z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
  return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left, right, target) {
  var flipResults = false;
  if (!left.length || !right.length) {
    if (!left.length) {
      flipResults = true;
      left = right;
      right = [];
    }
    var _loop = function _loop2() {
      var _left$i = left[i2], type2 = _left$i.t, args = _left$i.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i2 = 0; i2 < left.length; i2++) {
      _loop();
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left.length !== right.length) {
    var merged = mergeMatrices(left, right);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left.length; _i3++) {
      var leftType = left[_i3].t;
      var rightType = right[_i3].t;
      var leftArgs = left[_i3].d;
      var rightArgs = right[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
        leftResult.push(_merged[0]);
        rightResult.push(_merged[1]);
        types.push(["matrix", [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left, right);
        leftResult = [_merged2[0]];
        rightResult = [_merged2[1]];
        types = [["matrix", [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [leftResult, rightResult, function(list2) {
    return list2.map(function(args, i3) {
      var stringifiedArgs = args.map(function(arg, j2) {
        return types[i3][1][j2](arg);
      }).join(",");
      if (types[i3][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
        types[i3][0] = "matrix3d";
      }
      if (types[i3][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
        types[i3][0] = "matrix";
      }
      return "".concat(types[i3][0], "(").concat(stringifiedArgs, ")");
    }).join(" ");
  }];
}
var parseTransformOrigin = memoize$1(function(value) {
  if (isString$1(value)) {
    if (value === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values2 = value.split(" ");
    if (values2.length === 1) {
      if (values2[0] === "top" || values2[0] === "bottom") {
        values2[1] = values2[0];
        values2[0] = "center";
      } else {
        values2[1] = "center";
      }
    }
    if (values2.length !== 2) {
      return null;
    }
    return [parseLengthOrPercentage(convertKeyword2Percent(values2[0])), parseLengthOrPercentage(convertKeyword2Percent(values2[1]))];
  }
  return [getOrCreateUnitValue(value[0] || 0, "px"), getOrCreateUnitValue(value[1] || 0, "px")];
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  }
  if (keyword === "left" || keyword === "top") {
    return "0%";
  }
  if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT,
    /**
     * Stroke 'none' won't affect geometry but others will.
     */
    l: true
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    "int": true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    "int": true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    "int": true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    "int": true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    "int": true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    "int": true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    "int": true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    d: "0 0",
    // // int: true,
    // d: (nodeName: string) => {
    //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
    //     return 'center';
    //   }
    //   if (nodeName === Shape.TEXT) {
    //     return 'text-anchor';
    //   }
    //   return 'left top';
    // },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "cx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cz",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "d",
    "int": true,
    l: true,
    d: "",
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    /**
     * support interpolation
     */
    "int": true,
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    "int": true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  }
];
var GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n2) {
  return !!n2.l;
}).map(function(n2) {
  return n2.n;
}));
var propertyMetadataCache = {};
var DefaultStyleValueRegistry = /* @__PURE__ */ function() {
  function DefaultStyleValueRegistry2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, DefaultStyleValueRegistry2);
    this.runtime = runtime2;
    BUILT_IN_PROPERTIES.forEach(function(property) {
      _this2.registerMetadata(property);
    });
  }
  return _createClass(DefaultStyleValueRegistry2, [{
    key: "registerMetadata",
    value: function registerMetadata(metadata) {
      [metadata.n].concat(_toConsumableArray(metadata.a || [])).forEach(function(name) {
        propertyMetadataCache[name] = metadata;
      });
    }
  }, {
    key: "getPropertySyntax",
    value: function getPropertySyntax(syntax) {
      return this.runtime.CSSPropertySyntaxFactory[syntax];
    }
    /**
     * * parse value, eg.
     * fill: 'red' => CSSRGB
     * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
     * fontSize: '2em' => { unit: 'px', value: 32 }
     *
     * * calculate used value
     * * post process
     */
  }, {
    key: "processProperties",
    value: function processProperties(object, attributes) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        forceUpdateGeometry: false
      };
      Object.assign(object.attributes, attributes);
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      assignParsedStyle(object, attributes);
      var needUpdateGeometry = !!options.forceUpdateGeometry;
      if (!needUpdateGeometry) {
        for (var i2 in attributes) {
          if (GEOMETRY_ATTRIBUTE_NAMES.has(i2)) {
            needUpdateGeometry = true;
            break;
          }
        }
      }
      var list2 = getParsedStyleListOf(object);
      if (list2.has("fill") && attributes.fill) {
        object.parsedStyle.fill = parseColor$1(attributes.fill);
      }
      if (list2.has("stroke") && attributes.stroke) {
        object.parsedStyle.stroke = parseColor$1(attributes.stroke);
      }
      if (list2.has("shadowColor") && attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor$1(attributes.shadowColor);
      }
      if (list2.has("filter") && attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      if (list2.has("radius") && !isNil(attributes.radius)) {
        object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius,
          4
        );
      }
      if (list2.has("lineDash") && !isNil(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, "even");
      }
      if (list2.has("points") && attributes.points) {
        object.parsedStyle.points = parsePoints(attributes.points);
      }
      if (list2.has("d") && attributes.d === "") {
        object.parsedStyle.d = _objectSpread2({}, EMPTY_PARSED_PATH);
      }
      if (list2.has("d") && attributes.d) {
        object.parsedStyle.d = parsePath$1(
          // @ts-ignore
          attributes.d
        );
      }
      if (list2.has("textTransform") && attributes.textTransform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (list2.has("clipPath") && !isUndefined(attributes.clipPath)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
      }
      if (list2.has("offsetPath") && attributes.offsetPath) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
      }
      if (list2.has("transform") && attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (list2.has("transformOrigin") && attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      if (list2.has("markerStart") && attributes.markerStart) {
        object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart,
          null,
          null
        );
      }
      if (list2.has("markerEnd") && attributes.markerEnd) {
        object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd,
          null,
          null
        );
      }
      if (list2.has("markerMid") && attributes.markerMid) {
        object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          "",
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid,
          null,
          null
        );
      }
      if (list2.has("zIndex") && !isNil(attributes.zIndex)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);
      }
      if (list2.has("offsetDistance") && !isNil(attributes.offsetDistance)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);
      }
      if (list2.has("transform") && attributes.transform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);
      }
      if (list2.has("transformOrigin") && attributes.transformOrigin) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);
      }
      if (needUpdateGeometry) {
        object.dirty(true, true);
        if (!options.forceUpdateGeometry) {
          this.runtime.sceneGraphService.dirtyToRoot(object);
        }
      }
    }
    /**
     * update geometry when relative props changed,
     * eg. r of Circle, width/height of Rect
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(object) {
      var nodeName = object.nodeName;
      var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
      if (geometryUpdater) {
        var geometry = object.geometry;
        if (!geometry.contentBounds) {
          geometry.contentBounds = new AABB();
        }
        if (!geometry.renderBounds) {
          geometry.renderBounds = new AABB();
        }
        var parsedStyle = object.parsedStyle;
        var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
        var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
        var stroke = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter2 = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin2 = parsedStyle.transformOrigin;
        var center = [cx, cy, cz];
        geometry.contentBounds.update(center, halfExtents);
        var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
        var hasStroke = stroke && !stroke.isNone;
        if (hasStroke) {
          var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
          halfExtents[0] += halfLineWidth;
          halfExtents[1] += halfLineWidth;
        }
        geometry.renderBounds.update(center, halfExtents);
        if (shadowColor && shadowType && shadowType !== "inner") {
          var _geometry$renderBound = geometry.renderBounds, min2 = _geometry$renderBound.min, max2 = _geometry$renderBound.max;
          var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
          var shadowBlurInPixels = shadowBlur || 0;
          var shadowOffsetXInPixels = shadowOffsetX || 0;
          var shadowOffsetYInPixels = shadowOffsetY || 0;
          var shadowLeft = min2[0] - shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowRight = max2[0] + shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowTop = min2[1] - shadowBlurInPixels + shadowOffsetYInPixels;
          var shadowBottom = max2[1] + shadowBlurInPixels + shadowOffsetYInPixels;
          min2[0] = Math.min(min2[0], shadowLeft);
          max2[0] = Math.max(max2[0], shadowRight);
          min2[1] = Math.min(min2[1], shadowTop);
          max2[1] = Math.max(max2[1], shadowBottom);
          geometry.renderBounds.setMinMax(min2, max2);
        }
        filter2.forEach(function(_ref) {
          var name = _ref.name, params = _ref.params;
          if (name === "blur") {
            var blurRadius = params[0].value;
            geometry.renderBounds.update(geometry.renderBounds.center, add$5(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
          } else if (name === "drop-shadow") {
            var _shadowOffsetX = params[0].value;
            var _shadowOffsetY = params[1].value;
            var _shadowBlur = params[2].value;
            var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
            var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
            var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
            var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
            var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
            _min[0] = Math.min(_min[0], _shadowLeft);
            _max[0] = Math.max(_max[0], _shadowRight);
            _min[1] = Math.min(_min[1], _shadowTop);
            _max[1] = Math.max(_max[1], _shadowBottom);
            geometry.renderBounds.setMinMax(_min, _max);
          }
        });
        object.geometry.dirty = false;
        var flipY = hwidth < 0;
        var flipX = hheight < 0;
        var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin2 ? convertPercentUnit(transformOrigin2[0], 0, object, true) : 0);
        var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin2 ? convertPercentUnit(transformOrigin2[1], 1, object, true) : 0);
        if (usedOriginXValue || usedOriginYValue) {
          object.setOrigin(usedOriginXValue, usedOriginYValue);
        }
      }
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation(node, zoom) {
      if (node.style.isSizeAttenuation) {
        if (!node.style.rawLineWidth) {
          node.style.rawLineWidth = node.style.lineWidth;
        }
        node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
        if (node.nodeName === Shape.CIRCLE) {
          if (!node.style.rawR) {
            node.style.rawR = node.style.r;
          }
          node.style.r = (node.style.rawR || 1) / zoom;
        }
      } else {
        if (node.style.rawLineWidth) {
          node.style.lineWidth = node.style.rawLineWidth;
          delete node.style.rawLineWidth;
        }
        if (node.nodeName === Shape.CIRCLE) {
          if (node.style.rawR) {
            node.style.r = node.style.rawR;
            delete node.style.rawR;
          }
        }
      }
    }
  }]);
}();
function assignParsedStyle(object, attributes) {
  var list2 = getParsedStyleListOf(object);
  for (var key in attributes) {
    if (list2.has(key)) {
      object.parsedStyle[key] = attributes[key];
    }
  }
}
function getParsedStyleListOf(object) {
  return object.constructor.PARSED_STYLE_LIST;
}
var CSSPropertyAngle = /* @__PURE__ */ function() {
  function CSSPropertyAngle2() {
    _classCallCheck(this, CSSPropertyAngle2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyAngle2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      return convertAngleUnit(parsed);
    }
  }]);
}();
var CSSPropertyClipPath = /* @__PURE__ */ function() {
  function CSSPropertyClipPath2() {
    _classCallCheck(this, CSSPropertyClipPath2);
  }
  return _createClass(CSSPropertyClipPath2, [{
    key: "calculator",
    value: function calculator(name, oldPath, newPath, object, runtime2) {
      if (newPath instanceof CSSKeywordValue) {
        newPath = null;
      }
      runtime2.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
      if (name === "clipPath") {
        object.forEach(function(leaf) {
          if (leaf.childNodes.length === 0) {
            runtime2.sceneGraphService.dirtyToRoot(leaf);
          }
        });
      }
      return newPath;
    }
  }]);
}();
var CSSPropertyColor = /* @__PURE__ */ function() {
  function CSSPropertyColor2() {
    _classCallCheck(this, CSSPropertyColor2);
    this.parser = parseColor$1;
    this.mixer = mergeColors;
  }
  return _createClass(CSSPropertyColor2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return parsed.value === "none" ? noneColor : transparentColor;
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyFilter = /* @__PURE__ */ function() {
  function CSSPropertyFilter2() {
    _classCallCheck(this, CSSPropertyFilter2);
  }
  return _createClass(CSSPropertyFilter2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }]);
}();
function getFontSize(object) {
  var _ref = object.parsedStyle, fontSize2 = _ref.fontSize;
  return isNil(fontSize2) ? null : fontSize2;
}
var CSSPropertyLengthOrPercentage = /* @__PURE__ */ function() {
  function CSSPropertyLengthOrPercentage2() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyLengthOrPercentage2, [{
    key: "calculator",
    value: (
      /**
       * according to parent's bounds
       *
       * @example
       * CSS.percent(50) -> CSS.px(0.5 * parent.width)
       */
      function calculator(name, oldParsed, computed, object, runtime2) {
        if (isNumber(computed)) {
          return computed;
        }
        if (CSSUnitValue.isRelativeUnit(computed.unit)) {
          if (computed.unit === UnitType.kPercentage) {
            return 0;
          }
          if (computed.unit === UnitType.kEms) {
            if (object.parentNode) {
              var fontSize2 = getFontSize(object.parentNode);
              if (fontSize2) {
                fontSize2 *= computed.value;
                return fontSize2;
              }
            }
            return 0;
          }
          if (computed.unit === UnitType.kRems) {
            var _object$ownerDocument;
            if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
              var _fontSize = getFontSize(object.ownerDocument.documentElement);
              if (_fontSize) {
                _fontSize *= computed.value;
                return _fontSize;
              }
            }
            return 0;
          }
        } else {
          return computed.value;
        }
      }
    )
  }]);
}();
var CSSPropertyLengthOrPercentage12 = /* @__PURE__ */ function() {
  function CSSPropertyLengthOrPercentage122() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage122);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage122, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.map(function(c2) {
        return c2.value;
      });
    }
  }]);
}();
var CSSPropertyLengthOrPercentage14 = /* @__PURE__ */ function() {
  function CSSPropertyLengthOrPercentage142() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage142);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage142, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.map(function(c2) {
        return c2.value;
      });
    }
  }]);
}();
var CSSPropertyMarker = /* @__PURE__ */ function() {
  function CSSPropertyMarker2() {
    _classCallCheck(this, CSSPropertyMarker2);
  }
  return _createClass(CSSPropertyMarker2, [{
    key: "calculator",
    value: function calculator(name, oldMarker, newMarker, object) {
      var _newMarker;
      if (newMarker instanceof CSSKeywordValue) {
        newMarker = null;
      }
      var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
      if (cloned) {
        cloned.style.isMarker = true;
      }
      return cloned;
    }
  }]);
}();
var CSSPropertyNumber = /* @__PURE__ */ function() {
  function CSSPropertyNumber2() {
    _classCallCheck(this, CSSPropertyNumber2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyNumber2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyOffsetDistance = /* @__PURE__ */ function() {
  function CSSPropertyOffsetDistance2() {
    _classCallCheck(this, CSSPropertyOffsetDistance2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOffsetDistance2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
      if (!offsetPath) {
        return;
      }
      var nodeName = offsetPath.nodeName;
      if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
        var point2 = offsetPath.getPoint(offsetDistance);
        if (point2) {
          object.setLocalPosition(point2.x, point2.y);
        }
      }
    }
  }]);
}();
var CSSPropertyOpacity = /* @__PURE__ */ function() {
  function CSSPropertyOpacity2() {
    _classCallCheck(this, CSSPropertyOpacity2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOpacity2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyPath = /* @__PURE__ */ function() {
  function CSSPropertyPath2() {
    _classCallCheck(this, CSSPropertyPath2);
    this.parser = parsePath$1;
    this.mixer = mergePaths;
  }
  return _createClass(CSSPropertyPath2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
        return {
          absolutePath: [],
          hasArc: false,
          segments: [],
          polygons: [],
          polylines: [],
          curve: null,
          totalLength: 0,
          rect: new Rectangle$1(0, 0, 0, 0)
        };
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyPoints = /* @__PURE__ */ _createClass(function CSSPropertyPoints2() {
  _classCallCheck(this, CSSPropertyPoints2);
  this.mixer = mergePoints;
});
var CSSPropertyShadowBlur = /* @__PURE__ */ function(_CSSPropertyLengthOrP) {
  function CSSPropertyShadowBlur2() {
    var _this2;
    _classCallCheck(this, CSSPropertyShadowBlur2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, CSSPropertyShadowBlur2, [].concat(args));
    _this2.mixer = clampedMergeNumbers(0, Infinity);
    return _this2;
  }
  _inherits(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
  return _createClass(CSSPropertyShadowBlur2);
}(CSSPropertyLengthOrPercentage);
var CSSPropertyText = /* @__PURE__ */ function() {
  function CSSPropertyText2() {
    _classCallCheck(this, CSSPropertyText2);
  }
  return _createClass(CSSPropertyText2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        if (parsed.value === "unset") {
          return "";
        }
        return parsed.value;
      }
      return "".concat(parsed);
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      object.nodeValue = "".concat(object.parsedStyle.text) || "";
    }
  }]);
}();
var CSSPropertyTextTransform = /* @__PURE__ */ function() {
  function CSSPropertyTextTransform2() {
    _classCallCheck(this, CSSPropertyTextTransform2);
  }
  return _createClass(CSSPropertyTextTransform2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      var rawText = object.getAttribute("text");
      if (rawText) {
        var transformedText = rawText;
        if (parsed.value === "capitalize") {
          transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
        } else if (parsed.value === "lowercase") {
          transformedText = rawText.toLowerCase();
        } else if (parsed.value === "uppercase") {
          transformedText = rawText.toUpperCase();
        }
        object.parsedStyle.text = transformedText;
      }
      return parsed.value;
    }
  }]);
}();
var CANVAS_Map = /* @__PURE__ */ new WeakMap();
function cleanExistedCanvas(container, canvas2, cleanUp) {
  if (container) {
    var $dom = typeof container === "string" ? document.getElementById(container) : container;
    if (CANVAS_Map.has($dom)) CANVAS_Map.get($dom).destroy(cleanUp);
    CANVAS_Map.set($dom, canvas2);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isElement$1(target) {
  return !!target.getAttribute;
}
function sortedIndex(array, value) {
  var low = 0;
  var high = array.length;
  while (low < high) {
    var mid = low + high >>> 1;
    if (sortByZIndex(array[mid], value) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
  var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
  if (zIndex1 === zIndex2) {
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$parsedStyle;
    var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
    if (clipPath) return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
var PX_SUFFIX = "px";
function setDOMSize($el, width2, height) {
  if (isBrowser && $el.style) {
    $el.style.width = width2 + PX_SUFFIX;
    $el.style.height = height + PX_SUFFIX;
  }
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width2 = getStyle($el, "width");
  if (width2 === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width2);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var clock$1 = typeof performance === "object" && performance.now ? performance : Date;
function isInFragment(node) {
  if (node.nodeName === Shape.FRAGMENT) return true;
  return node.getRootNode().nodeName === Shape.FRAGMENT;
}
function isFillOrStrokeAffected() {
  var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
  var fill = arguments.length > 1 ? arguments[1] : void 0;
  var stroke = arguments.length > 2 ? arguments[2] : void 0;
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var uId = 1;
var uniqueId = function uniqueId2() {
  return uId++;
};
var root = (
  // eslint-disable-next-line no-nested-ternary
  typeof self === "object" && self.self === self ? self : (
    // @ts-ignore
    typeof global === "object" && global.global === global ? (
      // @ts-ignore
      global
    ) : {}
  )
);
var nowOffset = Date.now();
var pnow = function pnow2() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf2(callback) {
  if (typeof callback !== "function") {
    throw new TypeError("".concat(callback, " is not a function"));
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id2 = uniqueId();
  reservedCBs[id2] = callback;
  if (Object.keys(reservedCBs).length > 1) return id2;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay);
  return id2;
};
var polyfillCaf = function polyfillCaf2(id2) {
  delete reservedCBs[id2];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
  if (typeof vp2 !== "string") return polyfillRaf;
  if (vp2 === "") return root.requestAnimationFrame;
  return root["".concat(vp2, "RequestAnimationFrame")];
};
var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
  if (typeof vp2 !== "string") return polyfillCaf;
  if (vp2 === "") return root.cancelAnimationFrame;
  return root["".concat(vp2, "CancelAnimationFrame")] || root["".concat(vp2, "CancelRequestAnimationFrame")];
};
var find$2 = function find(arr, predicate) {
  var i2 = 0;
  while (arr[i2] !== void 0) {
    if (predicate(arr[i2])) return arr[i2];
    i2 += 1;
  }
};
var vp = find$2(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var AsyncParallelHook = /* @__PURE__ */ function() {
  function AsyncParallelHook2() {
    _classCallCheck(this, AsyncParallelHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncParallelHook2, [{
    key: "getCallbacksNum",
    value: function getCallbacksNum() {
      return this.callbacks.length;
    }
  }, {
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function promise() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return Promise.all(this.callbacks.map(function(callback) {
        return callback.apply(void 0, args);
      }));
    }
  }]);
}();
var AsyncSeriesWaterfallHook = /* @__PURE__ */ function() {
  function AsyncSeriesWaterfallHook2() {
    _classCallCheck(this, AsyncSeriesWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncSeriesWaterfallHook2, [{
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function() {
      var _promise = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var _this$callbacks, result, i2, callback, _args = arguments;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.callbacks.length) {
                _context.next = 6;
                break;
              }
              _context.next = 1;
              return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
            case 1:
              result = _context.sent;
              i2 = 1;
            case 2:
              if (!(i2 < this.callbacks.length)) {
                _context.next = 5;
                break;
              }
              callback = this.callbacks[i2];
              _context.next = 3;
              return callback(result);
            case 3:
              result = _context.sent;
            case 4:
              i2++;
              _context.next = 2;
              break;
            case 5:
              return _context.abrupt("return", result);
            case 6:
              return _context.abrupt("return", null);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function promise() {
        return _promise.apply(this, arguments);
      }
      return promise;
    }()
  }]);
}();
var SyncHook = /* @__PURE__ */ function() {
  function SyncHook2() {
    _classCallCheck(this, SyncHook2);
    this.callbacks = [];
  }
  return _createClass(SyncHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argsArr = arguments;
      this.callbacks.forEach(function(callback) {
        callback.apply(void 0, argsArr);
      });
    }
  }]);
}();
var SyncWaterfallHook = /* @__PURE__ */ function() {
  function SyncWaterfallHook2() {
    _classCallCheck(this, SyncWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(SyncWaterfallHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (this.callbacks.length) {
        var argsArr = arguments;
        var result = this.callbacks[0].apply(void 0, argsArr);
        for (var i2 = 1; i2 < this.callbacks.length; i2++) {
          var callback = this.callbacks[i2];
          result = callback(result);
        }
        return result;
      }
      return null;
    }
  }]);
}();
var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function getFontAttr(attributes) {
  var _attributes$fontSize = attributes.fontSize, fontSize2 = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily2 = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle2 = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant2 = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight2 = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
  return {
    fontSize: fontSize2,
    fontFamily: fontFamily2,
    fontStyle: fontStyle2,
    fontVariant: fontVariant2,
    fontWeight: fontWeight2
  };
}
var toFontString = memoize$1(function toFontStringRaw(attributes) {
  var _getFontAttr = getFontAttr(attributes), fontSize2 = _getFontAttr.fontSize, fontFamily2 = _getFontAttr.fontFamily, fontStyle2 = _getFontAttr.fontStyle, fontVariant2 = _getFontAttr.fontVariant, fontWeight2 = _getFontAttr.fontWeight;
  var fontSizeString = isNumber(fontSize2) && "".concat(fontSize2, "px") || "16px";
  var fontFamilies = fontFamily2.split(",");
  for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
    var _fontFamily = fontFamilies[i2].trim();
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = '"'.concat(_fontFamily, '"');
    }
    fontFamilies[i2] = _fontFamily;
  }
  return "".concat(fontStyle2, " ").concat(fontVariant2, " ").concat(fontWeight2, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
}, function(attributes) {
  var _getFontAttr2 = getFontAttr(attributes), fontSize2 = _getFontAttr2.fontSize, fontFamily2 = _getFontAttr2.fontFamily, fontStyle2 = _getFontAttr2.fontStyle, fontVariant2 = _getFontAttr2.fontVariant, fontWeight2 = _getFontAttr2.fontWeight;
  return "".concat(fontStyle2, "_").concat(fontVariant2, "_").concat(fontWeight2, "_").concat(fontSize2, "_").concat(fontFamily2);
});
var MIN_SCALE = 1e-6;
var clampScale = function clampScale2(item) {
  return Math.max(item, MIN_SCALE);
};
function createSkewMatrix(skewMatrix, skewX2, skewY2) {
  identity$1(skewMatrix);
  skewMatrix[4] = Math.tan(skewX2);
  skewMatrix[1] = Math.tan(skewY2);
  return skewMatrix;
}
var $mat4_1 = create$5();
var $mat4_2 = create$5();
var parser = {
  scale: function scale(d3) {
    fromScaling($mat4_1, [d3[0].value, d3[1].value, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleX: function scaleX(d3) {
    fromScaling($mat4_1, [d3[0].value, 1, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleY: function scaleY(d3) {
    fromScaling($mat4_1, [1, d3[0].value, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleZ: function scaleZ(d3) {
    fromScaling($mat4_1, [1, 1, d3[0].value].map(function(item) {
      return clampScale(item);
    }));
  },
  scale3d: function scale3d(d3) {
    fromScaling($mat4_1, [d3[0].value, d3[1].value, d3[2].value].map(function(item) {
      return clampScale(item);
    }));
  },
  translate: function translate2(d3) {
    fromTranslation($mat4_1, [d3[0].value, d3[1].value, 0]);
  },
  translateX: function translateX(d3) {
    fromTranslation($mat4_1, [d3[0].value, 0, 0]);
  },
  translateY: function translateY(d3) {
    fromTranslation($mat4_1, [0, d3[0].value, 0]);
  },
  translateZ: function translateZ(d3) {
    fromTranslation($mat4_1, [0, 0, d3[0].value]);
  },
  translate3d: function translate3d(d3) {
    fromTranslation($mat4_1, [d3[0].value, d3[1].value, d3[2].value]);
  },
  rotate: function rotate(d3) {
    fromZRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotateX: function rotateX2(d3) {
    fromXRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotateY: function rotateY2(d3) {
    fromYRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotateZ: function rotateZ2(d3) {
    fromZRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotate3d: function rotate3d(d3) {
    fromRotation($mat4_1, deg2rad(convertAngleUnit(d3[3])), [d3[0].value, d3[1].value, d3[2].value]);
  },
  skew: function skew(d3) {
    createSkewMatrix($mat4_1, deg2rad(d3[0].value), deg2rad(d3[1].value));
  },
  skewX: function skewX(d3) {
    createSkewMatrix($mat4_1, deg2rad(d3[0].value), 0);
  },
  skewY: function skewY(d3) {
    createSkewMatrix($mat4_1, 0, deg2rad(d3[0].value));
  },
  matrix: function matrix(d3) {
    set$6($mat4_1, d3[0].value, d3[1].value, 0, 0, d3[2].value, d3[3].value, 0, 0, 0, 0, 1, 0, d3[4].value, d3[5].value, 0, 1);
  },
  matrix3d: function matrix3d(d3) {
    set$6.apply(mat4, [$mat4_1].concat(_toConsumableArray(d3.map(function(s3) {
      return s3.value;
    }))));
  }
};
var $vec3One$1 = fromValues$2(1, 1, 1);
var $vec3Zero$1 = create$4();
var optimizer = {
  translate: function translate3(object, d3) {
    runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);
    runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, void 0, void 0, false);
    runtime.sceneGraphService.setLocalPosition(object, [d3[0].value, d3[1].value, 0], false);
    runtime.sceneGraphService.dirtyLocalTransform(object, object.transformable);
  }
};
function parsedTransformToMat4(transform2, object) {
  if (transform2.length) {
    if (transform2.length === 1 && optimizer[transform2[0].t]) {
      optimizer[transform2[0].t](object, transform2[0].d);
      return;
    }
    var m3 = identity$1($mat4_2);
    for (var i2 = 0; i2 < transform2.length; i2++) {
      var _transform$i = transform2[i2], t3 = _transform$i.t, d3 = _transform$i.d;
      var p2 = parser[t3];
      if (p2) {
        p2(d3);
        mul$1(m3, m3, $mat4_1);
      }
    }
    object.setLocalTransform(m3);
  } else {
    object.resetLocalTransform();
  }
  return object.getLocalTransform();
}
var CSSPropertyTransform = /* @__PURE__ */ function() {
  function CSSPropertyTransform2() {
    _classCallCheck(this, CSSPropertyTransform2);
    this.parser = parseTransformUnmemoize;
    this.mixer = mergeTransforms;
  }
  return _createClass(CSSPropertyTransform2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      parsedTransformToMat4(object.parsedStyle.transform, object);
    }
  }]);
}();
var CSSPropertyTransformOrigin = /* @__PURE__ */ function() {
  function CSSPropertyTransformOrigin2() {
    _classCallCheck(this, CSSPropertyTransformOrigin2);
  }
  return _createClass(CSSPropertyTransformOrigin2, [{
    key: "postProcessor",
    value: function postProcessor(object) {
      var transformOrigin2 = object.parsedStyle.transformOrigin;
      if (transformOrigin2[0].unit === UnitType.kPixels && transformOrigin2[1].unit === UnitType.kPixels) {
        object.setOrigin(transformOrigin2[0].value, transformOrigin2[1].value);
      } else {
        object.getGeometryBounds();
      }
    }
  }]);
}();
var CSSPropertyZIndex = /* @__PURE__ */ function() {
  function CSSPropertyZIndex2() {
    _classCallCheck(this, CSSPropertyZIndex2);
  }
  return _createClass(CSSPropertyZIndex2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed, object) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      if (object.parentNode) {
        var parentEntity = object.parentNode;
        var parentRenderable = parentEntity.renderable;
        var parentSortable = parentEntity.sortable;
        if (parentRenderable) {
          parentEntity.dirty();
        }
        if (parentSortable) {
          parentSortable.dirty = true;
          parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
        }
      }
    }
  }]);
}();
var CircleUpdater = /* @__PURE__ */ function() {
  function CircleUpdater2() {
    _classCallCheck(this, CircleUpdater2);
  }
  return _createClass(CircleUpdater2, [{
    key: "update",
    value: function update(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r2 = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
      return {
        cx,
        cy,
        hwidth: r2,
        hheight: r2
      };
    }
  }]);
}();
var EllipseUpdater = /* @__PURE__ */ function() {
  function EllipseUpdater2() {
    _classCallCheck(this, EllipseUpdater2);
  }
  return _createClass(EllipseUpdater2, [{
    key: "update",
    value: function update(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
      return {
        cx,
        cy,
        hwidth: rx,
        hheight: ry
      };
    }
  }]);
}();
var LineUpdater = /* @__PURE__ */ function() {
  function LineUpdater2() {
    _classCallCheck(this, LineUpdater2);
  }
  return _createClass(LineUpdater2, [{
    key: "update",
    value: function update(parsedStyle) {
      var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2;
      var minX = Math.min(x1, x2);
      var maxX = Math.max(x1, x2);
      var minY = Math.min(y1, y2);
      var maxY = Math.max(y1, y2);
      var width2 = maxX - minX;
      var height = maxY - minY;
      var hwidth = width2 / 2;
      var hheight = height / 2;
      return {
        cx: minX + hwidth,
        cy: minY + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PathUpdater = /* @__PURE__ */ function() {
  function PathUpdater2() {
    _classCallCheck(this, PathUpdater2);
  }
  return _createClass(PathUpdater2, [{
    key: "update",
    value: function update(parsedStyle) {
      var d3 = parsedStyle.d;
      var _d$rect = d3.rect, x2 = _d$rect.x, y2 = _d$rect.y, width2 = _d$rect.width, height = _d$rect.height;
      var hwidth = width2 / 2;
      var hheight = height / 2;
      return {
        cx: x2 + hwidth,
        cy: y2 + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PolylineUpdater = /* @__PURE__ */ function() {
  function PolylineUpdater2() {
    _classCallCheck(this, PolylineUpdater2);
  }
  return _createClass(PolylineUpdater2, [{
    key: "update",
    value: function update(parsedStyle) {
      if (parsedStyle.points && isArray$2(parsedStyle.points.points)) {
        var points = parsedStyle.points.points;
        var minX = Math.min.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[0];
        })));
        var maxX = Math.max.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[0];
        })));
        var minY = Math.min.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[1];
        })));
        var maxY = Math.max.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[1];
        })));
        var width2 = maxX - minX;
        var height = maxY - minY;
        var hwidth = width2 / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      }
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var RectUpdater = /* @__PURE__ */ function() {
  function RectUpdater2() {
    _classCallCheck(this, RectUpdater2);
  }
  return _createClass(RectUpdater2, [{
    key: "update",
    value: function update(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x2 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y2 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width2 = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      var contentWidth = width2;
      var contentHeight = height;
      if (src && !isString$1(src)) {
        if (!contentWidth) {
          contentWidth = src.width;
          parsedStyle.width = contentWidth;
        }
        if (!contentHeight) {
          contentHeight = src.height;
          parsedStyle.height = contentHeight;
        }
      }
      return {
        cx: x2 + contentWidth / 2,
        cy: y2 + contentHeight / 2,
        hwidth: contentWidth / 2,
        hheight: contentHeight / 2
      };
    }
  }]);
}();
var TextUpdater = /* @__PURE__ */ function() {
  function TextUpdater2(globalRuntime) {
    _classCallCheck(this, TextUpdater2);
    this.globalRuntime = globalRuntime;
  }
  return _createClass(TextUpdater2, [{
    key: "isReadyToMeasure",
    value: function isReadyToMeasure(parsedStyle, object) {
      var text = parsedStyle.text;
      return text;
    }
  }, {
    key: "update",
    value: function update(parsedStyle, object) {
      var _object$ownerDocument;
      var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign2 = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x2 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y2 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
      if (!this.isReadyToMeasure(parsedStyle, object)) {
        parsedStyle.metrics = {
          font: "",
          width: 0,
          height: 0,
          lines: [],
          lineWidths: [],
          lineHeight: 0,
          maxLineWidth: 0,
          fontProperties: {
            ascent: 0,
            descent: 0,
            fontSize: 0
          },
          lineMetrics: []
        };
        return {
          hwidth: 0,
          hheight: 0,
          cx: 0,
          cy: 0
        };
      }
      var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
      var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
      parsedStyle.metrics = metrics;
      var width2 = metrics.width, height = metrics.height;
      var hwidth = width2 / 2;
      var hheight = height / 2;
      var lineXOffset = x2 + hwidth;
      if (textAlign2 === "center" || textAlign2 === "middle") {
        lineXOffset += lineWidth / 2 - hwidth;
      } else if (textAlign2 === "right" || textAlign2 === "end") {
        lineXOffset += lineWidth - hwidth * 2;
      }
      var lineYOffset = y2 - hheight;
      if (textBaseline === "middle") {
        lineYOffset += hheight;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        lineYOffset += hheight * 2;
      } else if (textBaseline === "alphabetic") ;
      else if (textBaseline === "bottom" || textBaseline === "ideographic") {
        lineYOffset += 0;
      }
      if (dx) {
        lineXOffset += dx;
      }
      if (dy) {
        lineYOffset += dy;
      }
      return {
        cx: lineXOffset,
        cy: lineYOffset,
        hwidth,
        hheight
      };
    }
  }]);
}();
var GroupUpdater = /* @__PURE__ */ function() {
  function GroupUpdater2() {
    _classCallCheck(this, GroupUpdater2);
  }
  return _createClass(GroupUpdater2, [{
    key: "update",
    value: function update(parsedStyle, object) {
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var HTMLUpdater = /* @__PURE__ */ function() {
  function HTMLUpdater2() {
    _classCallCheck(this, HTMLUpdater2);
  }
  return _createClass(HTMLUpdater2, [{
    key: "update",
    value: function update(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x2 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y2 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width2 = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      return {
        cx: x2 + width2 / 2,
        cy: y2 + height / 2,
        hwidth: width2 / 2,
        hheight: height / 2
      };
    }
  }]);
}();
var FederatedEvent = /* @__PURE__ */ function() {
  function FederatedEvent2(manager) {
    _classCallCheck(this, FederatedEvent2);
    this.eventPhase = FederatedEvent2.prototype.NONE;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point();
    this.page = new Point();
    this.canvas = new Point();
    this.viewport = new Point();
    this.composed = false;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  return _createClass(FederatedEvent2, [{
    key: "name",
    get: (
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      /**
       * @deprecated
       */
      function get2() {
        return this.type;
      }
    )
  }, {
    key: "layerX",
    get: function get2() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get2() {
      return this.layer.y;
    }
  }, {
    key: "pageX",
    get: function get2() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get2() {
      return this.page.y;
    }
  }, {
    key: "x",
    get: function get2() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get2() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get2() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get2() {
      return this.canvas.y;
    }
  }, {
    key: "viewportX",
    get: function get2() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get2() {
      return this.viewport.y;
    }
  }, {
    key: "composedPath",
    value: (
      /**
       * The propagation path for this event
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
       *
       * So composedPath()[0] represents the original target.
       * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
       */
      function composedPath() {
        if (this.manager && (!this.path || this.path[0] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
    )
    /**
     * @deprecated
     */
  }, {
    key: "propagationPath",
    get: function get2() {
      return this.composedPath();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
     */
  }, {
    key: "preventDefault",
    value: function preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
     */
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
     */
  }, {
    key: "initEvent",
    value: (
      /**
       * added for compatibility with DOM Event,
       * deprecated props and methods
       */
      function initEvent() {
      }
    )
  }, {
    key: "initUIEvent",
    value: function initUIEvent() {
    }
  }, {
    key: "clone",
    value: function clone2() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var FederatedMouseEvent = /* @__PURE__ */ function(_ref) {
  function FederatedMouseEvent2() {
    var _this2;
    _classCallCheck(this, FederatedMouseEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedMouseEvent2, [].concat(args));
    _this2.client = new Point();
    _this2.movement = new Point();
    _this2.offset = new Point();
    _this2.global = new Point();
    _this2.screen = new Point();
    return _this2;
  }
  _inherits(FederatedMouseEvent2, _ref);
  return _createClass(FederatedMouseEvent2, [{
    key: "clientX",
    get: function get2() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get2() {
      return this.client.y;
    }
  }, {
    key: "movementX",
    get: function get2() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get2() {
      return this.movement.y;
    }
  }, {
    key: "offsetX",
    get: function get2() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get2() {
      return this.offset.y;
    }
  }, {
    key: "globalX",
    get: function get2() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get2() {
      return this.global.y;
    }
  }, {
    key: "screenX",
    get: function get2() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get2() {
      return this.screen.y;
    }
  }, {
    key: "getModifierState",
    value: function getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
  }, {
    key: "initMouseEvent",
    value: function initMouseEvent() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(FederatedEvent);
var FederatedPointerEvent = /* @__PURE__ */ function(_FederatedMouseEvent) {
  function FederatedPointerEvent2() {
    var _this2;
    _classCallCheck(this, FederatedPointerEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedPointerEvent2, [].concat(args));
    _this2.width = 0;
    _this2.height = 0;
    _this2.isPrimary = false;
    return _this2;
  }
  _inherits(FederatedPointerEvent2, _FederatedMouseEvent);
  return _createClass(FederatedPointerEvent2, [{
    key: "getCoalescedEvents",
    value: (
      /**
       * The type of pointer that triggered the event.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
       */
      /**
       * Pressure applied by the pointing device during the event.
       *s
       * A Touch's force property will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
       */
      /**
       * Barrel pressure on a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
       */
      /**
       * Twist of a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
       */
      function getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
    )
    /**
     * @see https://chromestatus.com/feature/5765569655603200
     */
  }, {
    key: "getPredictedEvents",
    value: function getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
    /**
     * @see https://github.com/antvis/G/issues/1115
     * We currently reuses event objects in the event system,
     * avoiding the creation of a large number of event objects.
     * Reused objects are only used to carry different data,
     * such as coordinate information, native event objects,
     * and therefore the lifecycle is limited to the event handler,
     * which can lead to unintended consequences if an attempt is made to cache the entire event object.
     *
     * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
     */
  }, {
    key: "clone",
    value: function clone2() {
      return this.manager.clonePointerEvent(this);
    }
  }]);
}(FederatedMouseEvent);
var FederatedWheelEvent = /* @__PURE__ */ function(_FederatedMouseEvent) {
  function FederatedWheelEvent2() {
    _classCallCheck(this, FederatedWheelEvent2);
    return _callSuper(this, FederatedWheelEvent2, arguments);
  }
  _inherits(FederatedWheelEvent2, _FederatedMouseEvent);
  return _createClass(FederatedWheelEvent2, [{
    key: "clone",
    value: (
      /**
       * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
       * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
       */
      /** Horizontal scroll amount */
      /** Vertical scroll amount */
      /** z-axis scroll amount. */
      function clone2() {
        return this.manager.cloneWheelEvent(this);
      }
    )
  }]);
}(FederatedMouseEvent);
var CustomEvent = /* @__PURE__ */ function(_FederatedEvent) {
  function CustomEvent2(eventName, options) {
    var _this2;
    _classCallCheck(this, CustomEvent2);
    _this2 = _callSuper(this, CustomEvent2, [null]);
    _this2.type = eventName;
    _this2.detail = options === null || options === void 0 ? void 0 : options.detail;
    if (options && !("detail" in options)) {
      _this2.detail = options;
    }
    Object.assign(_this2, options);
    return _this2;
  }
  _inherits(CustomEvent2, _FederatedEvent);
  return _createClass(CustomEvent2);
}(FederatedEvent);
var EventTarget = /* @__PURE__ */ function() {
  function EventTarget2() {
    _classCallCheck(this, EventTarget2);
    this.emitter = new EventEmitter$1();
  }
  return _createClass(EventTarget2, [{
    key: "on",
    value: (
      /**
       * @deprecated
       * @alias addEventListener
       */
      function on(type, listener, options) {
        this.addEventListener(type, listener, options);
        return this;
      }
    )
    /**
     * support `capture` & `once` in options
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
     */
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      var capture = false;
      var once = false;
      if (isBoolean(options)) capture = options;
      else if (options) {
        var _options$capture = options.capture;
        capture = _options$capture === void 0 ? false : _options$capture;
        var _options$once = options.once;
        once = _options$once === void 0 ? false : _options$once;
      }
      if (capture) type += "capture";
      listener = isFunction$1(listener) ? listener : listener.handleEvent;
      var context = isFunction$1(listener) ? void 0 : listener;
      if (once) this.emitter.once(type, listener, context);
      else this.emitter.on(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias removeEventListener
     */
  }, {
    key: "off",
    value: function off(type, listener, options) {
      if (type) {
        this.removeEventListener(type, listener, options);
      } else {
        this.removeAllEventListeners();
      }
      return this;
    }
  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners() {
      var _this$emitter;
      (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      var _listener;
      if (!this.emitter) return this;
      var capture = isBoolean(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
      if (capture) type += "capture";
      listener = isFunction$1(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
      var context = isFunction$1(listener) ? void 0 : listener;
      this.emitter.off(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias dispatchEvent
     */
  }, {
    key: "emit",
    value: function emit2(eventName, object) {
      this.dispatchEvent(new CustomEvent(eventName, object));
    }
  }, {
    key: "dispatchEventToSelf",
    value: function dispatchEventToSelf(e3) {
      e3.target || (e3.target = this);
      e3.currentTarget = this;
      this.emitter.emit(e3.type, e3);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e3) {
      var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var dispatchToSelf = arguments.length > 2 ? arguments[2] : void 0;
      if (dispatchToSelf) {
        this.dispatchEventToSelf(e3);
        return true;
      }
      var canvas2;
      if (this.document) {
        canvas2 = this;
      } else if (this.defaultView) {
        canvas2 = this.defaultView;
      } else {
        var _ownerDocument;
        canvas2 = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
      }
      if (canvas2) {
        e3.manager = canvas2.getEventService();
        if (!e3.manager) return false;
        e3.defaultPrevented = false;
        if (e3.path) {
          e3.path.length = 0;
        } else {
          e3.page = [];
        }
        if (!skipPropagate) {
          e3.target = this;
        }
        e3.manager.dispatchEvent(e3, e3.type, skipPropagate);
      } else {
        this.dispatchEventToSelf(e3);
      }
      return !e3.defaultPrevented;
    }
  }]);
}();
var Node$1 = /* @__PURE__ */ function(_EventTarget) {
  function Node2() {
    var _this2;
    _classCallCheck(this, Node2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Node2, [].concat(args));
    _this2.shadow = false;
    _this2.ownerDocument = null;
    _this2.isConnected = false;
    _this2.baseURI = "";
    _this2.childNodes = [];
    _this2.nodeType = 0;
    _this2.nodeName = "";
    _this2.nodeValue = null;
    _this2.mutations = void 0;
    _this2.parentNode = null;
    _this2.destroyed = false;
    return _this2;
  }
  _inherits(Node2, _EventTarget);
  return _createClass(Node2, [{
    key: "textContent",
    get: (
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get2() {
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        var _iterator = _createForOfIteratorHelper(this.childNodes), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _child = _step.value;
            if (_child.nodeName === Shape.TEXT) {
              out += _child.nodeValue;
            } else {
              out += _child.textContent;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return out;
      }
    ),
    set: function set2(content) {
      var _this2 = this;
      this.childNodes.slice().forEach(function(child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === Shape.TEXT) {
        this.style.text = "".concat(content);
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
     */
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this.parentNode) {
        return this.parentNode.getRootNode(opts);
      }
      if (opts.composed && this.host) {
        return this.host.getRootNode(opts);
      }
      return this;
    }
  }, {
    key: "hasChildNodes",
    value: function hasChildNodes() {
      return this.childNodes.length > 0;
    }
  }, {
    key: "isDefaultNamespace",
    value: function isDefaultNamespace(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupNamespaceURI",
    value: function lookupNamespaceURI(prefix) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupPrefix",
    value: function lookupPrefix(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "normalize",
    value: function normalize2() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
     */
  }, {
    key: "isEqualNode",
    value: function isEqualNode(otherNode) {
      return this === otherNode;
    }
  }, {
    key: "isSameNode",
    value: function isSameNode2(otherNode) {
      return this.isEqualNode(otherNode);
    }
  }, {
    key: "parent",
    get: (
      /**
       * @deprecated
       * @alias parentNode
       */
      function get2() {
        return this.parentNode;
      }
    )
  }, {
    key: "parentElement",
    get: function get2() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get2() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get2() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get2() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get2() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
     * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
     */
  }, {
    key: "compareDocumentPosition",
    value: function compareDocumentPosition(other) {
      if (other === this) {
        return 0;
      }
      var node1Root = other;
      var node2Root = this;
      var node1Hierarchy = [node1Root];
      var node2Hierarchy = [node2Root];
      while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
        var _node1Root$parentNode;
        node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
        node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
      }
      if (node1Root !== node2Root) {
        return Node2.DOCUMENT_POSITION_DISCONNECTED | Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node2.DOCUMENT_POSITION_PRECEDING;
      }
      var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
      var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
      if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
        return longerHierarchy === node1Hierarchy ? (
          // other is a child of this
          Node2.DOCUMENT_POSITION_CONTAINED_BY | Node2.DOCUMENT_POSITION_FOLLOWING
        ) : (
          // this is a child of other
          Node2.DOCUMENT_POSITION_CONTAINS | Node2.DOCUMENT_POSITION_PRECEDING
        );
      }
      var longerStart = longerHierarchy.length - shorterHierarchy.length;
      for (var i2 = shorterHierarchy.length - 1; i2 >= 0; i2--) {
        var shorterHierarchyNode = shorterHierarchy[i2];
        var longerHierarchyNode = longerHierarchy[longerStart + i2];
        if (longerHierarchyNode !== shorterHierarchyNode) {
          var siblings = shorterHierarchyNode.parentNode.childNodes;
          if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
            if (shorterHierarchy === node1Hierarchy) {
              return Node2.DOCUMENT_POSITION_PRECEDING;
            }
            return Node2.DOCUMENT_POSITION_FOLLOWING;
          }
          if (longerHierarchy === node1Hierarchy) {
            return Node2.DOCUMENT_POSITION_PRECEDING;
          }
          return Node2.DOCUMENT_POSITION_FOLLOWING;
        }
      }
      return Node2.DOCUMENT_POSITION_FOLLOWING;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
     */
  }, {
    key: "contain",
    value: (
      /**
       * @deprecated
       * @alias contains
       */
      function contain2(other) {
        return this.contains(other);
      }
    )
  }, {
    key: "contains",
    value: function contains2(other) {
      var tmp2 = other;
      while (tmp2 && this !== tmp2) {
        tmp2 = tmp2.parentNode;
      }
      return !!tmp2;
    }
  }, {
    key: "getAncestor",
    value: function getAncestor(n2) {
      var temp = this;
      while (n2 > 0 && temp) {
        temp = temp.parentNode;
        n2--;
      }
      return temp;
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var stack = [this];
      while (stack.length > 0) {
        var node = stack.pop();
        var result = callback(node);
        if (result === false) {
          break;
        }
        for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
          stack.push(node.childNodes[i2]);
        }
      }
    }
  }], [{
    key: "isNode",
    value: function isNode2(target) {
      return !!target.childNodes;
    }
  }]);
}(EventTarget);
Node$1.DOCUMENT_POSITION_DISCONNECTED = 1;
Node$1.DOCUMENT_POSITION_PRECEDING = 2;
Node$1.DOCUMENT_POSITION_FOLLOWING = 4;
Node$1.DOCUMENT_POSITION_CONTAINS = 8;
Node$1.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node$1.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var PROPAGATION_LIMIT = 2048;
var EventService = /* @__PURE__ */ function() {
  function EventService2(globalRuntime, context) {
    var _this2 = this;
    _classCallCheck(this, EventService2);
    this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
    this.cursor = "default";
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this.tmpMatrix = create$5();
    this.tmpVec3 = create$4();
    this.onPointerDown = function(from) {
      var e3 = _this2.createPointerEvent(from);
      _this2.dispatchEvent(e3, "pointerdown");
      if (e3.pointerType === "touch") {
        _this2.dispatchEvent(e3, "touchstart");
      } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
        var isRightButton = e3.button === 2;
        _this2.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      trackingData.pressTargetsByButton[from.button] = e3.composedPath();
      _this2.freeEvent(e3);
    };
    this.onPointerUp = function(from) {
      var now2 = clock$1.now();
      var e3 = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e3, "pointerup");
      if (e3.pointerType === "touch") {
        _this2.dispatchEvent(e3, "touchend");
      } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
        var isRightButton = e3.button === 2;
        _this2.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var clickTarget = pressTarget;
      if (pressTarget && !e3.composedPath().includes(pressTarget)) {
        var currentTarget = pressTarget;
        while (currentTarget && !e3.composedPath().includes(currentTarget)) {
          e3.currentTarget = currentTarget;
          _this2.notifyTarget(e3, "pointerupoutside");
          if (e3.pointerType === "touch") {
            _this2.notifyTarget(e3, "touchendoutside");
          } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
            var _isRightButton = e3.button === 2;
            _this2.notifyTarget(e3, _isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          if (Node$1.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
        clickTarget = currentTarget;
      }
      if (clickTarget) {
        var _e$detail;
        var clickEvent = _this2.clonePointerEvent(e3, "click");
        clickEvent.target = clickTarget;
        clickEvent.path = [];
        if (!trackingData.clicksByButton[from.button]) {
          trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now2
          };
        }
        var canvas2 = _this2.context.renderingContext.root.ownerDocument.defaultView;
        var clickHistory = trackingData.clicksByButton[from.button];
        if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < canvas2.getConfig().dblClickSpeed) {
          ++clickHistory.clickCount;
        } else {
          clickHistory.clickCount = 1;
        }
        clickHistory.target = clickEvent.target;
        clickHistory.timeStamp = now2;
        clickEvent.detail = clickHistory.clickCount;
        if (!((_e$detail = e3.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
          if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
            _this2.dispatchEvent(clickEvent, "click");
          }
          _this2.dispatchEvent(clickEvent, "pointertap");
        }
        _this2.freeEvent(clickEvent);
      }
      _this2.freeEvent(e3);
    };
    this.onPointerMove = function(from) {
      var e3 = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
      var trackingData = _this2.trackingData(from.pointerId);
      var outTarget = _this2.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget !== e3.target) {
        var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
        var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
        _this2.dispatchEvent(outEvent, "pointerout");
        if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
        if (!e3.composedPath().includes(outTarget)) {
          var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this2.notifyTarget(leaveEvent);
            if (isMouse) {
              _this2.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node$1.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          _this2.freeEvent(leaveEvent);
        }
        _this2.freeEvent(outEvent);
      }
      if (outTarget !== e3.target) {
        var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
        var overEvent = _this2.clonePointerEvent(e3, overType);
        _this2.dispatchEvent(overEvent, "pointerover");
        if (isMouse) _this2.dispatchEvent(overEvent, "mouseover");
        var overTargetAncestor = outTarget && Node$1.isNode(outTarget) && outTarget.parentNode;
        while (overTargetAncestor && overTargetAncestor !== (Node$1.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          if (overTargetAncestor === e3.target) break;
          overTargetAncestor = overTargetAncestor.parentNode;
        }
        var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node$1.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
        if (didPointerEnter) {
          var enterEvent = _this2.clonePointerEvent(e3, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node$1.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            enterEvent.currentTarget = enterEvent.target;
            _this2.notifyTarget(enterEvent);
            if (isMouse) _this2.notifyTarget(enterEvent, "mouseenter");
            if (Node$1.isNode(enterEvent.target)) {
              enterEvent.target = enterEvent.target.parentNode;
            }
          }
          _this2.freeEvent(enterEvent);
        }
        _this2.freeEvent(overEvent);
      }
      _this2.dispatchEvent(e3, "pointermove");
      if (e3.pointerType === "touch") _this2.dispatchEvent(e3, "touchmove");
      if (isMouse) {
        _this2.dispatchEvent(e3, "mousemove");
        _this2.cursor = _this2.getCursor(e3.target);
      }
      trackingData.overTargets = e3.composedPath();
      _this2.freeEvent(e3);
    };
    this.onPointerOut = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
        var outTarget = _this2.findMountedTarget(trackingData.overTargets);
        var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
        _this2.dispatchEvent(outEvent);
        if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
        var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && leaveEvent.target !== (Node$1.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          leaveEvent.currentTarget = leaveEvent.target;
          _this2.notifyTarget(leaveEvent);
          if (isMouse) {
            _this2.notifyTarget(leaveEvent, "mouseleave");
          }
          if (Node$1.isNode(leaveEvent.target)) {
            leaveEvent.target = leaveEvent.target.parentNode;
          }
        }
        trackingData.overTargets = null;
        _this2.freeEvent(outEvent);
        _this2.freeEvent(leaveEvent);
      }
      _this2.cursor = null;
    };
    this.onPointerOver = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var e3 = _this2.createPointerEvent(from);
      var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
      _this2.dispatchEvent(e3, "pointerover");
      if (isMouse) _this2.dispatchEvent(e3, "mouseover");
      if (e3.pointerType === "mouse") _this2.cursor = _this2.getCursor(e3.target);
      var enterEvent = _this2.clonePointerEvent(e3, "pointerenter");
      enterEvent.eventPhase = enterEvent.AT_TARGET;
      while (enterEvent.target && enterEvent.target !== (Node$1.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
        enterEvent.currentTarget = enterEvent.target;
        _this2.notifyTarget(enterEvent);
        if (isMouse) {
          _this2.notifyTarget(enterEvent, "mouseenter");
        }
        if (Node$1.isNode(enterEvent.target)) {
          enterEvent.target = enterEvent.target.parentNode;
        }
      }
      trackingData.overTargets = e3.composedPath();
      _this2.freeEvent(e3);
      _this2.freeEvent(enterEvent);
    };
    this.onPointerUpOutside = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var e3 = _this2.createPointerEvent(from);
      if (pressTarget) {
        var currentTarget = pressTarget;
        while (currentTarget) {
          e3.currentTarget = currentTarget;
          _this2.notifyTarget(e3, "pointerupoutside");
          if (e3.pointerType === "touch") ;
          else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
            _this2.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
          }
          if (Node$1.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
      }
      _this2.freeEvent(e3);
    };
    this.onWheel = function(from) {
      var wheelEvent = _this2.createWheelEvent(from);
      _this2.dispatchEvent(wheelEvent);
      _this2.freeEvent(wheelEvent);
    };
    this.onClick = function(from) {
      if (_this2.context.config.useNativeClickEvent) {
        var e3 = _this2.createPointerEvent(from);
        _this2.dispatchEvent(e3);
        _this2.freeEvent(e3);
      }
    };
    this.onPointerCancel = function(from) {
      var e3 = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e3);
      _this2.freeEvent(e3);
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(EventService2, [{
    key: "init",
    value: function init() {
      this.rootTarget = this.context.renderingContext.root.parentNode;
      this.addEventMapping("pointerdown", this.onPointerDown);
      this.addEventMapping("pointerup", this.onPointerUp);
      this.addEventMapping("pointermove", this.onPointerMove);
      this.addEventMapping("pointerout", this.onPointerOut);
      this.addEventMapping("pointerleave", this.onPointerOut);
      this.addEventMapping("pointercancel", this.onPointerCancel);
      this.addEventMapping("pointerover", this.onPointerOver);
      this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
      this.addEventMapping("wheel", this.onWheel);
      this.addEventMapping("click", this.onClick);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.mappingTable = {};
      this.mappingState = {};
      this.eventPool.clear();
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var bbox = this.context.contextService.getBoundingClientRect();
      var scaleX2 = 1;
      var scaleY2 = 1;
      var $el = this.context.contextService.getDomElement();
      if ($el && bbox) {
        var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
        if (offsetWidth && offsetHeight) {
          scaleX2 = bbox.width / offsetWidth;
          scaleY2 = bbox.height / offsetHeight;
        }
      }
      return {
        scaleX: scaleX2,
        scaleY: scaleY2,
        bbox
      };
    }
    /**
     * Should account for CSS Transform applied on container.
     * @see https://github.com/antvis/G/issues/1161
     * @see https://github.com/antvis/G/issues/1677
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
     */
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
      return new Point((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas2) {
      var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
      return new Point((canvas2.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas2.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(_ref) {
      var x2 = _ref.x, y2 = _ref.y;
      var canvas2 = this.rootTarget.defaultView;
      var camera = canvas2.getCamera();
      var _this$context$config = this.context.config, width2 = _this$context$config.width, height = _this$context$config.height;
      var projectionMatrixInverse = camera.getPerspectiveInverse();
      var worldMatrix = camera.getWorldTransform();
      var vpMatrix = multiply$3(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
      var viewport = set$5(this.tmpVec3, x2 / width2 * 2 - 1, (1 - y2 / height) * 2 - 1, 0);
      transformMat4$1(viewport, viewport, vpMatrix);
      return new Point(viewport[0], viewport[1]);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvasP) {
      var canvas2 = this.rootTarget.defaultView;
      var camera = canvas2.getCamera();
      var projectionMatrix = camera.getPerspective();
      var viewMatrix = camera.getViewTransform();
      var vpMatrix = multiply$3(this.tmpMatrix, projectionMatrix, viewMatrix);
      var clip = set$5(this.tmpVec3, canvasP.x, canvasP.y, 0);
      transformMat4$1(this.tmpVec3, this.tmpVec3, vpMatrix);
      var _this$context$config2 = this.context.config, width2 = _this$context$config2.width, height = _this$context$config2.height;
      return new Point((clip[0] + 1) / 2 * width2, (1 - (clip[1] + 1) / 2) * height);
    }
  }, {
    key: "setPickHandler",
    value: function setPickHandler(pickHandler) {
      this.pickHandler = pickHandler;
    }
  }, {
    key: "addEventMapping",
    value: function addEventMapping(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn,
        priority: 0
      });
      this.mappingTable[type].sort(function(a2, b2) {
        return a2.priority - b2.priority;
      });
    }
  }, {
    key: "mapEvent",
    value: function mapEvent(e3) {
      if (!this.rootTarget) {
        return;
      }
      var mappers = this.mappingTable[e3.type];
      if (mappers) {
        for (var i2 = 0, j = mappers.length; i2 < j; i2++) {
          mappers[i2].fn(e3);
        }
      } else {
        console.warn("[EventService]: Event mapping not defined for ".concat(e3.type));
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e3, type, skipPropagate) {
      if (!skipPropagate) {
        e3.propagationStopped = false;
        e3.propagationImmediatelyStopped = false;
        this.propagate(e3, type);
      } else {
        e3.eventPhase = e3.AT_TARGET;
        var canvas2 = this.rootTarget.defaultView || null;
        e3.currentTarget = canvas2;
        this.notifyListeners(e3, type);
      }
    }
  }, {
    key: "propagate",
    value: function propagate(e3, type) {
      if (!e3.target) {
        return;
      }
      var composedPath = e3.composedPath();
      e3.eventPhase = e3.CAPTURING_PHASE;
      for (var i2 = composedPath.length - 1; i2 >= 1; i2--) {
        e3.currentTarget = composedPath[i2];
        this.notifyTarget(e3, type);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
      }
      e3.eventPhase = e3.AT_TARGET;
      e3.currentTarget = e3.target;
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
      var index2 = composedPath.indexOf(e3.currentTarget);
      e3.eventPhase = e3.BUBBLING_PHASE;
      for (var _i = index2 + 1; _i < composedPath.length; _i++) {
        e3.currentTarget = composedPath[_i];
        this.notifyTarget(e3, type);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
      }
    }
  }, {
    key: "propagationPath",
    value: function propagationPath(target) {
      var propagationPath2 = [target];
      var canvas2 = this.rootTarget.defaultView || null;
      if (canvas2 && canvas2 === target) {
        propagationPath2.unshift(canvas2.document);
        return propagationPath2;
      }
      for (var i2 = 0; i2 < PROPAGATION_LIMIT && target !== this.rootTarget; i2++) {
        if (Node$1.isNode(target) && target.parentNode) {
          propagationPath2.push(target.parentNode);
          target = target.parentNode;
        }
      }
      if (canvas2) {
        propagationPath2.push(canvas2);
      }
      return propagationPath2;
    }
  }, {
    key: "hitTest",
    value: function hitTest(position2) {
      var viewportX = position2.viewportX, viewportY = position2.viewportY;
      var _this$context$config3 = this.context.config, width2 = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
      if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
        return null;
      }
      return !disableHitTesting && this.pickHandler(position2) || this.rootTarget || // return Document
      null;
    }
    /**
     * whether the native event trigger came from Canvas,
     * should account for HTML shape
     */
  }, {
    key: "isNativeEventFromCanvas",
    value: function isNativeEventFromCanvas($el, nativeEvent) {
      var _target;
      var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
      if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
        target = nativeEvent.composedPath()[0];
      }
      if (target) {
        if (target === $el) {
          return true;
        }
        if ($el && $el.contains) {
          return $el.contains(target);
        }
      }
      if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
        return nativeEvent.composedPath().indexOf($el) > -1;
      }
      return false;
    }
    /**
     * Find HTML from composed path in native UI event.
     */
  }, {
    key: "getExistedHTML",
    value: function getExistedHTML(event) {
      if (event.nativeEvent.composedPath) {
        for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
          var eventTarget = _arr[_i2];
          var existed = this.nativeHTMLMap.get(eventTarget);
          if (existed) {
            return existed;
          }
        }
      }
      return null;
    }
  }, {
    key: "pickTarget",
    value: function pickTarget(event) {
      return this.hitTest({
        clientX: event.clientX,
        clientY: event.clientY,
        viewportX: event.viewportX,
        viewportY: event.viewportY,
        x: event.canvasX,
        y: event.canvasY
      });
    }
  }, {
    key: "createPointerEvent",
    value: function createPointerEvent(from, type, target, fallbackTarget) {
      var event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
      if (typeof type === "string") {
        event.type = type;
      }
      return event;
    }
  }, {
    key: "createWheelEvent",
    value: function createWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
      return event;
    }
  }, {
    key: "trackingData",
    value: function trackingData(id2) {
      if (!this.mappingState.trackingData[id2]) {
        this.mappingState.trackingData[id2] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id2];
    }
  }, {
    key: "cloneWheelEvent",
    value: function cloneWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = from.type;
      return event;
    }
  }, {
    key: "clonePointerEvent",
    value: function clonePointerEvent(from, type) {
      var event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type !== null && type !== void 0 ? type : event.type;
      return event;
    }
  }, {
    key: "copyPointerData",
    value: function copyPointerData(from, to) {
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    }
  }, {
    key: "copyMouseData",
    value: function copyMouseData(from, to) {
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.shiftKey = from.shiftKey;
      to.client.copyFrom(from.client);
      to.movement.copyFrom(from.movement);
      to.canvas.copyFrom(from.canvas);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
      to.offset.copyFrom(from.offset);
    }
  }, {
    key: "copyWheelData",
    value: function copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
  }, {
    key: "copyData",
    value: function copyData(from, to) {
      to.isTrusted = from.isTrusted;
      to.timeStamp = clock$1.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.page.copyFrom(from.page);
      to.viewport.copyFrom(from.viewport);
    }
  }, {
    key: "allocateEvent",
    value: function allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      var event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = [];
      event.target = null;
      return event;
    }
  }, {
    key: "freeEvent",
    value: function freeEvent(event) {
      if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      var constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    }
  }, {
    key: "notifyTarget",
    value: function notifyTarget(e3, type) {
      type = type !== null && type !== void 0 ? type : e3.type;
      var key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? "".concat(type, "capture") : type;
      this.notifyListeners(e3, key);
      if (e3.eventPhase === e3.AT_TARGET) {
        this.notifyListeners(e3, type);
      }
    }
  }, {
    key: "notifyListeners",
    value: function notifyListeners(e3, type) {
      var emitter = e3.currentTarget.emitter;
      var listeners = emitter._events[type];
      if (!listeners) return;
      if ("fn" in listeners) {
        if (listeners.once) {
          emitter.removeListener(type, listeners.fn, void 0, true);
        }
        listeners.fn.call(e3.currentTarget || listeners.context, e3);
      } else {
        for (var i2 = 0; i2 < listeners.length && !e3.propagationImmediatelyStopped; i2++) {
          if (listeners[i2].once) {
            emitter.removeListener(type, listeners[i2].fn, void 0, true);
          }
          listeners[i2].fn.call(e3.currentTarget || listeners[i2].context, e3);
        }
      }
    }
    /**
     * some detached nodes may exist in propagation path, need to skip them
     */
  }, {
    key: "findMountedTarget",
    value: function findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      var currentTarget = propagationPath[propagationPath.length - 1];
      for (var i2 = propagationPath.length - 2; i2 >= 0; i2--) {
        var target = propagationPath[i2];
        if (target === this.rootTarget || Node$1.isNode(target) && target.parentNode === currentTarget) {
          currentTarget = propagationPath[i2];
        } else {
          break;
        }
      }
      return currentTarget;
    }
  }, {
    key: "getCursor",
    value: function getCursor(target) {
      var tmp2 = target;
      while (tmp2) {
        var cursor = isElement$1(tmp2) && tmp2.getAttribute("cursor");
        if (cursor) {
          return cursor;
        }
        tmp2 = Node$1.isNode(tmp2) && tmp2.parentNode;
      }
    }
  }]);
}();
var OffscreenCanvasCreator = /* @__PURE__ */ function() {
  function OffscreenCanvasCreator2() {
    _classCallCheck(this, OffscreenCanvasCreator2);
  }
  return _createClass(OffscreenCanvasCreator2, [{
    key: "getOrCreateCanvas",
    value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
      if (this.canvas) {
        return this.canvas;
      }
      if (offscreenCanvas || runtime.offscreenCanvas) {
        this.canvas = offscreenCanvas || runtime.offscreenCanvas;
        this.context = this.canvas.getContext("2d", _objectSpread2({
          willReadFrequently: true
        }, contextAttributes));
      } else {
        try {
          this.canvas = new window.OffscreenCanvas(0, 0);
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
          if (!this.context || !this.context.measureText) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d");
          }
        } catch (_unused) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
        }
      }
      this.canvas.width = 10;
      this.canvas.height = 10;
      return this.canvas;
    }
  }, {
    key: "getOrCreateContext",
    value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
      if (this.context) {
        return this.context;
      }
      this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
      return this.context;
    }
  }], [{
    key: "createCanvas",
    value: (
      /**
       * @returns new canvas instance
       */
      function createCanvas2() {
        try {
          return new window.OffscreenCanvas(0, 0);
        } catch (_unused2) {
        }
        try {
          return document.createElement("canvas");
        } catch (_unused3) {
        }
        return null;
      }
    )
  }]);
}();
var RenderReason = /* @__PURE__ */ function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
  return RenderReason2;
}({});
var RenderingService = /* @__PURE__ */ function() {
  function RenderingService2(globalRuntime, context) {
    _classCallCheck(this, RenderingService2);
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new SyncHook(),
      initAsync: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook(),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(),
      /**
       * commit - draw the result on the canvas
       */
      endFrame: new SyncHook(),
      destroy: new SyncHook(),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(),
      pointerUp: new SyncHook(),
      pointerMove: new SyncHook(),
      pointerOut: new SyncHook(),
      pointerOver: new SyncHook(),
      pointerWheel: new SyncHook(),
      pointerCancel: new SyncHook(),
      click: new SyncHook()
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(RenderingService2, [{
    key: "init",
    value: function init(callback) {
      var _this2 = this;
      var context = _objectSpread2(_objectSpread2({}, this.globalRuntime), this.context);
      this.context.renderingPlugins.forEach(function(plugin) {
        plugin.apply(context, _this2.globalRuntime);
      });
      this.hooks.init.call();
      if (this.hooks.initAsync.getCallbacksNum() === 0) {
        this.inited = true;
        callback();
      } else {
        this.hooks.initAsync.promise().then(function() {
          _this2.inited = true;
          callback();
        })["catch"](function(err) {
        });
      }
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.stats;
    }
    /**
     * Meet the following conditions:
     * * disable DirtyRectangleRendering
     * * camera changed
     */
  }, {
    key: "disableDirtyRectangleRendering",
    value: function disableDirtyRectangleRendering() {
      var renderer = this.context.config.renderer;
      var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
      return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "render",
    value: function render(canvas2, frame2, rerenderCallback) {
      var _this2 = this;
      var canvasConfig = canvas2.getConfig();
      var renderingContext = this.context.renderingContext;
      this.stats.total = 0;
      this.stats.rendered = 0;
      this.zIndexCounter = 0;
      this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
      this.globalRuntime.sceneGraphService.notifyMutationObservers(canvas2);
      if (renderingContext.renderReasons.size && this.inited) {
        renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
        var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
        var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !onlyCameraChanged;
        if (shouldTriggerRenderHooks) {
          this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
        }
        this.hooks.beginFrame.call(frame2);
        if (shouldTriggerRenderHooks) {
          renderingContext.renderListCurrentFrame.forEach(function(object) {
            _this2.hooks.beforeRender.call(object);
            _this2.hooks.render.call(object);
            _this2.hooks.afterRender.call(object);
          });
        }
        this.hooks.endFrame.call(frame2);
        renderingContext.renderListCurrentFrame = [];
        renderingContext.renderReasons.clear();
        rerenderCallback();
      }
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
      var self2 = this;
      var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
      function internalRenderSingleDisplayObject(object) {
        var renderable = object.renderable, sortable = object.sortable;
        var objectChanged = enableDirtyCheck ? (
          // @ts-ignore
          renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
        ) : object;
        var objectToRender = null;
        if (objectChanged) {
          objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
          if (objectToRender) {
            self2.stats.rendered += 1;
            renderingContext.renderListCurrentFrame.push(objectToRender);
          }
        }
        object.dirty(false);
        sortable.renderOrder = self2.zIndexCounter;
        self2.zIndexCounter += 1;
        self2.stats.total += 1;
        if (sortable.dirty) {
          self2.sort(object, sortable);
          sortable.dirty = false;
          sortable.dirtyChildren = [];
          sortable.dirtyReason = void 0;
        }
      }
      var stack = [displayObject];
      while (stack.length > 0) {
        var _currentObject$sortab;
        var currentObject = stack.pop();
        internalRenderSingleDisplayObject(currentObject);
        var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
        for (var i2 = objects.length - 1; i2 >= 0; i2--) {
          stack.push(objects[i2]);
        }
      }
    }
  }, {
    key: "sort",
    value: function sort2(displayObject, sortable) {
      var _sortable$sorted, _sortable$sorted2;
      if ((sortable === null || sortable === void 0 || (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) > 0 && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
        sortable.dirtyChildren.forEach(function(child) {
          var sortIndex = sortable.sorted.indexOf(child);
          if (sortIndex > -1) {
            sortable.sorted.splice(sortIndex, 1);
          }
          var index2 = displayObject.childNodes.indexOf(child);
          if (index2 > -1) {
            if (sortable.sorted.length === 0) {
              sortable.sorted.push(child);
            } else {
              var _index = sortedIndex(sortable.sorted, child);
              sortable.sorted.splice(_index, 0, child);
            }
          }
        });
      } else {
        sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      }
      if (((_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) > 0 && displayObject.childNodes.filter(function(child) {
        return child.parsedStyle.zIndex;
      }).length === 0) {
        sortable.sorted = [];
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.inited = false;
      this.hooks.destroy.call();
    }
  }, {
    key: "dirty",
    value: function dirty() {
      this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
    }
  }]);
}();
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = /* @__PURE__ */ function() {
  function DefaultSceneGraphSelector2() {
    _classCallCheck(this, DefaultSceneGraphSelector2);
  }
  return _createClass(DefaultSceneGraphSelector2, [{
    key: "selectOne",
    value: function selectOne(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.find(function(node) {
          return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.find(function(node) {
          return node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;
        if (name) {
          return root2.find(function(node) {
            return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
          });
        }
        return null;
      }
      return root2.find(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "selectAll",
    value: function selectAll(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.findAll(function(node) {
          return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.findAll(function(node) {
          return root2 !== node && node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;
        if (name) {
          return root2.findAll(function(node) {
            return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
          });
        }
        return [];
      }
      return root2.findAll(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "is",
    value: function is(query, node) {
      if (query.startsWith(".")) {
        return node.className === this.getIdOrClassname(query);
      }
      if (query.startsWith("#")) {
        return node.id === this.getIdOrClassname(query);
      }
      if (query.startsWith("[")) {
        var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;
        return name === "name" ? node.name === value : this.attributeToString(node, name) === value;
      }
      return node.nodeName === query;
    }
  }, {
    key: "getIdOrClassname",
    value: function getIdOrClassname(query) {
      return query.substring(1);
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(query) {
      var matches = query.match(ATTRIBUTE_REGEXP);
      var name = "";
      var value = "";
      if (matches && matches.length > 2) {
        name = matches[1].replace(/"/g, "");
        value = matches[2].replace(/"/g, "");
      }
      return {
        name,
        value
      };
    }
  }, {
    key: "attributeToString",
    value: function attributeToString(node, name) {
      if (!node.getAttribute) {
        return "";
      }
      var value = node.getAttribute(name);
      if (isNil(value)) {
        return "";
      }
      if (value.toString) {
        return value.toString();
      }
      return "";
    }
  }]);
}();
var ElementEvent = /* @__PURE__ */ function(ElementEvent2) {
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["CULLED"] = "culled";
  return ElementEvent2;
}({});
var MutationEvent = /* @__PURE__ */ function(_FederatedEvent) {
  function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this2;
    _classCallCheck(this, MutationEvent2);
    _this2 = _callSuper(this, MutationEvent2, [null]);
    _this2.relatedNode = relatedNode;
    _this2.prevValue = prevValue;
    _this2.newValue = newValue;
    _this2.attrName = attrName;
    _this2.attrChange = attrChange;
    _this2.prevParsedValue = prevParsedValue;
    _this2.newParsedValue = newParsedValue;
    _this2.type = typeArg;
    return _this2;
  }
  _inherits(MutationEvent2, _FederatedEvent);
  return _createClass(MutationEvent2);
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var $vec2Zero = create$1();
var $vec3Zero = create$4();
var $vec3One = fromValues$2(1, 1, 1);
var $mat4Identity = create$5();
var $vec2 = create$1();
var $vec3$1 = create$4();
var $mat4 = create$5();
var $quat$1 = create$2();
var $setLocalTransform_1 = create$4();
var $setLocalTransform_2 = create$2();
var $setLocalTransform_3 = create$4();
var $setLocalPosition = create$4();
var $setPosition_1 = create$4();
var $setPosition_ParentInvertMatrix = create$5();
var $setEulerAngles_InvParentRot = create$2();
var $rotateLocal = create$2();
var $rotate_ParentInvertRotation = create$2();
var DefaultSceneGraphService = /* @__PURE__ */ function() {
  function DefaultSceneGraphService2(runtime2) {
    _classCallCheck(this, DefaultSceneGraphService2);
    this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
    this.runtime = runtime2;
  }
  return _createClass(DefaultSceneGraphService2, [{
    key: "matches",
    value: function matches(query, root2) {
      return this.runtime.sceneGraphSelector.is(query, root2);
    }
  }, {
    key: "querySelector",
    value: function querySelector(query, root2) {
      return this.runtime.sceneGraphSelector.selectOne(query, root2);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(query, root2) {
      return this.runtime.sceneGraphSelector.selectAll(query, root2);
    }
  }, {
    key: "attach",
    value: function attach(child, parent, index2) {
      var _sortable$sorted;
      var detached = false;
      if (child.parentNode) {
        detached = child.parentNode !== parent;
        this.detach(child);
      }
      var isChildFragment = child.nodeName === Shape.FRAGMENT;
      var isAttachToFragment = isInFragment(parent);
      child.parentNode = parent;
      var nodes = isChildFragment ? child.childNodes : [child];
      if (isNumber(index2)) {
        nodes.forEach(function(node) {
          parent.childNodes.splice(index2, 0, node);
          node.parentNode = parent;
        });
      } else {
        nodes.forEach(function(node) {
          parent.childNodes.push(node);
          node.parentNode = parent;
        });
      }
      var _ref = parent, sortable = _ref.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || sortable.dirty || child.parsedStyle.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.ADDED;
      }
      if (isAttachToFragment) return;
      if (isChildFragment) {
        this.dirtyFragment(child);
      } else {
        var transform2 = child.transformable;
        if (transform2) {
          this.dirtyWorldTransform(child, transform2);
        }
      }
      if (detached) {
        var _parent$ownerDocument;
        var enableCancelEventPropagation = ((_parent$ownerDocument = parent.ownerDocument) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.defaultView) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.getConfig()) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.future) === null || _parent$ownerDocument === void 0 ? void 0 : _parent$ownerDocument.experimentalCancelEventPropagation) === true;
        child.dispatchEvent(reparentEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      }
    }
  }, {
    key: "detach",
    value: function detach(child) {
      var _sortable$sorted2, _style;
      if (!child.parentNode) {
        return;
      }
      var transform2 = child.transformable;
      var _ref2 = child.parentNode, sortable = _ref2.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.REMOVED;
      }
      var index2 = child.parentNode.childNodes.indexOf(child);
      if (index2 > -1) {
        child.parentNode.childNodes.splice(index2, 1);
      }
      if (transform2) {
        this.dirtyWorldTransform(child, transform2);
      }
      child.parentNode = null;
    }
    // #region local-transform ----------------------------------------------------------------
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition(element) {
      return element.transformable.localPosition;
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation(element) {
      return element.transformable.localRotation;
    }
  }, {
    key: "getLocalScale",
    value: function getLocalScale(element) {
      return element.transformable.localScale;
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew(element) {
      return element.transformable.localSkew;
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform(element) {
      var transform2 = element.transformable;
      updateLocalTransform(transform2);
      return transform2.localTransform;
    }
    /**
     * move to position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(element, position2) {
      var _position$;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      $setLocalPosition[0] = position2[0];
      $setLocalPosition[1] = position2[1];
      $setLocalPosition[2] = (_position$ = position2[2]) !== null && _position$ !== void 0 ? _position$ : 0;
      if (equals(transform2.localPosition, $setLocalPosition)) {
        return;
      }
      copy$3(transform2.localPosition, $setLocalPosition);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * translate in local space
     *
     * @example
     * ```
     * translateLocal(x, y, z)
     * translateLocal(vec3(x, y, z))
     * ```
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(element, translation) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = fromValues$2(translation, y2, z2);
      }
      var transform2 = element.transformable;
      if (equals(translation, $vec3Zero)) return;
      transformQuat(translation, translation, transform2.localRotation);
      add$5(transform2.localPosition, transform2.localPosition, translation);
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(element, rotation, y2, z2, w2) {
      var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (typeof rotation === "number") {
        rotation = set$3($quat$1, rotation, y2, z2, w2);
      }
      var transform2 = element.transformable;
      copy$1(transform2.localRotation, rotation);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * rotate in local space
     * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
     */
  }, {
    key: "rotateLocal",
    value: function rotateLocal(element, degrees) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees === "number") {
        degrees = fromValues$2(degrees, y2, z2);
      }
      var transform2 = element.transformable;
      fromEuler($rotateLocal, degrees[0], degrees[1], degrees[2]);
      mul(transform2.localRotation, transform2.localRotation, $rotateLocal);
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalScale",
    value: function setLocalScale(element, scaling) {
      var _scaling$;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      set$5($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : transform2.localScale[2]);
      if (equals($vec3$1, transform2.localScale)) {
        return;
      }
      copy$3(transform2.localScale, $vec3$1);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * scale in local space
     */
  }, {
    key: "scaleLocal",
    value: function scaleLocal(element, scaling) {
      var _scaling$2;
      var transform2 = element.transformable;
      multiply$2(transform2.localScale, transform2.localScale, set$5($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : 1));
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(element, skew2, y2) {
      var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (typeof skew2 === "number") {
        skew2 = set$2($vec2, skew2, y2);
      }
      var transform2 = element.transformable;
      copy(transform2.localSkew, skew2);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(element, degrees) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      if (typeof degrees === "number") {
        degrees = fromValues$2(degrees, y2, z2);
      }
      var transform2 = element.transformable;
      fromEuler(transform2.localRotation, degrees[0], degrees[1], degrees[2]);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(element, transform2) {
      var t3 = getTranslation($setLocalTransform_1, transform2);
      var r2 = getRotation($setLocalTransform_2, transform2);
      var s3 = getScaling($setLocalTransform_3, transform2);
      this.setLocalScale(element, s3, false);
      this.setLocalPosition(element, t3, false);
      this.setLocalRotation(element, r2, void 0, void 0, void 0, false);
      this.dirtyLocalTransform(element, element.transformable);
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform(element) {
      this.setLocalScale(element, $vec3One, false);
      this.setLocalPosition(element, $vec3Zero, false);
      this.setLocalEulerAngles(element, $vec3Zero, void 0, void 0, false);
      this.setLocalSkew(element, $vec2Zero, void 0, false);
      this.dirtyLocalTransform(element, element.transformable);
    }
    // #endregion local-transform
    // #region transform ----------------------------------------------------------------
  }, {
    key: "getPosition",
    value: function getPosition(element) {
      var transform2 = element.transformable;
      return getTranslation(transform2.position, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getRotation",
    value: function getRotation$1(element) {
      var transform2 = element.transformable;
      return getRotation(transform2.rotation, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getScale",
    value: function getScale(element) {
      var transform2 = element.transformable;
      return getScaling(transform2.scaling, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getOrigin",
    value: function getOrigin(element) {
      element.getGeometryBounds();
      return element.transformable.origin;
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform(element) {
      var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
      if (!transform2.localDirtyFlag && !transform2.dirtyFlag) {
        return transform2.worldTransform;
      }
      if (element.parentNode && element.parentNode.transformable) {
        this.getWorldTransform(element.parentNode);
      }
      this.internalUpdateTransform(element);
      return transform2.worldTransform;
    }
    /**
     * move to position in world space
     *
     *  g  move/moveTo
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
     */
  }, {
    key: "setPosition",
    value: function setPosition(element, position2) {
      var _position$2;
      var transform2 = element.transformable;
      $setPosition_1[0] = position2[0];
      $setPosition_1[1] = position2[1];
      $setPosition_1[2] = (_position$2 = position2[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
      if (equals(this.getPosition(element), $setPosition_1)) {
        return;
      }
      copy$3(transform2.position, $setPosition_1);
      if (element.parentNode === null || !element.parentNode.transformable) {
        copy$3(transform2.localPosition, $setPosition_1);
      } else {
        var parentTransform = element.parentNode.transformable;
        copy$4($setPosition_ParentInvertMatrix, parentTransform.worldTransform);
        invert$1($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);
        transformMat4$1(transform2.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);
      }
      this.dirtyLocalTransform(element, transform2);
    }
    /**
     * translate in world space
     *
     * @example
     * ```
     * translate(x, y, z)
     * translate(vec3(x, y, z))
     * ```
     *
     *  g  translate 2D
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
     */
  }, {
    key: "translate",
    value: function translate4(element, translation) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = set$5($vec3$1, translation, y2, z2);
      }
      if (equals(translation, $vec3Zero)) return;
      add$5($vec3$1, this.getPosition(element), translation);
      this.setPosition(element, $vec3$1);
    }
  }, {
    key: "setRotation",
    value: function setRotation(element, rotation, y2, z2, w2) {
      var transform2 = element.transformable;
      if (typeof rotation === "number") {
        rotation = fromValues(rotation, y2, z2, w2);
      }
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalRotation(element, rotation);
      } else {
        var parentRot = this.getRotation(element.parentNode);
        copy$1($quat$1, parentRot);
        invert($quat$1, $quat$1);
        multiply$1(transform2.localRotation, $quat$1, rotation);
        normalize$7(transform2.localRotation, transform2.localRotation);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * rotate in world space
     */
  }, {
    key: "rotate",
    value: function rotate3(element, degrees) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees === "number") {
        degrees = fromValues$2(degrees, y2, z2);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.rotateLocal(element, degrees);
      } else {
        var rotation = $quat$1;
        fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
        var rot = this.getRotation(element);
        var parentRot = this.getRotation(element.parentNode);
        copy$1($rotate_ParentInvertRotation, parentRot);
        invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);
        multiply$1(rotation, $rotate_ParentInvertRotation, rotation);
        multiply$1(transform2.localRotation, rotation, rot);
        normalize$7(transform2.localRotation, transform2.localRotation);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * same as pivot in Pixi.js
     *
     * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
     */
  }, {
    key: "setOrigin",
    value: function setOrigin(element, origin) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof origin === "number") {
        origin = [origin, y2, z2];
      }
      var transform2 = element.transformable;
      if (origin[0] === transform2.origin[0] && origin[1] === transform2.origin[1] && origin[2] === transform2.origin[2]) {
        return;
      }
      var originVec = transform2.origin;
      originVec[0] = origin[0];
      originVec[1] = origin[1];
      originVec[2] = origin[2] || 0;
      this.dirtyLocalTransform(element, transform2);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(element, degrees) {
      var y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees === "number") {
        degrees = fromValues$2(degrees, y2, z2);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalEulerAngles(element, degrees);
      } else {
        fromEuler(transform2.localRotation, degrees[0], degrees[1], degrees[2]);
        var parentRotation = this.getRotation(element.parentNode);
        copy$1($setEulerAngles_InvParentRot, invert($quat$1, parentRotation));
        mul(transform2.localRotation, transform2.localRotation, $setEulerAngles_InvParentRot);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    // #endregion transform
    // #region bbox ----------------------------------------------------------------
    /**
     * Get the geometry bounds of the element itself, excluding children.
     *
     * @param element - The element to get geometry bounds for
     * @param render - If true, returns render bounds (including strokes, etc.); otherwise returns content bounds
     */
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds(element) {
      var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref3 = element, geometry = _ref3.geometry;
      if (geometry.dirty) {
        runtime.styleValueRegistry.updateGeometry(element);
      }
      var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
      return bounds || new AABB();
    }
    /**
     * Get the geometry bounds of the element itself in world space, excluding children.
     *
     * @param element - The element to get transformed geometry bounds for
     * @param render - If true, returns render bounds (including strokes, etc.); otherwise returns content bounds
     * @param existedAABB - Optional existing AABB to reuse
     */
  }, {
    key: "getTransformedGeometryBounds",
    value: function getTransformedGeometryBounds(element) {
      var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
      var bounds = this.getGeometryBounds(element, render);
      if (!AABB.isEmpty(bounds)) {
        var aabb = existedAABB || new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        return aabb;
      }
      return null;
    }
    /**
     * account for children in world space
     */
  }, {
    key: "getBounds",
    value: function getBounds2(element) {
      var _this2 = this;
      var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref4 = element, renderable = _ref4.renderable;
      if (!renderable.boundsDirty && !render && renderable.bounds) {
        return renderable.bounds;
      }
      if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
        return renderable.renderBounds;
      }
      var existedAABB = render ? renderable.renderBounds : renderable.bounds;
      var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
      var children = element.childNodes;
      children.forEach(function(child) {
        var childBounds = _this2.getBounds(child, render);
        if (childBounds) {
          if (!aabb) {
            aabb = existedAABB || new AABB();
            aabb.update(childBounds.center, childBounds.halfExtents);
          } else {
            aabb.add(childBounds);
          }
        }
      });
      if (!aabb) {
        aabb = new AABB();
      }
      if (render) {
        var clipped = findClosestClipPathTarget(element);
        if (clipped) {
          var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);
          if (!aabb) {
            aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
          } else if (clipPathBounds) {
            aabb = clipPathBounds.intersection(aabb);
          }
        }
      }
      if (render) {
        renderable.renderBounds = aabb;
        renderable.renderBoundsDirty = false;
      } else {
        renderable.bounds = aabb;
        renderable.boundsDirty = false;
      }
      return aabb;
    }
    /**
     * account for children in local space
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds(element) {
      if (element.parentNode) {
        var parentInvert = $mat4Identity;
        if (element.parentNode.transformable) {
          parentInvert = invert$1($mat4, this.getWorldTransform(element.parentNode));
        }
        var bounds = this.getBounds(element);
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds(element);
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect(element) {
      var _element$ownerDocumen;
      var aabb;
      var bounds = this.getGeometryBounds(element);
      if (!AABB.isEmpty(bounds)) {
        aabb = new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      }
      var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
      if (aabb) {
        var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
        var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
        return new Rectangle$1(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
      }
      return new Rectangle$1((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
    }
    // #endregion bbox
    // #region other ----------------------------------------------------------------
  }, {
    key: "internalUpdateTransform",
    value: function internalUpdateTransform(element) {
      var _element$parentNode;
      var parentTransform = (_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.transformable;
      updateLocalTransform(element.transformable);
      updateWorldTransform(element.transformable, parentTransform);
    }
  }, {
    key: "internalUpdateElement",
    value: function internalUpdateElement(element, ancestors) {
      var _element$ownerDocumen2, _element$transformabl, _element$renderable, _element$renderable2;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.defaultView) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.getConfig()) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.future) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.experimentalAttributeUpdateOptimization) === true;
      var parent = ancestors[ancestors.length - 1];
      var transformDirty = (parent === null || parent === void 0 ? void 0 : parent.transformDirty) || ((_element$transformabl = element.transformable) === null || _element$transformabl === void 0 ? void 0 : _element$transformabl.localDirtyFlag);
      if (element.transformable) {
        var _element$transformabl2;
        (_element$transformabl2 = element.transformable).dirtyFlag || (_element$transformabl2.dirtyFlag = transformDirty);
      }
      this.internalUpdateTransform(element);
      if (transformDirty) {
        var _element$dirty;
        (_element$dirty = element.dirty) === null || _element$dirty === void 0 || _element$dirty.call(element, true, true);
      }
      var shapeUpdated = ((_element$renderable = element.renderable) === null || _element$renderable === void 0 ? void 0 : _element$renderable.boundsDirty) || ((_element$renderable2 = element.renderable) === null || _element$renderable2 === void 0 ? void 0 : _element$renderable2.renderBoundsDirty);
      if ((transformDirty || shapeUpdated) && (parent === null || parent === void 0 ? void 0 : parent.shapeUpdated) === false && enableAttributeUpdateOptimization) {
        var tempElIndex = ancestors.length - 1;
        while (tempElIndex >= 0) {
          var _dirty, _ref5;
          var tempEl = ancestors[tempElIndex];
          if (tempEl.shapeUpdated) {
            break;
          }
          (_dirty = (_ref5 = tempEl.node).dirty) === null || _dirty === void 0 || _dirty.call(_ref5, true, true);
          tempEl.shapeUpdated = true;
          tempElIndex -= 1;
        }
      }
      return transformDirty;
    }
  }, {
    key: "syncHierarchy",
    value: function syncHierarchy(rootNode) {
      var _transformable, _transformable2;
      var stack = [rootNode];
      var ancestors = rootNode.parentNode ? [{
        node: rootNode.parentNode,
        transformDirty: ((_transformable = rootNode.parentNode.transformable) === null || _transformable === void 0 ? void 0 : _transformable.localDirtyFlag) || ((_transformable2 = rootNode.parentNode.transformable) === null || _transformable2 === void 0 ? void 0 : _transformable2.dirtyFlag),
        shapeUpdated: false
      }] : [];
      while (stack.length > 0) {
        var node = stack.pop();
        var parent = ancestors[ancestors.length - 1];
        while (ancestors.length > 0 && node.parentNode !== parent.node) {
          parent = ancestors.pop();
        }
        var transformDirty = this.internalUpdateElement(node, ancestors);
        if (node.childNodes.length > 0) {
          for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
            stack.push(node.childNodes[i2]);
          }
          ancestors.push({
            node,
            transformDirty,
            shapeUpdated: false
          });
        }
      }
    }
  }, {
    key: "dirtyLocalTransform",
    value: function dirtyLocalTransform(element, transform2) {
      if (isInFragment(element)) return;
      if (!transform2.localDirtyFlag) {
        transform2.localDirtyFlag = true;
        if (!transform2.dirtyFlag) {
          this.dirtyWorldTransform(element, transform2);
        }
      }
    }
  }, {
    key: "dirtyWorldTransform",
    value: function dirtyWorldTransform(element, transform2) {
      this.dirtyWorldInternal(element, transform2);
      this.dirtyToRoot(element, true);
    }
  }, {
    key: "dirtyWorldInternal",
    value: function dirtyWorldInternal(element, transform2) {
      var _element$ownerDocumen3, _this2 = this;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen3 = element.ownerDocument) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.defaultView) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.getConfig()) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.future) === null || _element$ownerDocumen3 === void 0 ? void 0 : _element$ownerDocumen3.experimentalAttributeUpdateOptimization) === true;
      if (!transform2.dirtyFlag) {
        transform2.dirtyFlag = true;
        element.dirty(true, true);
        if (!enableAttributeUpdateOptimization) {
          element.childNodes.forEach(function(child) {
            var childTransform = child.transformable;
            _this2.dirtyWorldInternal(child, childTransform);
          });
        }
      }
    }
  }, {
    key: "dirtyToRoot",
    value: function dirtyToRoot(element) {
      var _element$ownerDocumen4;
      var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var p2 = element;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.defaultView) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.getConfig()) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.future) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.experimentalAttributeUpdateOptimization) === true;
      while (p2) {
        var _dirty2, _ref6;
        (_dirty2 = (_ref6 = p2).dirty) === null || _dirty2 === void 0 || _dirty2.call(_ref6, true, true);
        if (enableAttributeUpdateOptimization) {
          break;
        } else {
          p2 = p2.parentNode;
        }
      }
      if (affectChildren) {
        element.forEach(function(e3) {
          var _e$dirty;
          (_e$dirty = e3.dirty) === null || _e$dirty === void 0 || _e$dirty.call(e3, true, true);
        });
      }
      this.informDependentDisplayObjects(element);
      var mutations = element.mutations || [];
      var boundChangeMutation = mutations.find(function(item) {
        return item.type === "attributes" && item._boundsChangeData;
      });
      if (!boundChangeMutation) {
        boundChangeMutation = {
          type: "attributes",
          target: element,
          _boundsChangeData: {
            affectChildren
          }
        };
        mutations.push(boundChangeMutation);
      } else {
        boundChangeMutation._boundsChangeData = {
          affectChildren: boundChangeMutation._boundsChangeData.affectChildren || affectChildren
        };
      }
      element.mutations = mutations;
    }
  }, {
    key: "dirtyFragment",
    value: function dirtyFragment(element) {
      var _dirty3, _ref7;
      var transform2 = element.transformable;
      if (transform2) {
        transform2.dirtyFlag = true;
        transform2.localDirtyFlag = true;
      }
      (_dirty3 = (_ref7 = element).dirty) === null || _dirty3 === void 0 || _dirty3.call(_ref7, true, true);
      var length2 = element.childNodes.length;
      for (var i2 = 0; i2 < length2; i2++) {
        this.dirtyFragment(element.childNodes[i2]);
      }
    }
  }, {
    key: "notifyMutationObservers",
    value: function notifyMutationObservers(canvas2) {
      var mutations = /* @__PURE__ */ new Set();
      canvas2.getRoot().forEach(function(item) {
        (item.mutations || []).forEach(function(mutation) {
          if (mutation.type === "attributes" && mutation._boundsChangeData) {
            if (mutation._boundsChangeData.affectChildren) {
              item.forEach(function(node) {
                var newMutation = _objectSpread2({}, mutation);
                newMutation.target = node;
                mutations.add(newMutation);
              });
            } else {
              mutations.add(mutation);
            }
          }
        });
        item.mutations = void 0;
      });
      if (mutations.size > 0) {
        var event = new CustomEvent(ElementEvent.BOUNDS_CHANGED, {
          detail: Array.from(mutations)
        });
        canvas2.dispatchEvent(event, true, true);
      }
    }
  }, {
    key: "updateDisplayObjectDependency",
    value: function updateDisplayObjectDependency(name, oldPath, newPath, object) {
      if (oldPath && oldPath !== newPath) {
        var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
        if (oldDependencyMap && oldDependencyMap[name]) {
          var index2 = oldDependencyMap[name].indexOf(object);
          oldDependencyMap[name].splice(index2, 1);
        }
      }
      if (newPath) {
        var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        if (!newDependencyMap) {
          this.displayObjectDependencyMap.set(newPath, {});
          newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        }
        if (!newDependencyMap[name]) {
          newDependencyMap[name] = [];
        }
        newDependencyMap[name].push(object);
      }
    }
  }, {
    key: "informDependentDisplayObjects",
    value: function informDependentDisplayObjects(object) {
      var _object$ownerDocument, _this3 = this;
      var dependencyMap = this.displayObjectDependencyMap.get(object);
      if (!dependencyMap) {
        return;
      }
      var enableCancelEventPropagation = (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.getConfig()) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.future) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.experimentalCancelEventPropagation;
      Object.keys(dependencyMap).forEach(function(name) {
        dependencyMap[name].forEach(function(target) {
          _this3.dirtyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this3, _this3, name, MutationEvent.MODIFICATION, _this3, _this3), enableCancelEventPropagation, enableCancelEventPropagation);
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name, _this3, _this3);
            }
          }
        });
      });
    }
  }]);
}();
var LRU = /* @__PURE__ */ function() {
  function LRU2(capacity) {
    _classCallCheck(this, LRU2);
    if (capacity <= 0) {
      throw new Error("LRU capacity must be a positive number.");
    }
    this.capacity = capacity;
    this.cache = /* @__PURE__ */ new Map();
  }
  return _createClass(LRU2, [{
    key: "get",
    value: function get2(key) {
      if (!this.cache.has(key)) {
        return void 0;
      }
      var value = this.cache.get(key);
      this.cache["delete"](key);
      this.cache.set(key, value);
      return value;
    }
    /**
     * Adds or updates an item in the cache. Marks the item as recently used.
     * If the cache is full, it removes the least recently used item.
     * @param key The key of the item.
     * @param value The value of the item.
     */
  }, {
    key: "put",
    value: function put(key, value) {
      if (this.cache.has(key)) {
        this.cache["delete"](key);
      }
      this.cache.set(key, value);
      if (this.cache.size > this.capacity) {
        var leastRecentlyUsedKey = this.cache.keys().next().value;
        this.cache["delete"](leastRecentlyUsedKey);
      }
    }
    /**
     * Returns the current number of items in the cache.
     */
  }, {
    key: "len",
    value: function len2() {
      return this.cache.size;
    }
    /**
     * Clears all items from the cache.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.cache.clear();
    }
  }]);
}();
var TEXT_METRICS = {
  MetricsString: "|q",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    // line feed
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}'""]/;
var regexCannotEndZhCn = /[$('"]/;
var regexCannotStartZhTw = /[!),.:;?\]}'""]/;
var regexCannotEndZhTw = /[([{'"]/;
var regexCannotStartJaJp = /[)\]'"?!:;,.]/;
var regexCannotEndJaJp = /[(['"...]/;
var regexCannotStartKoKr = /[!%),.:;?\]}'"]/;
var regexCannotEndKoKr = /[$([{'"#]/;
var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
var TextService = /* @__PURE__ */ function() {
  function TextService2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, TextService2);
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
      if (_this2.isBreakingSpace(nextChar)) return false;
      if (_char) {
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime2;
    this.charWidthCache = new LRU(100);
  }
  return _createClass(TextService2, [{
    key: "measureFont",
    value: (
      /**
       * A global cache for character widths, keyed by font string.
       * e.g. { '16px Arial': { 'a': 8, 'b': 9 } }
       */
      /**
       * Calculates the ascent, descent and fontSize of a given font-style.
       */
      function measureFont(font, offscreenCanvas) {
        if (this.fontMetricsCache[font]) {
          return this.fontMetricsCache[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas2 = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
          willReadFrequently: true
        });
        context.font = font;
        var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
        var width2 = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
        var height = TEXT_METRICS.HeightMultiplier * baseline;
        baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
        canvas2.width = width2;
        canvas2.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width2, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width2 || 1, height || 1).data;
        var pixels = imagedata.length;
        var line2 = width2 * 4;
        var i2 = 0;
        var idx = 0;
        var stop = false;
        for (i2 = 0; i2 < baseline; ++i2) {
          for (var j = 0; j < line2; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line2;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i2;
        idx = pixels - line2;
        stop = false;
        for (i2 = height; i2 > baseline; --i2) {
          for (var _j = 0; _j < line2; _j += 4) {
            if (imagedata[idx + _j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line2;
          } else {
            break;
          }
        }
        properties.descent = i2 - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        this.fontMetricsCache[font] = properties;
        return properties;
      }
    )
  }, {
    key: "measureText",
    value: function measureText(text, parsedStyle, offscreenCanvas) {
      var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize2 = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign2 = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing2 = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
      parsedStyle.textPathSide;
      parsedStyle.textPathStartOffset;
      var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
      var font = toFontString(parsedStyle);
      var fontProperties = this.measureFont(font, offscreenCanvas);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize2;
        fontProperties.ascent = fontSize2;
      }
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      context.font = font;
      parsedStyle.isOverflowing = false;
      var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      if (textPath) {
        textPath.getTotalLength();
        for (var i2 = 0; i2 < lines.length; i2++) {
          context.measureText(lines[i2]).width + (lines[i2].length - 1) * letterSpacing2;
        }
      } else {
        for (var _i = 0; _i < lines.length; _i++) {
          var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing2;
          lineWidths[_i] = _lineWidth;
          maxLineWidth = Math.max(maxLineWidth, _lineWidth);
        }
        var _width = maxLineWidth + lineWidth;
        var lineHeight2 = strokeHeight || fontProperties.fontSize + lineWidth;
        var height = Math.max(lineHeight2, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight2 + leading);
        lineHeight2 += leading;
        var offsetY = 0;
        if (textBaseline === "middle") {
          offsetY = -height / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          offsetY = -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          offsetY = 0;
        }
        return {
          font,
          width: _width,
          height,
          lines,
          lineWidths,
          lineHeight: lineHeight2,
          maxLineWidth,
          fontProperties,
          lineMetrics: lineWidths.map(function(width2, i3) {
            var offsetX = 0;
            if (textAlign2 === "center" || textAlign2 === "middle") {
              offsetX -= width2 / 2;
            } else if (textAlign2 === "right" || textAlign2 === "end") {
              offsetX -= width2;
            }
            return new Rectangle$1(offsetX - lineWidth / 2, offsetY + i3 * lineHeight2, width2 + lineWidth, lineHeight2);
          })
        };
      }
    }
  }, {
    key: "wordWrap",
    value: function wordWrap(text, parsedStyle, offscreenCanvas) {
      var _this2 = this;
      var chars2 = Array.from(text);
      if (chars2.length === 0) {
        return "";
      }
      var self2 = this;
      var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing2 = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var maxWidth = wordWrapWidth + letterSpacing2;
      var ellipsis = "";
      if (textOverflow === "ellipsis") {
        ellipsis = "...";
      } else if (textOverflow && textOverflow !== "clip") {
        ellipsis = textOverflow;
      }
      var lines = [""];
      var currentLineIndex = 0;
      var currentLineWidth = 0;
      var prevLineLastCharIndex = -1;
      var font = toFontString(parsedStyle);
      var charCache = this.charWidthCache.get(font);
      if (!charCache) {
        charCache = new LRU(500);
        this.charWidthCache.put(font, charCache);
      }
      var calcWidth = function calcWidth2(_char2) {
        return _this2.getFromCache(_char2, letterSpacing2, charCache, context);
      };
      var ellipsisWidth = calcWidth(ellipsis);
      function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {
        while (calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars2.length - 1) {
          if (self2.isNewline(chars2[txtLastCharIndex + 1])) {
            break;
          }
          txtLastCharIndex += 1;
          lineTxt += chars2[txtLastCharIndex];
        }
        while (calcWidth(lineTxt) > widthThreshold && // @see https://github.com/antvis/G/issues/1932
        txtLastCharIndex >= txtStartCharIndex) {
          txtLastCharIndex -= 1;
          lineTxt = lineTxt.slice(0, -1);
        }
        return {
          lineTxt,
          txtLastCharIndex
        };
      }
      function appendEllipsis(lineIndex, textCharIndex) {
        if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
          return;
        }
        if (!lines[lineIndex]) {
          lines[lineIndex] = ellipsis;
          return;
        }
        var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);
        lines[lineIndex] = result2.lineTxt + ellipsis;
      }
      for (var i2 = 0; i2 < chars2.length; i2++) {
        var _char3 = chars2[i2];
        var prevChar = chars2[i2 - 1];
        var nextChar = chars2[i2 + 1];
        var charWidth = calcWidth(_char3);
        if (this.isNewline(_char3)) {
          if (currentLineIndex + 1 >= maxLines) {
            if (i2 < chars2.length - 1) {
              appendEllipsis(currentLineIndex, i2 - 1);
            }
            parsedStyle.isOverflowing = true;
            break;
          }
          prevLineLastCharIndex = i2 - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          continue;
        }
        if (charWidth > maxWidth) {
          appendEllipsis(currentLineIndex, i2 - 1);
          parsedStyle.isOverflowing = true;
          break;
        }
        if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
          var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i2 - 1, prevLineLastCharIndex + 1, maxWidth);
          if (result.txtLastCharIndex !== i2 - 1) {
            lines[currentLineIndex] = result.lineTxt;
            if (result.txtLastCharIndex === chars2.length - 1) {
              break;
            }
            i2 = result.txtLastCharIndex + 1;
            _char3 = chars2[i2];
            prevChar = chars2[i2 - 1];
            nextChar = chars2[i2 + 1];
            charWidth = calcWidth(_char3);
          }
          if (currentLineIndex + 1 >= maxLines) {
            appendEllipsis(currentLineIndex, i2 - 1);
            parsedStyle.isOverflowing = true;
            break;
          }
          prevLineLastCharIndex = i2 - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          if (this.isBreakingSpace(_char3)) {
            continue;
          }
          if (!this.canBreakInLastChar(_char3)) {
            lines = this.trimToBreakable(lines);
            currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", calcWidth);
          }
          if (this.shouldBreakByKinsokuShorui(_char3, nextChar)) {
            lines = this.trimByKinsokuShorui(lines);
            currentLineWidth += calcWidth(prevChar || "");
          }
        }
        currentLineWidth += charWidth;
        lines[currentLineIndex] += _char3;
      }
      return lines.join("\n");
    }
  }, {
    key: "isBreakingSpace",
    value: function isBreakingSpace(_char4) {
      if (typeof _char4 !== "string") {
        return false;
      }
      return TEXT_METRICS.BreakingSpaces.indexOf(_char4.charCodeAt(0)) >= 0;
    }
  }, {
    key: "isNewline",
    value: function isNewline(_char5) {
      if (typeof _char5 !== "string") {
        return false;
      }
      return TEXT_METRICS.Newlines.indexOf(_char5.charCodeAt(0)) >= 0;
    }
  }, {
    key: "trimToBreakable",
    value: function trimToBreakable(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      var index2 = this.findBreakableIndex(prevLine);
      if (index2 === -1 || !prevLine) return next;
      var trimmedChar = prevLine.slice(index2, index2 + 1);
      var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
      var trimFrom = index2 + 1;
      var trimTo = index2 + (isTrimmedWithSpace ? 0 : 1);
      next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
      next[next.length - 2] = prevLine.slice(0, trimTo);
      return next;
    }
  }, {
    key: "canBreakInLastChar",
    value: function canBreakInLastChar(_char6) {
      if (_char6 && LATIN_REGEX.test(_char6)) return false;
      return true;
    }
  }, {
    key: "sumTextWidthByCache",
    value: function sumTextWidthByCache(text, calcWidthWithCache) {
      return text.split("").reduce(function(sum, c2) {
        return sum + calcWidthWithCache(c2);
      }, 0);
    }
  }, {
    key: "findBreakableIndex",
    value: function findBreakableIndex(line2) {
      for (var i2 = line2.length - 1; i2 >= 0; i2--) {
        if (!LATIN_REGEX.test(line2[i2])) return i2;
      }
      return -1;
    }
  }, {
    key: "getFromCache",
    value: function getFromCache(key, letterSpacing2, cache, context) {
      var width2 = cache.get(key);
      if (typeof width2 !== "number") {
        var spacing = key.length * letterSpacing2;
        var metrics = context.measureText(key);
        width2 = metrics.width + spacing;
        cache.put(key, width2);
      }
      return width2;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.fontMetricsCache = {};
      this.charWidthCache.clear();
    }
  }]);
}();
var runtime = {};
var geometryUpdaterFactory = function(_ref) {
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _defineProperty$1(_defineProperty$1(_defineProperty$1(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);
}();
var CSSPropertySyntaxFactory = function(_ref2) {
  var color2 = new CSSPropertyColor();
  var length2 = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color2), PropertySyntax.COLOR, color2), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length2), PropertySyntax.LENGTH_PERCENTAGE, length2), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _defineProperty$1(_defineProperty$1(_defineProperty$1(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());
}();
var getGlobalThis = function getGlobalThis2() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  return {};
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableStyleSyntax = true;
runtime.enableSizeAttenuation = false;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element$1 = /* @__PURE__ */ function(_Node) {
  function Element2() {
    var _this2;
    _classCallCheck(this, Element2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Element2, [].concat(args));
    _this2.entity = entityCounter++;
    _this2.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      origin: [0, 0, 0]
    };
    _this2.renderable = {
      bounds: void 0,
      boundsDirty: true,
      renderBounds: void 0,
      renderBoundsDirty: true,
      dirtyRenderBounds: void 0,
      dirty: false
    };
    _this2.geometry = {
      contentBounds: void 0,
      renderBounds: void 0,
      dirty: true
    };
    _this2.cullable = {
      strategy: Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this2.sortable = {
      dirty: false,
      sorted: void 0,
      renderOrder: 0,
      dirtyChildren: [],
      dirtyReason: void 0
    };
    _this2.namespaceURI = "g";
    _this2.scrollLeft = 0;
    _this2.scrollTop = 0;
    _this2.clientTop = 0;
    _this2.clientLeft = 0;
    _this2.style = {};
    _this2.computedStyle = {};
    _this2.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this2.attributes = {};
    return _this2;
  }
  _inherits(Element2, _Node);
  return _createClass(Element2, [{
    key: "dirty",
    value: (
      /**
       * Marks the element as dirty, indicating it needs re-rendering or relayout.
       *
       * @param styleFlag - Whether to update style state (default: true).
       *                   When true, sets `renderable.dirty` to true.
       * @param layoutFlag - Optional. When provided, updates layout-related dirty flags:
       *                    - `renderable.boundsDirty`
       *                    - `renderable.renderBoundsDirty`
       *                    - `geometry.dirty`
       */
      function dirty() {
        var styleFlag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var layoutFlag = arguments.length > 1 ? arguments[1] : void 0;
        this.renderable.dirty = styleFlag;
        if (layoutFlag !== void 0) {
          this.renderable.boundsDirty = layoutFlag;
          this.renderable.renderBoundsDirty = layoutFlag;
          this.geometry.dirty = layoutFlag;
        }
      }
    )
  }, {
    key: "className",
    get: (
      /**
       * used with `getElementById()`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
       */
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get2() {
        return this.getAttribute("class") || "";
      }
    ),
    set: function set2(className) {
      this.setAttribute("class", className);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get2() {
        return this.className.split(" ").filter(function(c2) {
          return c2 !== "";
        });
      }
    )
  }, {
    key: "tagName",
    get: function get2() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get2() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get2() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get2() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get2() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get2() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get2() {
      if (this.parentNode) {
        var index2 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index2 + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get2() {
      if (this.parentNode) {
        var index2 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index2 - 1] || null;
      }
      return null;
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "appendChild",
    value: function appendChild(child, index2) {
      var _this$ownerDocument;
      if (child.destroyed) {
        throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
      }
      runtime.sceneGraphService.attach(child, this, index2);
      if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
        if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {
          this.ownerDocument.defaultView.mountFragment(child);
        } else {
          this.ownerDocument.defaultView.mountChildren(child);
        }
      }
      if (this.isMutationObserved) {
        insertedEvent.relatedNode = this;
        child.dispatchEvent(insertedEvent);
      }
      return child;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      if (!refChild) {
        this.appendChild(newChild);
      } else {
        if (newChild.parentElement) {
          newChild.parentElement.removeChild(newChild);
        }
        var index2 = this.childNodes.indexOf(refChild);
        if (index2 === -1) {
          this.appendChild(newChild);
        } else {
          this.appendChild(newChild, index2);
        }
      }
      return newChild;
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(newChild, oldChild) {
      var index2 = this.childNodes.indexOf(oldChild);
      this.removeChild(oldChild);
      this.appendChild(newChild, index2);
      return oldChild;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var _this$ownerDocument2, _child$ownerDocument;
      var enableCancelEventPropagation = ((_this$ownerDocument2 = this.ownerDocument) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.defaultView) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.getConfig().future) === null || _this$ownerDocument2 === void 0 ? void 0 : _this$ownerDocument2.experimentalCancelEventPropagation) === true;
      removedEvent.relatedNode = this;
      child.dispatchEvent(removedEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
        child.ownerDocument.defaultView.unmountChildren(child);
      }
      runtime.sceneGraphService.detach(child);
      return child;
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      for (var i2 = this.childNodes.length - 1; i2 >= 0; i2--) {
        var child = this.childNodes[i2];
        this.removeChild(child);
      }
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      for (var i2 = this.childNodes.length - 1; i2 >= 0; i2--) {
        var child = this.childNodes[i2];
        if (child.childNodes.length > 0) {
          child.destroyChildren();
        }
        child.destroy();
      }
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
     */
  }, {
    key: "matches",
    value: function matches(selector) {
      return runtime.sceneGraphService.matches(selector, this);
    }
  }, {
    key: "getElementById",
    value: function getElementById(id2) {
      return runtime.sceneGraphService.querySelector("#".concat(id2), this);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name) {
      return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name, '"]'), this);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className) {
      return runtime.sceneGraphService.querySelectorAll(".".concat(className), this);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return runtime.sceneGraphService.querySelectorAll(tagName, this);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return runtime.sceneGraphService.querySelector(selectors, this);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return runtime.sceneGraphService.querySelectorAll(selectors, this);
    }
    /**
     * should traverses the element and its parents (heading toward the document root)
     * until it finds a node that matches the specified CSS selector.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
     */
  }, {
    key: "closest",
    value: function closest(selectors) {
      var el = this;
      do {
        if (runtime.sceneGraphService.matches(selectors, el)) return el;
        el = el.parentElement;
      } while (el !== null);
      return null;
    }
    /**
     * search in scene group, but should not include itself
     */
  }, {
    key: "find",
    value: function find3(filter2) {
      var _this2 = this;
      var target = null;
      this.forEach(function(object) {
        if (object !== _this2 && filter2(object)) {
          target = object;
          return false;
        }
        return true;
      });
      return target;
    }
  }, {
    key: "findAll",
    value: function findAll(filter2) {
      var _this3 = this;
      var objects = [];
      this.forEach(function(object) {
        if (object !== _this3 && filter2(object)) {
          objects.push(object);
        }
      });
      return objects;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
     */
  }, {
    key: "after",
    value: function after() {
      var _this4 = this;
      if (this.parentNode) {
        var index2 = this.parentNode.childNodes.indexOf(this);
        for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nodes[_key2] = arguments[_key2];
        }
        nodes.forEach(function(node, i2) {
          var _this4$parentNode;
          return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index2 + i2 + 1);
        });
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
     */
  }, {
    key: "before",
    value: function before() {
      if (this.parentNode) {
        var _ref;
        var index2 = this.parentNode.childNodes.indexOf(this);
        for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nodes[_key3] = arguments[_key3];
        }
        var first = nodes[0], rest = _arrayLikeToArray(nodes).slice(1);
        this.parentNode.appendChild(first, index2);
        (_ref = first).after.apply(_ref, _toConsumableArray(rest));
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
     */
  }, {
    key: "replaceWith",
    value: function replaceWith() {
      this.after.apply(this, arguments);
      this.remove();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
     */
  }, {
    key: "append",
    value: function append() {
      var _this5 = this;
      for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nodes[_key4] = arguments[_key4];
      }
      nodes.forEach(function(node) {
        return _this5.appendChild(node);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
     */
  }, {
    key: "prepend",
    value: function prepend() {
      var _this6 = this;
      for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        nodes[_key5] = arguments[_key5];
      }
      nodes.forEach(function(node, i2) {
        return _this6.appendChild(node, i2);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
     */
  }, {
    key: "replaceChildren",
    value: function replaceChildren2() {
      while (this.childNodes.length && this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.append.apply(this, arguments);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
     */
  }, {
    key: "remove",
    value: function remove() {
      if (this.parentNode) {
        return this.parentNode.removeChild(this);
      }
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$ownerDocument3;
      var enableCancelEventPropagation = ((_this$ownerDocument3 = this.ownerDocument) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.defaultView) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.getConfig().future) === null || _this$ownerDocument3 === void 0 ? void 0 : _this$ownerDocument3.experimentalCancelEventPropagation) === true;
      this.destroyChildren();
      this.dispatchEvent(destroyEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      this.remove();
      this.emitter.removeAllListeners();
      this.destroyed = true;
    }
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds() {
      var render = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      return runtime.sceneGraphService.getGeometryBounds(this, render);
    }
    /**
     * get geometry bounds in world space, not accounting for children
     */
  }, {
    key: "getTransformedGeometryBounds",
    value: function getTransformedGeometryBounds() {
      var render = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      return runtime.sceneGraphService.getTransformedGeometryBounds(this, render);
    }
    /**
     * get bounds in world space, account for children
     */
  }, {
    key: "getBounds",
    value: function getBounds2() {
      return runtime.sceneGraphService.getBounds(this);
    }
  }, {
    key: "getRenderBounds",
    value: function getRenderBounds() {
      return runtime.sceneGraphService.getBounds(this, true);
    }
    /**
     * get bounds in local space, account for children
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds() {
      return runtime.sceneGraphService.getLocalBounds(this);
    }
    /**
     * account for context's bounds in client space,
     * but not accounting for children
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
     */
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      return runtime.sceneGraphService.getBoundingClientRect(this);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
     */
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
  }, {
    key: "computedStyleMap",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
       * eg. circle.computedStyleMap().get('fill');
       */
      function computedStyleMap() {
        return new Map(Object.entries(this.computedStyle));
      }
    )
  }, {
    key: "getAttributeNames",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
       */
      function getAttributeNames() {
        return Object.keys(this.attributes);
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      if (typeof name === "symbol") {
        return void 0;
      }
      var value = this.attributes[name];
      if (value === void 0) {
        return value;
      }
      return value;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
     */
  }, {
    key: "hasAttribute",
    value: function hasAttribute(qualifiedName) {
      return this.getAttributeNames().includes(qualifiedName);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
     */
  }, {
    key: "hasAttributes",
    value: function hasAttributes() {
      return !!this.getAttributeNames().length;
    }
    /**
     * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
     */
  }, {
    key: "removeAttribute",
    value: function removeAttribute(attributeName) {
      this.setAttribute(attributeName, null);
      delete this.attributes[attributeName];
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
     */
  }, {
    key: "setAttribute",
    value: function setAttribute(attributeName, value) {
      this.attributes[attributeName] = value;
    }
  }, {
    key: "getAttributeNS",
    value: function getAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNode",
    value: function getAttributeNode(qualifiedName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNodeNS",
    value: function getAttributeNodeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "hasAttributeNS",
    value: function hasAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNS",
    value: function removeAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNode",
    value: function removeAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNS",
    value: function setAttributeNS(namespace, qualifiedName, value) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNode",
    value: function setAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNodeNS",
    value: function setAttributeNodeNS(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "toggleAttribute",
    value: function toggleAttribute(qualifiedName, force) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(Node$1);
function isDisplayObject(value) {
  return !!(value !== null && value !== void 0 && value.nodeName);
}
var Proxy$1 = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
};
var attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var $vec3 = create$4();
var $quat = create$2();
var DisplayObject = /* @__PURE__ */ function(_Element) {
  function DisplayObject2(config) {
    var _this2;
    _classCallCheck(this, DisplayObject2);
    _this2 = _callSuper(this, DisplayObject2);
    _this2.isCustomElement = false;
    _this2.isMutationObserved = false;
    _this2.activeAnimations = [];
    _this2.config = config;
    _this2.id = config.id || "";
    _this2.name = config.name || "";
    if (config.className || config["class"]) {
      _this2.className = config.className || config["class"];
    }
    _this2.nodeName = config.type || Shape.GROUP;
    if (config.initialParsedStyle) {
      Object.assign(_this2.parsedStyle, config.initialParsedStyle);
    }
    _this2.initAttributes(config.style);
    if (runtime.enableStyleSyntax) {
      _this2.style = new Proxy$1(
        // @ts-ignore
        {
          // ...this.attributes,
          setProperty: function setProperty(propertyName, value) {
            _this2.setAttribute(propertyName, value);
          },
          getPropertyValue: function getPropertyValue(propertyName) {
            return _this2.getAttribute(propertyName);
          },
          removeProperty: function removeProperty(propertyName) {
            _this2.removeAttribute(propertyName);
          },
          item: function item() {
            return "";
          }
        },
        {
          get: function get2(target, name) {
            if (target[name] !== void 0) {
              return target[name];
            }
            return _this2.getAttribute(name);
          },
          set: function set2(_2, prop, value) {
            _this2.setAttribute(prop, value);
            return true;
          }
        }
      );
    }
    return _this2;
  }
  _inherits(DisplayObject2, _Element);
  return _createClass(DisplayObject2, [{
    key: "destroy",
    value: function destroy() {
      _superPropGet(DisplayObject2, "destroy", this)([]);
      this.getAnimations().forEach(function(animation) {
        animation.cancel();
      });
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2, customCloneFunc) {
      var clonedStyle = _objectSpread2({}, this.attributes);
      for (var attributeName in clonedStyle) {
        var attribute = clonedStyle[attributeName];
        if (isDisplayObject(attribute) && // share the same clipPath if possible
        attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
          clonedStyle[attributeName] = attribute.cloneNode(deep2);
        }
        if (customCloneFunc) {
          clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
        }
      }
      var cloned = new this.constructor(_objectSpread2(_objectSpread2({}, this.config), {}, {
        style: clonedStyle
      }));
      cloned.setLocalTransform(this.getLocalTransform());
      if (deep2) {
        this.children.forEach(function(child) {
          if (!child.style.isMarker) {
            var clonedChild = child.cloneNode(deep2);
            cloned.appendChild(clonedChild);
          }
        });
      }
      return cloned;
    }
  }, {
    key: "initAttributes",
    value: function initAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var options = {
        forceUpdateGeometry: true
      };
      runtime.styleValueRegistry.processProperties(this, attributes, options);
      this.dirty();
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var memoize2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (isUndefined(value)) {
        return;
      }
      if (force || value !== this.attributes[name]) {
        this.internalSetAttribute(name, value, {
          memoize: memoize2
        });
        _superPropGet(DisplayObject2, "setAttribute", this)([name, value]);
      }
    }
    /**
     * batch update attributes without attributeChangedCallback, for performance
     * use with caution
     * @param attributes
     * @param parseOptions
     * @experimental
     */
  }, {
    key: "setAttributes",
    value: function setAttributes2(attributes) {
      var parseOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _parseOptions$skipDis = parseOptions.skipDispatchAttrModifiedEvent, skipDispatchAttrModifiedEvent = _parseOptions$skipDis === void 0 ? false : _parseOptions$skipDis;
      var oldAttributes;
      var oldParsedValues;
      if (!skipDispatchAttrModifiedEvent) {
        oldAttributes = _objectSpread2({}, this.attributes);
        oldParsedValues = _objectSpread2({}, this.parsedStyle);
      }
      runtime.styleValueRegistry.processProperties(this, attributes, parseOptions);
      this.dirty();
      if (!skipDispatchAttrModifiedEvent) {
        for (var key in attributes) {
          this.dispatchAttrModifiedEvent(key, oldAttributes[key], attributes[key], oldParsedValues[key]);
        }
      }
    }
    /**
     * called when attributes get changed or initialized
     */
  }, {
    key: "internalSetAttribute",
    value: function internalSetAttribute(name, value) {
      var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var oldValue = this.attributes[name];
      var oldParsedValue = this.parsedStyle[name];
      runtime.styleValueRegistry.processProperties(this, _defineProperty$1({}, name, value), parseOptions);
      this.dirty();
      this.dispatchAttrModifiedEvent(name, oldValue, value, oldParsedValue);
    }
  }, {
    key: "dispatchAttrModifiedEvent",
    value: function dispatchAttrModifiedEvent(name, oldValue, value, oldParsedValue) {
      var newParsedValue = this.parsedStyle[name];
      if (this.isConnected) {
        attrModifiedEvent.relatedNode = this;
        attrModifiedEvent.prevValue = oldValue;
        attrModifiedEvent.newValue = value;
        attrModifiedEvent.attrName = name;
        attrModifiedEvent.prevParsedValue = oldParsedValue;
        attrModifiedEvent.newParsedValue = newParsedValue;
        if (this.isMutationObserved) {
          this.dispatchEvent(attrModifiedEvent);
        } else {
          var _this$ownerDocument$d;
          var enableCancelEventPropagation = ((_this$ownerDocument$d = this.ownerDocument.defaultView.getConfig().future) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.experimentalCancelEventPropagation) === true;
          attrModifiedEvent.target = this;
          this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true, enableCancelEventPropagation);
        }
      }
      if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
        var _attributeChangedCall, _ref;
        (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name, oldValue, value, oldParsedValue, newParsedValue);
      }
    }
    // #region transformable
    /**
     * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
     *
     * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
     * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
     */
  }, {
    key: "getBBox",
    value: function getBBox2() {
      var aabb = this.getBounds();
      var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
      var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
      return new Rectangle$1(left, top, right - left, bottom - top);
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setOrigin(this, createVec3(position2, y2, z2, false));
      return this;
    }
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return runtime.sceneGraphService.getOrigin(this);
    }
    /**
     * set position in world space
     */
  }, {
    key: "setPosition",
    value: function setPosition(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setPosition(this, createVec3(position2, y2, z2, false));
      return this;
    }
    /**
     * set position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setLocalPosition(this, createVec3(position2, y2, z2, false));
      return this;
    }
    /**
     * translate in world space
     */
  }, {
    key: "translate",
    value: function translate4(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translate(this, createVec3(position2, y2, z2, false));
      return this;
    }
    /**
     * translate in local space
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translateLocal(this, createVec3(position2, y2, z2, false));
      return this;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return runtime.sceneGraphService.getPosition(this);
    }
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition() {
      return runtime.sceneGraphService.getLocalPosition(this);
    }
    /**
     * compatible with G 3.0
     *
     * scaling in local space
     * scale(10) = scale(10, 10, 10)
     *
     * we can't set scale in world space
     */
  }, {
    key: "scale",
    value: function scale3(scaling, y2, z2) {
      return this.scaleLocal(scaling, y2, z2);
    }
  }, {
    key: "scaleLocal",
    value: function scaleLocal(scaling, y2, z2) {
      if (typeof scaling === "number") {
        y2 = y2 || scaling;
        z2 = z2 || scaling;
        scaling = createVec3(scaling, y2, z2, false);
      }
      runtime.sceneGraphService.scaleLocal(this, scaling);
      return this;
    }
    /**
     * set scaling in local space
     */
  }, {
    key: "setLocalScale",
    value: function setLocalScale(scaling, y2, z2) {
      if (typeof scaling === "number") {
        y2 = y2 || scaling;
        z2 = z2 || scaling;
        scaling = createVec3(scaling, y2, z2, false);
      }
      runtime.sceneGraphService.setLocalScale(this, scaling);
      return this;
    }
    /**
     * get scaling in local space
     */
  }, {
    key: "getLocalScale",
    value: function getLocalScale() {
      return runtime.sceneGraphService.getLocalScale(this);
    }
    /**
     * get scaling in world space
     */
  }, {
    key: "getScale",
    value: function getScale() {
      return runtime.sceneGraphService.getScale(this);
    }
    /**
     * only return degrees of Z axis in world space
     */
  }, {
    key: "getEulerAngles",
    value: function getEulerAngles() {
      var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray(_getEuler, 3), ez = _getEuler2[2];
      return rad2deg(ez);
    }
    /**
     * only return degrees of Z axis in local space
     */
  }, {
    key: "getLocalEulerAngles",
    value: function getLocalEulerAngles() {
      var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray(_getEuler3, 3), ez = _getEuler4[2];
      return rad2deg(ez);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(z2) {
      runtime.sceneGraphService.setEulerAngles(this, 0, 0, z2);
      return this;
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(z2) {
      runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z2);
      return this;
    }
  }, {
    key: "rotateLocal",
    value: function rotateLocal(x2, y2, z2) {
      if (isNil(y2) && isNil(z2)) {
        runtime.sceneGraphService.rotateLocal(this, 0, 0, x2);
      } else {
        runtime.sceneGraphService.rotateLocal(this, x2, y2, z2);
      }
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate3(x2, y2, z2) {
      if (isNil(y2) && isNil(z2)) {
        runtime.sceneGraphService.rotate(this, 0, 0, x2);
      } else {
        runtime.sceneGraphService.rotate(this, x2, y2, z2);
      }
      return this;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation, y2, z2, w2) {
      runtime.sceneGraphService.setRotation(this, rotation, y2, z2, w2);
      return this;
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(rotation, y2, z2, w2) {
      runtime.sceneGraphService.setLocalRotation(this, rotation, y2, z2, w2);
      return this;
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(skew2, y2) {
      runtime.sceneGraphService.setLocalSkew(this, skew2, y2);
      return this;
    }
  }, {
    key: "getRotation",
    value: function getRotation2() {
      return runtime.sceneGraphService.getRotation(this);
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation() {
      return runtime.sceneGraphService.getLocalRotation(this);
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew() {
      return runtime.sceneGraphService.getLocalSkew(this);
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform() {
      return runtime.sceneGraphService.getLocalTransform(this);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return runtime.sceneGraphService.getWorldTransform(this);
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(transform2) {
      runtime.sceneGraphService.setLocalTransform(this, transform2);
      return this;
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform() {
      runtime.sceneGraphService.resetLocalTransform(this);
    }
    // #endregion transformable
    // #region animatable
    /**
     * returns an array of all Animation objects affecting this element
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
     */
  }, {
    key: "getAnimations",
    value: function getAnimations() {
      return this.activeAnimations;
    }
    /**
     * create an animation with WAAPI
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
     */
  }, {
    key: "animate",
    value: function animate2(keyframes, options) {
      var _this$ownerDocument;
      var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
      if (timeline) {
        return timeline.play(this, keyframes, options);
      }
      return null;
    }
    // #endregion animatable
    // #region visible
    /**
     * shortcut for Used value of `visibility`
     */
  }, {
    key: "isVisible",
    value: function isVisible2() {
      var _this$parsedStyle;
      return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
    }
  }, {
    key: "interactive",
    get: function get2() {
      return this.isInteractive();
    },
    set: function set2(b2) {
      this.style.pointerEvents = b2 ? "auto" : "none";
    }
  }, {
    key: "isInteractive",
    value: function isInteractive() {
      var _this$parsedStyle2;
      return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
    }
  }, {
    key: "isCulled",
    value: function isCulled() {
      return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
    }
    /**
     * bring to front in current group
     */
  }, {
    key: "toFront",
    value: function toFront() {
      if (this.parentNode) {
        this.style.zIndex = Math.max.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) + 1;
      }
      return this;
    }
    /**
     * send to back in current group
     */
  }, {
    key: "toBack",
    value: function toBack() {
      if (this.parentNode) {
        this.style.zIndex = Math.min.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) - 1;
      }
      return this;
    }
    // #endregion visible
    // #region deprecated
    /**
     * compatible with G 3.0
     * @alias object.config
     * @deprecated
     */
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
    /**
     * @alias style
     * @example
     * circle.style.r = 10;
     * const r = circle.style;
     * @deprecated
     */
  }, {
    key: "attr",
    value: function attr2() {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var name = args[0], value = args[1];
      if (!name) {
        return this.attributes;
      }
      if (isObject$2(name)) {
        Object.keys(name).forEach(function(key) {
          _this2.setAttribute(key, name[key]);
        });
        return this;
      }
      if (args.length === 2) {
        this.setAttribute(name, value);
        return this;
      }
      return this.attributes[name];
    }
    /**
     * return 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "getMatrix",
    value: function getMatrix(transformMat42) {
      var transform2 = transformMat42 || this.getWorldTransform();
      var _mat4$getTranslation = getTranslation($vec3, transform2), _mat4$getTranslation2 = _slicedToArray(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
      var _mat4$getScaling = getScaling($vec3, transform2), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
      var rotation = getRotation($quat, transform2);
      var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _slicedToArray(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
      return fromRotationTranslationScale(eux || euz, tx, ty, sx, sy);
    }
    /**
     * return 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "getLocalMatrix",
    value: function getLocalMatrix() {
      return this.getMatrix(this.getLocalTransform());
    }
    /**
     * set 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(mat) {
      var _decompose = decompose(mat), _decompose2 = _slicedToArray(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle2 = _decompose2[4];
      this.setEulerAngles(angle2).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * set 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "setLocalMatrix",
    value: function setLocalMatrix(mat) {
      var _decompose3 = decompose(mat), _decompose4 = _slicedToArray(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle2 = _decompose4[4];
      this.setLocalEulerAngles(angle2).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * Use `visibility: visible` instead.
     * @deprecated
     */
  }, {
    key: "show",
    value: function show2() {
      this.forEach(function(object) {
        object.style.visibility = "visible";
      });
    }
    /**
     * Use `visibility: hidden` instead.
     * @deprecated
     */
  }, {
    key: "hide",
    value: function hide2() {
      this.forEach(function(object) {
        object.style.visibility = "hidden";
      });
    }
    /**
     * Use `childElementCount` instead.
     * @deprecated
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.childElementCount;
    }
    /**
     * Use `parentElement` instead.
     * @deprecated
     */
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parentElement;
    }
    /**
     * Use `children` instead.
     * @deprecated
     */
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this.children;
    }
    /**
     * Use `firstElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getFirst",
    value: function getFirst() {
      return this.firstElementChild;
    }
    /**
     * Use `lastElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getLast",
    value: function getLast() {
      return this.lastElementChild;
    }
    /**
     * Use `this.children[index]` instead.
     * @deprecated
     */
  }, {
    key: "getChildByIndex",
    value: function getChildByIndex(index2) {
      return this.children[index2] || null;
    }
    /**
     * Use `appendChild` instead.
     * @deprecated
     */
  }, {
    key: "add",
    value: function add2(child, index2) {
      return this.appendChild(child, index2);
    }
    /**
     * @deprecated
     */
  }, {
    key: "set",
    value: function set2(name, value) {
      this.config[name] = value;
    }
    /**
     * @deprecated
     */
  }, {
    key: "get",
    value: function get2(name) {
      return this.config[name];
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "moveTo",
    value: function moveTo2(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position2, y2, z2);
      return this;
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "move",
    value: function move(position2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position2, y2, z2);
      return this;
    }
    /**
     * Use `this.style.zIndex` instead.
     * @deprecated
     */
  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex2) {
      this.style.zIndex = zIndex2;
      return this;
    }
    // #endregion deprecated
  }]);
}(Element$1);
DisplayObject.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
var Circle$2 = /* @__PURE__ */ function(_DisplayObject) {
  function Circle3() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Circle3);
    return _callSuper(this, Circle3, [_objectSpread2({
      type: Shape.CIRCLE
    }, options)]);
  }
  _inherits(Circle3, _DisplayObject);
  return _createClass(Circle3);
}(DisplayObject);
Circle$2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
var _excluded$6 = ["style"];
var CustomElement = /* @__PURE__ */ function(_DisplayObject) {
  function CustomElement2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$6);
    _classCallCheck(this, CustomElement2);
    _this2 = _callSuper(this, CustomElement2, [_objectSpread2({
      style
    }, rest)]);
    _this2.isCustomElement = true;
    return _this2;
  }
  _inherits(CustomElement2, _DisplayObject);
  return _createClass(CustomElement2);
}(DisplayObject);
CustomElement.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var Ellipse$1 = /* @__PURE__ */ function(_DisplayObject) {
  function Ellipse2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Ellipse2);
    return _callSuper(this, Ellipse2, [_objectSpread2({
      type: Shape.ELLIPSE
    }, options)]);
  }
  _inherits(Ellipse2, _DisplayObject);
  return _createClass(Ellipse2);
}(DisplayObject);
Ellipse$1.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
var Fragment = /* @__PURE__ */ function(_DisplayObject) {
  function Fragment2() {
    _classCallCheck(this, Fragment2);
    return _callSuper(this, Fragment2, [{
      type: Shape.FRAGMENT
    }]);
  }
  _inherits(Fragment2, _DisplayObject);
  return _createClass(Fragment2);
}(DisplayObject);
Fragment.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
var Group = /* @__PURE__ */ function(_DisplayObject) {
  function Group2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Group2);
    return _callSuper(this, Group2, [_objectSpread2({
      type: Shape.GROUP
    }, options)]);
  }
  _inherits(Group2, _DisplayObject);
  return _createClass(Group2);
}(DisplayObject);
Group.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var _excluded$5 = ["style"];
var HTML$1 = /* @__PURE__ */ function(_DisplayObject) {
  function HTML2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$5);
    _classCallCheck(this, HTML2);
    _this2 = _callSuper(this, HTML2, [_objectSpread2({
      type: Shape.HTML,
      style
    }, rest)]);
    _this2.cullable.enable = false;
    return _this2;
  }
  _inherits(HTML2, _DisplayObject);
  return _createClass(HTML2, [{
    key: "getDomElement",
    value: function getDomElement() {
      return this.parsedStyle.$el;
    }
    /**
     * override with $el.getBoundingClientRect
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
     *
     * ! The calculation logic of the html element should be consistent with that of the canvas element
     */
    // getBoundingClientRect(): Rectangle {
    //   if (this.parsedStyle.$el) {
    //     return this.parsedStyle.$el.getBoundingClientRect();
    //   } else {
    //     const { x, y, width, height } = this.parsedStyle;
    //     return new Rectangle(x, y, width, height);
    //   }
    // }
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
    // getBounds() {
    //   const clientRect = this.getBoundingClientRect();
    //   // calc context's offset
    //   // @ts-ignore
    //   const canvasRect = this.ownerDocument?.defaultView
    //     ?.getContextService()
    //     .getBoundingClientRect();
    //   const aabb = new AABB();
    //   const minX = clientRect.left - (canvasRect?.left || 0);
    //   const minY = clientRect.top - (canvasRect?.top || 0);
    //   aabb.setMinMax(
    //     [minX, minY, 0],
    //     [minX + clientRect.width, minY + clientRect.height, 0],
    //   );
    //   return aabb;
    // }
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds() {
      if (this.parentNode) {
        var parentInvert = invert$1(create$5(), this.parentNode.getWorldTransform());
        var bounds = this.getBounds();
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds();
    }
  }]);
}(DisplayObject);
HTML$1.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
var Image$3 = /* @__PURE__ */ function(_DisplayObject) {
  function Image4() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Image4);
    return _callSuper(this, Image4, [_objectSpread2({
      type: Shape.IMAGE
    }, options)]);
  }
  _inherits(Image4, _DisplayObject);
  return _createClass(Image4);
}(DisplayObject);
Image$3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
var _excluded$4 = ["style"];
var Line$2 = /* @__PURE__ */ function(_DisplayObject) {
  function Line3() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$4);
    _classCallCheck(this, Line3);
    _this2 = _callSuper(this, Line3, [_objectSpread2({
      type: Shape.LINE,
      style: _objectSpread2({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0
      }, style)
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Line3, _DisplayObject);
  return _createClass(Line3, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x2 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y2 = _this$parsedStyle2.y2;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad3 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      if (isStart) {
        ox = x1;
        oy = y1;
        x3 = x2 - x1;
        y3 = y2 - y1;
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        ox = x2;
        oy = y2;
        x3 = x1 - x2;
        y3 = y1 - y2;
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad3 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad3 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad3) * offset, oy + Math.sin(rad3) * offset);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x2 = _this$parsedStyle3.x2, y2 = _this$parsedStyle3.y2;
      var _linePointAt = pointAt$3(x1, y1, x2, y2, ratio), x3 = _linePointAt.x, y3 = _linePointAt.y;
      var transformed = transformMat4$1(create$4(), fromValues$2(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point(transformed[0], transformed[1]);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance2) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance2 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x2 = _this$parsedStyle4.x2, y2 = _this$parsedStyle4.y2;
      return length$4(x1, y1, x2, y2);
    }
  }]);
}(DisplayObject);
Line$2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
var _excluded$3 = ["style"];
var Path = /* @__PURE__ */ function(_DisplayObject) {
  function Path2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$3);
    _classCallCheck(this, Path2);
    _this2 = _callSuper(this, Path2, [_objectSpread2({
      type: Shape.PATH,
      style,
      initialParsedStyle: {
        miterLimit: 4,
        d: _objectSpread2({}, EMPTY_PARSED_PATH)
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Path2, _DisplayObject);
  return _createClass(Path2, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "d") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad3 = 0;
      var x2;
      var y2;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      if (isStart) {
        var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];
        ox = p2[0];
        oy = p2[1];
        x2 = p1[0] - p2[0];
        y2 = p1[1] - p2[1];
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
        ox = _p2[0];
        oy = _p2[1];
        x2 = _p[0] - _p2[0];
        y2 = _p[1] - _p2[1];
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad3 = Math.atan2(y2, x2);
      marker.setLocalEulerAngles(rad3 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad3) * offset, oy + Math.sin(rad3) * offset);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var segments = this.parsedStyle.d.segments;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      if (marker && isDisplayObject(marker)) {
        for (var i2 = 1; i2 < segments.length - 1; i2++) {
          var _segments$i$currentPo = _slicedToArray(segments[i2].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
          var cloned = i2 === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
    /**
     * Returns the total length of the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
     */
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePathTotalLength(this);
    }
    /**
     * Returns the point at a given distance along the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
     */
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength$1(distance2) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var absolutePath = this.parsedStyle.d.absolutePath;
      var _getPointAtLength2 = getPointAtLength(absolutePath, distance2), x2 = _getPointAtLength2.x, y2 = _getPointAtLength2.y;
      var transformed = transformMat4$1(create$4(), fromValues$2(x2, y2, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point(transformed[0], transformed[1]);
    }
    /**
     * Returns the point at a given ratio of the total length in path.
     */
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
    }
    /**
     * Get start tangent vector
     */
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var segments = this.parsedStyle.d.segments;
      var result = [];
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    }
    /**
     * Get end tangent vector
     */
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var segments = this.parsedStyle.d.segments;
      var length2 = segments.length;
      var result = [];
      if (length2 > 1) {
        var startPoint = segments[length2 - 2].currentPoint;
        var endPoint = segments[length2 - 1].currentPoint;
        var tangent = segments[length2 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    }
  }]);
}(DisplayObject);
Path.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
var _excluded$2 = ["style"];
var Polygon$1 = /* @__PURE__ */ function(_DisplayObject) {
  function Polygon2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$2);
    _classCallCheck(this, Polygon2);
    _this2 = _callSuper(this, Polygon2, [_objectSpread2({
      type: Shape.POLYGON,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Polygon2, _DisplayObject);
  return _createClass(Polygon2, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "points") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P2 = _this$parsedStyle2.points;
      var _ref2 = P2 || {}, points = _ref2.points;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker) || !points) {
        return;
      }
      var rad3 = 0;
      var x2;
      var y2;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      ox = points[0][0];
      oy = points[0][1];
      if (isStart) {
        x2 = points[1][0] - points[0][0];
        y2 = points[1][1] - points[0][1];
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var length2 = points.length;
        if (!this.parsedStyle.isClosed) {
          ox = points[length2 - 1][0];
          oy = points[length2 - 1][1];
          x2 = points[length2 - 2][0] - points[length2 - 1][0];
          y2 = points[length2 - 2][1] - points[length2 - 1][1];
        } else {
          x2 = points[length2 - 1][0] - points[0][0];
          y2 = points[length2 - 1][1] - points[0][1];
        }
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad3 = Math.atan2(y2, x2);
      marker.setLocalEulerAngles(rad3 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad3) * offset, oy + Math.sin(rad3) * offset);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var P2 = this.parsedStyle.points;
      var _ref3 = P2 || {}, points = _ref3.points;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      this.markerMidList = [];
      if (marker && isDisplayObject(marker) && points) {
        for (var i2 = 1; i2 < (this.parsedStyle.isClosed ? points.length : points.length - 1); i2++) {
          var ox = points[i2][0];
          var oy = points[i2][1];
          var cloned = i2 === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
  }]);
}(DisplayObject);
Polygon$1.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
var _excluded$1 = ["style"];
var Polyline$1 = /* @__PURE__ */ function(_Polygon) {
  function Polyline2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$1);
    _classCallCheck(this, Polyline2);
    return _callSuper(this, Polyline2, [_objectSpread2({
      type: Shape.POLYLINE,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)]);
  }
  _inherits(Polyline2, _Polygon);
  return _createClass(Polyline2, [{
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePolylineTotalLength(this);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance2) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance2 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var points = this.parsedStyle.points.points;
      if (this.parsedStyle.points.segments.length === 0) {
        var segments = [];
        var tempLength = 0;
        var segmentT;
        var segmentL;
        var totalLength = this.getTotalLength();
        points.forEach(function(p2, i2) {
          if (points[i2 + 1]) {
            segmentT = [0, 0];
            segmentT[0] = tempLength / totalLength;
            segmentL = length$4(p2[0], p2[1], points[i2 + 1][0], points[i2 + 1][1]);
            tempLength += segmentL;
            segmentT[1] = tempLength / totalLength;
            segments.push(segmentT);
          }
        });
        this.parsedStyle.points.segments = segments;
      }
      var subt = 0;
      var index2 = 0;
      this.parsedStyle.points.segments.forEach(function(v2, i2) {
        if (ratio >= v2[0] && ratio <= v2[1]) {
          subt = (ratio - v2[0]) / (v2[1] - v2[0]);
          index2 = i2;
        }
      });
      var _linePointAt = pointAt$3(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt), x2 = _linePointAt.x, y2 = _linePointAt.y;
      var transformed = transformMat4$1(create$4(), fromValues$2(x2, y2, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point(transformed[0], transformed[1]);
    }
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var points = this.parsedStyle.points.points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    }
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var points = this.parsedStyle.points.points;
      var l2 = points.length - 1;
      var result = [];
      result.push([points[l2 - 1][0], points[l2 - 1][1]]);
      result.push([points[l2][0], points[l2][1]]);
      return result;
    }
  }]);
}(Polygon$1);
Polyline$1.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Polygon$1.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
var Rect$1 = /* @__PURE__ */ function(_DisplayObject) {
  function Rect2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Rect2);
    return _callSuper(this, Rect2, [_objectSpread2({
      type: Shape.RECT
    }, options)]);
  }
  _inherits(Rect2, _DisplayObject);
  return _createClass(Rect2);
}(DisplayObject);
Rect$1.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
var _excluded$7 = ["style"];
var Text$1 = /* @__PURE__ */ function(_DisplayObject) {
  function Text2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$7);
    _classCallCheck(this, Text2);
    return _callSuper(this, Text2, [_objectSpread2({
      type: Shape.TEXT,
      style: _objectSpread2({
        fill: "black"
      }, style)
    }, rest)]);
  }
  _inherits(Text2, _DisplayObject);
  return _createClass(Text2, [{
    key: "getComputedTextLength",
    value: function getComputedTextLength() {
      var _this$parsedStyle$met;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
    }
  }, {
    key: "getLineBoundingRects",
    value: function getLineBoundingRects() {
      var _this$parsedStyle$met2;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
    }
  }, {
    key: "isOverflowing",
    value: function isOverflowing() {
      this.getGeometryBounds();
      return !!this.parsedStyle.isOverflowing;
    }
  }]);
}(DisplayObject);
Text$1.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
var CustomElementRegistry = /* @__PURE__ */ function() {
  function CustomElementRegistry2() {
    _classCallCheck(this, CustomElementRegistry2);
    this.registry = {};
    this.define(Shape.CIRCLE, Circle$2);
    this.define(Shape.ELLIPSE, Ellipse$1);
    this.define(Shape.RECT, Rect$1);
    this.define(Shape.IMAGE, Image$3);
    this.define(Shape.LINE, Line$2);
    this.define(Shape.GROUP, Group);
    this.define(Shape.PATH, Path);
    this.define(Shape.POLYGON, Polygon$1);
    this.define(Shape.POLYLINE, Polyline$1);
    this.define(Shape.TEXT, Text$1);
    this.define(Shape.HTML, HTML$1);
  }
  return _createClass(CustomElementRegistry2, [{
    key: "define",
    value: function define2(name, constructor) {
      this.registry[name] = constructor;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
     */
  }, {
    key: "get",
    value: function get2(name) {
      return this.registry[name];
    }
  }]);
}();
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number(n2) {
    return new CSSUnitValue(n2);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n2) {
    return new CSSUnitValue(n2, "%");
  },
  /**
   * <length>
   */
  px: function px(n2) {
    return new CSSUnitValue(n2, "px");
  },
  /**
   * <length>
   */
  em: function em(n2) {
    return new CSSUnitValue(n2, "em");
  },
  rem: function rem(n2) {
    return new CSSUnitValue(n2, "rem");
  },
  /**
   * <angle>
   */
  deg: function deg(n2) {
    return new CSSUnitValue(n2, "deg");
  },
  /**
   * <angle>
   */
  grad: function grad(n2) {
    return new CSSUnitValue(n2, "grad");
  },
  /**
   * <angle>
   */
  rad: function rad(n2) {
    return new CSSUnitValue(n2, "rad");
  },
  /**
   * <angle>
   */
  turn: function turn(n2) {
    return new CSSUnitValue(n2, "turn");
  },
  /**
   * <time>
   */
  s: function s(n2) {
    return new CSSUnitValue(n2, "s");
  },
  /**
   * <time>
   */
  ms: function ms(n2) {
    return new CSSUnitValue(n2, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name,
      inh: inherits,
      "int": interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name, clazz) {
    runtime.layoutRegistry.registerLayout(name, clazz);
  }
};
var Document$1 = /* @__PURE__ */ function(_Node) {
  function Document2() {
    var _this2;
    _classCallCheck(this, Document2);
    _this2 = _callSuper(this, Document2);
    _this2.defaultView = null;
    _this2.ownerDocument = null;
    _this2.nodeName = "document";
    try {
      _this2.timeline = new runtime.AnimationTimeline(_this2);
    } catch (_unused) {
    }
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function(_ref) {
      var n2 = _ref.n, inh = _ref.inh, d3 = _ref.d;
      if (inh && d3) {
        initialStyle[n2] = isFunction$1(d3) ? d3(Shape.GROUP) : d3;
      }
    });
    _this2.documentElement = new Group({
      id: "g-root",
      style: initialStyle
    });
    _this2.documentElement.ownerDocument = _this2;
    _this2.documentElement.parentNode = _this2;
    _this2.childNodes = [_this2.documentElement];
    return _this2;
  }
  _inherits(Document2, _Node);
  return _createClass(Document2, [{
    key: "children",
    get: function get2() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get2() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get2() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get2() {
      return this.lastChild;
    }
  }, {
    key: "createElement",
    value: (
      /**
       * @example const circle = document.createElement('circle', { style: { r: 10 } });
       */
      function createElement2(tagName, options) {
        if (tagName === "svg") {
          return this.documentElement;
        }
        var clazz = this.defaultView.customElements.get(tagName);
        if (!clazz) {
          console.warn("Unsupported tagName: ", tagName);
          clazz = tagName === "tspan" ? Text$1 : Group;
        }
        var shape = new clazz(options);
        shape.ownerDocument = this;
        return shape;
      }
    )
  }, {
    key: "createElementNS",
    value: function createElementNS(namespaceURI, tagName, options) {
      return this.createElement(tagName, options);
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      try {
        this.documentElement.destroyChildren();
        this.timeline.destroy();
      } catch (_unused2) {
      }
    }
    /**
     * Picking 2D graphics by traversing elements and checking bounding boxes.
     */
  }, {
    key: "elementsFromBBox",
    value: function elementsFromBBox(minX, minY, maxX, maxY) {
      var hitTestList = [];
      var _traverse = function traverse2(node) {
        if (!node.isInteractive() || node.isCulled()) {
          return;
        }
        var _node$parsedStyle$poi = node.parsedStyle.pointerEvents, pointerEvents = _node$parsedStyle$poi === void 0 ? "auto" : _node$parsedStyle$poi;
        var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
        if (!isVisibilityAffected || node.isVisible()) {
          var bounds = node.getTransformedGeometryBounds(true);
          if (bounds && !AABB.isEmpty(bounds)) {
            if (bounds.max[0] >= minX && bounds.min[0] <= maxX && bounds.max[1] >= minY && bounds.min[1] <= maxY) {
              hitTestList.push(node);
            }
          }
        }
        if (node.childNodes) {
          node.childNodes.forEach(function(child) {
            if (child instanceof DisplayObject) {
              _traverse(child);
            }
          });
        }
      };
      _traverse(this.documentElement);
      hitTestList.sort(function(a2, b2) {
        return b2.sortable.renderOrder - a2.sortable.renderOrder;
      });
      return hitTestList;
    }
  }, {
    key: "elementFromPointSync",
    value: function elementFromPointSync(x2, y2) {
      var _this$defaultView$can = this.defaultView.canvas2Viewport({
        x: x2,
        y: y2
      }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
      var _this$defaultView$get = this.defaultView.getConfig(), width2 = _this$defaultView$get.width, height = _this$defaultView$get.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
        return null;
      }
      var _this$defaultView$vie = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
      var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: true,
        position: {
          x: x2,
          y: y2,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get2.picked;
      return picked && picked[0] || this.documentElement;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
     */
  }, {
    key: "elementFromPoint",
    value: function() {
      var _elementFromPoint = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(x2, y2) {
        var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width2, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x: x2,
                y: y2
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width2 = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height)) {
                _context.next = 1;
                break;
              }
              return _context.abrupt("return", null);
            case 1:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 2;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x: x2,
                  y: y2,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 2:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function elementFromPoint(_x, _x2) {
        return _elementFromPoint.apply(this, arguments);
      }
      return elementFromPoint;
    }()
  }, {
    key: "elementsFromPointSync",
    value: function elementsFromPointSync(x2, y2) {
      var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
        x: x2,
        y: y2
      }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
      var _this$defaultView$get4 = this.defaultView.getConfig(), width2 = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
        return [];
      }
      var _this$defaultView$vie3 = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
      var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: false,
        position: {
          x: x2,
          y: y2,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get5.picked;
      if (picked[picked.length - 1] !== this.documentElement) {
        picked.push(this.documentElement);
      }
      return picked;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
     */
  }, {
    key: "elementsFromPoint",
    value: function() {
      var _elementsFromPoint = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(x2, y2) {
        var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width2, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
        return _regeneratorRuntime().wrap(function(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x: x2,
                y: y2
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width2 = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height)) {
                _context2.next = 1;
                break;
              }
              return _context2.abrupt("return", []);
            case 1:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 2;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x: x2,
                  y: y2,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 2:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function elementsFromPoint(_x3, _x4) {
        return _elementsFromPoint.apply(this, arguments);
      }
      return elementsFromPoint;
    }()
  }, {
    key: "appendChild",
    value: function appendChild(newChild, index2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "removeChild",
    value: function removeChild(oldChild, destroy) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(newChild, oldChild, destroy) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "append",
    value: function append() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "prepend",
    value: function prepend() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
    /**
     * Execute query on documentElement.
     */
  }, {
    key: "getElementById",
    value: function getElementById(id2) {
      return this.documentElement.getElementById(id2);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name) {
      return this.documentElement.getElementsByName(name);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return this.documentElement.getElementsByTagName(tagName);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className) {
      return this.documentElement.getElementsByClassName(className);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return this.documentElement.querySelector(selectors);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return this.documentElement.querySelectorAll(selectors);
    }
  }, {
    key: "find",
    value: function find3(filter2) {
      return this.documentElement.find(filter2);
    }
  }, {
    key: "findAll",
    value: function findAll(filter2) {
      return this.documentElement.findAll(filter2);
    }
  }]);
}(Node$1);
var CullingPlugin = /* @__PURE__ */ function() {
  function CullingPlugin2(strategies) {
    _classCallCheck(this, CullingPlugin2);
    this.strategies = strategies;
  }
  return _createClass(CullingPlugin2, [{
    key: "apply",
    value: function apply2(context) {
      var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
      var strategies = this.strategies;
      renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
        if (object) {
          var _config$future;
          var cullable = object.cullable;
          if (strategies.length === 0) {
            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
          } else {
            cullable.visible = strategies.every(function(strategy) {
              return strategy.isVisible(camera, object);
            });
          }
          if (!object.isCulled() && object.isVisible()) {
            return object;
          }
          var enableCancelEventPropagation = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalCancelEventPropagation) === true;
          object.dispatchEvent(new CustomEvent(ElementEvent.CULLED), enableCancelEventPropagation, enableCancelEventPropagation);
          return null;
        }
        return object;
      });
      renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
        object.cullable.visibilityPlaneMask = -1;
      });
    }
  }]);
}();
CullingPlugin.tag = "Culling";
var EventPlugin = /* @__PURE__ */ function() {
  function EventPlugin2() {
    var _this2 = this;
    _classCallCheck(this, EventPlugin2);
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.onPointerMove = function(nativeEvent) {
      var _this$context$renderi;
      var canvas2 = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
      if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
      var _iterator = _createForOfIteratorHelper(normalizedEvents), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var normalizedEvent = _step.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
    this.onClick = function(nativeEvent) {
      var _this$context$renderi2;
      var canvas2 = (_this$context$renderi2 = _this2.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
      var _iterator2 = _createForOfIteratorHelper(normalizedEvents), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var normalizedEvent = _step2.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
  }
  return _createClass(EventPlugin2, [{
    key: "apply",
    value: function apply2(context) {
      var _this2 = this;
      this.context = context;
      var renderingService = context.renderingService;
      var canvas2 = this.context.renderingContext.root.ownerDocument.defaultView;
      this.context.eventService.setPickHandler(function(position2) {
        var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
          position: position2,
          picked: [],
          topmost: true
          // we only concern the topmost element
        }), picked = _this2$context$render.picked;
        return picked[0] || null;
      });
      renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
        var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
        _this2.context.eventService.mapEvent(wheelEvent);
      });
      renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var events = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
        if (_this2.autoPreventDefault && events[0].isNormalized) {
          var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        var _iterator3 = _createForOfIteratorHelper(events), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var event = _step3.value;
            var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas2, nativeEvent);
            _this2.context.eventService.mapEvent(federatedEvent);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var $element = _this2.context.contextService.getDomElement();
        var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
        var outside = !isNativeEventFromCanvas ? "outside" : "";
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
        var _iterator4 = _createForOfIteratorHelper(normalizedEvents), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var normalizedEvent = _step4.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
            event.type += outside;
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
      renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
        var _iterator5 = _createForOfIteratorHelper(normalizedEvents), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var normalizedEvent = _step5.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
    }
  }, {
    key: "bootstrapEvent",
    value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      var _this$context$eventSe = this.context.eventService.client2Viewport({
        x: normalizedEvent.clientX,
        y: normalizedEvent.clientY
      }), x2 = _this$context$eventSe.x, y2 = _this$context$eventSe.y;
      event.viewport.x = x2;
      event.viewport.y = y2;
      var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    }
  }, {
    key: "normalizeWheelEvent",
    value: function normalizeWheelEvent(nativeEvent) {
      var event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaMode = nativeEvent.deltaMode;
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      var _this$context$eventSe3 = this.context.eventService.client2Viewport({
        x: nativeEvent.clientX,
        y: nativeEvent.clientY
      }), x2 = _this$context$eventSe3.x, y2 = _this$context$eventSe3.y;
      event.viewport.x = x2;
      event.viewport.y = y2;
      var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    /**
     * Transfers base & mouse event data from the nativeEvent to the federated event.
     */
  }, {
    key: "transferMouseData",
    value: function transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = clock$1.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    }
  }, {
    key: "setCursor",
    value: function setCursor(cursor) {
      this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
    }
  }, {
    key: "normalizeToPointerEvent",
    value: function normalizeToPointerEvent(event, canvas2) {
      var normalizedEvents = [];
      if (canvas2.isTouchEvent(event)) {
        for (var i2 = 0; i2 < event.changedTouches.length; i2++) {
          var touch = event.changedTouches[i2];
          if (isUndefined(touch.button)) touch.button = 0;
          if (isUndefined(touch.buttons)) touch.buttons = 1;
          if (isUndefined(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (isUndefined(touch.width)) touch.width = touch.radiusX || 1;
          if (isUndefined(touch.height)) touch.height = touch.radiusY || 1;
          if (isUndefined(touch.tiltX)) touch.tiltX = 0;
          if (isUndefined(touch.tiltY)) touch.tiltY = 0;
          if (isUndefined(touch.pointerType)) touch.pointerType = "touch";
          if (isUndefined(touch.pointerId)) touch.pointerId = touch.identifier || 0;
          if (isUndefined(touch.pressure)) touch.pressure = touch.force || 0.5;
          if (isUndefined(touch.twist)) touch.twist = 0;
          if (isUndefined(touch.tangentialPressure)) touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas2.isMouseEvent(event)) {
        var tempEvent = event;
        if (isUndefined(tempEvent.isPrimary)) tempEvent.isPrimary = true;
        if (isUndefined(tempEvent.width)) tempEvent.width = 1;
        if (isUndefined(tempEvent.height)) tempEvent.height = 1;
        if (isUndefined(tempEvent.tiltX)) tempEvent.tiltX = 0;
        if (isUndefined(tempEvent.tiltY)) tempEvent.tiltY = 0;
        if (isUndefined(tempEvent.pointerType)) tempEvent.pointerType = "mouse";
        if (isUndefined(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
        if (isUndefined(tempEvent.pressure)) tempEvent.pressure = 0.5;
        if (isUndefined(tempEvent.twist)) tempEvent.twist = 0;
        if (isUndefined(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
  }]);
}();
EventPlugin.tag = "Event";
var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
var FrustumCullingStrategy = /* @__PURE__ */ function() {
  function FrustumCullingStrategy2() {
    _classCallCheck(this, FrustumCullingStrategy2);
  }
  return _createClass(FrustumCullingStrategy2, [{
    key: "isVisible",
    value: function isVisible2(camera, object) {
      var _object$parentNode;
      var cullable = object.cullable;
      if (!cullable.enable) {
        return true;
      }
      var renderBounds = object.getRenderBounds();
      if (AABB.isEmpty(renderBounds)) {
        return false;
      }
      var frustum2 = camera.getFrustum();
      var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
      cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
      cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
      return cullable.visible;
    }
    /**
     *
     * @seeOptimized View Frustum Culling Algorithms for Bounding Boxes
     * @see https://github.com/antvis/GWebGPUEngine/issues/3
     *
     * *  the basic intersection test
     * *  masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
     * * TODO:  the plane-coherency test
     * * TODO:  mesh  Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
     *
     * @param aabb aabb
     * @param parentPlaneMask mask of parent
     * @param planes planes of frustum
     */
  }, {
    key: "computeVisibilityWithPlaneMask",
    value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
      if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
        return parentPlaneMask;
      }
      var mask = Mask.INSIDE;
      var isShape2D = shape2D.indexOf(object.nodeName) > -1;
      for (var k = 0, len2 = planes.length; k < len2; ++k) {
        var flag = 1 << k;
        if ((parentPlaneMask & flag) === 0) {
          continue;
        }
        if (isShape2D && (k === 4 || k === 5)) {
          continue;
        }
        var _planes$k = planes[k], normal = _planes$k.normal, distance2 = _planes$k.distance;
        if (dot$4(normal, aabb.getPositiveFarPoint(planes[k])) + distance2 < 0) {
          return Mask.OUTSIDE;
        }
        if (dot$4(normal, aabb.getNegativeFarPoint(planes[k])) + distance2 < 0) {
          mask |= flag;
        }
      }
      return mask;
    }
  }]);
}();
var PrepareRendererPlugin = /* @__PURE__ */ function() {
  function PrepareRendererPlugin2() {
    _classCallCheck(this, PrepareRendererPlugin2);
    this.mutationRecords = [];
    this.isFirstTimeRendering = true;
    this.isFirstTimeRenderingFinished = false;
  }
  return _createClass(PrepareRendererPlugin2, [{
    key: "apply",
    value: function apply2(context) {
      var _this2 = this, _runtime$globalThis$r;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      var canvas2 = renderingContext.root.ownerDocument.defaultView;
      var handleAttributeChanged = function handleAttributeChanged2(e3) {
        renderingService.dirty();
      };
      var handleBoundsChanged = function handleBoundsChanged2(e3) {
        var _this$mutationRecords;
        var records = e3.detail;
        (_this$mutationRecords = _this2.mutationRecords).push.apply(_this$mutationRecords, _toConsumableArray(records));
        renderingService.dirty();
      };
      var handleMounted = function handleMounted2(e3) {
        var object = e3.target;
        if (runtime.enableSizeAttenuation) {
          runtime.styleValueRegistry.updateSizeAttenuation(object, canvas2.getCamera().getZoom());
        }
      };
      var handleUnmounted = function handleUnmounted2(e3) {
        var object = e3.target;
        runtime.sceneGraphService.dirtyToRoot(object);
        renderingService.dirty();
      };
      renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
        canvas2.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas2.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas2.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas2.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
        canvas2.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas2.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas2.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas2.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        _this2.mutationRecords = [];
      });
      var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);
      renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
        if (_this2.isFirstTimeRendering) {
          _this2.isFirstTimeRendering = false;
          ric(function() {
            _this2.isFirstTimeRenderingFinished = true;
          });
        }
        _this2.mutationRecords = [];
      });
    }
  }]);
}();
PrepareRendererPlugin.tag = "Prepare";
var CanvasEvent$1 = /* @__PURE__ */ function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
  CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
  return CanvasEvent2;
}({});
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent$1.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent$1.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent$1.AFTER_RENDER);
var Canvas$1 = /* @__PURE__ */ function(_EventTarget) {
  function Canvas2(config) {
    var _this2;
    _classCallCheck(this, Canvas2);
    _this2 = _callSuper(this, Canvas2);
    _this2.Element = DisplayObject;
    _this2.inited = false;
    _this2.context = {};
    var container = config.container, canvas2 = config.canvas, renderer = config.renderer, width2 = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame = config.requestAnimationFrame, cancelAnimationFrame = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;
    var canvasWidth = width2;
    var canvasHeight = height;
    var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
    dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
    if (canvas2) {
      canvasWidth = width2 || getWidth(canvas2) || canvas2.width / dpr;
      canvasHeight = height || getHeight(canvas2) || canvas2.height / dpr;
    }
    _this2.customElements = new CustomElementRegistry();
    _this2.devicePixelRatio = dpr;
    _this2.requestAnimationFrame = requestAnimationFrame !== null && requestAnimationFrame !== void 0 ? requestAnimationFrame : raf.bind(runtime.globalThis);
    _this2.cancelAnimationFrame = cancelAnimationFrame !== null && cancelAnimationFrame !== void 0 ? cancelAnimationFrame : caf.bind(runtime.globalThis);
    _this2.createImage = createImage !== null && createImage !== void 0 ? createImage : function() {
      return new window.Image();
    };
    _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
    _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
      return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    if (offscreenCanvas) {
      runtime.offscreenCanvas = offscreenCanvas;
    }
    _this2.document = new Document$1();
    _this2.document.defaultView = _this2;
    if (!supportsMutipleCanvasesInOneContainer) {
      cleanExistedCanvas(container, _this2, cleanUpOnDestroy);
    }
    _this2.initRenderingContext(_objectSpread2(_objectSpread2({}, config), {}, {
      width: canvasWidth,
      height: canvasHeight,
      background: background !== null && background !== void 0 ? background : "transparent",
      cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
      cleanUpOnDestroy,
      devicePixelRatio: dpr,
      requestAnimationFrame: _this2.requestAnimationFrame,
      cancelAnimationFrame: _this2.cancelAnimationFrame,
      createImage: _this2.createImage,
      supportsTouchEvents: _this2.supportsTouchEvents,
      supportsPointerEvents: _this2.supportsPointerEvents,
      isTouchEvent: _this2.isTouchEvent,
      isMouseEvent: _this2.isMouseEvent,
      dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200
    }));
    _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
    _this2.initRenderer(renderer, true);
    return _this2;
  }
  _inherits(Canvas2, _EventTarget);
  return _createClass(Canvas2, [{
    key: "initRenderingContext",
    value: function initRenderingContext(mergedConfig) {
      this.context.config = mergedConfig;
      this.context.renderingContext = {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        unculledEntities: [],
        renderListCurrentFrame: [],
        renderReasons: /* @__PURE__ */ new Set(),
        force: false,
        dirty: false
      };
    }
  }, {
    key: "initDefaultCamera",
    value: function initDefaultCamera(width2, height, clipSpaceNearZ) {
      var _this2 = this;
      var camera = new runtime.CameraContribution();
      camera.clipSpaceNearZ = clipSpaceNearZ;
      camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width2 / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width2 / 2, height / 2, 0).setOrthographic(width2 / -2, width2 / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
      camera.canvas = this;
      camera.eventEmitter.on(CameraEvent.UPDATED, function() {
        _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
        if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
          _this2.updateSizeAttenuation();
        }
      });
      this.context.camera = camera;
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation() {
      var zoom = this.getCamera().getZoom();
      this.document.documentElement.forEach(function(node) {
        runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.context.config;
    }
    /**
     * get the root displayObject in scenegraph
     * @alias this.document.documentElement
     */
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this.document.documentElement;
    }
    /**
     * get the camera of canvas
     */
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.context.camera;
    }
  }, {
    key: "getContextService",
    value: function getContextService() {
      return this.context.contextService;
    }
  }, {
    key: "getEventService",
    value: function getEventService() {
      return this.context.eventService;
    }
  }, {
    key: "getRenderingService",
    value: function getRenderingService() {
      return this.context.renderingService;
    }
  }, {
    key: "getRenderingContext",
    value: function getRenderingContext() {
      return this.context.renderingContext;
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.getRenderingService().getStats();
    }
    // /**
    //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
    //  */
    // getComputedStyle(node: DisplayObject) {
    //   return node.computedStyle;
    // }
  }, {
    key: "ready",
    get: function get2() {
      var _this3 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function(resolve) {
          _this3.resolveReadyPromise = function() {
            resolve(_this3);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
    /**
     * @param cleanUp - whether to clean up all the internal services of Canvas
     * @param skipTriggerEvent - whether to skip trigger destroy event
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$getConfig$futur;
      var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
      memoize$1.clearCache();
      var enableCancelEventPropagation = ((_this$getConfig$futur = this.getConfig().future) === null || _this$getConfig$futur === void 0 ? void 0 : _this$getConfig$futur.experimentalCancelEventPropagation) === true;
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent$1.BEFORE_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      if (this.frameId) {
        this.cancelAnimationFrame(this.frameId);
      }
      var root2 = this.getRoot();
      if (cleanUp) {
        this.unmountChildren(root2);
        this.document.destroy();
        this.getEventService().destroy();
      }
      this.getRenderingService().destroy();
      this.getContextService().destroy();
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent$1.AFTER_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      var clearEventRetain = function clearEventRetain2(event) {
        event.currentTarget = null;
        event.manager = null;
        event.target = null;
        event.relatedNode = null;
      };
      clearEventRetain(mountedEvent);
      clearEventRetain(unmountedEvent);
      clearEventRetain(beforeRenderEvent);
      clearEventRetain(rerenderEvent);
      clearEventRetain(afterRenderEvent);
      clearEventRetain(attrModifiedEvent);
      clearEventRetain(insertedEvent);
      clearEventRetain(removedEvent);
      clearEventRetain(destroyEvent);
      runtime.textService.clearCache();
    }
    /**
     * compatible with G 3.0
     * @deprecated
     * @alias resize
     */
  }, {
    key: "changeSize",
    value: function changeSize(width2, height) {
      this.resize(width2, height);
    }
  }, {
    key: "resize",
    value: function resize(width2, height) {
      var _canvasConfig$future;
      var canvasConfig = this.context.config;
      canvasConfig.width = width2;
      canvasConfig.height = height;
      this.getContextService().resize(width2, height);
      var camera = this.context.camera;
      var projectionMode = camera.getProjectionMode();
      camera.setPosition(width2 / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width2 / 2, height / 2, 0);
      if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        camera.setOrthographic(width2 / -2, width2 / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
      } else {
        camera.setAspect(width2 / height);
      }
      var enableCancelEventPropagation = ((_canvasConfig$future = canvasConfig.future) === null || _canvasConfig$future === void 0 ? void 0 : _canvasConfig$future.experimentalCancelEventPropagation) === true;
      this.dispatchEvent(new CustomEvent(CanvasEvent$1.RESIZE, {
        width: width2,
        height
      }), enableCancelEventPropagation, enableCancelEventPropagation);
    }
    // proxy to document.documentElement
  }, {
    key: "appendChild",
    value: function appendChild(child, index2) {
      return this.document.documentElement.appendChild(child, index2);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      return this.document.documentElement.insertBefore(newChild, refChild);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      return this.document.documentElement.removeChild(child);
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      this.document.documentElement.removeChildren();
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     * But the canvas remains running which means display objects can be appended later.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      this.document.documentElement.destroyChildren();
    }
  }, {
    key: "render",
    value: function render(frame2) {
      var _this$getConfig$futur2, _this4 = this;
      if (frame2) {
        beforeRenderEvent.detail = frame2;
        afterRenderEvent.detail = frame2;
      }
      var enableCancelEventPropagation = ((_this$getConfig$futur2 = this.getConfig().future) === null || _this$getConfig$futur2 === void 0 ? void 0 : _this$getConfig$futur2.experimentalCancelEventPropagation) === true;
      this.dispatchEvent(beforeRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      var renderingService = this.getRenderingService();
      renderingService.render(this, frame2, function() {
        _this4.dispatchEvent(rerenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      });
      this.dispatchEvent(afterRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
    }
  }, {
    key: "run",
    value: function run2() {
      var _this5 = this;
      var _tick = function tick2(time2, frame2) {
        _this5.render(frame2);
        _this5.frameId = _this5.requestAnimationFrame(_tick);
      };
      _tick();
    }
  }, {
    key: "initRenderer",
    value: function initRenderer(renderer) {
      var _this6 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!renderer) {
        throw new Error("Renderer is required.");
      }
      this.inited = false;
      this.readyPromise = void 0;
      this.context.renderingPlugins = [];
      this.context.renderingPlugins.push(
        new EventPlugin(),
        new PrepareRendererPlugin(),
        // new DirtyCheckPlugin(),
        new CullingPlugin([new FrustumCullingStrategy()])
      );
      this.loadRendererContainerModule(renderer);
      this.context.contextService = new this.context.ContextService(_objectSpread2(_objectSpread2({}, runtime), this.context));
      this.context.renderingService = new RenderingService(runtime, this.context);
      this.context.eventService = new EventService(runtime, this.context);
      this.context.eventService.init();
      if (this.context.contextService.init) {
        this.context.contextService.init();
        this.initRenderingService(renderer, firstContentfullPaint, true);
      } else {
        this.context.contextService.initAsync().then(function() {
          _this6.initRenderingService(renderer, firstContentfullPaint);
        })["catch"](function(err) {
          console.error(err);
        });
      }
    }
  }, {
    key: "initRenderingService",
    value: function initRenderingService(renderer) {
      var _this7 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.context.renderingService.init(function() {
        var _this7$getConfig$futu;
        _this7.inited = true;
        var enableCancelEventPropagation = ((_this7$getConfig$futu = _this7.getConfig().future) === null || _this7$getConfig$futu === void 0 ? void 0 : _this7$getConfig$futu.experimentalCancelEventPropagation) === true;
        if (firstContentfullPaint) {
          if (async) {
            _this7.requestAnimationFrame(function() {
              _this7.dispatchEvent(new CustomEvent(CanvasEvent$1.READY), enableCancelEventPropagation, enableCancelEventPropagation);
            });
          } else {
            _this7.dispatchEvent(new CustomEvent(CanvasEvent$1.READY), enableCancelEventPropagation, enableCancelEventPropagation);
          }
        } else {
          _this7.dispatchEvent(new CustomEvent(CanvasEvent$1.RENDERER_CHANGED), enableCancelEventPropagation, enableCancelEventPropagation);
        }
        if (_this7.readyPromise) {
          _this7.resolveReadyPromise();
        }
        if (!firstContentfullPaint) {
          _this7.getRoot().forEach(function(node) {
            var _dirty, _ref;
            (_dirty = (_ref = node).dirty) === null || _dirty === void 0 || _dirty.call(_ref, true, true);
          });
        }
        _this7.mountChildren(_this7.getRoot());
        if (renderer.getConfig().enableAutoRendering) {
          _this7.run();
        }
      });
    }
  }, {
    key: "loadRendererContainerModule",
    value: function loadRendererContainerModule(renderer) {
      var _this8 = this;
      var plugins = renderer.getPlugins();
      plugins.forEach(function(plugin) {
        plugin.context = _this8.context;
        plugin.init(runtime);
      });
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      var canvasConfig = this.getConfig();
      if (canvasConfig.renderer === renderer) {
        return;
      }
      var oldRenderer = canvasConfig.renderer;
      canvasConfig.renderer = renderer;
      this.destroy(false, true);
      _toConsumableArray((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
        plugin.destroy(runtime);
      });
      this.initRenderer(renderer);
    }
  }, {
    key: "setCursor",
    value: function setCursor(cursor) {
      var canvasConfig = this.getConfig();
      canvasConfig.cursor = cursor;
      this.getContextService().applyCursorStyle(cursor);
    }
  }, {
    key: "unmountChildren",
    value: function unmountChildren(parent) {
      var _this9 = this;
      parent.childNodes.forEach(function(child) {
        _this9.unmountChildren(child);
      });
      if (this.inited) {
        if (parent.isMutationObserved) {
          parent.dispatchEvent(unmountedEvent);
        } else {
          var _this$getConfig$futur3;
          var enableCancelEventPropagation = ((_this$getConfig$futur3 = this.getConfig().future) === null || _this$getConfig$futur3 === void 0 ? void 0 : _this$getConfig$futur3.experimentalCancelEventPropagation) === true;
          unmountedEvent.target = parent;
          this.dispatchEvent(unmountedEvent, true, enableCancelEventPropagation);
        }
        if (parent !== this.document.documentElement) {
          parent.ownerDocument = null;
        }
        parent.isConnected = false;
      }
      if (parent.isCustomElement) {
        if (parent.disconnectedCallback) {
          parent.disconnectedCallback();
        }
      }
    }
  }, {
    key: "mountChildren",
    value: function mountChildren(child) {
      var _this0 = this;
      var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment(child);
      if (this.inited) {
        if (!child.isConnected) {
          child.ownerDocument = this.document;
          child.isConnected = true;
          if (!skipTriggerEvent) {
            if (child.isMutationObserved) {
              child.dispatchEvent(mountedEvent);
            } else {
              var _this$getConfig$futur4;
              var enableCancelEventPropagation = ((_this$getConfig$futur4 = this.getConfig().future) === null || _this$getConfig$futur4 === void 0 ? void 0 : _this$getConfig$futur4.experimentalCancelEventPropagation) === true;
              mountedEvent.target = child;
              this.dispatchEvent(mountedEvent, true, enableCancelEventPropagation);
            }
          }
        }
      } else {
        console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
      }
      child.childNodes.forEach(function(c2) {
        _this0.mountChildren(c2, skipTriggerEvent);
      });
      if (child.isCustomElement) {
        if (child.connectedCallback) {
          child.connectedCallback();
        }
      }
    }
  }, {
    key: "mountFragment",
    value: function mountFragment(child) {
      this.mountChildren(child, false);
    }
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      return this.getEventService().client2Viewport(client);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas2) {
      return this.getEventService().viewport2Client(canvas2);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(viewport) {
      return this.getEventService().viewport2Canvas(viewport);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvas2) {
      return this.getEventService().canvas2Viewport(canvas2);
    }
    /**
     * @deprecated
     * @alias client2Viewport
     */
  }, {
    key: "getPointByClient",
    value: function getPointByClient(clientX, clientY) {
      return this.client2Viewport({
        x: clientX,
        y: clientY
      });
    }
    /**
     * @deprecated
     * @alias viewport2Client
     */
  }, {
    key: "getClientByPoint",
    value: function getClientByPoint(x2, y2) {
      return this.viewport2Client({
        x: x2,
        y: y2
      });
    }
  }]);
}(EventTarget);
var RefCountCache = /* @__PURE__ */ function() {
  function RefCountCache2() {
    _classCallCheck(this, RefCountCache2);
    this.cacheStore = /* @__PURE__ */ new Map();
  }
  return _createClass(RefCountCache2, [{
    key: "onRefAdded",
    value: function onRefAdded2(ref) {
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.cacheStore.has(key);
    }
  }, {
    key: "put",
    value: function put(key, item, ref) {
      if (this.cacheStore.has(key)) {
        return false;
      }
      this.cacheStore.set(key, {
        value: item,
        counter: /* @__PURE__ */ new Set([ref.entity])
      });
      this.onRefAdded(ref);
      return true;
    }
  }, {
    key: "get",
    value: function get2(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return null;
      }
      if (!cacheItem.counter.has(ref.entity)) {
        cacheItem.counter.add(ref.entity);
        this.onRefAdded(ref);
      }
      return cacheItem.value;
    }
  }, {
    key: "update",
    value: function update(key, value, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.value = _objectSpread2(_objectSpread2({}, cacheItem.value), value);
      if (!cacheItem.counter.has(ref.entity)) {
        cacheItem.counter.add(ref.entity);
        this.onRefAdded(ref);
      }
      return true;
    }
  }, {
    key: "release",
    value: function release(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.counter["delete"](ref.entity);
      if (cacheItem.counter.size <= 0) {
        this.cacheStore["delete"](key);
      }
      return true;
    }
  }, {
    key: "releaseRef",
    value: function releaseRef(ref) {
      var _this2 = this;
      Array.from(this.cacheStore.keys()).forEach(function(key) {
        _this2.release(key, ref);
      });
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.cacheStore.size;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cacheStore.clear();
    }
  }]);
}();
var tasks = [];
var nextFrameTasks = [];
var ImageSlicer = /* @__PURE__ */ function() {
  function ImageSlicer2() {
    _classCallCheck(this, ImageSlicer2);
  }
  return _createClass(ImageSlicer2, null, [{
    key: "stop",
    value: function stop() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (ImageSlicer2.rafId) {
        api.cancelAnimationFrame(ImageSlicer2.rafId);
        ImageSlicer2.rafId = null;
      }
    }
  }, {
    key: "executeTask",
    value: function executeTask() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (tasks.length <= 0 && nextFrameTasks.length <= 0) {
        return;
      }
      nextFrameTasks.forEach(function(task) {
        return task();
      });
      nextFrameTasks = tasks.splice(0, ImageSlicer2.TASK_NUM_PER_FRAME);
      ImageSlicer2.rafId = api.requestAnimationFrame(function() {
        ImageSlicer2.executeTask(api);
      });
    }
  }, {
    key: "sliceImage",
    value: function sliceImage(image2, sliceWidth, sliceHeight, rerender) {
      var overlap = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      var api = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ImageSlicer2.api;
      var imageWidth = image2.naturalWidth || image2.width;
      var imageHeight = image2.naturalHeight || image2.height;
      var strideW = sliceWidth - overlap;
      var strideH = sliceHeight - overlap;
      var gridCols = Math.ceil(imageWidth / strideW);
      var gridRows = Math.ceil(imageHeight / strideH);
      var result = {
        tileSize: [sliceWidth, sliceHeight],
        gridSize: [gridRows, gridCols],
        tiles: Array(gridRows).fill(null).map(function() {
          return Array(gridCols).fill(null);
        })
      };
      var _loop = function _loop2(row3) {
        var _loop22 = function _loop23(col2) {
          tasks.push(function() {
            var startX = col2 * strideW;
            var startY = row3 * strideH;
            var _ref = [Math.min(sliceWidth, imageWidth - startX), Math.min(sliceHeight, imageHeight - startY)], tempSliceWidth = _ref[0], tempSliceHeight = _ref[1];
            var sliceCanvas = api.createCanvas();
            sliceCanvas.width = sliceWidth;
            sliceCanvas.height = sliceHeight;
            var sliceCtx = sliceCanvas.getContext("2d");
            sliceCtx.drawImage(image2, startX, startY, tempSliceWidth, tempSliceHeight, 0, 0, tempSliceWidth, tempSliceHeight);
            result.tiles[row3][col2] = {
              x: startX,
              y: startY,
              tileX: col2,
              tileY: row3,
              data: sliceCanvas
            };
            rerender();
          });
        };
        for (var col = 0; col < gridCols; col++) {
          _loop22(col);
        }
      };
      for (var row2 = 0; row2 < gridRows; row2++) {
        _loop(row2);
      }
      ImageSlicer2.stop();
      ImageSlicer2.executeTask();
      return result;
    }
  }]);
}();
ImageSlicer.TASK_NUM_PER_FRAME = 10;
var IMAGE_CACHE = new RefCountCache();
IMAGE_CACHE.onRefAdded = function onRefAdded(ref) {
  var _this2 = this;
  ref.addEventListener(ElementEvent.DESTROY, function() {
    _this2.releaseRef(ref);
  }, {
    once: true
  });
};
var ImagePool$1 = /* @__PURE__ */ function() {
  function ImagePool2(context, runtime2) {
    _classCallCheck(this, ImagePool2);
    this.gradientCache = {};
    this.patternCache = {};
    this.context = context;
    this.runtime = runtime2;
  }
  return _createClass(ImagePool2, [{
    key: "getImageSync",
    value: function getImageSync(src, ref, callback) {
      var imageSource = isString$1(src) ? src : src.src;
      if (IMAGE_CACHE.has(imageSource)) {
        var imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (imageCache.img.complete) {
          callback === null || callback === void 0 || callback(imageCache);
          return imageCache;
        }
      }
      this.getOrCreateImage(src, ref).then(function(cache) {
        callback === null || callback === void 0 || callback(cache);
      })["catch"](function(reason) {
        console.error(reason);
      });
      return null;
    }
  }, {
    key: "getOrCreateImage",
    value: function getOrCreateImage(src, ref) {
      var _this2 = this;
      var imageSource = isString$1(src) ? src : src.src;
      if (!isString$1(src) && !IMAGE_CACHE.has(imageSource)) {
        var imageCache = {
          img: src,
          size: [src.naturalWidth || src.width, src.naturalHeight || src.height],
          tileSize: calculateImageTileSize(src)
        };
        IMAGE_CACHE.put(imageSource, imageCache, ref);
      }
      if (IMAGE_CACHE.has(imageSource)) {
        var _imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (_imageCache.img.complete) {
          return Promise.resolve(_imageCache);
        }
        return new Promise(function(resolve, reject) {
          _imageCache.img.addEventListener("load", function() {
            _imageCache.size = [_imageCache.img.naturalWidth || _imageCache.img.width, _imageCache.img.naturalHeight || _imageCache.img.height];
            _imageCache.tileSize = calculateImageTileSize(_imageCache.img);
            resolve(_imageCache);
          });
          _imageCache.img.addEventListener("error", function(ev) {
            reject(ev);
          });
        });
      }
      return new Promise(function(resolve, reject) {
        var image2 = _this2.context.config.createImage();
        if (image2) {
          var _imageCache2 = {
            img: image2,
            size: [0, 0],
            tileSize: calculateImageTileSize(image2)
          };
          IMAGE_CACHE.put(imageSource, _imageCache2, ref);
          image2.onload = function() {
            _imageCache2.size = [image2.naturalWidth || image2.width, image2.naturalHeight || image2.height];
            _imageCache2.tileSize = calculateImageTileSize(_imageCache2.img);
            resolve(_imageCache2);
          };
          image2.onerror = function(ev) {
            reject(ev);
          };
          image2.crossOrigin = "Anonymous";
          image2.src = imageSource;
        }
      });
    }
  }, {
    key: "createDownSampledImage",
    value: function() {
      var _createDownSampledImage = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(src, ref) {
        var imageCache, enableLargeImageOptimization, _ref, _ref$maxDownSampledIm, maxDownSampledImageSize, _ref$downSamplingRate, downSamplingRateThreshold, createImageBitmapFunc, _imageCache$size, originWidth, originHeight, resizedImage, downSamplingRate, updateCache;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 1;
              return this.getOrCreateImage(src, ref);
            case 1:
              imageCache = _context.sent;
              if (!(typeof imageCache.downSamplingRate !== "undefined")) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", imageCache);
            case 2:
              enableLargeImageOptimization = this.context.config.enableLargeImageOptimization;
              _ref = typeof enableLargeImageOptimization === "boolean" ? {} : enableLargeImageOptimization, _ref$maxDownSampledIm = _ref.maxDownSampledImageSize, maxDownSampledImageSize = _ref$maxDownSampledIm === void 0 ? 2048 : _ref$maxDownSampledIm, _ref$downSamplingRate = _ref.downSamplingRateThreshold, downSamplingRateThreshold = _ref$downSamplingRate === void 0 ? 0.5 : _ref$downSamplingRate;
              createImageBitmapFunc = this.runtime.globalThis.createImageBitmap;
              _imageCache$size = _slicedToArray(imageCache.size, 2), originWidth = _imageCache$size[0], originHeight = _imageCache$size[1];
              resizedImage = imageCache.img;
              downSamplingRate = Math.min((maxDownSampledImageSize + maxDownSampledImageSize) / (originWidth + originHeight), Math.max(0.01, Math.min(downSamplingRateThreshold, 0.5)));
              updateCache = _objectSpread2(_objectSpread2({}, imageCache), {}, {
                downSamplingRate
              });
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              if (!createImageBitmapFunc) {
                _context.next = 7;
                break;
              }
              _context.prev = 3;
              _context.next = 4;
              return createImageBitmapFunc(imageCache.img, {
                resizeWidth: originWidth * downSamplingRate,
                resizeHeight: originHeight * downSamplingRate
              });
            case 4:
              resizedImage = _context.sent;
              _context.next = 6;
              break;
            case 5:
              _context.prev = 5;
              _context["catch"](3);
              downSamplingRate = 1;
            case 6:
              _context.next = 8;
              break;
            case 7:
              downSamplingRate = 1;
            case 8:
              updateCache = _objectSpread2(_objectSpread2({}, this.getImageSync(src, ref)), {}, {
                downSampled: resizedImage,
                downSamplingRate
              });
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              return _context.abrupt("return", updateCache);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 5]]);
      }));
      function createDownSampledImage(_x, _x2) {
        return _createDownSampledImage.apply(this, arguments);
      }
      return createDownSampledImage;
    }()
  }, {
    key: "createImageTiles",
    value: function() {
      var _createImageTiles = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(src, tiles, rerender, ref) {
        var imageCache, _ref$ownerDocument$de, requestAnimationFrame, cancelAnimationFrame, updateCache;
        return _regeneratorRuntime().wrap(function(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 1;
              return this.getOrCreateImage(src, ref);
            case 1:
              imageCache = _context2.sent;
              _ref$ownerDocument$de = ref.ownerDocument.defaultView, requestAnimationFrame = _ref$ownerDocument$de.requestAnimationFrame, cancelAnimationFrame = _ref$ownerDocument$de.cancelAnimationFrame;
              ImageSlicer.api = {
                requestAnimationFrame,
                cancelAnimationFrame,
                createCanvas: function createCanvas2() {
                  return OffscreenCanvasCreator.createCanvas();
                }
              };
              updateCache = _objectSpread2(_objectSpread2({}, imageCache), ImageSlicer.sliceImage(imageCache.img, imageCache.tileSize[0], imageCache.tileSize[0], rerender));
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              return _context2.abrupt("return", updateCache);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createImageTiles(_x3, _x4, _x5, _x6) {
        return _createImageTiles.apply(this, arguments);
      }
      return createImageTiles;
    }()
  }, {
    key: "releaseImage",
    value: function releaseImage(src, ref) {
      IMAGE_CACHE.release(isString$1(src) ? src : src.src, ref);
    }
  }, {
    key: "releaseImageRef",
    value: function releaseImageRef(ref) {
      IMAGE_CACHE.releaseRef(ref);
    }
  }, {
    key: "getOrCreatePatternSync",
    value: function getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, min2, callback) {
      var patternKey = this.generatePatternKey(pattern);
      if (patternKey && this.patternCache[patternKey]) {
        return this.patternCache[patternKey];
      }
      var image2 = pattern.image, repetition = pattern.repetition, transform2 = pattern.transform;
      var src;
      var needScaleWithDPR = false;
      if (isString$1(image2)) {
        var imageCache = this.getImageSync(image2, object, callback);
        src = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      } else if ($offscreenCanvas) {
        src = $offscreenCanvas;
        needScaleWithDPR = true;
      } else {
        src = image2;
      }
      var canvasPattern = src && context.createPattern(src, repetition);
      if (canvasPattern) {
        var mat;
        if (transform2) {
          mat = parsedTransformToMat4(parseTransform(transform2), new DisplayObject({}));
        } else {
          mat = identity$1(create$5());
        }
        if (needScaleWithDPR) {
          scale$3(mat, mat, [1 / dpr, 1 / dpr, 1]);
        }
        canvasPattern.setTransform({
          a: mat[0],
          b: mat[1],
          c: mat[4],
          d: mat[5],
          e: mat[12] + min2[0],
          f: mat[13] + min2[1]
        });
      }
      if (patternKey && canvasPattern) {
        this.patternCache[patternKey] = canvasPattern;
      }
      return canvasPattern;
    }
  }, {
    key: "getOrCreateGradient",
    value: function getOrCreateGradient(params, context) {
      var key = this.generateGradientKey(params);
      var type = params.type, steps = params.steps, min2 = params.min, width2 = params.width, height = params.height, angle2 = params.angle, cx = params.cx, cy = params.cy, size = params.size;
      if (this.gradientCache[key]) {
        return this.gradientCache[key];
      }
      var gradient = null;
      if (type === GradientType.LinearGradient) {
        var _computeLinearGradien = computeLinearGradient(min2, width2, height, angle2), x1 = _computeLinearGradien.x1, y1 = _computeLinearGradien.y1, x2 = _computeLinearGradien.x2, y2 = _computeLinearGradien.y2;
        gradient = context.createLinearGradient(x1, y1, x2, y2);
      } else if (type === GradientType.RadialGradient) {
        var _computeRadialGradien = computeRadialGradient(min2, width2, height, cx, cy, size), x3 = _computeRadialGradien.x, y3 = _computeRadialGradien.y, r2 = _computeRadialGradien.r;
        gradient = context.createRadialGradient(x3, y3, 0, x3, y3, r2);
      }
      if (gradient) {
        steps.forEach(function(_ref2) {
          var offset = _ref2.offset, color2 = _ref2.color;
          if (offset.unit === UnitType.kPercentage) {
            var _gradient;
            (_gradient = gradient) === null || _gradient === void 0 || _gradient.addColorStop(offset.value / 100, color2.toString());
          }
        });
        this.gradientCache[key] = gradient;
      }
      return this.gradientCache[key];
    }
  }, {
    key: "generateGradientKey",
    value: function generateGradientKey(params) {
      var type = params.type, min2 = params.min, width2 = params.width, height = params.height, steps = params.steps, angle2 = params.angle, cx = params.cx, cy = params.cy, size = params.size;
      return "gradient-".concat(type, "-").concat((angle2 === null || angle2 === void 0 ? void 0 : angle2.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size === null || size === void 0 ? void 0 : size.toString()) || 0, "-").concat(min2[0], "-").concat(min2[1], "-").concat(width2, "-").concat(height, "-").concat(steps.map(function(_ref3) {
        var offset = _ref3.offset, color2 = _ref3.color;
        return "".concat(offset).concat(color2);
      }).join("-"));
    }
  }, {
    key: "generatePatternKey",
    value: function generatePatternKey(pattern) {
      var image2 = pattern.image, repetition = pattern.repetition;
      if (isString$1(image2)) {
        return "pattern-".concat(image2, "-").concat(repetition);
      }
      if (image2.nodeName === "rect") {
        return "pattern-".concat(image2.entity, "-").concat(repetition);
      }
    }
  }]);
}();
ImagePool$1.isSupportTile = !!OffscreenCanvasCreator.createCanvas();
function calculateImageTileSize(img) {
  if (!img.complete) {
    return [0, 0];
  }
  var width2 = img.naturalWidth || img.width, height = img.naturalHeight || img.height;
  var tileSize = 256;
  [256, 512].forEach(function(size) {
    var rows = Math.ceil(height / size);
    var cols = Math.ceil(width2 / size);
    if (rows * cols < 1e3) {
      tileSize = size;
    }
  });
  return [tileSize, tileSize];
}
var LoadImagePlugin = /* @__PURE__ */ function() {
  function LoadImagePlugin2() {
    _classCallCheck(this, LoadImagePlugin2);
  }
  return _createClass(LoadImagePlugin2, [{
    key: "apply",
    value: function apply2(context) {
      var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
      var canvas2 = renderingContext.root.ownerDocument.defaultView;
      var calculateWithAspectRatio = function calculateWithAspectRatio2(object, imageWidth, imageHeight) {
        var _object$parsedStyle = object.parsedStyle, width2 = _object$parsedStyle.width, height = _object$parsedStyle.height;
        if (width2 && !height) {
          object.setAttribute("height", imageHeight / imageWidth * width2);
        } else if (!width2 && height) {
          object.setAttribute("width", imageWidth / imageHeight * height);
        }
      };
      var handleMounted = function handleMounted2(e3) {
        var object = e3.target;
        var nodeName = object.nodeName, attributes = object.attributes;
        if (nodeName === Shape.IMAGE) {
          var src = attributes.src, keepAspectRatio = attributes.keepAspectRatio;
          imagePool.getImageSync(src, object, function(_ref) {
            var _ref$img = _ref.img, width2 = _ref$img.width, height = _ref$img.height;
            if (keepAspectRatio) {
              calculateWithAspectRatio(object, width2, height);
            }
            object.dirty();
            renderingService.dirty();
          });
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e3) {
        var object = e3.target;
        var attrName = e3.attrName, prevValue = e3.prevValue, newValue = e3.newValue;
        if (object.nodeName !== Shape.IMAGE || attrName !== "src") {
          return;
        }
        if (prevValue !== newValue) {
          imagePool.releaseImage(prevValue, object);
        }
        if (isString$1(newValue)) {
          imagePool.getOrCreateImage(newValue, object).then(function(_ref2) {
            var _ref2$img = _ref2.img, width2 = _ref2$img.width, height = _ref2$img.height;
            if (object.attributes.keepAspectRatio) {
              calculateWithAspectRatio(object, width2, height);
            }
            object.dirty();
            renderingService.dirty();
          })["catch"](function() {
          });
        }
      };
      renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
        canvas2.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas2.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
      renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
        canvas2.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas2.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
    }
  }]);
}();
LoadImagePlugin.tag = "LoadImage";
var Plugin$3$1 = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    _classCallCheck(this, Plugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin2, [].concat(args));
    _this2.name = "image-loader";
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init(runtime2) {
      this.context.imagePool = new ImagePool$1(this.context, runtime2);
      this.addRenderingPlugin(new LoadImagePlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ImagePool: ImagePool$1,
  Plugin: Plugin$3$1
});
var CANVAS_CAMERA_ID = "g-canvas-camera";
var HTMLRenderingPlugin = /* @__PURE__ */ function() {
  function HTMLRenderingPlugin2() {
    _classCallCheck(this, HTMLRenderingPlugin2);
    this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
  }
  return _createClass(HTMLRenderingPlugin2, [{
    key: "joinTransformMatrix",
    value: (
      /**
       * ! The reason for adding `offset` is that the `transform-origin` coordinate system of DOM is the local coordinate system of the element, while the `transform-origin` coordinate system of canvas drawing is the local coordinate system of the element's parent element. At the same time, the `transform` attribute value of the DOM element does not include `transform-origin`.
       */
      function joinTransformMatrix(matrix3) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
        return "matrix(".concat([matrix3[0], matrix3[1], matrix3[4], matrix3[5], matrix3[12] + offset[0], matrix3[13] + offset[1]].join(","), ")");
      }
    )
  }, {
    key: "apply",
    value: function apply2(context, runtime2) {
      var _this2 = this;
      var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
      this.context = context;
      var canvas2 = renderingContext.root.ownerDocument.defaultView;
      var nativeHTMLMap = canvas2.context.eventService.nativeHTMLMap;
      var setTransform = function setTransform2(object, $el) {
        $el.style.transform = _this2.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      };
      var handleMounted = function handleMounted2(e3) {
        var object = e3.target;
        if (object.nodeName === Shape.HTML) {
          if (!_this2.$camera) {
            _this2.$camera = _this2.createCamera(camera);
          }
          var $el = _this2.getOrCreateEl(object);
          _this2.$camera.appendChild($el);
          Object.keys(object.attributes).forEach(function(name) {
            _this2.updateAttribute(name, object);
          });
          setTransform(object, $el);
          nativeHTMLMap.set($el, object);
        }
      };
      var handleUnmounted = function handleUnmounted2(e3) {
        var object = e3.target;
        if (object.nodeName === Shape.HTML && _this2.$camera) {
          var $el = _this2.getOrCreateEl(object);
          if ($el) {
            $el.remove();
            nativeHTMLMap["delete"]($el);
          }
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e3) {
        var object = e3.target;
        if (object.nodeName === Shape.HTML) {
          var attrName = e3.attrName;
          _this2.updateAttribute(attrName, object);
        }
      };
      var handleBoundsChanged = function handleBoundsChanged2(e3) {
        var records = e3.detail;
        for (var i2 = 0; i2 < records.length; i2++) {
          var record = records[i2];
          var object = record.target;
          var nodes = object.nodeName === Shape.FRAGMENT ? object.childNodes : [object];
          nodes.forEach(function(node) {
            if (node.nodeName === Shape.HTML) {
              var $el = _this2.getOrCreateEl(node);
              setTransform(node, $el);
            }
          });
        }
      };
      var handleCanvasResize = function handleCanvasResize2() {
        if (_this2.$camera) {
          var _this$context$config = _this2.context.config, width2 = _this$context$config.width, height = _this$context$config.height;
          _this2.$camera.parentElement.style.width = "".concat(width2 || 0, "px");
          _this2.$camera.parentElement.style.height = "".concat(height || 0, "px");
        }
      };
      renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
        canvas2.addEventListener(CanvasEvent$1.RESIZE, handleCanvasResize);
        canvas2.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas2.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas2.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas2.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
          _this2.$camera.style.transform = _this2.joinTransformMatrix(camera.getOrthoMatrix());
        }
      });
      renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera) {
          _this2.$camera.remove();
        }
        canvas2.removeEventListener(CanvasEvent$1.RESIZE, handleCanvasResize);
        canvas2.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas2.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas2.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas2.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
    }
  }, {
    key: "createCamera",
    value: function createCamera(camera) {
      var _this$context$config2 = this.context.config, doc = _this$context$config2.document, width2 = _this$context$config2.width, height = _this$context$config2.height;
      var $canvas = this.context.contextService.getDomElement();
      var $container = $canvas.parentNode;
      if ($container) {
        var cameraId = CANVAS_CAMERA_ID;
        var $existedCamera = $container.querySelector("#".concat(cameraId));
        if (!$existedCamera) {
          var $cameraContainer = (doc || document).createElement("div");
          $cameraContainer.style.overflow = "hidden";
          $cameraContainer.style.pointerEvents = "none";
          $cameraContainer.style.position = "absolute";
          $cameraContainer.style.left = "0px";
          $cameraContainer.style.top = "0px";
          $cameraContainer.style.width = "".concat(width2 || 0, "px");
          $cameraContainer.style.height = "".concat(height || 0, "px");
          var $camera = (doc || document).createElement("div");
          $existedCamera = $camera;
          $camera.id = cameraId;
          $camera.style.position = "absolute";
          $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
          $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
          $camera.style.transformOrigin = "left top";
          $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
          $camera.style.pointerEvents = "none";
          $camera.style.width = "100%";
          $camera.style.height = "100%";
          $cameraContainer.appendChild($camera);
          $container.appendChild($cameraContainer);
        }
        return $existedCamera;
      }
      return null;
    }
  }, {
    key: "getOrCreateEl",
    value: function getOrCreateEl(object) {
      var doc = this.context.config.document;
      var $existedElement = this.displayObjectHTMLElementMap.get(object);
      if (!$existedElement) {
        $existedElement = (doc || document).createElement("div");
        object.parsedStyle.$el = $existedElement;
        this.displayObjectHTMLElementMap.set(object, $existedElement);
        if (object.id) {
          $existedElement.id = object.id;
        }
        if (object.name) {
          $existedElement.setAttribute("name", object.name);
        }
        if (object.className) {
          $existedElement.className = object.className;
        }
        $existedElement.style.position = "absolute";
        $existedElement.style["will-change"] = "transform";
        $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      }
      return $existedElement;
    }
  }, {
    key: "updateAttribute",
    value: function updateAttribute(name, object) {
      var $el = this.getOrCreateEl(object);
      switch (name) {
        case "innerHTML":
          var innerHTML = object.parsedStyle.innerHTML;
          if (isString$1(innerHTML)) {
            $el.innerHTML = innerHTML;
          } else {
            $el.innerHTML = "";
            $el.appendChild(innerHTML);
          }
          break;
        case "x":
          $el.style.left = "".concat(object.parsedStyle.x, "px");
          break;
        case "y":
          $el.style.top = "".concat(object.parsedStyle.y, "px");
          break;
        case "transformOrigin":
          var transformOrigin2 = object.parsedStyle.transformOrigin;
          $el.style["transform-origin"] = "".concat(transformOrigin2[0].buildCSSText(null, null, ""), " ").concat(transformOrigin2[1].buildCSSText(null, null, ""));
          break;
        case "width":
          var width2 = object.parsedStyle.width;
          $el.style.width = isNumber(width2) ? "".concat(width2, "px") : width2.toString();
          break;
        case "height":
          var height = object.parsedStyle.height;
          $el.style.height = isNumber(height) ? "".concat(height, "px") : height.toString();
          break;
        case "zIndex":
          var zIndex2 = object.parsedStyle.zIndex;
          $el.style["z-index"] = "".concat(zIndex2);
          break;
        case "visibility":
          var visibility2 = object.parsedStyle.visibility;
          $el.style.visibility = visibility2;
          break;
        case "pointerEvents":
          var _object$parsedStyle$p = object.parsedStyle.pointerEvents, pointerEvents = _object$parsedStyle$p === void 0 ? "auto" : _object$parsedStyle$p;
          $el.style.pointerEvents = pointerEvents;
          break;
        case "opacity":
          var opacity2 = object.parsedStyle.opacity;
          $el.style.opacity = "".concat(opacity2);
          break;
        case "fill":
          var fill = object.parsedStyle.fill;
          var color2 = "";
          if (isCSSRGB(fill)) {
            if (fill.isNone) {
              color2 = "transparent";
            } else {
              color2 = object.getAttribute("fill");
            }
          } else if (Array.isArray(fill)) {
            color2 = object.getAttribute("fill");
          } else if (isPattern(fill)) ;
          $el.style.background = color2;
          break;
        case "stroke":
          var stroke = object.parsedStyle.stroke;
          var borderColor = "";
          if (isCSSRGB(stroke)) {
            if (stroke.isNone) {
              borderColor = "transparent";
            } else {
              borderColor = object.getAttribute("stroke");
            }
          } else if (Array.isArray(stroke)) {
            borderColor = object.getAttribute("stroke");
          } else if (isPattern(stroke)) ;
          $el.style["border-color"] = borderColor;
          $el.style["border-style"] = "solid";
          break;
        case "lineWidth":
          var lineWidth = object.parsedStyle.lineWidth;
          $el.style["border-width"] = "".concat(lineWidth || 0, "px");
          break;
        case "lineDash":
          $el.style["border-style"] = "dashed";
          break;
        case "filter":
          var filter2 = object.style.filter;
          $el.style.filter = filter2;
          break;
        default:
          if (!isNil(object.style[name]) && object.style[name] !== "") {
            $el.style[name] = object.style[name];
          }
      }
    }
  }]);
}();
HTMLRenderingPlugin.tag = "HTMLRendering";
var Plugin$2$1 = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    _classCallCheck(this, Plugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin2, [].concat(args));
    _this2.name = "html-renderer";
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new HTMLRenderingPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Plugin: Plugin$2$1
});
var DOMInteractionPlugin = /* @__PURE__ */ function() {
  function DOMInteractionPlugin2() {
    _classCallCheck(this, DOMInteractionPlugin2);
  }
  return _createClass(DOMInteractionPlugin2, [{
    key: "apply",
    value: function apply2(context, runtime2) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;
      this.context = context;
      var canvas2 = renderingContext.root.ownerDocument.defaultView;
      var onPointerMove = function onPointerMove2(ev) {
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerUp = function onPointerUp2(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerDown = function onPointerDown2(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerOver = function onPointerOver2(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function onPointerOut2(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onPointerCancel = function onPointerCancel2(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      var onPointerWheel = function onPointerWheel2(ev) {
        renderingService.hooks.pointerWheel.call(ev);
      };
      var onClick = function onClick2(ev) {
        renderingService.hooks.click.call(ev);
      };
      var addPointerEventListener = function addPointerEventListener2($el) {
        runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
        $el.addEventListener("pointerdown", onPointerDown, true);
        $el.addEventListener("pointerleave", onPointerOut, true);
        $el.addEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
      };
      var addTouchEventListener = function addTouchEventListener2($el) {
        $el.addEventListener("touchstart", onPointerDown, true);
        $el.addEventListener("touchend", onPointerUp, true);
        $el.addEventListener("touchmove", onPointerMove, true);
        $el.addEventListener("touchcancel", onPointerCancel, true);
      };
      var addMouseEventListener = function addMouseEventListener2($el) {
        runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
        $el.addEventListener("mousedown", onPointerDown, true);
        $el.addEventListener("mouseout", onPointerOut, true);
        $el.addEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
      };
      var removePointerEventListener = function removePointerEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
        $el.removeEventListener("pointerdown", onPointerDown, true);
        $el.removeEventListener("pointerleave", onPointerOut, true);
        $el.removeEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.removeEventListener("pointercancel", onPointerCancel, true);
      };
      var removeTouchEventListener = function removeTouchEventListener2($el) {
        $el.removeEventListener("touchstart", onPointerDown, true);
        $el.removeEventListener("touchend", onPointerUp, true);
        $el.removeEventListener("touchmove", onPointerMove, true);
        $el.removeEventListener("touchcancel", onPointerCancel, true);
      };
      var removeMouseEventListener = function removeMouseEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
        $el.removeEventListener("mousedown", onPointerDown, true);
        $el.removeEventListener("mouseout", onPointerOut, true);
        $el.removeEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
      };
      renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "none";
          $el.style.msTouchAction = "none";
        } else if (canvas2.supportsPointerEvents) {
          $el.style.touchAction = "none";
        }
        if (canvas2.supportsPointerEvents) {
          addPointerEventListener($el);
        } else {
          addMouseEventListener($el);
        }
        if (canvas2.supportsTouchEvents) {
          addTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.addEventListener("click", onClick, true);
        }
        $el.addEventListener("wheel", onPointerWheel, {
          passive: true,
          capture: true
        });
      });
      renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "";
          $el.style.msTouchAction = "";
        } else if (canvas2.supportsPointerEvents) {
          $el.style.touchAction = "";
        }
        if (canvas2.supportsPointerEvents) {
          removePointerEventListener($el);
        } else {
          removeMouseEventListener($el);
        }
        if (canvas2.supportsTouchEvents) {
          removeTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.removeEventListener("click", onClick, true);
        }
        $el.removeEventListener("wheel", onPointerWheel, true);
      });
    }
  }]);
}();
DOMInteractionPlugin.tag = "DOMInteraction";
var Plugin$1$1 = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    _classCallCheck(this, Plugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin2, [].concat(args));
    _this2.name = "dom-interaction";
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DOMInteractionPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);
var index$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Plugin: Plugin$1$1
});
var MobileInteractionPlugin = /* @__PURE__ */ function() {
  function MobileInteractionPlugin2() {
    _classCallCheck(this, MobileInteractionPlugin2);
  }
  return _createClass(MobileInteractionPlugin2, [{
    key: "apply",
    value: function apply2(context) {
      var renderingService = context.renderingService, contextService = context.contextService, config = context.config;
      var canvasEl = contextService.getDomElement();
      var onPointerDown = function onPointerDown2(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerUp = function onPointerUp2(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerMove = function onPointerMove2(ev) {
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerOver = function onPointerOver2(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function onPointerOut2(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onClick = function onClick2(ev) {
        renderingService.hooks.click.call(ev);
      };
      var onPointerCancel = function onPointerCancel2(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      renderingService.hooks.init.tap(MobileInteractionPlugin2.tag, function() {
        canvasEl.addEventListener("touchstart", onPointerDown, true);
        canvasEl.addEventListener("touchend", onPointerUp, true);
        canvasEl.addEventListener("touchmove", onPointerMove, true);
        canvasEl.addEventListener("touchcancel", onPointerCancel, true);
        canvasEl.addEventListener("mouseout", onPointerOut, true);
        canvasEl.addEventListener("mouseover", onPointerOver, true);
        if (config.useNativeClickEvent) {
          canvasEl.addEventListener("click", onClick, true);
        }
      });
      renderingService.hooks.destroy.tap(MobileInteractionPlugin2.tag, function() {
        canvasEl.removeEventListener("touchstart", onPointerDown, true);
        canvasEl.removeEventListener("touchend", onPointerUp, true);
        canvasEl.removeEventListener("touchmove", onPointerMove, true);
        canvasEl.removeEventListener("touchcancel", onPointerCancel, true);
        canvasEl.removeEventListener("mouseout", onPointerOut, true);
        canvasEl.removeEventListener("mouseover", onPointerOver, true);
        if (config.useNativeClickEvent) {
          canvasEl.removeEventListener("click", onClick, true);
        }
      });
    }
  }]);
}();
MobileInteractionPlugin.tag = "MobileInteraction";
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter$q(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step2([n2, v2]);
    };
  }
  function step2(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done) return t3;
      if (y2 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y2 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var Bounds$1 = (
  /** @class */
  function() {
    function Bounds2(left, top, width2, height) {
      this.left = left;
      this.top = top;
      this.width = width2;
      this.height = height;
    }
    Bounds2.prototype.add = function(x2, y2, w2, h2) {
      return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
    };
    Bounds2.fromClientRect = function(context, clientRect) {
      return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
    };
    Bounds2.fromDOMRectList = function(context, domRectList) {
      var domRect = Array.from(domRectList).find(function(rect2) {
        return rect2.width !== 0;
      });
      return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
    };
    Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
    return Bounds2;
  }()
);
var parseBounds = function(context, node) {
  return Bounds$1.fromClientRect(context, node.getBoundingClientRect());
};
var toCodePoints$1 = function(str2) {
  var codePoints = [];
  var i2 = 0;
  var length2 = str2.length;
  while (i2 < length2) {
    var value = str2.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length2) {
      var extra = str2.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length2 = codePoints.length;
  if (!length2) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length2) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length2 || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len2 = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i2 = 0; i2 < len2; i2 += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array$1 = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 2) {
    bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 4) {
    bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer = decode$1(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data2 = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data2);
};
var Trie$1 = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data2;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "";
var BREAK_ALLOWED$1 = "";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
  var current2 = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current2) !== -1 : a2 === current2) {
    var i2 = currentIndex;
    while (i2 <= classTypes.length) {
      i2++;
      var next = classTypes[i2];
      if (next === b2) {
        return true;
      }
      if (next !== SP) {
        break;
      }
    }
  }
  if (current2 === SP) {
    var i2 = currentIndex;
    while (i2 > 0) {
      i2--;
      var prev = classTypes[i2];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next = classTypes[n2];
          if (next === b2) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i2 = currentIndex;
  while (i2 >= 0) {
    var type = classTypes[i2];
    if (type === SP) {
      i2--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current2 = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next = classTypes[afterIndex];
  if (current2 === CR$1 && next === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current2) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current2 === EB || current2 === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === WJ || next === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current2) === -1 && next === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current2 === QU || next === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === CB || current2 === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next) !== -1 || current2 === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === SY && next === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next) !== -1 && current2 === NU || ALPHABETICS.indexOf(current2) !== -1 && next === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current2) !== -1 && next === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current2) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current2) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (
    // (PR | PO)  ( OP | HY )? NU
    [PR, PO].indexOf(current2) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY )  NU
    [OP, HY].indexOf(current2) !== -1 && next === NU || // NU 	(NU | SY | IS)
    current2 === NU && [NU, SY, IS].indexOf(next) !== -1
  ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next) !== -1) {
    var prevIndex = [CL, CP].indexOf(current2) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current2 && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current2) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current2) !== -1 && next === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current2) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current2 === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current2) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === IS && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current2) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current2 === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current2 === RI$1 && next === RI$1) {
    var i2 = indicies[currentIndex];
    var count = 1;
    while (i2 > 0) {
      i2--;
      if (classTypes[i2] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current2 === EB && next === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a3 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a3[0], classTypes = _a3[1], isLetterNumber = _a3[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
    return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = (
  /** @class */
  function() {
    function Break2(codePoints, lineBreak2, start, end) {
      this.codePoints = codePoints;
      this.required = lineBreak2 === BREAK_MANDATORY;
      this.start = start;
      this.end = end;
    }
    Break2.prototype.slice = function() {
      return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
    };
    return Break2;
  }()
);
var LineBreaker = function(str2, options) {
  var codePoints = toCodePoints$1(str2);
  var _a3 = cssFormattedClasses(codePoints, options), indicies = _a3[0], classTypes = _a3[1], forbiddenBreakpoints = _a3[2];
  var length2 = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length2) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length2 && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length2) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a$3 = 97;
var e$2 = 101;
var f$1 = 102;
var u$1 = 117;
var z$2 = 122;
var A$2 = 65;
var E$2 = 69;
var F$1 = 70;
var U = 85;
var Z = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A$2 && codePoint <= F$1 || codePoint >= a$3 && codePoint <= f$1;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a$3 && codePoint <= z$2;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A$2 && codePoint <= Z;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c2 = 0;
  var sign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      sign = -1;
    }
    c2++;
  }
  var integers = [];
  while (isDigit(codePoints[c2])) {
    integers.push(codePoints[c2++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c2] === FULL_STOP) {
    c2++;
  }
  var fraction = [];
  while (isDigit(codePoints[c2])) {
    fraction.push(codePoints[c2++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c2] === E$2 || codePoints[c2] === e$2) {
    c2++;
  }
  var expsign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c2++;
  }
  var exponent = [];
  while (isDigit(codePoints[c2])) {
    exponent.push(codePoints[c2++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
};
var COMMA_TOKEN = {
  type: 4
  /* COMMA_TOKEN */
};
var SUFFIX_MATCH_TOKEN = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
};
var PREFIX_MATCH_TOKEN = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
};
var COLUMN_TOKEN = {
  type: 21
  /* COLUMN_TOKEN */
};
var DASH_MATCH_TOKEN = {
  type: 9
  /* DASH_MATCH_TOKEN */
};
var INCLUDE_MATCH_TOKEN = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
};
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
};
var SUBSTRING_MATCH_TOKEN = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
};
var BAD_URL_TOKEN = {
  type: 23
  /* BAD_URL_TOKEN */
};
var BAD_STRING_TOKEN = {
  type: 1
  /* BAD_STRING_TOKEN */
};
var CDO_TOKEN = {
  type: 25
  /* CDO_TOKEN */
};
var CDC_TOKEN = {
  type: 24
  /* CDC_TOKEN */
};
var COLON_TOKEN = {
  type: 26
  /* COLON_TOKEN */
};
var SEMICOLON_TOKEN = {
  type: 27
  /* SEMICOLON_TOKEN */
};
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
};
var WHITESPACE_TOKEN = {
  type: 31
  /* WHITESPACE_TOKEN */
};
var EOF_TOKEN = {
  type: 32
  /* EOF_TOKEN */
};
var Tokenizer = (
  /** @class */
  function() {
    function Tokenizer2() {
      this._value = [];
    }
    Tokenizer2.prototype.write = function(chunk) {
      this._value = this._value.concat(toCodePoints$1(chunk));
    };
    Tokenizer2.prototype.read = function() {
      var tokens2 = [];
      var token = this.consumeToken();
      while (token !== EOF_TOKEN) {
        tokens2.push(token);
        token = this.consumeToken();
      }
      return tokens2;
    };
    Tokenizer2.prototype.consumeToken = function() {
      var codePoint = this.consumeCodePoint();
      switch (codePoint) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
            var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
            var value = this.consumeName();
            return { type: 5, value, flags };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUFFIX_MATCH_TOKEN;
          }
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUBSTRING_MATCH_TOKEN;
          }
          break;
        case PLUS_SIGN:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var e1 = codePoint;
          var e22 = this.peekCodePoint(0);
          var e3 = this.peekCodePoint(1);
          if (isNumberStart(e1, e22, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isIdentifierStart(e1, e22, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          if (e22 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDC_TOKEN;
          }
          break;
        case FULL_STOP:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK) {
            this.consumeCodePoint();
            while (true) {
              var c4 = this.consumeCodePoint();
              if (c4 === ASTERISK) {
                c4 = this.consumeCodePoint();
                if (c4 === SOLIDUS) {
                  return this.consumeToken();
                }
              }
              if (c4 === EOF) {
                return this.consumeToken();
              }
            }
          }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDO_TOKEN;
          }
          break;
        case COMMERCIAL_AT:
          var a1 = this.peekCodePoint(0);
          var a2 = this.peekCodePoint(1);
          var a3 = this.peekCodePoint(2);
          if (isIdentifierStart(a1, a2, a3)) {
            var value = this.consumeName();
            return { type: 7, value };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return PREFIX_MATCH_TOKEN;
          }
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u$1:
        case U:
          var u1 = this.peekCodePoint(0);
          var u2 = this.peekCodePoint(1);
          if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
            this.consumeCodePoint();
            this.consumeUnicodeRangeToken();
          }
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return DASH_MATCH_TOKEN;
          }
          if (this.peekCodePoint(0) === VERTICAL_LINE) {
            this.consumeCodePoint();
            return COLUMN_TOKEN;
          }
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return INCLUDE_MATCH_TOKEN;
          }
          break;
        case EOF:
          return EOF_TOKEN;
      }
      if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        return WHITESPACE_TOKEN;
      }
      if (isDigit(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeNumericToken();
      }
      if (isNameStartCodePoint(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      }
      return { type: 6, value: fromCodePoint$1(codePoint) };
    };
    Tokenizer2.prototype.consumeCodePoint = function() {
      var value = this._value.shift();
      return typeof value === "undefined" ? -1 : value;
    };
    Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
      this._value.unshift(codePoint);
    };
    Tokenizer2.prototype.peekCodePoint = function(delta) {
      if (delta >= this._value.length) {
        return -1;
      }
      return this._value[delta];
    };
    Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
      var digits = [];
      var codePoint = this.consumeCodePoint();
      while (isHex(codePoint) && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var questionMarks = false;
      while (codePoint === QUESTION_MARK && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
        questionMarks = true;
      }
      if (questionMarks) {
        var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
          return digit === QUESTION_MARK ? ZERO : digit;
        })), 16);
        var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
          return digit === QUESTION_MARK ? F$1 : digit;
        })), 16);
        return { type: 30, start: start_1, end };
      }
      var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint();
        codePoint = this.consumeCodePoint();
        var endDigits = [];
        while (isHex(codePoint) && endDigits.length < 6) {
          endDigits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
        return { type: 30, start, end };
      } else {
        return { type: 30, start, end: start };
      }
    };
    Tokenizer2.prototype.consumeIdentLikeToken = function() {
      var value = this.consumeName();
      if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return this.consumeUrlToken();
      } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return { type: 19, value };
      }
      return { type: 20, value };
    };
    Tokenizer2.prototype.consumeUrlToken = function() {
      var value = [];
      this.consumeWhiteSpace();
      if (this.peekCodePoint(0) === EOF) {
        return { type: 22, value: "" };
      }
      var next = this.peekCodePoint(0);
      if (next === APOSTROPHE || next === QUOTATION_MARK) {
        var stringToken = this.consumeStringToken(this.consumeCodePoint());
        if (stringToken.type === 0) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: stringToken.value };
          }
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      }
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        } else if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === REVERSE_SOLIDUS) {
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            value.push(this.consumeEscapedCodePoint());
          } else {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
        } else {
          value.push(codePoint);
        }
      }
    };
    Tokenizer2.prototype.consumeWhiteSpace = function() {
      while (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
    };
    Tokenizer2.prototype.consumeBadUrlRemnants = function() {
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
          return;
        }
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.consumeEscapedCodePoint();
        }
      }
    };
    Tokenizer2.prototype.consumeStringSlice = function(count) {
      var SLICE_STACK_SIZE = 5e4;
      var value = "";
      while (count > 0) {
        var amount = Math.min(SLICE_STACK_SIZE, count);
        value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
        count -= amount;
      }
      this._value.shift();
      return value;
    };
    Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
      var value = "";
      var i2 = 0;
      do {
        var codePoint = this._value[i2];
        if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
          value += this.consumeStringSlice(i2);
          return { type: 0, value };
        }
        if (codePoint === LINE_FEED) {
          this._value.splice(0, i2);
          return BAD_STRING_TOKEN;
        }
        if (codePoint === REVERSE_SOLIDUS) {
          var next = this._value[i2 + 1];
          if (next !== EOF && next !== void 0) {
            if (next === LINE_FEED) {
              value += this.consumeStringSlice(i2);
              i2 = -1;
              this._value.shift();
            } else if (isValidEscape(codePoint, next)) {
              value += this.consumeStringSlice(i2);
              value += fromCodePoint$1(this.consumeEscapedCodePoint());
              i2 = -1;
            }
          }
        }
        i2++;
      } while (true);
    };
    Tokenizer2.prototype.consumeNumber = function() {
      var repr = [];
      var type = FLAG_INTEGER;
      var c1 = this.peekCodePoint(0);
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        repr.push(this.consumeCodePoint());
      }
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
      c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      if (c1 === FULL_STOP && isDigit(c2)) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      c1 = this.peekCodePoint(0);
      c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if ((c1 === E$2 || c1 === e$2) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      return [stringToNumber(repr), type];
    };
    Tokenizer2.prototype.consumeNumericToken = function() {
      var _a3 = this.consumeNumber(), number2 = _a3[0], flags = _a3[1];
      var c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if (isIdentifierStart(c1, c2, c3)) {
        var unit = this.consumeName();
        return { type: 15, number: number2, flags, unit };
      }
      if (c1 === PERCENTAGE_SIGN) {
        this.consumeCodePoint();
        return { type: 16, number: number2, flags };
      }
      return { type: 17, number: number2, flags };
    };
    Tokenizer2.prototype.consumeEscapedCodePoint = function() {
      var codePoint = this.consumeCodePoint();
      if (isHex(codePoint)) {
        var hex2 = fromCodePoint$1(codePoint);
        while (isHex(this.peekCodePoint(0)) && hex2.length < 6) {
          hex2 += fromCodePoint$1(this.consumeCodePoint());
        }
        if (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
        var hexCodePoint = parseInt(hex2, 16);
        if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
          return REPLACEMENT_CHARACTER;
        }
        return hexCodePoint;
      }
      if (codePoint === EOF) {
        return REPLACEMENT_CHARACTER;
      }
      return codePoint;
    };
    Tokenizer2.prototype.consumeName = function() {
      var result = "";
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (isNameCodePoint(codePoint)) {
          result += fromCodePoint$1(codePoint);
        } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          result += fromCodePoint$1(this.consumeEscapedCodePoint());
        } else {
          this.reconsumeCodePoint(codePoint);
          return result;
        }
      }
    };
    return Tokenizer2;
  }()
);
var Parser = (
  /** @class */
  function() {
    function Parser2(tokens2) {
      this._tokens = tokens2;
    }
    Parser2.create = function(value) {
      var tokenizer = new Tokenizer();
      tokenizer.write(value);
      return new Parser2(tokenizer.read());
    };
    Parser2.parseValue = function(value) {
      return Parser2.create(value).parseComponentValue();
    };
    Parser2.parseValues = function(value) {
      return Parser2.create(value).parseComponentValues();
    };
    Parser2.prototype.parseComponentValue = function() {
      var token = this.consumeToken();
      while (token.type === 31) {
        token = this.consumeToken();
      }
      if (token.type === 32) {
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      }
      this.reconsumeToken(token);
      var value = this.consumeComponentValue();
      do {
        token = this.consumeToken();
      } while (token.type === 31);
      if (token.type === 32) {
        return value;
      }
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    };
    Parser2.prototype.parseComponentValues = function() {
      var values2 = [];
      while (true) {
        var value = this.consumeComponentValue();
        if (value.type === 32) {
          return values2;
        }
        values2.push(value);
        values2.push();
      }
    };
    Parser2.prototype.consumeComponentValue = function() {
      var token = this.consumeToken();
      switch (token.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(token.type);
        case 19:
          return this.consumeFunction(token);
      }
      return token;
    };
    Parser2.prototype.consumeSimpleBlock = function(type) {
      var block = { type, values: [] };
      var token = this.consumeToken();
      while (true) {
        if (token.type === 32 || isEndingTokenFor(token, type)) {
          return block;
        }
        this.reconsumeToken(token);
        block.values.push(this.consumeComponentValue());
        token = this.consumeToken();
      }
    };
    Parser2.prototype.consumeFunction = function(functionToken) {
      var cssFunction = {
        name: functionToken.value,
        values: [],
        type: 18
        /* FUNCTION */
      };
      while (true) {
        var token = this.consumeToken();
        if (token.type === 32 || token.type === 3) {
          return cssFunction;
        }
        this.reconsumeToken(token);
        cssFunction.values.push(this.consumeComponentValue());
      }
    };
    Parser2.prototype.consumeToken = function() {
      var token = this._tokens.shift();
      return typeof token === "undefined" ? EOF_TOKEN : token;
    };
    Parser2.prototype.reconsumeToken = function(token) {
      this._tokens.unshift(token);
    };
    return Parser2;
  }()
);
var isDimensionToken = function(token) {
  return token.type === 15;
};
var isNumberToken = function(token) {
  return token.type === 17;
};
var isIdentToken = function(token) {
  return token.type === 20;
};
var isIdentWithValue = function(token, value) {
  return isIdentToken(token) && token.value === value;
};
var nonFunctionArgSeparator = function(token) {
  return token.type !== 31 && token.type !== 4;
};
var parseFunctionArgs = function(tokens2) {
  var args = [];
  var arg = [];
  tokens2.forEach(function(token) {
    if (token.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token.type !== 31) {
      arg.push(token);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token, type) {
  if (type === 11 && token.type === 12) {
    return true;
  }
  if (type === 28 && token.type === 29) {
    return true;
  }
  return type === 2 && token.type === 3;
};
var isLength = function(token) {
  return token.type === 17 || token.type === 15;
};
var isLengthPercentage = function(token) {
  return token.type === 16 || isLength(token);
};
var parseLengthPercentageTuple = function(tokens2) {
  return tokens2.length > 1 ? [tokens2[0], tokens2[1]] : [tokens2[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width2, height) {
  var x2 = tuple[0], y2 = tuple[1];
  return [getAbsoluteValue(x2, width2), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
};
var getAbsoluteValue = function(token, parent) {
  if (token.type === 16) {
    return token.number / 100 * parent;
  }
  if (isDimensionToken(token)) {
    switch (token.unit) {
      case "rem":
      case "em":
        return 16 * token.number;
      case "px":
      default:
        return token.number;
    }
  }
  return token.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle$1 = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens2) {
  var sideOrCorner = tokens2.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg2(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg2(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg2(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg2(270);
  }
  return 0;
};
var deg2 = function(deg3) {
  return Math.PI * deg3 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
      }
      if (value.value.length === 4) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
      }
      if (value.value.length === 8) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r2, g2, b2, a2) {
  return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token, i2) {
  if (token.type === 17) {
    return token.number;
  }
  if (token.type === 16) {
    var max2 = i2 === 3 ? 1 : 255;
    return i2 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens2 = args.filter(nonFunctionArgSeparator);
  if (tokens2.length === 3) {
    var _a3 = tokens2.map(getTokenColorValue), r2 = _a3[0], g2 = _a3[1], b2 = _a3[2];
    return pack(r2, g2, b2, 1);
  }
  if (tokens2.length === 4) {
    var _b = tokens2.map(getTokenColorValue), r2 = _b[0], g2 = _b[1], b2 = _b[2], a2 = _b[3];
    return pack(r2, g2, b2, a2);
  }
  return 0;
};
function hue2rgb$1(t1, t22, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t22 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t22;
  } else if (hue < 2 / 3) {
    return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens2 = args.filter(nonFunctionArgSeparator);
  var hue = tokens2[0], saturation = tokens2[1], lightness = tokens2[2], alpha = tokens2[3];
  var h2 = (hue.type === 17 ? deg2(hue.number) : angle$1.parse(context, hue)) / (Math.PI * 2);
  var s3 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s3 === 0) {
    return pack(l2 * 255, l2 * 255, l2 * 255, 1);
  }
  var t22 = l2 <= 0.5 ? l2 * (s3 + 1) : l2 + s3 - l2 * s3;
  var t1 = l2 * 2 - t22;
  var r2 = hue2rgb$1(t1, t22, h2 + 1 / 3);
  var g2 = hue2rgb$1(t1, t22, h2);
  var b2 = hue2rgb$1(t1, t22, h2 - 1 / 3);
  return pack(r2 * 255, g2 * 255, b2 * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value) {
  return color$1.parse(context, Parser.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return tokens2.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1.parse(context, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i2 = 0; i2 < stops.length; i2++) {
    var stop_1 = stops[i2].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i2 = 0; i2 < processStops.length; i2++) {
    var stop_2 = processStops[i2];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i2;
      }
    } else if (gapBegin !== null) {
      var gapLength = i2 - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g2 = 1; g2 <= gapLength; g2++) {
        processStops[gapBegin + g2 - 1] = gapValue * g2;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a3, i3) {
    var color2 = _a3.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width2, height) {
  var centerX = width2 / 2;
  var centerY = height / 2;
  var x2 = getAbsoluteValue(corner[0], width2) - centerX;
  var y2 = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width2, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width2, height);
  var lineLength = Math.abs(width2 * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width2 / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance$4 = function(a2, b2) {
  return Math.sqrt(a2 * a2 + b2 * b2);
};
var findCorner = function(width2, height, x2, y2, closest) {
  var corners = [
    [0, 0],
    [0, height],
    [width2, 0],
    [width2, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d3 = distance$4(x2 - cx, y2 - cy);
    if (closest ? d3 < stat.optimumDistance : d3 > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d3
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x2, y2, width2, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x2), Math.abs(x2 - width2));
        ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance$4(x2, y2), distance$4(x2, y2 - height), distance$4(x2 - width2, y2), distance$4(x2 - width2, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width2));
        var _a3 = findCorner(width2, height, x2, y2, true), cx = _a3[0], cy = _a3[1];
        rx = distance$4(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x2), Math.abs(x2 - width2));
        ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance$4(x2, y2), distance$4(x2, y2 - height), distance$4(x2 - width2, y2), distance$4(x2 - width2, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width2));
        var _b = findCorner(width2, height, x2, y2, false), cx = _b[0], cy = _b[1];
        rx = distance$4(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width2);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens2) {
  var angle$1$1 = deg2(180);
  var stops = [];
  parseFunctionArgs(tokens2).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1$1 = angle$1.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var prefixLinearGradient = function(context, tokens2) {
  var angle$1$1 = deg2(180);
  var stops = [];
  parseFunctionArgs(tokens2).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1$1 = (angle$1.parse(context, firstToken) + deg2(270)) % deg2(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var webkitGradient = function(context, tokens2) {
  var angle2 = deg2(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size = 3;
  var position2 = [];
  parseFunctionArgs(tokens2).forEach(function(arg, i2) {
    var firstToken = arg[0];
    if (i2 === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values2 = firstToken.values.filter(nonFunctionArgSeparator);
        if (values2.length === 2) {
          var color2 = color$1.parse(context, values2[1]);
          var stop_1 = values2[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg2(180)) % deg2(360),
    stops,
    type
  } : { size, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens2) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens2).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token) {
        if (isAtPosition_1) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
          }
        } else if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var prefixRadialGradient = function(context, tokens2) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens2).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token) || isLength(token)) {
          position2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i2 === 1) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context, value) {
    if (value.type === 22) {
      var image_1 = {
        url: value.value,
        type: 0
        /* URL */
      };
      context.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens2) {
    if (tokens2.length === 0) {
      return [];
    }
    var first = tokens2[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens2.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image.parse(context, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return tokens2.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens2) {
    return parseFunctionArgs(tokens2).map(function(values2) {
      return values2.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return parseFunctionArgs(tokens2).map(function(values2) {
      return values2.filter(isIdentToken).map(function(token) {
        return token.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return parseFunctionArgs(tokens2).map(function(values2) {
      return values2.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens2) {
      return parseLengthPercentageTuple(tokens2.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style) {
      switch (style) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction$1 = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return tokens2.filter(isIdentToken).reduce(
      function(bit, token) {
        return bit | parseDisplayValue(token.value);
      },
      0
      /* NONE */
    );
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "normal") {
      return 0;
    }
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 15) {
      return token.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
  /* TOKEN_VALUE */
};
var computeLineHeight = function(token, fontSize2) {
  if (isIdentToken(token) && token.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token.type === 17) {
    return fontSize2 * token.number;
  } else if (isLengthPercentage(token)) {
    return getAbsoluteValue(token, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    return image.parse(context, token);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return tokens2.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position$3 = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens2) {
    if (tokens2.length === 1 && isIdentWithValue(tokens2[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens2).map(function(values2) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        var token = values2[i2];
        if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else {
            shadow.blur = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    if (token.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
      }
      return transformFunction(token.values);
    }
    return null;
  }
};
var matrix$1 = function(args) {
  var values2 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values2.length === 6 ? values2 : null;
};
var matrix3d2 = function(args) {
  var values2 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values2[0], b1 = values2[1];
  values2[2];
  values2[3];
  var a2 = values2[4], b2 = values2[5];
  values2[6];
  values2[7];
  values2[8];
  values2[9];
  values2[10];
  values2[11];
  var a4 = values2[12], b4 = values2[13];
  values2[14];
  values2[15];
  return values2.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix: matrix$1,
  matrix3d: matrix3d2
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens2) {
    var origins = tokens2.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility$1 = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token)) {
      return { auto: false, order: token.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time$1 = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    return tokens2.filter(isIdentToken).map(function(token) {
      switch (token.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line2) {
      return line2 !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    var accumulator = [];
    var results = [];
    tokens2.forEach(function(token) {
      switch (token.type) {
        case 20:
        case 0:
          accumulator.push(token.value);
          break;
        case 17:
          accumulator.push(token.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    if (isIdentToken(token)) {
      switch (token.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens2) {
    return tokens2.filter(isIdentToken).map(function(token) {
      return token.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value) {
  return (bit & value) !== 0;
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens2) {
    return tokens2.filter(isDimensionToken).map(function(token) {
      return time$1.parse(context, token);
    });
  }
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens2) {
    if (tokens2.length === 1 && isIdentWithValue(tokens2[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens2).map(function(values2) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        var token = values2[i2];
        if (isIdentWithValue(token, "inset")) {
          shadow.inset = true;
        } else if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else if (c2 === 2) {
            shadow.blur = token;
          } else {
            shadow.spread = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens2) {
    var DEFAULT_VALUE2 = [
      0,
      1,
      2
      /* MARKERS */
    ];
    var layers = [];
    tokens2.filter(isIdentToken).forEach(function(token) {
      switch (token.value) {
        case "stroke":
          layers.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          layers.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          layers.push(
            2
            /* MARKERS */
          );
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isDimensionToken(token)) {
      return token.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = (
  /** @class */
  function() {
    function CSSParsedDeclaration2(context, declaration) {
      var _a3, _b;
      this.animationDuration = parse(context, duration, declaration.animationDuration);
      this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
      this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
      this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
      this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
      this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
      this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
      this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
      this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
      this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
      this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
      this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
      this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
      this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
      this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
      this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
      this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
      this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
      this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
      this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
      this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
      this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
      this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
      this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
      this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
      this.color = parse(context, color, declaration.color);
      this.direction = parse(context, direction$1, declaration.direction);
      this.display = parse(context, display, declaration.display);
      this.float = parse(context, float, declaration.cssFloat);
      this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
      this.fontSize = parse(context, fontSize, declaration.fontSize);
      this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
      this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
      this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
      this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
      this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
      this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
      this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
      this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
      this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
      this.marginTop = parse(context, marginTop, declaration.marginTop);
      this.marginRight = parse(context, marginRight, declaration.marginRight);
      this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
      this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
      this.opacity = parse(context, opacity, declaration.opacity);
      var overflowTuple = parse(context, overflow, declaration.overflow);
      this.overflowX = overflowTuple[0];
      this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
      this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
      this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
      this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
      this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
      this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
      this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
      this.position = parse(context, position$3, declaration.position);
      this.textAlign = parse(context, textAlign, declaration.textAlign);
      this.textDecorationColor = parse(context, textDecorationColor, (_a3 = declaration.textDecorationColor) !== null && _a3 !== void 0 ? _a3 : declaration.color);
      this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
      this.textShadow = parse(context, textShadow, declaration.textShadow);
      this.textTransform = parse(context, textTransform, declaration.textTransform);
      this.transform = parse(context, transform$1, declaration.transform);
      this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
      this.visibility = parse(context, visibility$1, declaration.visibility);
      this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
      this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
      this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
      this.zIndex = parse(context, zIndex, declaration.zIndex);
    }
    CSSParsedDeclaration2.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    };
    CSSParsedDeclaration2.prototype.isTransparent = function() {
      return isTransparent(this.backgroundColor);
    };
    CSSParsedDeclaration2.prototype.isTransformed = function() {
      return this.transform !== null;
    };
    CSSParsedDeclaration2.prototype.isPositioned = function() {
      return this.position !== 0;
    };
    CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    };
    CSSParsedDeclaration2.prototype.isFloating = function() {
      return this.float !== 0;
    };
    CSSParsedDeclaration2.prototype.isInlineLevel = function() {
      return contains(
        this.display,
        4
        /* INLINE */
      ) || contains(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || contains(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || contains(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || contains(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || contains(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    };
    return CSSParsedDeclaration2;
  }()
);
var parse = function(context, descriptor, style) {
  var tokenizer = new Tokenizer();
  var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser2 = new Parser(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token = parser2.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser2.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser2.parseComponentValues());
    case 4:
      return parser2.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle$1.parse(context, parser2.parseComponentValue());
        case "color":
          return color$1.parse(context, parser2.parseComponentValue());
        case "image":
          return image.parse(context, parser2.parseComponentValue());
        case "length":
          var length_1 = parser2.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser2.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time$1.parse(context, parser2.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = (
  /** @class */
  /* @__PURE__ */ function() {
    function ElementContainer2(context, element) {
      this.context = context;
      this.textNodes = [];
      this.elements = [];
      this.flags = 0;
      if (isDebugging(
        element,
        3
        /* PARSE */
      )) {
        debugger;
      }
      this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
      if (isHTMLElementNode(element)) {
        if (this.styles.animationDuration.some(function(duration2) {
          return duration2 > 0;
        })) {
          element.style.animationDuration = "0s";
        }
        if (this.styles.transform !== null) {
          element.style.transform = "none";
        }
      }
      this.bounds = parseBounds(this.context, element);
      if (isDebugging(
        element,
        4
        /* RENDER */
      )) {
        this.flags |= 16;
      }
    }
    return ElementContainer2;
  }()
);
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
  lookup$1[chars$1.charCodeAt(i$1)] = i$1;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len2 = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i2 = 0; i2 < len2; i2 += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 2) {
    bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var polyUint32Array = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 4) {
    bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer = decode(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data2 = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data2);
};
var Trie = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data2;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$4 = 0; i$4 < chars.length; i$4++) {
  lookup[chars.charCodeAt(i$4)] = i$4;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L$1 = 8;
var V$1 = 9;
var T$1 = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str2) {
  var codePoints = [];
  var i2 = 0;
  var length2 = str2.length;
  while (i2 < length2) {
    var value = str2.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length2) {
      var extra = str2.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length2 = codePoints.length;
  if (!length2) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length2) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length2 || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "";
var BREAK_ALLOWED = "";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev = classTypes[prevIndex];
  var current2 = classTypes[index2 - 1];
  var next = classTypes[index2];
  if (current2 === CR && next === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current2 === CR || current2 === LF || current2 === Control) {
    return BREAK_ALLOWED;
  }
  if (next === CR || next === LF || next === Control) {
    return BREAK_ALLOWED;
  }
  if (current2 === L$1 && [L$1, V$1, LV, LVT].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current2 === LV || current2 === V$1) && (next === V$1 || next === T$1)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current2 === LVT || current2 === T$1) && next === T$1) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === ZWJ || next === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current2 === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current2 === ZWJ && next === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current2 === RI && next === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str2) {
  var codePoints = toCodePoints(str2);
  var length2 = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length2) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length2 && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length2) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str2) {
  var breaker = GraphemeBreaker(str2);
  var graphemes = [];
  var bk2;
  while (!(bk2 = breaker.next()).done) {
    if (bk2.value) {
      graphemes.push(bk2.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node = testElement.firstChild;
  var textList = toCodePoints$1(node.data).map(function(i2) {
    return fromCodePoint$1(i2);
  });
  var offset = 0;
  var prev = {};
  var supports = textList.every(function(text, i2) {
    range.setStart(node, offset);
    range.setEnd(node, offset + text.length);
    var rect2 = range.getBoundingClientRect();
    offset += text.length;
    var boundAhead = rect2.x > prev.x || rect2.y > prev.y;
    prev = rect2;
    if (i2 === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas2 = document2.createElement("canvas");
  var ctx2 = canvas2.getContext("2d");
  if (!ctx2) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx2.drawImage(img, 0, 0);
    canvas2.toDataURL();
  } catch (e3) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data2) {
  return data2[0] === 0 && data2[1] === 255 && data2[2] === 0 && data2[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas2 = document2.createElement("canvas");
  var size = 100;
  canvas2.width = size;
  canvas2.height = size;
  var ctx2 = canvas2.getContext("2d");
  if (!ctx2) {
    return Promise.reject(false);
  }
  ctx2.fillStyle = "rgb(0, 255, 0)";
  ctx2.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas2.toDataURL();
  img.src = greenImageSrc;
  var svg = createForeignObjectSVG(size, size, 0, 0, img);
  ctx2.fillStyle = "red";
  ctx2.fillRect(0, 0, size, size);
  return loadSerializedSVG$1(svg).then(function(img2) {
    ctx2.drawImage(img2, 0, 0);
    var data2 = ctx2.getImageData(0, 0, size, size).data;
    ctx2.fillStyle = "red";
    ctx2.fillRect(0, 0, size, size);
    var node = document2.createElement("div");
    node.style.backgroundImage = "url(" + greenImageSrc + ")";
    node.style.height = size + "px";
    return isGreenPixel(data2) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
  }).then(function(img2) {
    ctx2.drawImage(img2, 0, 0);
    return isGreenPixel(ctx2.getImageData(0, 0, size, size).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width2, height, x2, y2, node) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttributeNS(null, "width", width2.toString());
  svg.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x2.toString());
  foreignObject.setAttributeNS(null, "y", y2.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svg;
};
var loadSerializedSVG$1 = function(svg) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      return resolve(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextBounds2(text, bounds) {
      this.text = text;
      this.bounds = bounds;
    }
    return TextBounds2;
  }()
);
var parseTextBounds = function(context, value, styles, node) {
  var textList = breakText(value, styles);
  var textBounds = [];
  var offset = 0;
  textList.forEach(function(text) {
    if (styles.textDecorationLine.length || text.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node, offset, text.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds$1.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text, Bounds$1.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node.splitText(text.length);
        textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
        node = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node = node.splitText(text.length);
    }
    offset += text.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node) {
  var ownerDocument = node.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node.cloneNode(true));
    var parentNode = node.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds$1.EMPTY;
};
var createRange = function(node, offset, length2) {
  var ownerDocument = node.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument.createRange();
  range.setStart(node, offset);
  range.setEnd(node, offset + length2);
  return range;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles);
};
var breakText = function(value, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str2, styles) {
  var breaker = LineBreaker(str2, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk2;
  var _loop_1 = function() {
    if (bk2.value) {
      var value = bk2.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk2 = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextContainer2(context, node, styles) {
      this.text = transform(node.data, styles.textTransform);
      this.textBounds = parseTextBounds(context, this.text, styles, node);
    }
    return TextContainer2;
  }()
);
var transform = function(text, transform2) {
  switch (transform2) {
    case 1:
      return text.toLowerCase();
    case 3:
      return text.replace(CAPITALIZE, capitalize);
    case 2:
      return text.toUpperCase();
    default:
      return text;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m3, p1, p2) {
  if (m3.length > 0) {
    return p1 + p2.toUpperCase();
  }
  return m3;
};
var ImageElementContainer = (
  /** @class */
  function(_super) {
    __extends(ImageElementContainer2, _super);
    function ImageElementContainer2(context, img) {
      var _this2 = _super.call(this, context, img) || this;
      _this2.src = img.currentSrc || img.src;
      _this2.intrinsicWidth = img.naturalWidth;
      _this2.intrinsicHeight = img.naturalHeight;
      _this2.context.cache.addImage(_this2.src);
      return _this2;
    }
    return ImageElementContainer2;
  }(ElementContainer)
);
var CanvasElementContainer = (
  /** @class */
  function(_super) {
    __extends(CanvasElementContainer2, _super);
    function CanvasElementContainer2(context, canvas2) {
      var _this2 = _super.call(this, context, canvas2) || this;
      _this2.canvas = canvas2;
      _this2.intrinsicWidth = canvas2.width;
      _this2.intrinsicHeight = canvas2.height;
      return _this2;
    }
    return CanvasElementContainer2;
  }(ElementContainer)
);
var SVGElementContainer = (
  /** @class */
  function(_super) {
    __extends(SVGElementContainer2, _super);
    function SVGElementContainer2(context, img) {
      var _this2 = _super.call(this, context, img) || this;
      var s3 = new XMLSerializer();
      var bounds = parseBounds(context, img);
      img.setAttribute("width", bounds.width + "px");
      img.setAttribute("height", bounds.height + "px");
      _this2.svg = "data:image/svg+xml," + encodeURIComponent(s3.serializeToString(img));
      _this2.intrinsicWidth = img.width.baseVal.value;
      _this2.intrinsicHeight = img.height.baseVal.value;
      _this2.context.cache.addImage(_this2.svg);
      return _this2;
    }
    return SVGElementContainer2;
  }(ElementContainer)
);
var LIElementContainer = (
  /** @class */
  function(_super) {
    __extends(LIElementContainer2, _super);
    function LIElementContainer2(context, element) {
      var _this2 = _super.call(this, context, element) || this;
      _this2.value = element.value;
      return _this2;
    }
    return LIElementContainer2;
  }(ElementContainer)
);
var OLElementContainer = (
  /** @class */
  function(_super) {
    __extends(OLElementContainer2, _super);
    function OLElementContainer2(context, element) {
      var _this2 = _super.call(this, context, element) || this;
      _this2.start = element.start;
      _this2.reversed = typeof element.reversed === "boolean" && element.reversed === true;
      return _this2;
    }
    return OLElementContainer2;
  }(ElementContainer)
);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds$1(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds$1(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node) {
  var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("") : node.value;
  return value.length === 0 ? node.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = (
  /** @class */
  function(_super) {
    __extends(InputElementContainer2, _super);
    function InputElementContainer2(context, input) {
      var _this2 = _super.call(this, context, input) || this;
      _this2.type = input.type.toLowerCase();
      _this2.checked = input.checked;
      _this2.value = getInputValue(input);
      if (_this2.type === CHECKBOX || _this2.type === RADIO) {
        _this2.styles.backgroundColor = 3739148031;
        _this2.styles.borderTopColor = _this2.styles.borderRightColor = _this2.styles.borderBottomColor = _this2.styles.borderLeftColor = 2779096575;
        _this2.styles.borderTopWidth = _this2.styles.borderRightWidth = _this2.styles.borderBottomWidth = _this2.styles.borderLeftWidth = 1;
        _this2.styles.borderTopStyle = _this2.styles.borderRightStyle = _this2.styles.borderBottomStyle = _this2.styles.borderLeftStyle = 1;
        _this2.styles.backgroundClip = [
          0
          /* BORDER_BOX */
        ];
        _this2.styles.backgroundOrigin = [
          0
          /* BORDER_BOX */
        ];
        _this2.bounds = reformatInputBounds(_this2.bounds);
      }
      switch (_this2.type) {
        case CHECKBOX:
          _this2.styles.borderTopRightRadius = _this2.styles.borderTopLeftRadius = _this2.styles.borderBottomRightRadius = _this2.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          _this2.styles.borderTopRightRadius = _this2.styles.borderTopLeftRadius = _this2.styles.borderBottomRightRadius = _this2.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
          break;
      }
      return _this2;
    }
    return InputElementContainer2;
  }(ElementContainer)
);
var SelectElementContainer = (
  /** @class */
  function(_super) {
    __extends(SelectElementContainer2, _super);
    function SelectElementContainer2(context, element) {
      var _this2 = _super.call(this, context, element) || this;
      var option = element.options[element.selectedIndex || 0];
      _this2.value = option ? option.text || "" : "";
      return _this2;
    }
    return SelectElementContainer2;
  }(ElementContainer)
);
var TextareaElementContainer = (
  /** @class */
  function(_super) {
    __extends(TextareaElementContainer2, _super);
    function TextareaElementContainer2(context, element) {
      var _this2 = _super.call(this, context, element) || this;
      _this2.value = element.value;
      return _this2;
    }
    return TextareaElementContainer2;
  }(ElementContainer)
);
var IFrameElementContainer = (
  /** @class */
  function(_super) {
    __extends(IFrameElementContainer2, _super);
    function IFrameElementContainer2(context, iframe) {
      var _this2 = _super.call(this, context, iframe) || this;
      _this2.src = iframe.src;
      _this2.width = parseInt(iframe.width, 10) || 0;
      _this2.height = parseInt(iframe.height, 10) || 0;
      _this2.backgroundColor = _this2.styles.backgroundColor;
      try {
        if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
          _this2.tree = parseTree(context, iframe.contentWindow.document.documentElement);
          var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
          _this2.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this2.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
        }
      } catch (e3) {
      }
      return _this2;
    }
    return IFrameElementContainer2;
  }(ElementContainer)
);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node, parent, root2) {
  for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root2);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root2)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root2);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root2);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node, container, root2) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root2.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node) {
  return node.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node) {
  return node.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node) {
  return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node) {
  return node.tagName === "LI";
};
var isOLElement = function(node) {
  return node.tagName === "OL";
};
var isInputElement = function(node) {
  return node.tagName === "INPUT";
};
var isSVGElement = function(node) {
  return node.tagName === "svg";
};
var isBodyElement = function(node) {
  return node.tagName === "BODY";
};
var isCanvasElement = function(node) {
  return node.tagName === "CANVAS";
};
var isImageElement = function(node) {
  return node.tagName === "IMG";
};
var isIFrameElement = function(node) {
  return node.tagName === "IFRAME";
};
var isTextareaElement = function(node) {
  return node.tagName === "TEXTAREA";
};
var isSelectElement = function(node) {
  return node.tagName === "SELECT";
};
var isSlotElement = function(node) {
  return node.tagName === "SLOT";
};
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
var createAdditiveCounter = function(value, min2, max2, symbols, fallback, suffix) {
  if (value < min2 || value > max2) {
    return createCounterText(value, fallback, suffix.length > 0);
  }
  return symbols.integers.reduce(function(string, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string += symbols.values[index2];
    }
    return string;
  }, "") + suffix;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string = resolver(value) + string;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix) {
  if (suffix === void 0) {
    suffix = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix.length > 0);
  }
  var tmp2 = Math.abs(value);
  var string = suffix;
  if (tmp2 === 0) {
    return numbers[0] + string;
  }
  for (var digit = 0; tmp2 > 0 && digit <= 4; digit++) {
    var coefficient = tmp2 % 10;
    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }
    tmp2 = Math.floor(tmp2 / 10);
  }
  return (value < 0 ? negativeSign : "") + string;
};
var CHINESE_INFORMAL_MULTIPLIERS = "";
var CHINESE_FORMAL_MULTIPLIERS = "";
var JAPANESE_NEGATIVE = "";
var KOREAN_NEGATIVE = "";
var createCounterText = function(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "" + spaceSuffix;
    case 1:
      return "" + spaceSuffix;
    case 2:
      return "" + spaceSuffix;
    case 5:
      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string.length < 4 ? "0" + string : string;
    case 4:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "");
    case 24:
      return createCounterStyleFromSymbols(value, "");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var CacheStorage = (
  /** @class */
  function() {
    function CacheStorage2() {
    }
    CacheStorage2.getOrigin = function(url) {
      var link = CacheStorage2._link;
      if (!link) {
        return "about:blank";
      }
      link.href = url;
      link.href = link.href;
      return link.protocol + link.hostname + link.port;
    };
    CacheStorage2.isSameOrigin = function(src) {
      return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
    };
    CacheStorage2.setContext = function(window2) {
      CacheStorage2._link = window2.document.createElement("a");
      CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
    };
    CacheStorage2._origin = "about:blank";
    return CacheStorage2;
  }()
);
var Vector = (
  /** @class */
  function() {
    function Vector2(x2, y2) {
      this.type = 0;
      this.x = x2;
      this.y = y2;
    }
    Vector2.prototype.add = function(deltaX, deltaY) {
      return new Vector2(this.x + deltaX, this.y + deltaY);
    };
    return Vector2;
  }()
);
var lerp = function(a2, b2, t3) {
  return new Vector(a2.x + (b2.x - a2.x) * t3, a2.y + (b2.y - a2.y) * t3);
};
var BezierCurve = (
  /** @class */
  function() {
    function BezierCurve2(start, startControl, endControl, end) {
      this.type = 1;
      this.start = start;
      this.startControl = startControl;
      this.endControl = endControl;
      this.end = end;
    }
    BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
      var ab = lerp(this.start, this.startControl, t3);
      var bc = lerp(this.startControl, this.endControl, t3);
      var cd = lerp(this.endControl, this.end, t3);
      var abbc = lerp(ab, bc, t3);
      var bccd = lerp(bc, cd, t3);
      var dest = lerp(abbc, bccd, t3);
      return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
    };
    BezierCurve2.prototype.add = function(deltaX, deltaY) {
      return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
    };
    BezierCurve2.prototype.reverse = function() {
      return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
    };
    return BezierCurve2;
  }()
);
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = (
  /** @class */
  /* @__PURE__ */ function() {
    function BoundCurves2(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var _a3 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a3[0], tlv = _a3[1];
      var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
      var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
      var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
      var factors = [];
      factors.push((tlh + trh) / bounds.width);
      factors.push((blh + brh) / bounds.width);
      factors.push((tlv + blv) / bounds.height);
      factors.push((trv + brv) / bounds.height);
      var maxFactor = Math.max.apply(Math, factors);
      if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
      }
      var topWidth = bounds.width - trh;
      var rightHeight = bounds.height - brv;
      var bottomWidth = bounds.width - brh;
      var leftHeight = bounds.height - blv;
      var borderTopWidth2 = styles.borderTopWidth;
      var borderRightWidth2 = styles.borderRightWidth;
      var borderBottomWidth2 = styles.borderBottomWidth;
      var borderLeftWidth2 = styles.borderLeftWidth;
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
      this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
      this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
      this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
      this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
      this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
      this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
      this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
      this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
      this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    }
    return BoundCurves2;
  }()
);
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x2, y2, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x2 + r1;
  var ym = y2 + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function TransformEffect2(offsetX, offsetY, matrix3) {
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.matrix = matrix3;
      this.type = 0;
      this.target = 2 | 4;
    }
    return TransformEffect2;
  }()
);
var ClipEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function ClipEffect2(path, target) {
      this.path = path;
      this.target = target;
      this.type = 1;
    }
    return ClipEffect2;
  }()
);
var OpacityEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function OpacityEffect2(opacity2) {
      this.opacity = opacity2;
      this.type = 2;
      this.target = 2 | 4;
    }
    return OpacityEffect2;
  }()
);
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b2) {
  if (a2.length === b2.length) {
    return a2.some(function(v2, i2) {
      return v2 === b2[i2];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point2, index2) {
    switch (index2) {
      case 0:
        return point2.add(deltaX, deltaY);
      case 1:
        return point2.add(deltaX + deltaW, deltaY);
      case 2:
        return point2.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point2.add(deltaX, deltaY + deltaH);
    }
    return point2;
  });
};
var StackingContext = (
  /** @class */
  /* @__PURE__ */ function() {
    function StackingContext2(container) {
      this.element = container;
      this.inlineLevel = [];
      this.nonInlineLevel = [];
      this.negativeZIndex = [];
      this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
      this.positiveZIndex = [];
      this.nonPositionedFloats = [];
      this.nonPositionedInlineLevel = [];
    }
    return StackingContext2;
  }()
);
var ElementPaint = (
  /** @class */
  function() {
    function ElementPaint2(container, parent) {
      this.container = container;
      this.parent = parent;
      this.effects = [];
      this.curves = new BoundCurves(this.container);
      if (this.container.styles.opacity < 1) {
        this.effects.push(new OpacityEffect(this.container.styles.opacity));
      }
      if (this.container.styles.transform !== null) {
        var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
        var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
        var matrix3 = this.container.styles.transform;
        this.effects.push(new TransformEffect(offsetX, offsetY, matrix3));
      }
      if (this.container.styles.overflowX !== 0) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox2 = calculatePaddingBoxPath(this.curves);
        if (equalPath(borderBox, paddingBox2)) {
          this.effects.push(new ClipEffect(
            borderBox,
            2 | 4
            /* CONTENT */
          ));
        } else {
          this.effects.push(new ClipEffect(
            borderBox,
            2
            /* BACKGROUND_BORDERS */
          ));
          this.effects.push(new ClipEffect(
            paddingBox2,
            4
            /* CONTENT */
          ));
        }
      }
    }
    ElementPaint2.prototype.getEffects = function(target) {
      var inFlow = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1;
      var parent = this.parent;
      var effects = this.effects.slice(0);
      while (parent) {
        var croplessEffects = parent.effects.filter(function(effect) {
          return !isClipEffect(effect);
        });
        if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
          effects.unshift.apply(effects, croplessEffects);
          inFlow = [
            2,
            3
            /* FIXED */
          ].indexOf(parent.container.styles.position) === -1;
          if (parent.container.styles.overflowX !== 0) {
            var borderBox = calculateBorderBoxPath(parent.curves);
            var paddingBox2 = calculatePaddingBoxPath(parent.curves);
            if (!equalPath(borderBox, paddingBox2)) {
              effects.unshift(new ClipEffect(
                paddingBox2,
                2 | 4
                /* CONTENT */
              ));
            }
          }
        } else {
          effects.unshift.apply(effects, croplessEffects);
        }
        parent = parent.parent;
      }
      return effects.filter(function(effect) {
        return contains(effect.target, target);
      });
    };
    return ElementPaint2;
  }()
);
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(
      child.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    );
    var createsStackingContext2 = contains(
      child.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    );
    var paintContainer = new ElementPaint(child, parent);
    if (contains(
      child.styles.display,
      2048
      /* LIST_ITEM */
    )) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_12 = child.styles.zIndex.order;
        if (order_12 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current2, i2) {
            if (order_12 > current2.element.container.styles.zIndex.order) {
              index_1 = i2;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack);
        } else if (order_12 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current2, i2) {
            if (order_12 >= current2.element.container.styles.zIndex.order) {
              index_2 = i2 + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack);
        }
      }
      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    )) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i2 = 0; i2 < elements.length; i2++) {
    var item = elements[i2];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root2 = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root2, root2, listItems);
  processListItems(paintContainer.container, listItems);
  return root2;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token) {
  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size, _a3, bounds) {
  var intrinsicWidth = _a3[0], intrinsicHeight = _a3[1], intrinsicProportion = _a3[2];
  var first = size[0], second = size[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width2 = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width2 = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width2 !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width2 / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width2 = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width2 !== null && height !== null) {
    return [width2, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values2, index2) {
  var value = values2[index2];
  if (typeof value === "undefined") {
    return values2[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat, _a3, _b, backgroundPositioningArea, backgroundPaintingArea) {
  var x2 = _a3[0], y2 = _a3[1];
  var width2 = _b[0], height = _b[1];
  switch (repeat) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y2 + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = (
  /** @class */
  function() {
    function FontMetrics2(document2) {
      this._data = {};
      this._document = document2;
    }
    FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
      var container = this._document.createElement("div");
      var img = this._document.createElement("img");
      var span = this._document.createElement("span");
      var body = this._document.body;
      container.style.visibility = "hidden";
      container.style.fontFamily = fontFamily2;
      container.style.fontSize = fontSize2;
      container.style.margin = "0";
      container.style.padding = "0";
      container.style.whiteSpace = "nowrap";
      body.appendChild(container);
      img.src = SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = "0";
      img.style.padding = "0";
      img.style.verticalAlign = "baseline";
      span.style.fontFamily = fontFamily2;
      span.style.fontSize = fontSize2;
      span.style.margin = "0";
      span.style.padding = "0";
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = "normal";
      img.style.verticalAlign = "super";
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return { baseline, middle };
    };
    FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
      var key = fontFamily2 + " " + fontSize2;
      if (typeof this._data[key] === "undefined") {
        this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
      }
      return this._data[key];
    };
    return FontMetrics2;
  }()
);
var Renderer$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Renderer2(context, options) {
      this.context = context;
      this.options = options;
    }
    return Renderer2;
  }()
);
var MASK_OFFSET = 1e4;
(function(_super) {
  __extends(CanvasRenderer, _super);
  function CanvasRenderer(context, options) {
    var _this2 = _super.call(this, context, options) || this;
    _this2._activeEffects = [];
    _this2.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this2.ctx = _this2.canvas.getContext("2d");
    if (!options.canvas) {
      _this2.canvas.width = Math.floor(options.width * options.scale);
      _this2.canvas.height = Math.floor(options.height * options.scale);
      _this2.canvas.style.width = options.width + "px";
      _this2.canvas.style.height = options.height + "px";
    }
    _this2.fontMetrics = new FontMetrics(document);
    _this2.ctx.scale(_this2.options.scale, _this2.options.scale);
    _this2.ctx.translate(-options.x, -options.y);
    _this2.ctx.textBaseline = "bottom";
    _this2._activeEffects = [];
    _this2.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
    return _this2;
  }
  CanvasRenderer.prototype.applyEffects = function(effects) {
    var _this2 = this;
    while (this._activeEffects.length) {
      this.popEffect();
    }
    effects.forEach(function(effect) {
      return _this2.applyEffect(effect);
    });
  };
  CanvasRenderer.prototype.applyEffect = function(effect) {
    this.ctx.save();
    if (isOpacityEffect(effect)) {
      this.ctx.globalAlpha = effect.opacity;
    }
    if (isTransformEffect(effect)) {
      this.ctx.translate(effect.offsetX, effect.offsetY);
      this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
      this.ctx.translate(-effect.offsetX, -effect.offsetY);
    }
    if (isClipEffect(effect)) {
      this.path(effect.path);
      this.ctx.clip();
    }
    this._activeEffects.push(effect);
  };
  CanvasRenderer.prototype.popEffect = function() {
    this._activeEffects.pop();
    this.ctx.restore();
  };
  CanvasRenderer.prototype.renderStack = function(stack) {
    return __awaiter$q(this, void 0, void 0, function() {
      var styles;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            styles = stack.element.container.styles;
            if (!styles.isVisible()) return [3, 2];
            return [4, this.renderStackContent(stack)];
          case 1:
            _a3.sent();
            _a3.label = 2;
          case 2:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.renderNode = function(paint) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            if (contains(
              paint.container.flags,
              16
              /* DEBUG_RENDER */
            )) {
              debugger;
            }
            if (!paint.container.styles.isVisible()) return [3, 3];
            return [4, this.renderNodeBackgroundAndBorders(paint)];
          case 1:
            _a3.sent();
            return [4, this.renderNodeContent(paint)];
          case 2:
            _a3.sent();
            _a3.label = 3;
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
    var _this2 = this;
    if (letterSpacing2 === 0) {
      this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
    } else {
      var letters = segmentGraphemes(text.text);
      letters.reduce(function(left, letter) {
        _this2.ctx.fillText(letter, left, text.bounds.top + baseline);
        return left + _this2.ctx.measureText(letter).width;
      }, text.bounds.left);
    }
  };
  CanvasRenderer.prototype.createFontStyle = function(styles) {
    var fontVariant2 = styles.fontVariant.filter(function(variant) {
      return variant === "normal" || variant === "small-caps";
    }).join("");
    var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
    var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
    return [
      [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
      fontFamily2,
      fontSize2
    ];
  };
  CanvasRenderer.prototype.renderTextNode = function(text, styles) {
    return __awaiter$q(this, void 0, void 0, function() {
      var _a3, font, fontFamily2, fontSize2, _b, baseline, middle, paintOrder2;
      var _this2 = this;
      return __generator(this, function(_c) {
        _a3 = this.createFontStyle(styles), font = _a3[0], fontFamily2 = _a3[1], fontSize2 = _a3[2];
        this.ctx.font = font;
        this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
        this.ctx.textAlign = "left";
        this.ctx.textBaseline = "alphabetic";
        _b = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b.baseline, middle = _b.middle;
        paintOrder2 = styles.paintOrder;
        text.textBounds.forEach(function(text2) {
          paintOrder2.forEach(function(paintOrderLayer) {
            switch (paintOrderLayer) {
              case 0:
                _this2.ctx.fillStyle = asString(styles.color);
                _this2.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                var textShadows = styles.textShadow;
                if (textShadows.length && text2.text.trim().length) {
                  textShadows.slice(0).reverse().forEach(function(textShadow2) {
                    _this2.ctx.shadowColor = asString(textShadow2.color);
                    _this2.ctx.shadowOffsetX = textShadow2.offsetX.number * _this2.options.scale;
                    _this2.ctx.shadowOffsetY = textShadow2.offsetY.number * _this2.options.scale;
                    _this2.ctx.shadowBlur = textShadow2.blur.number;
                    _this2.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                  });
                  _this2.ctx.shadowColor = "";
                  _this2.ctx.shadowOffsetX = 0;
                  _this2.ctx.shadowOffsetY = 0;
                  _this2.ctx.shadowBlur = 0;
                }
                if (styles.textDecorationLine.length) {
                  _this2.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                  styles.textDecorationLine.forEach(function(textDecorationLine2) {
                    switch (textDecorationLine2) {
                      case 1:
                        _this2.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                        break;
                      case 2:
                        _this2.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                        break;
                      case 3:
                        _this2.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                        break;
                    }
                  });
                }
                break;
              case 1:
                if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                  _this2.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                  _this2.ctx.lineWidth = styles.webkitTextStrokeWidth;
                  _this2.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                  _this2.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                }
                _this2.ctx.strokeStyle = "";
                _this2.ctx.lineWidth = 0;
                _this2.ctx.lineJoin = "miter";
                break;
            }
          });
        });
        return [
          2
          /*return*/
        ];
      });
    });
  };
  CanvasRenderer.prototype.renderReplacedElement = function(container, curves, image2) {
    if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
      var box2 = contentBox(container);
      var path = calculatePaddingBoxPath(curves);
      this.path(path);
      this.ctx.save();
      this.ctx.clip();
      this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box2.left, box2.top, box2.width, box2.height);
      this.ctx.restore();
    }
  };
  CanvasRenderer.prototype.renderNodeContent = function(paint) {
    return __awaiter$q(this, void 0, void 0, function() {
      var container, curves, styles, _i, _a3, child, image2, image2, iframeRenderer, canvas2, size, _b, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            this.applyEffects(paint.getEffects(
              4
              /* CONTENT */
            ));
            container = paint.container;
            curves = paint.curves;
            styles = container.styles;
            _i = 0, _a3 = container.textNodes;
            _c.label = 1;
          case 1:
            if (!(_i < _a3.length)) return [3, 4];
            child = _a3[_i];
            return [4, this.renderTextNode(child, styles)];
          case 2:
            _c.sent();
            _c.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            if (!(container instanceof ImageElementContainer)) return [3, 8];
            _c.label = 5;
          case 5:
            _c.trys.push([5, 7, , 8]);
            return [4, this.context.cache.match(container.src)];
          case 6:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 8];
          case 7:
            _c.sent();
            this.context.logger.error("Error loading image " + container.src);
            return [3, 8];
          case 8:
            if (container instanceof CanvasElementContainer) {
              this.renderReplacedElement(container, curves, container.canvas);
            }
            if (!(container instanceof SVGElementContainer)) return [3, 12];
            _c.label = 9;
          case 9:
            _c.trys.push([9, 11, , 12]);
            return [4, this.context.cache.match(container.svg)];
          case 10:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 12];
          case 11:
            _c.sent();
            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
            return [3, 12];
          case 12:
            if (!(container instanceof IFrameElementContainer && container.tree)) return [3, 14];
            iframeRenderer = new CanvasRenderer(this.context, {
              scale: this.options.scale,
              backgroundColor: container.backgroundColor,
              x: 0,
              y: 0,
              width: container.width,
              height: container.height
            });
            return [4, iframeRenderer.render(container.tree)];
          case 13:
            canvas2 = _c.sent();
            if (container.width && container.height) {
              this.ctx.drawImage(canvas2, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
            }
            _c.label = 14;
          case 14:
            if (container instanceof InputElementContainer) {
              size = Math.min(container.bounds.width, container.bounds.height);
              if (container.type === CHECKBOX) {
                if (container.checked) {
                  this.ctx.save();
                  this.path([
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                    new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                    new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                    new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                    new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                    new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                  ]);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              } else if (container.type === RADIO) {
                if (container.checked) {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              }
            }
            if (isTextInputElement(container) && container.value.length) {
              _b = this.createFontStyle(styles), fontFamily2 = _b[0], fontSize2 = _b[1];
              baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
              bounds = contentBox(container);
              x2 = 0;
              switch (container.styles.textAlign) {
                case 1:
                  x2 += bounds.width / 2;
                  break;
                case 2:
                  x2 += bounds.width;
                  break;
              }
              textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
              this.ctx.save();
              this.path([
                new Vector(bounds.left, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                new Vector(bounds.left, bounds.top + bounds.height)
              ]);
              this.ctx.clip();
              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
              this.ctx.restore();
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = "left";
            }
            if (!contains(
              container.styles.display,
              2048
              /* LIST_ITEM */
            )) return [3, 20];
            if (!(container.styles.listStyleImage !== null)) return [3, 19];
            img = container.styles.listStyleImage;
            if (!(img.type === 0)) return [3, 18];
            image2 = void 0;
            url = img.url;
            _c.label = 15;
          case 15:
            _c.trys.push([15, 17, , 18]);
            return [4, this.context.cache.match(url)];
          case 16:
            image2 = _c.sent();
            this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
            return [3, 18];
          case 17:
            _c.sent();
            this.context.logger.error("Error loading list-style-image " + url);
            return [3, 18];
          case 18:
            return [3, 20];
          case 19:
            if (paint.listValue && container.styles.listStyleType !== -1) {
              fontFamily2 = this.createFontStyle(styles)[0];
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "middle";
              this.ctx.textAlign = "right";
              bounds = new Bounds$1(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
              this.ctx.textBaseline = "bottom";
              this.ctx.textAlign = "left";
            }
            _c.label = 20;
          case 20:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.renderStackContent = function(stack) {
    return __awaiter$q(this, void 0, void 0, function() {
      var _i, _a3, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
      return __generator(this, function(_p) {
        switch (_p.label) {
          case 0:
            if (contains(
              stack.element.container.flags,
              16
              /* DEBUG_RENDER */
            )) {
              debugger;
            }
            return [4, this.renderNodeBackgroundAndBorders(stack.element)];
          case 1:
            _p.sent();
            _i = 0, _a3 = stack.negativeZIndex;
            _p.label = 2;
          case 2:
            if (!(_i < _a3.length)) return [3, 5];
            child = _a3[_i];
            return [4, this.renderStack(child)];
          case 3:
            _p.sent();
            _p.label = 4;
          case 4:
            _i++;
            return [3, 2];
          case 5:
            return [4, this.renderNodeContent(stack.element)];
          case 6:
            _p.sent();
            _b = 0, _c = stack.nonInlineLevel;
            _p.label = 7;
          case 7:
            if (!(_b < _c.length)) return [3, 10];
            child = _c[_b];
            return [4, this.renderNode(child)];
          case 8:
            _p.sent();
            _p.label = 9;
          case 9:
            _b++;
            return [3, 7];
          case 10:
            _d = 0, _e = stack.nonPositionedFloats;
            _p.label = 11;
          case 11:
            if (!(_d < _e.length)) return [3, 14];
            child = _e[_d];
            return [4, this.renderStack(child)];
          case 12:
            _p.sent();
            _p.label = 13;
          case 13:
            _d++;
            return [3, 11];
          case 14:
            _f = 0, _g = stack.nonPositionedInlineLevel;
            _p.label = 15;
          case 15:
            if (!(_f < _g.length)) return [3, 18];
            child = _g[_f];
            return [4, this.renderStack(child)];
          case 16:
            _p.sent();
            _p.label = 17;
          case 17:
            _f++;
            return [3, 15];
          case 18:
            _h = 0, _j = stack.inlineLevel;
            _p.label = 19;
          case 19:
            if (!(_h < _j.length)) return [3, 22];
            child = _j[_h];
            return [4, this.renderNode(child)];
          case 20:
            _p.sent();
            _p.label = 21;
          case 21:
            _h++;
            return [3, 19];
          case 22:
            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
            _p.label = 23;
          case 23:
            if (!(_k < _l.length)) return [3, 26];
            child = _l[_k];
            return [4, this.renderStack(child)];
          case 24:
            _p.sent();
            _p.label = 25;
          case 25:
            _k++;
            return [3, 23];
          case 26:
            _m = 0, _o = stack.positiveZIndex;
            _p.label = 27;
          case 27:
            if (!(_m < _o.length)) return [3, 30];
            child = _o[_m];
            return [4, this.renderStack(child)];
          case 28:
            _p.sent();
            _p.label = 29;
          case 29:
            _m++;
            return [3, 27];
          case 30:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.mask = function(paths) {
    this.ctx.beginPath();
    this.ctx.moveTo(0, 0);
    this.ctx.lineTo(this.canvas.width, 0);
    this.ctx.lineTo(this.canvas.width, this.canvas.height);
    this.ctx.lineTo(0, this.canvas.height);
    this.ctx.lineTo(0, 0);
    this.formatPath(paths.slice(0).reverse());
    this.ctx.closePath();
  };
  CanvasRenderer.prototype.path = function(paths) {
    this.ctx.beginPath();
    this.formatPath(paths);
    this.ctx.closePath();
  };
  CanvasRenderer.prototype.formatPath = function(paths) {
    var _this2 = this;
    paths.forEach(function(point2, index2) {
      var start = isBezierCurve(point2) ? point2.start : point2;
      if (index2 === 0) {
        _this2.ctx.moveTo(start.x, start.y);
      } else {
        _this2.ctx.lineTo(start.x, start.y);
      }
      if (isBezierCurve(point2)) {
        _this2.ctx.bezierCurveTo(point2.startControl.x, point2.startControl.y, point2.endControl.x, point2.endControl.y, point2.end.x, point2.end.y);
      }
    });
  };
  CanvasRenderer.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
    this.path(path);
    this.ctx.fillStyle = pattern;
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
  };
  CanvasRenderer.prototype.resizeImage = function(image2, width2, height) {
    var _a3;
    if (image2.width === width2 && image2.height === height) {
      return image2;
    }
    var ownerDocument = (_a3 = this.canvas.ownerDocument) !== null && _a3 !== void 0 ? _a3 : document;
    var canvas2 = ownerDocument.createElement("canvas");
    canvas2.width = Math.max(1, width2);
    canvas2.height = Math.max(1, height);
    var ctx2 = canvas2.getContext("2d");
    ctx2.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width2, height);
    return canvas2;
  };
  CanvasRenderer.prototype.renderBackgroundImage = function(container) {
    return __awaiter$q(this, void 0, void 0, function() {
      var index2, _loop_1, this_1, _i, _a3, backgroundImage2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            index2 = container.styles.backgroundImage.length - 1;
            _loop_1 = function(backgroundImage3) {
              var image2, url, _c, path, x2, y2, width2, height, pattern, _d, path, x2, y2, width2, height, _e, lineLength, x0, x1, y0, y1, canvas2, ctx2, gradient_1, pattern, _f, path, left, top_1, width2, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
              return __generator(this, function(_h) {
                switch (_h.label) {
                  case 0:
                    if (!(backgroundImage3.type === 0)) return [3, 5];
                    image2 = void 0;
                    url = backgroundImage3.url;
                    _h.label = 1;
                  case 1:
                    _h.trys.push([1, 3, , 4]);
                    return [4, this_1.context.cache.match(url)];
                  case 2:
                    image2 = _h.sent();
                    return [3, 4];
                  case 3:
                    _h.sent();
                    this_1.context.logger.error("Error loading background-image " + url);
                    return [3, 4];
                  case 4:
                    if (image2) {
                      _c = calculateBackgroundRendering(container, index2, [
                        image2.width,
                        image2.height,
                        image2.width / image2.height
                      ]), path = _c[0], x2 = _c[1], y2 = _c[2], width2 = _c[3], height = _c[4];
                      pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width2, height), "repeat");
                      this_1.renderRepeat(path, pattern, x2, y2);
                    }
                    return [3, 6];
                  case 5:
                    if (isLinearGradient(backgroundImage3)) {
                      _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width2 = _d[3], height = _d[4];
                      _e = calculateGradientDirection(backgroundImage3.angle, width2, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                      canvas2 = document.createElement("canvas");
                      canvas2.width = width2;
                      canvas2.height = height;
                      ctx2 = canvas2.getContext("2d");
                      gradient_1 = ctx2.createLinearGradient(x0, y0, x1, y1);
                      processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                        return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                      });
                      ctx2.fillStyle = gradient_1;
                      ctx2.fillRect(0, 0, width2, height);
                      if (width2 > 0 && height > 0) {
                        pattern = this_1.ctx.createPattern(canvas2, "repeat");
                        this_1.renderRepeat(path, pattern, x2, y2);
                      }
                    } else if (isRadialGradient(backgroundImage3)) {
                      _f = calculateBackgroundRendering(container, index2, [
                        null,
                        null,
                        null
                      ]), path = _f[0], left = _f[1], top_1 = _f[2], width2 = _f[3], height = _f[4];
                      position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                      x2 = getAbsoluteValue(position2[0], width2);
                      y2 = getAbsoluteValue(position2[position2.length - 1], height);
                      _g = calculateRadius(backgroundImage3, x2, y2, width2, height), rx = _g[0], ry = _g[1];
                      if (rx > 0 && ry > 0) {
                        radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                        processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                          return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        this_1.path(path);
                        this_1.ctx.fillStyle = radialGradient_1;
                        if (rx !== ry) {
                          midX = container.bounds.left + 0.5 * container.bounds.width;
                          midY = container.bounds.top + 0.5 * container.bounds.height;
                          f2 = ry / rx;
                          invF = 1 / f2;
                          this_1.ctx.save();
                          this_1.ctx.translate(midX, midY);
                          this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                          this_1.ctx.translate(-midX, -midY);
                          this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width2, height * invF);
                          this_1.ctx.restore();
                        } else {
                          this_1.ctx.fill();
                        }
                      }
                    }
                    _h.label = 6;
                  case 6:
                    index2--;
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            this_1 = this;
            _i = 0, _a3 = container.styles.backgroundImage.slice(0).reverse();
            _b.label = 1;
          case 1:
            if (!(_i < _a3.length)) return [3, 4];
            backgroundImage2 = _a3[_i];
            return [5, _loop_1(backgroundImage2)];
          case 2:
            _b.sent();
            _b.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.renderSolidBorder = function(color2, side, curvePoints) {
    return __awaiter$q(this, void 0, void 0, function() {
      return __generator(this, function(_a3) {
        this.path(parsePathForBorder(curvePoints, side));
        this.ctx.fillStyle = asString(color2);
        this.ctx.fill();
        return [
          2
          /*return*/
        ];
      });
    });
  };
  CanvasRenderer.prototype.renderDoubleBorder = function(color2, width2, side, curvePoints) {
    return __awaiter$q(this, void 0, void 0, function() {
      var outerPaths, innerPaths;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            if (!(width2 < 3)) return [3, 2];
            return [4, this.renderSolidBorder(color2, side, curvePoints)];
          case 1:
            _a3.sent();
            return [
              2
              /*return*/
            ];
          case 2:
            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
            this.path(outerPaths);
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
            this.path(innerPaths);
            this.ctx.fill();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function(paint) {
    return __awaiter$q(this, void 0, void 0, function() {
      var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
      var _this2 = this;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            this.applyEffects(paint.getEffects(
              2
              /* BACKGROUND_BORDERS */
            ));
            styles = paint.container.styles;
            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
            borders = [
              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
            ];
            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
            if (!(hasBackground || styles.boxShadow.length)) return [3, 2];
            this.ctx.save();
            this.path(backgroundPaintingArea);
            this.ctx.clip();
            if (!isTransparent(styles.backgroundColor)) {
              this.ctx.fillStyle = asString(styles.backgroundColor);
              this.ctx.fill();
            }
            return [4, this.renderBackgroundImage(paint.container)];
          case 1:
            _a3.sent();
            this.ctx.restore();
            styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
              _this2.ctx.save();
              var borderBoxArea = calculateBorderBoxPath(paint.curves);
              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
              if (shadow.inset) {
                _this2.path(borderBoxArea);
                _this2.ctx.clip();
                _this2.mask(shadowPaintingArea);
              } else {
                _this2.mask(borderBoxArea);
                _this2.ctx.clip();
                _this2.path(shadowPaintingArea);
              }
              _this2.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
              _this2.ctx.shadowOffsetY = shadow.offsetY.number;
              _this2.ctx.shadowColor = asString(shadow.color);
              _this2.ctx.shadowBlur = shadow.blur.number;
              _this2.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
              _this2.ctx.fill();
              _this2.ctx.restore();
            });
            _a3.label = 2;
          case 2:
            side = 0;
            _i = 0, borders_1 = borders;
            _a3.label = 3;
          case 3:
            if (!(_i < borders_1.length)) return [3, 13];
            border = borders_1[_i];
            if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0)) return [3, 11];
            if (!(border.style === 2)) return [3, 5];
            return [4, this.renderDashedDottedBorder(
              border.color,
              border.width,
              side,
              paint.curves,
              2
              /* DASHED */
            )];
          case 4:
            _a3.sent();
            return [3, 11];
          case 5:
            if (!(border.style === 3)) return [3, 7];
            return [4, this.renderDashedDottedBorder(
              border.color,
              border.width,
              side,
              paint.curves,
              3
              /* DOTTED */
            )];
          case 6:
            _a3.sent();
            return [3, 11];
          case 7:
            if (!(border.style === 4)) return [3, 9];
            return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
          case 8:
            _a3.sent();
            return [3, 11];
          case 9:
            return [4, this.renderSolidBorder(border.color, side, paint.curves)];
          case 10:
            _a3.sent();
            _a3.label = 11;
          case 11:
            side++;
            _a3.label = 12;
          case 12:
            _i++;
            return [3, 3];
          case 13:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  CanvasRenderer.prototype.renderDashedDottedBorder = function(color2, width2, side, curvePoints, style) {
    return __awaiter$q(this, void 0, void 0, function() {
      var strokePaths, boxPaths, startX, startY, endX, endY, length2, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
      return __generator(this, function(_a3) {
        this.ctx.save();
        strokePaths = parsePathForBorderStroke(curvePoints, side);
        boxPaths = parsePathForBorder(curvePoints, side);
        if (style === 2) {
          this.path(boxPaths);
          this.ctx.clip();
        }
        if (isBezierCurve(boxPaths[0])) {
          startX = boxPaths[0].start.x;
          startY = boxPaths[0].start.y;
        } else {
          startX = boxPaths[0].x;
          startY = boxPaths[0].y;
        }
        if (isBezierCurve(boxPaths[1])) {
          endX = boxPaths[1].end.x;
          endY = boxPaths[1].end.y;
        } else {
          endX = boxPaths[1].x;
          endY = boxPaths[1].y;
        }
        if (side === 0 || side === 2) {
          length2 = Math.abs(startX - endX);
        } else {
          length2 = Math.abs(startY - endY);
        }
        this.ctx.beginPath();
        if (style === 3) {
          this.formatPath(strokePaths);
        } else {
          this.formatPath(boxPaths.slice(0, 2));
        }
        dashLength = width2 < 3 ? width2 * 3 : width2 * 2;
        spaceLength = width2 < 3 ? width2 * 2 : width2;
        if (style === 3) {
          dashLength = width2;
          spaceLength = width2;
        }
        useLineDash = true;
        if (length2 <= dashLength * 2) {
          useLineDash = false;
        } else if (length2 <= dashLength * 2 + spaceLength) {
          multiplier = length2 / (2 * dashLength + spaceLength);
          dashLength *= multiplier;
          spaceLength *= multiplier;
        } else {
          numberOfDashes = Math.floor((length2 + spaceLength) / (dashLength + spaceLength));
          minSpace = (length2 - numberOfDashes * dashLength) / (numberOfDashes - 1);
          maxSpace = (length2 - (numberOfDashes + 1) * dashLength) / numberOfDashes;
          spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
        }
        if (useLineDash) {
          if (style === 3) {
            this.ctx.setLineDash([0, dashLength + spaceLength]);
          } else {
            this.ctx.setLineDash([dashLength, spaceLength]);
          }
        }
        if (style === 3) {
          this.ctx.lineCap = "round";
          this.ctx.lineWidth = width2;
        } else {
          this.ctx.lineWidth = width2 * 2 + 1.1;
        }
        this.ctx.strokeStyle = asString(color2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        if (style === 2) {
          if (isBezierCurve(boxPaths[0])) {
            path1 = boxPaths[3];
            path2 = boxPaths[0];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
          if (isBezierCurve(boxPaths[1])) {
            path1 = boxPaths[1];
            path2 = boxPaths[2];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
        }
        this.ctx.restore();
        return [
          2
          /*return*/
        ];
      });
    });
  };
  CanvasRenderer.prototype.render = function(element) {
    return __awaiter$q(this, void 0, void 0, function() {
      var stack;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
            }
            stack = parseStackingContexts(element);
            return [4, this.renderStack(stack)];
          case 1:
            _a3.sent();
            this.applyEffects([]);
            return [2, this.canvas];
        }
      });
    });
  };
  return CanvasRenderer;
})(Renderer$1);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
(function(_super) {
  __extends(ForeignObjectRenderer, _super);
  function ForeignObjectRenderer(context, options) {
    var _this2 = _super.call(this, context, options) || this;
    _this2.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this2.ctx = _this2.canvas.getContext("2d");
    _this2.options = options;
    _this2.canvas.width = Math.floor(options.width * options.scale);
    _this2.canvas.height = Math.floor(options.height * options.scale);
    _this2.canvas.style.width = options.width + "px";
    _this2.canvas.style.height = options.height + "px";
    _this2.ctx.scale(_this2.options.scale, _this2.options.scale);
    _this2.ctx.translate(-options.x, -options.y);
    _this2.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
    return _this2;
  }
  ForeignObjectRenderer.prototype.render = function(element) {
    return __awaiter$q(this, void 0, void 0, function() {
      var svg, img;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
            return [4, loadSerializedSVG(svg)];
          case 1:
            img = _a3.sent();
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
            }
            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
            return [2, this.canvas];
        }
      });
    });
  };
  return ForeignObjectRenderer;
})(Renderer$1);
var loadSerializedSVG = function(svg) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      resolve(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
/*!
 * @antv/g
 * @description A core module for rendering engine implements DOM API.
 * @version 6.3.1
 * @date 12/24/2025, 11:55:39 AM
 * @author AntVis
 * @docs https://g.antv.antgroup.com/
 */
var AnimationEvent = /* @__PURE__ */ function(_FederatedEvent) {
  function AnimationEvent2(manager, target, currentTime, timelineTime) {
    var _this2;
    _classCallCheck(this, AnimationEvent2);
    _this2 = _callSuper(this, AnimationEvent2, [manager]);
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    _this2.target = target;
    _this2.type = "finish";
    _this2.bubbles = false;
    _this2.currentTarget = target;
    _this2.defaultPrevented = false;
    _this2.eventPhase = _this2.AT_TARGET;
    _this2.timeStamp = Date.now();
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    return _this2;
  }
  _inherits(AnimationEvent2, _FederatedEvent);
  return _createClass(AnimationEvent2);
}(FederatedEvent);
var sequenceNumber = 0;
var Animation$1 = /* @__PURE__ */ function() {
  function Animation2(effect, timeline) {
    var _this$effect;
    _classCallCheck(this, Animation2);
    this.currentTimePending = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._playbackRate = 1;
    this._inTimeline = true;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "".concat(sequenceNumber++);
    this._inEffect = !!this.effect.update(0);
    this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = "idle";
    this.updatePromises();
  }
  return _createClass(Animation2, [{
    key: "pending",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get2() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    )
  }, {
    key: "playState",
    get: function get2() {
      if (this._idle) return "idle";
      if (this._isFinished) return "finished";
      if (this._paused) return "paused";
      return "running";
    }
    /**
     * record previos state
     */
  }, {
    key: "ready",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get2() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
  }, {
    key: "finished",
    get: function get2() {
      var _this2 = this;
      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }
        this.finishedPromise = new Promise(function(resolve, reject) {
          _this2.resolveFinishedPromise = function() {
            resolve(_this2);
          };
          _this2.rejectFinishedPromise = function() {
            reject(new Error());
          };
        });
        if (this.playState === "finished") {
          this.resolveFinishedPromise();
        }
      }
      return this.finishedPromise;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
     */
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
     */
    /**
     * get called after each frame when running
     */
  }, {
    key: "currentTime",
    get: function get2() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set2(newTime) {
      newTime = Number(newTime);
      if (isNaN(newTime)) return;
      this.timeline.restart();
      if (!this._paused && this._startTime !== null) {
        var _this$timeline;
        this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
      }
      this.currentTimePending = false;
      if (this._currentTime === newTime) {
        return;
      }
      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }
      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
     */
  }, {
    key: "startTime",
    get: function get2() {
      return this._startTime;
    },
    set: function set2(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        if (this._paused || this._idle) return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }
  }, {
    key: "playbackRate",
    get: function get2() {
      return this._playbackRate;
    },
    set: function set2(value) {
      if (value === this._playbackRate) {
        return;
      }
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value;
      this.startTime = null;
      if (this.playState !== "paused" && this.playState !== "idle") {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
  }, {
    key: "_isFinished",
    get: function get2() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    }
  }, {
    key: "totalDuration",
    get: function get2() {
      return this._totalDuration;
    }
  }, {
    key: "_needsTick",
    get: function get2() {
      return this.pending || this.playState === "running" || !this._finishedFlag;
    }
  }, {
    key: "updatePromises",
    value: function updatePromises() {
      var _this$effect$target;
      if ((_this$effect$target = this.effect.target) !== null && _this$effect$target !== void 0 && _this$effect$target.destroyed) {
        this.readyPromise = void 0;
        this.finishedPromise = void 0;
        return false;
      }
      var oldPlayState = this.oldPlayState;
      var newPlayState = this.pending ? "pending" : this.playState;
      if (this.readyPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectReadyPromise();
          this.readyPromise = void 0;
        } else if (oldPlayState === "pending") {
          this.resolveReadyPromise();
        } else if (newPlayState === "pending") {
          this.readyPromise = void 0;
        }
      }
      if (this.finishedPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectFinishedPromise();
          this.finishedPromise = void 0;
        } else if (newPlayState === "finished") {
          this.resolveFinishedPromise();
        } else if (oldPlayState === "finished") {
          this.finishedPromise = void 0;
        }
      }
      this.oldPlayState = newPlayState;
      return this.readyPromise || this.finishedPromise;
    }
  }, {
    key: "play",
    value: function play() {
      this.updatePromises();
      this._paused = false;
      if (this._isFinished || this._idle) {
        this.rewind();
        this._startTime = null;
      }
      this._finishedFlag = false;
      this._idle = false;
      this.ensureAlive();
      this.timeline.applyDirtiedAnimation(this);
      if (this.timeline.animations.indexOf(this) === -1) {
        this.timeline.animations.push(this);
      }
      this.updatePromises();
    }
  }, {
    key: "pause",
    value: function pause() {
      this.updatePromises();
      if (this.currentTime) {
        this._holdTime = this.currentTime;
      }
      if (!this._isFinished && !this._paused && !this._idle) {
        this.currentTimePending = true;
      } else if (this._idle) {
        this.rewind();
        this._idle = false;
      }
      this._startTime = null;
      this._paused = true;
      this.updatePromises();
    }
  }, {
    key: "finish",
    value: function finish() {
      this.updatePromises();
      if (this._idle) return;
      this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      this._startTime = this._totalDuration - this.currentTime;
      this.currentTimePending = false;
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _this3 = this;
      this.updatePromises();
      if (!this._inEffect) return;
      this._inEffect = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = null;
      this._startTime = null;
      this.effect.update(null);
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
      if (this.oncancel) {
        var event = new AnimationEvent(null, this, this.currentTime, null);
        setTimeout(function() {
          _this3.oncancel(event);
        });
      }
    }
  }, {
    key: "reverse",
    value: function reverse() {
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this.playbackRate *= -1;
      this.play();
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
     */
  }, {
    key: "updatePlaybackRate",
    value: function updatePlaybackRate(playbackRate) {
      this.playbackRate = playbackRate;
    }
  }, {
    key: "targetAnimations",
    value: function targetAnimations() {
      var _this$effect2;
      var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
      return target.getAnimations();
    }
  }, {
    key: "markTarget",
    value: function markTarget() {
      var animations = this.targetAnimations();
      if (animations.indexOf(this) === -1) {
        animations.push(this);
      }
    }
  }, {
    key: "unmarkTarget",
    value: function unmarkTarget() {
      var animations = this.targetAnimations();
      var index2 = animations.indexOf(this);
      if (index2 !== -1) {
        animations.splice(index2, 1);
      }
    }
  }, {
    key: "tick",
    value: function tick2(timelineTime, isAnimationFrame) {
      if (!this._idle && !this._paused) {
        if (this._startTime === null) {
          if (isAnimationFrame) {
            this.startTime = timelineTime - this._currentTime / this.playbackRate;
          }
        } else if (!this._isFinished) {
          this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
        }
      }
      if (isAnimationFrame) {
        this.currentTimePending = false;
        this.fireEvents(timelineTime);
      }
    }
  }, {
    key: "rewind",
    value: function rewind() {
      if (this.playbackRate >= 0) {
        this.currentTime = 0;
      } else if (this._totalDuration < Infinity) {
        this.currentTime = this._totalDuration;
      } else {
        throw new Error("Unable to rewind negative playback rate animation with infinite duration");
      }
    }
  }, {
    key: "persist",
    value: function persist() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "commitStyles",
    value: (
      // replaceState: AnimationReplaceState;
      function commitStyles() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    )
  }, {
    key: "ensureAlive",
    value: function ensureAlive() {
      if (this.playbackRate < 0 && this.currentTime === 0) {
        var _this$effect3;
        this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
      } else {
        var _this$effect4;
        this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
      }
      if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
        this._inTimeline = true;
        this.timeline.animations.push(this);
      }
    }
  }, {
    key: "tickCurrentTime",
    value: function tickCurrentTime(newTime, ignoreLimit) {
      if (newTime !== this._currentTime) {
        this._currentTime = newTime;
        if (this._isFinished && !ignoreLimit) {
          this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        }
        this.ensureAlive();
      }
    }
  }, {
    key: "fireEvents",
    value: function fireEvents(baseTime) {
      var _this4 = this;
      if (this._isFinished) {
        if (!this._finishedFlag) {
          if (this.onfinish) {
            var event = new AnimationEvent(null, this, this.currentTime, baseTime);
            setTimeout(function() {
              if (_this4.onfinish) {
                _this4.onfinish(event);
              }
            });
          }
          this._finishedFlag = true;
        }
      } else {
        if (this.onframe && this.playState === "running") {
          var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
          this.onframe(_event);
        }
        this._finishedFlag = false;
      }
    }
  }]);
}();
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A$1 = function A(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B$1 = function B(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C$1 = function C(aA1) {
  return 3 * aA1;
};
var calcBezier = function calcBezier2(aT, aA1, aA2) {
  return ((A$1(aA1, aA2) * aT + B$1(aA1, aA2)) * aT + C$1(aA1)) * aT;
};
var getSlope = function getSlope2(aT, aA1, aA2) {
  return 3 * A$1(aA1, aA2) * aT * aT + 2 * B$1(aA1, aA2) * aT + C$1(aA1);
};
var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i2 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) aB = currentT;
    else aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
  for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier = function bezier2(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2) return function(t3) {
    return t3;
  };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function getTForX2(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
    --currentSample;
    var dist2 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist2 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    if (initialSlope === 0) return guessForT;
    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
  };
  return function(t3) {
    if (t3 === 0 || t3 === 1) return t3;
    return calcBezier(getTForX(t3), mY1, mY2);
  };
};
var convertToDash = function convertToDash2(str2) {
  str2 = str2.replace(/([A-Z])/g, function(letter) {
    return "-".concat(letter.toLowerCase());
  });
  return str2.charAt(0) === "-" ? str2.substring(1) : str2;
};
var Quad$2 = function Quad(t3) {
  return Math.pow(t3, 2);
};
var Cubic$1 = function Cubic(t3) {
  return Math.pow(t3, 3);
};
var Quart = function Quart2(t3) {
  return Math.pow(t3, 4);
};
var Quint = function Quint2(t3) {
  return Math.pow(t3, 5);
};
var Expo = function Expo2(t3) {
  return Math.pow(t3, 6);
};
var Sine = function Sine2(t3) {
  return 1 - Math.cos(t3 * Math.PI / 2);
};
var Circ = function Circ2(t3) {
  return 1 - Math.sqrt(1 - t3 * t3);
};
var Back = function Back2(t3) {
  return t3 * t3 * (3 * t3 - 2);
};
var Bounce = function Bounce2(t3) {
  var pow2;
  var b2 = 4;
  while (t3 < ((pow2 = Math.pow(2, --b2)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b2) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t3, 2);
};
var Elastic = function Elastic2(t3) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params = _slicedToArray(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
  var a2 = clamp$1(Number(amplitude), 1, 10);
  var p2 = clamp$1(Number(period), 0.1, 2);
  if (t3 === 0 || t3 === 1) return t3;
  return -a2 * Math.pow(2, 10 * (t3 - 1)) * Math.sin((t3 - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a2)) * (Math.PI * 2) / p2);
};
var Spring = function Spring2(t3) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var duration2 = arguments.length > 2 ? arguments[2] : void 0;
  var _params2 = _slicedToArray(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
  mass = clamp$1(mass, 0.1, 1e3);
  stiffness = clamp$1(stiffness, 0.1, 1e3);
  damping = clamp$1(damping, 0.1, 1e3);
  velocity = clamp$1(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a2 = 1;
  var b2 = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration2 ? duration2 * t3 / 1e3 : t3;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a2 * Math.cos(wd * progress) + b2 * Math.sin(wd * progress));
  } else {
    progress = (a2 + b2 * progress) * Math.exp(-progress * w0);
  }
  if (t3 === 0 || t3 === 1) return t3;
  return 1 - progress;
};
var Steps = function Steps2(t3) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _ref = params, _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
  var trunc = type === "start" ? Math.ceil : Math.floor;
  return trunc(clamp$1(t3, 0, 1) * steps) / steps;
};
var Bezier = function Bezier2(t3) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params3 = _slicedToArray(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
  return bezier(mX1, mY1, mX2, mY2)(t3);
};
var easein = bezier(0.42, 0, 1, 1);
var EaseOut = function EaseOut2(ease2) {
  return function(t3) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration2 = arguments.length > 2 ? arguments[2] : void 0;
    return 1 - ease2(1 - t3, params, duration2);
  };
};
var EaseInOut = function EaseInOut2(ease2) {
  return function(t3) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration2 = arguments.length > 2 ? arguments[2] : void 0;
    return t3 < 0.5 ? ease2(t3 * 2, params, duration2) / 2 : 1 - ease2(t3 * -2 + 2, params, duration2) / 2;
  };
};
var EaseOutIn = function EaseOutIn2(ease2) {
  return function(t3) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration2 = arguments.length > 2 ? arguments[2] : void 0;
    return t3 < 0.5 ? (1 - ease2(1 - t3 * 2, params, duration2)) / 2 : (ease2(t3 * 2 - 1, params, duration2) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function stepStart(t3) {
    return Steps(t3, [1, "start"]);
  },
  "step-end": function stepEnd(t3) {
    return Steps(t3, [1, "end"]);
  },
  linear: function linear(t3) {
    return t3;
  },
  "cubic-bezier": Bezier,
  ease: function ease(t3) {
    return Bezier(t3, [0.25, 0.1, 0.25, 1]);
  },
  "in": easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad$2,
  "out-quad": EaseOut(Quad$2),
  "in-out-quad": EaseInOut(Quad$2),
  "out-in-quad": EaseOutIn(Quad$2),
  "in-cubic": Cubic$1,
  "out-cubic": EaseOut(Cubic$1),
  "in-out-cubic": EaseInOut(Cubic$1),
  "out-in-cubic": EaseOutIn(Cubic$1),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function complexEasingSyntax2(ease2) {
  return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function getEasingFunction2(ease2) {
  return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
};
var linear$1 = function linear2(x2) {
  return x2;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count, pos) {
  return function(x2) {
    if (x2 >= 1) {
      return 1;
    }
    var stepSize = 1 / count;
    x2 += pos * stepSize;
    return x2 - x2 % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(".concat(numberString, ",").concat(numberString, ",").concat(numberString, ",").concat(numberString, "\\)"));
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier.apply(void 0, _toConsumableArray(cubicData.slice(1).map(Number)));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _timing$iterations;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both") return 0;
      return null;
    case PhaseActive:
      return localTime - delay;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both") return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d3 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d3 += 1;
    }
    currentDirection = "normal";
    if (d3 !== Infinity && d3 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null) return null;
  var duration2 = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration2, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration2);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
        target2.setAttribute(
          interpolation.property,
          interpolation.interpolation(scaledLocalTime),
          false,
          false
          // disable memoize
        );
      });
    } else {
      for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord(property)) {
        target2.setAttribute(property, null);
      }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i2 = 0; i2 < keyframes.length; i2++) {
    for (var member in keyframes[i2]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i2].offset,
          computedOffset: keyframes[i2].computedOffset,
          easing: keyframes[i2].easing,
          easingFunction: parseEasingFunction(keyframes[i2].easing) || timing.easingFunction,
          value: keyframes[i2][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i2 = 0; i2 < keyframes.length - 1; i2++) {
      var startIndex = i2;
      var endIndex = i2 + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i2 === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i2 === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
  return function(f2) {
    var interpolated = interpolate$1(from, to, f2);
    return isNumber(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property, left, right, target) {
  var metadata = propertyMetadataCache[property];
  if (metadata && metadata.syntax && metadata["int"]) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var parser2 = propertyHandler.parser;
      var usedLeft = parser2 ? parser2(left, target) : left;
      var usedRight = parser2 ? parser2(right, target) : right;
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp = InterpolationFactory.apply(void 0, _toConsumableArray(interpolationArgs));
        return function(t3) {
          if (t3 === 0) return left;
          if (t3 === 1) return right;
          return interp(t3);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right : left;
  });
}
function interpolate$1(from, to, f2) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f2) + to * f2;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f2 < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    var fromLength = from.length;
    var toLength = to.length;
    var length2 = Math.max(fromLength, toLength);
    var r2 = [];
    for (var i2 = 0; i2 < length2; i2++) {
      r2.push(interpolate$1(from[i2 < fromLength ? i2 : fromLength - 1], to[i2 < toLength ? i2 : toLength - 1], f2));
    }
    return r2;
  }
  throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
}
var AnimationEffectTiming = /* @__PURE__ */ function() {
  function AnimationEffectTiming2() {
    _classCallCheck(this, AnimationEffectTiming2);
    this.delay = 0;
    this.direction = "normal";
    this.duration = "auto";
    this._easing = "linear";
    this.easingFunction = linear$1;
    this.endDelay = 0;
    this.fill = "auto";
    this.iterationStart = 0;
    this.iterations = 1;
    this.currentIteration = null;
    this.progress = null;
  }
  return _createClass(AnimationEffectTiming2, [{
    key: "easing",
    get: function get2() {
      return this._easing;
    },
    set: function set2(value) {
      this.easingFunction = parseEasingFunction(value);
      this._easing = value;
    }
  }]);
}();
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property in effectInput) {
    if (property in ["easing", "offset", "composite"]) {
      continue;
    }
    var values2 = effectInput[property];
    if (!Array.isArray(values2)) {
      values2 = [values2];
    }
    var numKeyframes = values2.length;
    for (var i2 = 0; i2 < numKeyframes; i2++) {
      if (!normalizedEffectInput[i2]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i2] = keyframe;
      }
      if (values2[i2] !== void 0 && values2[i2] !== null) {
        normalizedEffectInput[i2][property] = values2[i2];
      }
    }
  }
  normalizedEffectInput.sort(function(a2, b2) {
    return (a2.computedOffset || 0) - (b2.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing !== null && timing !== void 0 && timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue)) throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1) throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error("".concat(memberValue, " compositing is not supported"));
        }
      } else ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i2 = 0; i2 < keyframes.length; i2++) {
    var offset = keyframes[i2].offset;
    if (!isNil(offset)) {
      if (offset < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _keyframes$offset;
    var _keyframes = keyframes, length2 = _keyframes.length;
    keyframes[length2 - 1].computedOffset = Number((_keyframes$offset = keyframes[length2 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
    if (length2 > 1) {
      var _keyframes$0$offset;
      keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var _i = 1; _i < length2; _i++) {
      var _offset = keyframes[_i].computedOffset;
      if (!isNil(_offset) && !isNil(previousOffset2)) {
        for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
        previousIndex = _i;
        previousOffset2 = Number(_offset);
      }
    }
  }
  if (!everyFrameHasOffset) spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property) {
      if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
        if (typeof timing[property] === "number" || property === "duration") {
          if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
            return;
          }
        }
        if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
          return;
        }
        if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
          return;
        }
        timing[property] = timingInput[property];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : {
    duration: "auto"
  });
  return makeTiming(timingInput);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = {
        duration: "auto"
      };
    } else {
      timingInput = {
        duration: timingInput
      };
    }
  }
  return timingInput;
}
var KeyframeEffect = /* @__PURE__ */ function() {
  function KeyframeEffect2(target, effectInput, timingInput) {
    var _this2 = this;
    _classCallCheck(this, KeyframeEffect2);
    this.composite = "replace";
    this.iterationComposite = "replace";
    this.target = target;
    this.timing = normalizeTimingInput(timingInput);
    this.timing.effect = this;
    this.timing.activeDuration = calculateActiveDuration(this.timing);
    this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
    this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
    this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
    var Proxy2 = runtime.globalThis.Proxy;
    this.computedTiming = Proxy2 ? new Proxy2(this.timing, {
      get: function get2(target2, prop) {
        if (prop === "duration") {
          return target2.duration === "auto" ? 0 : target2.duration;
        }
        if (prop === "fill") {
          return target2.fill === "auto" ? "none" : target2.fill;
        }
        if (prop === "localTime") {
          return _this2.animation && _this2.animation.currentTime || null;
        }
        if (prop === "currentIteration") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.currentIteration || 0;
        }
        if (prop === "progress") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.progress || 0;
        }
        return target2[prop];
      },
      set: function set2() {
        return true;
      }
    }) : this.timing;
  }
  return _createClass(KeyframeEffect2, [{
    key: "applyInterpolations",
    value: function applyInterpolations() {
      this.interpolations(this.target, Number(this.timeFraction));
    }
  }, {
    key: "update",
    value: function update(localTime) {
      if (localTime === null) {
        return false;
      }
      this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
      return this.timeFraction !== null;
    }
  }, {
    key: "getKeyframes",
    value: function getKeyframes() {
      return this.normalizedKeyframes;
    }
  }, {
    key: "setKeyframes",
    value: function setKeyframes(keyframes) {
      this.normalizedKeyframes = normalizeKeyframes(keyframes);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
     */
  }, {
    key: "getComputedTiming",
    value: function getComputedTiming() {
      return this.computedTiming;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
     */
  }, {
    key: "getTiming",
    value: function getTiming() {
      return this.timing;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
     */
  }, {
    key: "updateTiming",
    value: function updateTiming(timing) {
      var _this2 = this;
      Object.keys(timing || {}).forEach(function(name) {
        _this2.timing[name] = timing[name];
      });
    }
  }]);
}();
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = /* @__PURE__ */ function() {
  function AnimationTimeline2(document2) {
    var _this2 = this;
    _classCallCheck(this, AnimationTimeline2);
    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];
    this.webAnimationsNextTick = function(t3) {
      _this2.currentTime = t3;
      _this2.discardAnimations();
      if (_this2.animations.length === 0) {
        _this2.timelineTicking = false;
      } else {
        _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
      }
    };
    this.processRafCallbacks = function(t3) {
      var processing = _this2.rafCallbacks;
      _this2.rafCallbacks = [];
      if (t3 < Number(_this2.currentTime)) t3 = Number(_this2.currentTime);
      _this2.animations.sort(compareAnimations);
      _this2.animations = _this2.tick(t3, true, _this2.animations)[0];
      processing.forEach(function(entry) {
        entry[1](t3);
      });
      _this2.applyPendingEffects();
    };
    this.document = document2;
  }
  return _createClass(AnimationTimeline2, [{
    key: "getAnimations",
    value: function getAnimations() {
      this.discardAnimations();
      return this.animations.slice();
    }
  }, {
    key: "isTicking",
    value: function isTicking() {
      return this.inTick;
    }
  }, {
    key: "play",
    value: function play(target, keyframes, options) {
      var effect = new KeyframeEffect(target, keyframes, options);
      var animation = new Animation$1(effect, this);
      this.animations.push(animation);
      this.restartWebAnimationsNextTick();
      animation.updatePromises();
      animation.play();
      animation.updatePromises();
      return animation;
    }
    // RAF is supposed to be the last script to occur before frame rendering but not
    // all browsers behave like this. This function is for synchonously updating an
    // animation's effects whenever its state is mutated by script to work around
    // incorrect script execution ordering by the browser.
  }, {
    key: "applyDirtiedAnimation",
    value: function applyDirtiedAnimation(animation) {
      var _this2 = this;
      if (this.inTick) {
        return;
      }
      animation.markTarget();
      var animations = animation.targetAnimations();
      animations.sort(compareAnimations);
      var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
      inactiveAnimations.forEach(function(animation2) {
        var index2 = _this2.animations.indexOf(animation2);
        if (index2 !== -1) {
          _this2.animations.splice(index2, 1);
        }
      });
      this.applyPendingEffects();
    }
  }, {
    key: "restart",
    value: function restart() {
      if (!this.ticking) {
        this.ticking = true;
        this.requestAnimationFrame(function() {
        });
        this.hasRestartedThisFrame = true;
      }
      return this.hasRestartedThisFrame;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.document.defaultView.cancelAnimationFrame(this.frameId);
    }
  }, {
    key: "applyPendingEffects",
    value: function applyPendingEffects() {
      this.pendingEffects.forEach(function(effect) {
        effect === null || effect === void 0 || effect.applyInterpolations();
      });
      this.pendingEffects = [];
    }
  }, {
    key: "updateAnimationsPromises",
    value: function updateAnimationsPromises() {
      this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
        return animation.updatePromises();
      });
    }
  }, {
    key: "discardAnimations",
    value: function discardAnimations() {
      this.updateAnimationsPromises();
      this.animations = this.animations.filter(function(animation) {
        return animation.playState !== "finished" && animation.playState !== "idle";
      });
    }
  }, {
    key: "restartWebAnimationsNextTick",
    value: function restartWebAnimationsNextTick() {
      if (!this.timelineTicking) {
        this.timelineTicking = true;
        this.requestAnimationFrame(this.webAnimationsNextTick);
      }
    }
  }, {
    key: "rAF",
    value: function rAF(f2) {
      var id2 = this.rafId++;
      if (this.rafCallbacks.length === 0) {
        this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
      }
      this.rafCallbacks.push([id2, f2]);
      return id2;
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame(f2) {
      var _this3 = this;
      return this.rAF(function(x2) {
        _this3.updateAnimationsPromises();
        f2(x2);
        _this3.updateAnimationsPromises();
      });
    }
  }, {
    key: "tick",
    value: function tick2(t3, isAnimationFrame, updatingAnimations) {
      var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
      this.inTick = true;
      this.hasRestartedThisFrame = false;
      this.currentTime = t3;
      this.ticking = false;
      var newPendingClears = [];
      var newPendingEffects = [];
      var activeAnimations = [];
      var inactiveAnimations = [];
      updatingAnimations.forEach(function(animation) {
        animation.tick(t3, isAnimationFrame);
        if (!animation._inEffect) {
          newPendingClears.push(animation.effect);
          animation.unmarkTarget();
        } else {
          newPendingEffects.push(animation.effect);
          animation.markTarget();
        }
        if (animation._needsTick) _this4.ticking = true;
        var alive = animation._inEffect || animation._needsTick;
        animation._inTimeline = alive;
        if (alive) {
          activeAnimations.push(animation);
        } else {
          inactiveAnimations.push(animation);
        }
      });
      (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
      (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
      if (this.ticking) this.requestAnimationFrame(function() {
      });
      this.inTick = false;
      return [activeAnimations, inactiveAnimations];
    }
  }]);
}();
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;
var AdvancedCamera = /* @__PURE__ */ function(_Camera) {
  function AdvancedCamera2() {
    var _this2;
    _classCallCheck(this, AdvancedCamera2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, AdvancedCamera2, [].concat(args));
    _this2.landmarks = [];
    return _this2;
  }
  _inherits(AdvancedCamera2, _Camera);
  return _createClass(AdvancedCamera2, [{
    key: "rotate",
    value: (
      /**
       * Changes the azimuth and elevation with respect to the current camera axes
       * @param {Number} azimuth the relative azimuth
       * @param {Number} elevation the relative elevation
       * @param {Number} roll the relative roll
       */
      function rotate3(azimuth, elevation, roll) {
        this.relElevation = getAngle$1(elevation);
        this.relAzimuth = getAngle$1(azimuth);
        this.relRoll = getAngle$1(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        if (this.type === CameraType.EXPLORING) {
          var rotX = setAxisAngle(create$2(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
          var rotY = setAxisAngle(create$2(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
          var rotZ = setAxisAngle(create$2(), [0, 0, 1], deg2rad(this.relRoll));
          var rotQ = multiply$1(create$2(), rotY, rotX);
          rotQ = multiply$1(create$2(), rotQ, rotZ);
          var rotMatrix = fromQuat(create$5(), rotQ);
          translate(this.matrix, this.matrix, [0, 0, -this.distance]);
          multiply$3(this.matrix, this.matrix, rotMatrix);
          translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else {
          if (Math.abs(this.elevation) > 90) {
            return this;
          }
          this.computeMatrix();
        }
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this._update();
        return this;
      }
    )
    /**
     * (right) & (up)
     */
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = clone$2(this.position);
      add$5(pos, pos, scale$2(create$4(), this.right, coords[0]));
      add$5(pos, pos, scale$2(create$4(), this.up, coords[1]));
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
    /**
     *  n 
     */
  }, {
    key: "dolly",
    value: function dolly(value) {
      var n2 = this.forward;
      var pos = clone$2(this.position);
      var step2 = value * this.dollyingStep;
      var updatedDistance = this.distance + value * this.dollyingStep;
      step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
      pos[0] += step2 * n2[0];
      pos[1] += step2 * n2[1];
      pos[2] += step2 * n2[2];
      this._setPosition(pos);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getDistance();
      } else if (this.type === CameraType.TRACKING) {
        add$5(this.focalPoint, pos, this.distanceVector);
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      if (this.landmarkAnimationID !== void 0) {
        this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
      }
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name) {
      var _position$, _position$2, _focalPoint$, _focalPoint$2;
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _params$position = params.position, position2 = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
      var camera = new runtime.CameraContribution();
      camera.setType(this.type, void 0);
      camera.setPosition(position2[0], (_position$ = position2[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position2[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
      camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
      camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
      camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
      var landmark = {
        name,
        matrix: clone$3(camera.getWorldTransform()),
        right: clone$2(camera.right),
        up: clone$2(camera.up),
        forward: clone$2(camera.forward),
        position: clone$2(camera.getPosition()),
        focalPoint: clone$2(camera.getFocalPoint()),
        distanceVector: clone$2(camera.getDistanceVector()),
        distance: camera.getDistance(),
        dollyingStep: camera.getDollyingStep(),
        azimuth: camera.getAzimuth(),
        elevation: camera.getElevation(),
        roll: camera.getRoll(),
        relAzimuth: camera.relAzimuth,
        relElevation: camera.relElevation,
        relRoll: camera.relRoll,
        zoom: camera.getZoom()
      };
      this.landmarks.push(landmark);
      return landmark;
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var landmark = isString$1(name) ? this.landmarks.find(function(l2) {
        return l2.name === name;
      }) : name;
      if (landmark) {
        var _ref = isNumber(options) ? {
          duration: options
        } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration2 = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
        var epsilon2 = 0.01;
        this.cancelLandmarkAnimation();
        var destPosition = landmark.position;
        var destFocalPoint = landmark.focalPoint;
        var destZoom = landmark.zoom;
        var destRoll = landmark.roll;
        var easingFunc = easingFunction || runtime.EasingFunction(easing);
        var timeStart;
        var end = function end2() {
          _this2.setFocalPoint(destFocalPoint);
          _this2.setPosition(destPosition);
          _this2.setRoll(destRoll);
          _this2.setZoom(destZoom);
          _this2.computeMatrix();
          _this2.triggerUpdate();
          onfinish === null || onfinish === void 0 || onfinish();
        };
        if (duration2 === 0) return end();
        var _animate = function animate2(timestamp) {
          if (timeStart === void 0) {
            timeStart = timestamp;
          }
          var elapsed = timestamp - timeStart;
          if (elapsed >= duration2) {
            end();
            return;
          }
          var t3 = easingFunc(elapsed / duration2);
          var interFocalPoint = create$4();
          var interPosition = create$4();
          var interZoom = 1;
          var interRoll = 0;
          lerp$1(interFocalPoint, _this2.focalPoint, destFocalPoint, t3);
          lerp$1(interPosition, _this2.position, destPosition, t3);
          interRoll = _this2.roll * (1 - t3) + destRoll * t3;
          interZoom = _this2.zoom * (1 - t3) + destZoom * t3;
          _this2.setFocalPoint(interFocalPoint);
          _this2.setPosition(interPosition);
          _this2.setRoll(interRoll);
          _this2.setZoom(interZoom);
          var dist$1 = dist(interFocalPoint, destFocalPoint) + dist(interPosition, destPosition);
          if (dist$1 <= epsilon2 && destZoom === void 0 && destRoll === void 0) {
            return end();
          }
          _this2.computeMatrix();
          _this2.triggerUpdate();
          if (elapsed < duration2) {
            onframe === null || onframe === void 0 || onframe(t3);
            _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
          }
        };
        this.canvas.requestAnimationFrame(_animate);
      }
    }
    /**
     * Sets the camera to a distance such that the area covered by the bounding box is viewed.
     */
    // shot(displayObject: DisplayObject) {
    //   const aabb = displayObject.getBounds();
    //   if (!AABB.isEmpty(aabb)) {
    //     this.setElevation(0);
    //     this.setAzimuth(0);
    //     this.setRoll(0);
    //     const { halfExtents, center } = aabb;
    //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
    //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
    //     if (maxDim !== 0) {
    //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
    //       this.setPosition([cc[0], cc[1], cc[2] + d]);
    //     }
    //     this.setFocalPoint(cc);
    //   }
    // }
  }]);
}(Camera);
runtime.CameraContribution = AdvancedCamera;
var _excluded = ["body", "startHead", "endHead", "startHeadOffset", "endHeadOffset"], _excluded2 = ["body", "startHead", "endHead", "startHeadOffset", "endHeadOffset"], _excluded3 = ["body", "startHead", "endHead", "startHeadOffset", "endHeadOffset"];
var Arrow = /* @__PURE__ */ function(_CustomElement) {
  function Arrow2(config) {
    var _this2;
    _classCallCheck(this, Arrow2);
    _this2 = _callSuper(this, Arrow2, [_objectSpread2(_objectSpread2({}, config), {}, {
      type: Arrow2.tag
    })]);
    var _this$attributes = _this2.attributes, body = _this$attributes.body, startHead = _this$attributes.startHead, endHead = _this$attributes.endHead;
    _this$attributes.startHeadOffset;
    _this$attributes.endHeadOffset;
    var rest = _objectWithoutProperties(_this$attributes, _excluded);
    if (!body) {
      throw new Error("Arrow's body is required");
    }
    _this2.body = body;
    _this2.appendChild(_this2.body);
    _this2.handleBodyAttributeChanged(_this2.body);
    if (startHead) {
      _this2.appendArrowHead(_this2.getArrowHeadType(startHead), true);
    }
    if (endHead) {
      _this2.appendArrowHead(_this2.getArrowHeadType(endHead), false);
    }
    _this2.applyArrowStyle(rest, [_this2.body, _this2.startHead, _this2.endHead]);
    return _this2;
  }
  _inherits(Arrow2, _CustomElement);
  return _createClass(Arrow2, [{
    key: "handleBodyAttributeChanged",
    value: function handleBodyAttributeChanged(body) {
      var _this2 = this;
      body.addEventListener(ElementEvent.ATTR_MODIFIED, function(e3) {
        var attrName = e3.attrName;
        if (attrName === "x1" || attrName === "y1") {
          if (_this2.startHead) {
            _this2.transformArrowHead(_this2.startHead, true);
          }
        } else if (attrName === "x2" || attrName === "y2") {
          if (_this2.endHead) {
            _this2.transformArrowHead(_this2.endHead, false);
          }
        }
      });
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this.body;
    }
  }, {
    key: "getStartHead",
    value: function getStartHead() {
      return this.startHead;
    }
  }, {
    key: "getEndHead",
    value: function getEndHead() {
      return this.endHead;
    }
  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(name, oldValue, newValue) {
      if (name === "opacity" || name === "strokeOpacity" || name === "stroke" || name === "lineWidth" || name === "increasedLineWidthForHitTesting") {
        this.applyArrowStyle(_defineProperty$1({}, name, newValue), [this.body, this.startHead, this.endHead]);
      } else if (name === "startHead" || name === "endHead") {
        var isStart = name === "startHead";
        this.destroyArrowHead(isStart);
        if (newValue) {
          var _this$attributes2 = this.attributes;
          _this$attributes2.body;
          _this$attributes2.startHead;
          _this$attributes2.endHead;
          _this$attributes2.startHeadOffset;
          _this$attributes2.endHeadOffset;
          var rest = _objectWithoutProperties(_this$attributes2, _excluded2);
          this.appendArrowHead(this.getArrowHeadType(newValue), isStart);
          this.applyArrowStyle(rest, [isStart ? this.startHead : this.endHead]);
        }
      } else if (name === "body") {
        var _this$attributes3 = this.attributes;
        _this$attributes3.body;
        _this$attributes3.startHead;
        _this$attributes3.endHead;
        _this$attributes3.startHeadOffset;
        _this$attributes3.endHeadOffset;
        var _rest = _objectWithoutProperties(_this$attributes3, _excluded3);
        this.body.destroy();
        this.body = newValue;
        this.appendChild(this.body);
        this.applyArrowStyle(_rest, [this.body]);
      } else if (name === "startHeadOffset") {
        this.moveArrowHeadAlongTangent(newValue, true);
      } else if (name === "endHeadOffset") {
        this.moveArrowHeadAlongTangent(newValue, false);
      }
    }
  }, {
    key: "getArrowHeadType",
    value: function getArrowHeadType(head) {
      if (typeof head === "boolean") {
        return "default";
      }
      return "custom";
    }
  }, {
    key: "appendArrowHead",
    value: function appendArrowHead(type, isStart) {
      var head;
      if (type === "default") {
        head = this.createDefaultArrowHead();
      } else {
        head = isStart ? this.attributes.startHead : this.attributes.endHead;
      }
      this.transformArrowHead(head, isStart);
      head.setAttribute("zIndex", 1);
      if (isStart) {
        this.startHead = head;
      } else {
        this.endHead = head;
      }
      this.appendChild(head);
      var offset = isStart ? this.attributes.startHeadOffset : this.attributes.endHeadOffset;
      if (offset) {
        this.moveArrowHeadAlongTangent(offset, isStart);
      }
    }
    /**
     * transform arrow head according to arrow line
     */
  }, {
    key: "transformArrowHead",
    value: function transformArrowHead(head, isStart) {
      var position2 = create$4();
      var rad3 = 0;
      var x1 = 0;
      var x2 = 0;
      var y1 = 0;
      var y2 = 0;
      var bodyType = this.body && this.body.nodeName;
      if (bodyType === Shape.LINE) {
        var _attributes = this.body.attributes, _x1 = _attributes.x1, _x2 = _attributes.x2, _y1 = _attributes.y1, _y2 = _attributes.y2;
        x1 = isStart ? _x2 : _x1;
        x2 = isStart ? _x1 : _x2;
        y1 = isStart ? _y2 : _y1;
        y2 = isStart ? _y1 : _y2;
      } else if (bodyType === Shape.POLYLINE) {
        var points = this.body.attributes.points;
        var length2 = points.length;
        x1 = isStart ? points[1][0] : points[length2 - 2][0];
        y1 = isStart ? points[1][1] : points[length2 - 2][1];
        x2 = isStart ? points[0][0] : points[length2 - 1][0];
        y2 = isStart ? points[0][1] : points[length2 - 1][1];
      } else if (bodyType === Shape.PATH) {
        var _this$getTangent = this.getTangent(this.body, isStart), _this$getTangent2 = _slicedToArray(_this$getTangent, 2), p1 = _this$getTangent2[0], p2 = _this$getTangent2[1];
        x1 = p1[0];
        y1 = p1[1];
        x2 = p2[0];
        y2 = p2[1];
      }
      var x3 = x1 - x2;
      var y3 = y1 - y2;
      rad3 = Math.atan2(y3, x3);
      position2 = fromValues$2(x2, y2, 0);
      if (isStart) {
        this.startHeadPosition = position2;
        this.startHeadRad = rad3;
      } else {
        this.endHeadPosition = position2;
        this.endHeadRad = rad3;
      }
      head.setLocalPosition(position2);
      head.setLocalEulerAngles(rad3 * 180 / Math.PI + head.getLocalEulerAngles());
    }
  }, {
    key: "moveArrowHeadAlongTangent",
    value: function moveArrowHeadAlongTangent(offset, isStart) {
      var head = isStart ? this.startHead : this.endHead;
      if (head) {
        head.setLocalPosition(sub$1(create$4(), isStart ? this.startHeadPosition : this.endHeadPosition, fromValues$2(Math.cos(isStart ? this.startHeadRad : this.endHeadRad) * offset, Math.sin(isStart ? this.startHeadRad : this.endHeadRad) * offset, 0)));
      }
      if (this.body) ;
    }
  }, {
    key: "destroyArrowHead",
    value: function destroyArrowHead(isStart) {
      if (isStart && this.startHead) {
        this.startHead.destroy();
        this.startHead = void 0;
      }
      if (!isStart && this.endHead) {
        this.endHead.destroy();
        this.endHead = void 0;
      }
    }
  }, {
    key: "getTangent",
    value: function getTangent(path, isStart) {
      return isStart ? path.getStartTangent() : path.getEndTangent();
    }
  }, {
    key: "createDefaultArrowHead",
    value: function createDefaultArrowHead() {
      var _this$attributes4 = this.attributes, stroke = _this$attributes4.stroke, lineWidth = _this$attributes4.lineWidth;
      var sin = Math.sin, cos = Math.cos, PI3 = Math.PI;
      var width2 = 10 * cos(PI3 / 6);
      return new Path({
        style: {
          // draw an angle '<'
          d: "M".concat(width2 / 2, ",").concat(10 * sin(PI3 / 6), " L-").concat(width2 / 2, ",0 L").concat(width2 / 2, ",-").concat(10 * sin(PI3 / 6)),
          stroke,
          lineWidth,
          transformOrigin: "center"
        }
      });
    }
  }, {
    key: "applyArrowStyle",
    value: function applyArrowStyle(attributes, objects) {
      var opacity2 = attributes.opacity, stroke = attributes.stroke, strokeOpacity = attributes.strokeOpacity, lineWidth = attributes.lineWidth, increasedLineWidthForHitTesting = attributes.increasedLineWidthForHitTesting;
      objects.forEach(function(shape) {
        if (shape) {
          if (!isNil(opacity2)) {
            shape.style.opacity = opacity2;
          }
          if (!isNil(stroke)) {
            shape.style.stroke = stroke;
          }
          if (!isNil(strokeOpacity)) {
            shape.style.strokeOpacity = strokeOpacity;
          }
          if (!isNil(lineWidth)) {
            shape.style.lineWidth = lineWidth;
          }
          if (!isNil(increasedLineWidthForHitTesting)) {
            shape.style.increasedLineWidthForHitTesting = increasedLineWidthForHitTesting;
          }
        }
      });
    }
  }]);
}(CustomElement);
Arrow.tag = "arrow";
Arrow.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(CustomElement.PARSED_STYLE_LIST), ["body", "startHead", "endHead", "startHeadOffset", "endHeadOffset", "stroke", "lineWidth", "opacity", "strokeOpacity"]));
var PI = Math.PI;
var PI2 = PI * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathSqrt = Math.sqrt;
var mathMax = Math.max;
var mathMin = Math.min;
var e$1 = 1e-4;
var SECTOR_CSS_PROPERTY = [{
  name: "sr",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.LENGTH_PERCENTAGE
}, {
  name: "sr0",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.LENGTH_PERCENTAGE
}, {
  name: "startAngle",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.ANGLE
}, {
  name: "endAngle",
  inherits: false,
  interpolable: true,
  syntax: PropertySyntax.ANGLE
}];
SECTOR_CSS_PROPERTY.forEach(function(property) {
  CSS.registerProperty(property);
});
var polarToCartesian = function polarToCartesian2(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
};
function intersect$1(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t3 = dy32 * dx10 - dx32 * dy10;
  if (t3 * t3 < e$1) {
    return;
  }
  t3 = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t3;
  return [x0 + t3 * dx10, y0 + t3 * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = cr / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d22 = dx * dx + dy * dy;
  var r2 = radius - cr;
  var s3 = x11 * y10 - x10 * y11;
  var d3 = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r2 * r2 * d22 - s3 * s3));
  var cx0 = (s3 * dy - dx * d3) / d22;
  var cy0 = (-s3 * dx - dy * d3) / d22;
  var cx1 = (s3 * dy + dx * d3) / d22;
  var cy1 = (-s3 * dx + dy * d3) / d22;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r2 - 1),
    y1: cy0 * (radius / r2 - 1)
  };
}
function computeArcSweep(startAngle, endAngle) {
  endAngle = endAngle < 0 && startAngle >= 0 ? endAngle + PI2 : endAngle;
  return endAngle - startAngle <= PI ? 0 : 1;
}
var Sector = /* @__PURE__ */ function(_Path) {
  function Sector2(config) {
    var _this2;
    _classCallCheck(this, Sector2);
    _this2 = _callSuper(this, Sector2, [config]);
    _this2.updatePath();
    return _this2;
  }
  _inherits(Sector2, _Path);
  return _createClass(Sector2, [{
    key: "setAttribute",
    value: function setAttribute(name, value, force) {
      _superPropGet(Sector2, "setAttribute", this)([name, value, force]);
      if (["startAngle", "endAngle", "sr", "sr0", "radius"].indexOf(name) > -1) {
        this.updatePath();
      }
    }
  }, {
    key: "updatePath",
    value: function updatePath() {
      var _this$parsedStyle = this.parsedStyle, x2 = _this$parsedStyle.x, y2 = _this$parsedStyle.y, startAngle = _this$parsedStyle.startAngle, endAngle = _this$parsedStyle.endAngle, sr = _this$parsedStyle.sr, sr0 = _this$parsedStyle.sr0, radius = _this$parsedStyle.radius;
      var path = this.createPath(x2, y2, startAngle ? deg2rad(startAngle) : 0, endAngle ? deg2rad(endAngle) : Math.PI * 2, sr || 0, sr0 || 0, radius || [0, 0, 0, 0]);
      _superPropGet(Sector2, "setAttribute", this)(["d", path]);
    }
  }, {
    key: "createPath",
    value: function createPath(x2, y2, startAngle, endAngle, r2, r0, borderRadius) {
      if (r2 <= 0) {
        return;
      }
      var start = polarToCartesian(x2, y2, r2, startAngle);
      var end = polarToCartesian(x2, y2, r2, endAngle);
      var innerStart = polarToCartesian(x2, y2, r0, startAngle);
      var innerEnd = polarToCartesian(x2, y2, r0, endAngle);
      if (isNumberEqual(endAngle - startAngle, Math.PI * 2)) {
        var middlePoint = polarToCartesian(x2, y2, r2, startAngle + Math.PI);
        var innerMiddlePoint = polarToCartesian(x2, y2, r0, startAngle + Math.PI);
        var circlePathCommands = [["M", start.x, start.y], ["A", r2, r2, 0, 1, 1, middlePoint.x, middlePoint.y], ["A", r2, r2, 0, 1, 1, end.x, end.y], ["M", innerStart.x, innerStart.y]];
        if (r0) {
          circlePathCommands.push(["A", r0, r0, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
          circlePathCommands.push(["A", r0, r0, 0, 1, 0, innerEnd.x, innerEnd.y]);
        }
        circlePathCommands.push(["M", start.x, start.y]);
        circlePathCommands.push(["Z"]);
        return circlePathCommands;
      }
      var angle2 = endAngle - startAngle;
      var xrs = r2 * mathCos(startAngle);
      var yrs = r2 * mathSin(startAngle);
      var xire = r0 * mathCos(endAngle);
      var yire = r0 * mathSin(endAngle);
      var xre = r2 * mathCos(endAngle);
      var yre = r2 * mathSin(endAngle);
      var xirs = r0 * mathCos(startAngle);
      var yirs = r0 * mathSin(startAngle);
      var _borderRadius = _slicedToArray(borderRadius, 4), outStartRadius = _borderRadius[0], outEndRadius = _borderRadius[1], innerEndRadius = _borderRadius[2], innerStartRadius = _borderRadius[3];
      var halfRadius = (r2 - r0) / 2;
      var outStartBorderRadius = mathMin(halfRadius, outStartRadius);
      var outEndBorderRadius = mathMin(halfRadius, outEndRadius);
      var innerEndBorderRadius = mathMin(halfRadius, innerEndRadius);
      var innerStartBorderRadius = mathMin(halfRadius, innerStartRadius);
      var outBorderRadiusMax = mathMax(outStartBorderRadius, outEndBorderRadius);
      var innerBorderRadiusMax = mathMax(innerEndBorderRadius, innerStartBorderRadius);
      var limitedOutBorderRadiusMax = outBorderRadiusMax;
      var limitedInnerBorderRadiusMax = innerBorderRadiusMax;
      if (outBorderRadiusMax > e$1 || innerBorderRadiusMax > e$1) {
        if (angle2 < PI) {
          var it = intersect$1(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it) {
            var x0 = xrs - it[0];
            var y0 = yrs - it[1];
            var x1 = xre - it[0];
            var y1 = yre - it[1];
            var a2 = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b2 = mathSqrt(it[0] * it[0] + it[1] * it[1]);
            limitedOutBorderRadiusMax = mathMin(outBorderRadiusMax, (r2 - b2) / (a2 + 1));
            limitedInnerBorderRadiusMax = mathMin(innerBorderRadiusMax, (r0 - b2) / (a2 - 1));
          }
        }
      }
      var arcSweep = computeArcSweep(startAngle, endAngle);
      var sectorPathCommands = [];
      if (limitedOutBorderRadiusMax > e$1) {
        var crStart = mathMin(outStartRadius, limitedOutBorderRadiusMax);
        var crEnd = mathMin(outEndRadius, limitedOutBorderRadiusMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, r2, crStart);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, r2, crEnd);
        sectorPathCommands.push(["M", x2 + ct0.cx + ct0.x0, y2 + ct0.cy + ct0.y0]);
        if (limitedOutBorderRadiusMax < outBorderRadiusMax && crStart === crEnd) {
          var outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
          var outStartBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
          sectorPathCommands.push(["A", limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle), 1, x2 + ct1.cx + ct1.x0, y2 + ct1.cy + ct1.y0]);
        } else {
          if (crStart > 0) {
            var _outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var _outStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            var outStartBorderRadiusEndPoint = polarToCartesian(x2, y2, r2, _outStartBorderRadiusEndAngle);
            sectorPathCommands.push(["A", crStart, crStart, 0, computeArcSweep(_outStartBorderRadiusStartAngle, _outStartBorderRadiusEndAngle), 1, outStartBorderRadiusEndPoint.x, outStartBorderRadiusEndPoint.y]);
          }
          var outRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var outRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var outRadiusEndPoint = polarToCartesian(x2, y2, r2, outRadiusEndAngle);
          sectorPathCommands.push(["A", r2, r2, 0, computeArcSweep(outRadiusStartAngle, outRadiusEndAngle), 1, outRadiusEndPoint.x, outRadiusEndPoint.y]);
          if (crEnd > 0) {
            var outEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var outEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(["A", crEnd, crEnd, 0, computeArcSweep(outEndBorderRadiusStartAngle, outEndBorderRadiusEndAngle), 1, x2 + ct1.cx + ct1.x0, y2 + ct1.cy + ct1.y0]);
          }
        }
      } else {
        sectorPathCommands.push(["M", start.x, start.y]);
        sectorPathCommands.push(["A", r2, r2, 0, arcSweep, 1, end.x, end.y]);
      }
      if (r0 < e$1) {
        sectorPathCommands.push(["L", innerEnd.x, innerEnd.y]);
      } else if (limitedInnerBorderRadiusMax > e$1) {
        var _crStart = mathMin(innerStartRadius, limitedInnerBorderRadiusMax);
        var _crEnd = mathMin(innerEndRadius, limitedInnerBorderRadiusMax);
        var _ct = computeCornerTangents(xire, yire, 0, 0, r0 - r2, _crEnd);
        var _ct2 = computeCornerTangents(0, 0, xirs, yirs, r0 - r2, _crStart);
        sectorPathCommands.push(["L", x2 + _ct.cx + _ct.x0, y2 + _ct.cy + _ct.y0]);
        if (limitedInnerBorderRadiusMax < innerBorderRadiusMax && _crStart === _crEnd) {
          var innerStartBorderRadiusStartAngle = mathATan2(_ct.y0, _ct.x0);
          var innerStartBorderRadiusEndAngle = mathATan2(_ct2.y0, _ct2.x0);
          var innerStartBorderRadiusEndPoint = polarToCartesian(x2, y2, r0, innerStartBorderRadiusEndAngle);
          sectorPathCommands.push(["A", limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle), 1, innerStartBorderRadiusEndPoint.x, innerStartBorderRadiusEndPoint.y]);
        } else {
          if (_crEnd > 0) {
            var _innerStartBorderRadiusStartAngle = mathATan2(_ct.y0, _ct.x0);
            var _innerStartBorderRadiusEndAngle = mathATan2(_ct.y1, _ct.x1);
            var _innerStartBorderRadiusEndPoint = polarToCartesian(x2, y2, r0 - r2, _innerStartBorderRadiusEndAngle);
            sectorPathCommands.push(["A", _crEnd, _crEnd, 0, computeArcSweep(_innerStartBorderRadiusStartAngle, _innerStartBorderRadiusEndAngle), 1, _innerStartBorderRadiusEndPoint.x, _innerStartBorderRadiusEndPoint.y]);
          }
          var innerRadiusStartAngle = mathATan2(_ct.cy + _ct.y1, _ct.cx + _ct.x1);
          var innerRadiusEndAngle = mathATan2(_ct2.cy + _ct2.y1, _ct2.cx + _ct2.x1);
          var innerRadiusEndPoint = polarToCartesian(x2, y2, r0, innerRadiusEndAngle);
          sectorPathCommands.push(["A", r0, r0, 0, computeArcSweep(innerRadiusEndAngle, innerRadiusStartAngle), 0, innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
          sectorPathCommands.push(["L", innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
          if (_crStart > 0) {
            var innerEndBorderRadiusStartAngle = mathATan2(_ct2.y1, _ct2.x1);
            var innerEndBorderRadiusEndAngle = mathATan2(_ct2.y0, _ct2.x0);
            sectorPathCommands.push(["A", _crStart, _crStart, 0, computeArcSweep(innerEndBorderRadiusStartAngle, innerEndBorderRadiusEndAngle), 1, x2 + _ct2.cx + _ct2.x0, y2 + _ct2.cy + _ct2.y0]);
          }
        }
      } else {
        sectorPathCommands.push(["L", innerEnd.x, innerEnd.y]);
        sectorPathCommands.push(["A", r0, r0, 0, arcSweep, 0, innerStart.x, innerStart.y]);
      }
      sectorPathCommands.push(["Z"]);
      return sectorPathCommands;
    }
  }]);
}(Path);
Sector.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Path.PARSED_STYLE_LIST), ["x", "y", "sr", "sr0", "radius", "startAngle", "endAngle"]));
const DEFAULT_ANIMATION_OPTIONS = {
  duration: 500
};
const DEFAULT_ELEMENTS_ANIMATION_OPTIONS = {
  duration: 1e3,
  easing: "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
  iterations: 1,
  fill: "both"
};
var ChangeType;
(function(ChangeType2) {
  ChangeType2["NodeAdded"] = "NodeAdded";
  ChangeType2["NodeUpdated"] = "NodeUpdated";
  ChangeType2["NodeRemoved"] = "NodeRemoved";
  ChangeType2["EdgeAdded"] = "EdgeAdded";
  ChangeType2["EdgeUpdated"] = "EdgeUpdated";
  ChangeType2["EdgeRemoved"] = "EdgeRemoved";
  ChangeType2["ComboAdded"] = "ComboAdded";
  ChangeType2["ComboUpdated"] = "ComboUpdated";
  ChangeType2["ComboRemoved"] = "ComboRemoved";
})(ChangeType || (ChangeType = {}));
var AnimationType;
(function(AnimationType2) {
  AnimationType2["DRAW"] = "draw";
  AnimationType2["COLLAPSE"] = "collapse";
  AnimationType2["EXPAND"] = "expand";
  AnimationType2["TRANSFORM"] = "transform";
})(AnimationType || (AnimationType = {}));
var CanvasEvent;
(function(CanvasEvent2) {
  CanvasEvent2["CLICK"] = "canvas:click";
  CanvasEvent2["DBLCLICK"] = "canvas:dblclick";
  CanvasEvent2["POINTER_OVER"] = "canvas:pointerover";
  CanvasEvent2["POINTER_LEAVE"] = "canvas:pointerleave";
  CanvasEvent2["POINTER_ENTER"] = "canvas:pointerenter";
  CanvasEvent2["POINTER_MOVE"] = "canvas:pointermove";
  CanvasEvent2["POINTER_OUT"] = "canvas:pointerout";
  CanvasEvent2["POINTER_DOWN"] = "canvas:pointerdown";
  CanvasEvent2["POINTER_UP"] = "canvas:pointerup";
  CanvasEvent2["CONTEXT_MENU"] = "canvas:contextmenu";
  CanvasEvent2["DRAG_START"] = "canvas:dragstart";
  CanvasEvent2["DRAG"] = "canvas:drag";
  CanvasEvent2["DRAG_END"] = "canvas:dragend";
  CanvasEvent2["DRAG_ENTER"] = "canvas:dragenter";
  CanvasEvent2["DRAG_OVER"] = "canvas:dragover";
  CanvasEvent2["DRAG_LEAVE"] = "canvas:dragleave";
  CanvasEvent2["DROP"] = "canvas:drop";
  CanvasEvent2["WHEEL"] = "canvas:wheel";
})(CanvasEvent || (CanvasEvent = {}));
var ComboEvent;
(function(ComboEvent2) {
  ComboEvent2["CLICK"] = "combo:click";
  ComboEvent2["DBLCLICK"] = "combo:dblclick";
  ComboEvent2["POINTER_OVER"] = "combo:pointerover";
  ComboEvent2["POINTER_LEAVE"] = "combo:pointerleave";
  ComboEvent2["POINTER_ENTER"] = "combo:pointerenter";
  ComboEvent2["POINTER_MOVE"] = "combo:pointermove";
  ComboEvent2["POINTER_OUT"] = "combo:pointerout";
  ComboEvent2["POINTER_DOWN"] = "combo:pointerdown";
  ComboEvent2["POINTER_UP"] = "combo:pointerup";
  ComboEvent2["CONTEXT_MENU"] = "combo:contextmenu";
  ComboEvent2["DRAG_START"] = "combo:dragstart";
  ComboEvent2["DRAG"] = "combo:drag";
  ComboEvent2["DRAG_END"] = "combo:dragend";
  ComboEvent2["DRAG_ENTER"] = "combo:dragenter";
  ComboEvent2["DRAG_OVER"] = "combo:dragover";
  ComboEvent2["DRAG_LEAVE"] = "combo:dragleave";
  ComboEvent2["DROP"] = "combo:drop";
})(ComboEvent || (ComboEvent = {}));
var CommonEvent;
(function(CommonEvent2) {
  CommonEvent2["CLICK"] = "click";
  CommonEvent2["DBLCLICK"] = "dblclick";
  CommonEvent2["POINTER_OVER"] = "pointerover";
  CommonEvent2["POINTER_LEAVE"] = "pointerleave";
  CommonEvent2["POINTER_ENTER"] = "pointerenter";
  CommonEvent2["POINTER_MOVE"] = "pointermove";
  CommonEvent2["POINTER_OUT"] = "pointerout";
  CommonEvent2["POINTER_DOWN"] = "pointerdown";
  CommonEvent2["POINTER_UP"] = "pointerup";
  CommonEvent2["CONTEXT_MENU"] = "contextmenu";
  CommonEvent2["DRAG_START"] = "dragstart";
  CommonEvent2["DRAG"] = "drag";
  CommonEvent2["DRAG_END"] = "dragend";
  CommonEvent2["DRAG_ENTER"] = "dragenter";
  CommonEvent2["DRAG_OVER"] = "dragover";
  CommonEvent2["DRAG_LEAVE"] = "dragleave";
  CommonEvent2["DROP"] = "drop";
  CommonEvent2["KEY_DOWN"] = "keydown";
  CommonEvent2["KEY_UP"] = "keyup";
  CommonEvent2["WHEEL"] = "wheel";
  CommonEvent2["PINCH"] = "pinch";
})(CommonEvent || (CommonEvent = {}));
var ContainerEvent;
(function(ContainerEvent2) {
  ContainerEvent2["KEY_DOWN"] = "keydown";
  ContainerEvent2["KEY_UP"] = "keyup";
})(ContainerEvent || (ContainerEvent = {}));
var EdgeEvent;
(function(EdgeEvent2) {
  EdgeEvent2["CLICK"] = "edge:click";
  EdgeEvent2["DBLCLICK"] = "edge:dblclick";
  EdgeEvent2["POINTER_OVER"] = "edge:pointerover";
  EdgeEvent2["POINTER_LEAVE"] = "edge:pointerleave";
  EdgeEvent2["POINTER_ENTER"] = "edge:pointerenter";
  EdgeEvent2["POINTER_MOVE"] = "edge:pointermove";
  EdgeEvent2["POINTER_OUT"] = "edge:pointerout";
  EdgeEvent2["POINTER_DOWN"] = "edge:pointerdown";
  EdgeEvent2["POINTER_UP"] = "edge:pointerup";
  EdgeEvent2["CONTEXT_MENU"] = "edge:contextmenu";
  EdgeEvent2["DRAG_ENTER"] = "edge:dragenter";
  EdgeEvent2["DRAG_OVER"] = "edge:dragover";
  EdgeEvent2["DRAG_LEAVE"] = "edge:dragleave";
  EdgeEvent2["DROP"] = "edge:drop";
})(EdgeEvent || (EdgeEvent = {}));
var GraphEvent;
(function(GraphEvent2) {
  GraphEvent2["BEFORE_CANVAS_INIT"] = "beforecanvasinit";
  GraphEvent2["AFTER_CANVAS_INIT"] = "aftercanvasinit";
  GraphEvent2["BEFORE_SIZE_CHANGE"] = "beforesizechange";
  GraphEvent2["AFTER_SIZE_CHANGE"] = "aftersizechange";
  GraphEvent2["BEFORE_ELEMENT_CREATE"] = "beforeelementcreate";
  GraphEvent2["AFTER_ELEMENT_CREATE"] = "afterelementcreate";
  GraphEvent2["BEFORE_ELEMENT_UPDATE"] = "beforeelementupdate";
  GraphEvent2["AFTER_ELEMENT_UPDATE"] = "afterelementupdate";
  GraphEvent2["BEFORE_ELEMENT_DESTROY"] = "beforeelementdestroy";
  GraphEvent2["AFTER_ELEMENT_DESTROY"] = "afterelementdestroy";
  GraphEvent2["BEFORE_ELEMENT_TRANSLATE"] = "beforeelementtranslate";
  GraphEvent2["AFTER_ELEMENT_TRANSLATE"] = "afterelementtranslate";
  GraphEvent2["BEFORE_DRAW"] = "beforedraw";
  GraphEvent2["AFTER_DRAW"] = "afterdraw";
  GraphEvent2["BEFORE_RENDER"] = "beforerender";
  GraphEvent2["AFTER_RENDER"] = "afterrender";
  GraphEvent2["BEFORE_ANIMATE"] = "beforeanimate";
  GraphEvent2["AFTER_ANIMATE"] = "afteranimate";
  GraphEvent2["BEFORE_LAYOUT"] = "beforelayout";
  GraphEvent2["AFTER_LAYOUT"] = "afterlayout";
  GraphEvent2["BEFORE_STAGE_LAYOUT"] = "beforestagelayout";
  GraphEvent2["AFTER_STAGE_LAYOUT"] = "afterstagelayout";
  GraphEvent2["BEFORE_TRANSFORM"] = "beforetransform";
  GraphEvent2["AFTER_TRANSFORM"] = "aftertransform";
  GraphEvent2["BATCH_START"] = "batchstart";
  GraphEvent2["BATCH_END"] = "batchend";
  GraphEvent2["BEFORE_DESTROY"] = "beforedestroy";
  GraphEvent2["AFTER_DESTROY"] = "afterdestroy";
  GraphEvent2["BEFORE_RENDERER_CHANGE"] = "beforerendererchange";
  GraphEvent2["AFTER_RENDERER_CHANGE"] = "afterrendererchange";
})(GraphEvent || (GraphEvent = {}));
var HistoryEvent;
(function(HistoryEvent2) {
  HistoryEvent2["UNDO"] = "undo";
  HistoryEvent2["REDO"] = "redo";
  HistoryEvent2["CANCEL"] = "cancel";
  HistoryEvent2["ADD"] = "add";
  HistoryEvent2["CLEAR"] = "clear";
  HistoryEvent2["CHANGE"] = "change";
})(HistoryEvent || (HistoryEvent = {}));
var NodeEvent;
(function(NodeEvent2) {
  NodeEvent2["CLICK"] = "node:click";
  NodeEvent2["DBLCLICK"] = "node:dblclick";
  NodeEvent2["POINTER_OVER"] = "node:pointerover";
  NodeEvent2["POINTER_LEAVE"] = "node:pointerleave";
  NodeEvent2["POINTER_ENTER"] = "node:pointerenter";
  NodeEvent2["POINTER_MOVE"] = "node:pointermove";
  NodeEvent2["POINTER_OUT"] = "node:pointerout";
  NodeEvent2["POINTER_DOWN"] = "node:pointerdown";
  NodeEvent2["POINTER_UP"] = "node:pointerup";
  NodeEvent2["CONTEXT_MENU"] = "node:contextmenu";
  NodeEvent2["DRAG_START"] = "node:dragstart";
  NodeEvent2["DRAG"] = "node:drag";
  NodeEvent2["DRAG_END"] = "node:dragend";
  NodeEvent2["DRAG_ENTER"] = "node:dragenter";
  NodeEvent2["DRAG_OVER"] = "node:dragover";
  NodeEvent2["DRAG_LEAVE"] = "node:dragleave";
  NodeEvent2["DROP"] = "node:drop";
})(NodeEvent || (NodeEvent = {}));
const COMBO_KEY = "combo";
const TREE_KEY = "tree";
var ExtensionCategory;
(function(ExtensionCategory2) {
  ExtensionCategory2["NODE"] = "node";
  ExtensionCategory2["EDGE"] = "edge";
  ExtensionCategory2["COMBO"] = "combo";
  ExtensionCategory2["THEME"] = "theme";
  ExtensionCategory2["PALETTE"] = "palette";
  ExtensionCategory2["LAYOUT"] = "layout";
  ExtensionCategory2["BEHAVIOR"] = "behavior";
  ExtensionCategory2["PLUGIN"] = "plugin";
  ExtensionCategory2["ANIMATION"] = "animation";
  ExtensionCategory2["TRANSFORM"] = "transform";
  ExtensionCategory2["SHAPE"] = "shape";
})(ExtensionCategory || (ExtensionCategory = {}));
const EXTENSION_REGISTRY = {
  animation: {},
  behavior: {},
  combo: {},
  edge: {},
  layout: {},
  node: {},
  palette: {},
  theme: {},
  plugin: {},
  transform: {},
  shape: {}
};
function getExtension(category, type) {
  var _a3;
  const extension = (_a3 = EXTENSION_REGISTRY[category]) === null || _a3 === void 0 ? void 0 : _a3[type];
  if (extension) {
    return extension;
  }
  return void 0;
}
const version$2 = "5.0.51";
const BRAND = "G6";
function format(message) {
  return `[${BRAND} v${version$2}] ${message}`;
}
const print = {
  mute: false,
  debug: (message) => {
    console.debug(format(message));
  },
  info: (message) => {
    console.info(format(message));
  },
  warn: (message) => {
    console.warn(format(message));
  },
  error: (message) => {
    console.error(format(message));
  }
};
function themeOf(options) {
  const { theme } = options;
  if (!theme)
    return {};
  const themeOptions = getExtension(ExtensionCategory.THEME, theme);
  if (themeOptions)
    return themeOptions;
  print.warn(`The theme of ${theme} is not registered.`);
  return {};
}
function createAnimationsProxy(args1, args2) {
  if (Array.isArray(args1) && args1.length === 0)
    return null;
  const sourceAnimation = Array.isArray(args1) ? args1[0] : args1;
  const targetAnimations = Array.isArray(args1) ? args1.slice(1) : args2 || [];
  return new Proxy(sourceAnimation, {
    get(target, propKey) {
      if (typeof target[propKey] === "function" && !["onframe", "onfinish"].includes(propKey)) {
        return (...args) => {
          target[propKey](...args);
          targetAnimations.forEach((animation) => {
            var _a3;
            return (_a3 = animation[propKey]) === null || _a3 === void 0 ? void 0 : _a3.call(animation, ...args);
          });
        };
      }
      if (propKey === "finished") {
        return Promise.all([sourceAnimation.finished, ...targetAnimations.map((animation) => animation.finished)]);
      }
      return Reflect.get(target, propKey);
    },
    set(target, propKey, value) {
      if (!["onframe", "onfinish"].includes(propKey)) {
        targetAnimations.forEach((animation) => {
          animation[propKey] = value;
        });
      }
      return Reflect.set(target, propKey, value);
    }
  });
}
function preprocessKeyframes(keyframes) {
  const propertyIndexedKeyframes = keyframes.reduce((acc, kf) => {
    Object.entries(kf).forEach(([key, value]) => {
      if (acc[key] === void 0)
        acc[key] = [value];
      else
        acc[key].push(value);
    });
    return acc;
  }, {});
  Object.entries(propertyIndexedKeyframes).forEach(([key, values2]) => {
    if (
      //  / property value must exist in every frame
      values2.length !== keyframes.length || //  / property value cannot be empty
      values2.some((value) => isNil(value)) || //  / property value must not be exactly the same
      //  / property value can be the reserved property
      values2.every((value) => !["sourceNode", "targetNode", "childrenNode"].includes(key) && isEqual$1(value, values2[0]))
    ) {
      delete propertyIndexedKeyframes[key];
    }
  });
  const output = Object.entries(propertyIndexedKeyframes).reduce((acc, [key, values2]) => {
    values2.forEach((value, index2) => {
      if (!acc[index2])
        acc[index2] = { [key]: value };
      else
        acc[index2][key] = value;
    });
    return acc;
  }, []);
  if (keyframes.length !== 0 && output.length === 0)
    output.push(...[{ _: 0 }, { _: 0 }]);
  return output;
}
function inferDefaultValue(name) {
  switch (name) {
    case "opacity":
      return 1;
    case "x":
    case "y":
    case "z":
    case "zIndex":
      return 0;
    case "visibility":
      return "visible";
    case "collapsed":
      return false;
    case "states":
      return [];
    default:
      return void 0;
  }
}
function getAnimationOptions(options, localAnimation) {
  const { animation } = options;
  if (animation === false || localAnimation === false)
    return false;
  const effectTiming = Object.assign({}, DEFAULT_ANIMATION_OPTIONS);
  if (isObject$2(animation))
    Object.assign(effectTiming, animation);
  if (isObject$2(localAnimation))
    Object.assign(effectTiming, localAnimation);
  return effectTiming;
}
function animationOf(options) {
  if (typeof options === "string") {
    const animation = getExtension(ExtensionCategory.ANIMATION, options);
    if (animation)
      return animation;
    print.warn(`The animation of ${options} is not registered.`);
    return [];
  }
  return options;
}
function getElementAnimationOptions(options, elementType, stage, localAnimation) {
  var _a3, _b;
  const { animation: globalAnimation } = options;
  if (globalAnimation === false || localAnimation === false)
    return [];
  const userElementAnimation = (_a3 = options === null || options === void 0 ? void 0 : options[elementType]) === null || _a3 === void 0 ? void 0 : _a3.animation;
  if (userElementAnimation === false)
    return [];
  const useElementStageAnimation = userElementAnimation === null || userElementAnimation === void 0 ? void 0 : userElementAnimation[stage];
  if (useElementStageAnimation === false)
    return [];
  const themeElementAnimation = (_b = themeOf(options)[elementType]) === null || _b === void 0 ? void 0 : _b.animation;
  const combine2 = (_2 = []) => animationOf(_2).map((animation) => Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_ELEMENTS_ANIMATION_OPTIONS), isObject$2(globalAnimation) && globalAnimation), animation), isObject$2(localAnimation) && localAnimation));
  if (useElementStageAnimation)
    return combine2(useElementStageAnimation);
  if (!themeElementAnimation)
    return [];
  const themeElementStageAnimation = themeElementAnimation[stage];
  if (themeElementStageAnimation === false)
    return [];
  return combine2(themeElementStageAnimation);
}
function replaceTranslateInTransform(x2, y2, z2, transform2 = []) {
  if (!transform2 && x2 === 0 && y2 === 0 && z2 === 0)
    return null;
  if (Array.isArray(transform2)) {
    let translateIndex = -1;
    const newTransform = [];
    for (let i2 = 0; i2 < transform2.length; i2++) {
      const t3 = transform2[i2];
      if (t3[0] === "translate") {
        if (t3[1] === x2 && t3[2] === y2)
          return null;
        translateIndex = i2;
        newTransform.push(["translate", x2, y2]);
      } else if (t3[0] === "translate3d") {
        if (t3[1] === x2 && t3[2] === y2 && t3[3] === z2)
          return null;
        translateIndex = i2;
        newTransform.push(["translate3d", x2, y2, z2 !== null && z2 !== void 0 ? z2 : 0]);
      } else {
        newTransform.push(t3);
      }
    }
    if (translateIndex === -1) {
      newTransform.splice(0, 0, isNumber(z2) ? ["translate3d", x2, y2, z2 !== null && z2 !== void 0 ? z2 : 0] : ["translate", x2, y2]);
    }
    if (newTransform.length === 0)
      return null;
    return newTransform;
  }
  const removedTranslate = transform2 ? transform2.replace(/translate(3d)?\([^)]*\)/g, "") : "";
  if (z2 === 0) {
    return `translate(${x2}, ${y2})${removedTranslate}`;
  } else {
    return `translate3d(${x2}, ${y2}, ${z2})${removedTranslate}`;
  }
}
var __rest$l = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
const executor = (element, keyframes, options) => {
  if (!options.length)
    return null;
  const [originalStyle, modifiedStyle] = keyframes;
  const getKeyframeStyle = (shapeID) => {
    var _a3;
    if (shapeID) {
      const shape = element.getShape(shapeID);
      if (!shape)
        return null;
      const name = `get${upperFirst(shapeID)}Style`;
      const styler = ((_a3 = element === null || element === void 0 ? void 0 : element[name]) === null || _a3 === void 0 ? void 0 : _a3.bind(element)) || ((attrs) => attrs);
      const fromStyle = (styler === null || styler === void 0 ? void 0 : styler(originalStyle)) || {};
      const toStyle = (styler === null || styler === void 0 ? void 0 : styler(modifiedStyle)) || {};
      return { shape, fromStyle, toStyle };
    } else {
      const shape = element;
      return { shape, fromStyle: originalStyle, toStyle: modifiedStyle };
    }
  };
  let mainResult;
  const subResults = options.map((_a3) => {
    var { fields, shape: shapeID, states: enabledStates } = _a3, effectTiming = __rest$l(_a3, ["fields", "shape", "states"]);
    const keyframeStyle = getKeyframeStyle(shapeID);
    if (!keyframeStyle)
      return null;
    const { shape, fromStyle, toStyle } = keyframeStyle;
    const keyframes2 = [{}, {}];
    fields.forEach((attr2) => {
      var _a4, _b;
      Object.assign(keyframes2[0], { [attr2]: (_a4 = fromStyle[attr2]) !== null && _a4 !== void 0 ? _a4 : inferDefaultValue(attr2) });
      Object.assign(keyframes2[1], { [attr2]: (_b = toStyle[attr2]) !== null && _b !== void 0 ? _b : inferDefaultValue(attr2) });
    });
    if (keyframes2.some((keyframe) => Object.keys(keyframe).some((attr2) => ["x", "y", "z"].includes(attr2)))) {
      const { x: x2 = 0, y: y2 = 0, z: z2, transform: transform2 = "" } = shape.attributes || {};
      keyframes2.forEach((keyframe) => {
        var _a4, _b, _c;
        keyframe.transform = replaceTranslateInTransform((_a4 = keyframe.x) !== null && _a4 !== void 0 ? _a4 : x2, (_b = keyframe.y) !== null && _b !== void 0 ? _b : y2, (_c = keyframe.z) !== null && _c !== void 0 ? _c : z2, transform2);
      });
    }
    const result2 = shape.animate(preprocessKeyframes(keyframes2), effectTiming);
    if (shapeID === void 0)
      mainResult = result2;
    return result2;
  }).filter(Boolean);
  const result = mainResult || (subResults === null || subResults === void 0 ? void 0 : subResults[0]);
  if (!result)
    return null;
  return createAnimationsProxy(result, subResults.filter((result2) => result2 !== result2));
};
const Fade = [{ fields: ["opacity"] }];
const Translate = [{ fields: ["x", "y"] }];
const NodeCollapse = [{ fields: ["x", "y"] }];
const NodeExpand = NodeCollapse;
const PathIn = [{ fields: ["sourceNode", "targetNode"] }];
const PathOut = PathIn;
const ComboCollapse = [{ fields: ["childrenNode", "x", "y"] }];
const ComboExpand = ComboCollapse;
function isEdgeData(data2) {
  if ("source" in data2 && "target" in data2)
    return true;
  return false;
}
function isVector2(vector) {
  return vector.length === 2;
}
function isPoint(p2) {
  if (p2 instanceof Float32Array)
    return true;
  if (Array.isArray(p2) && (p2.length === 2 || p2.length === 3)) {
    return p2.every((elem) => typeof elem === "number");
  }
  return false;
}
function isBetween(value, min2, max2) {
  return value >= min2 && value <= max2;
}
function parsePadding(padding = 0) {
  if (Array.isArray(padding)) {
    const [top = 0, right = top, bottom = top, left = right] = padding;
    return [top, right, bottom, left];
  }
  return [padding, padding, padding, padding];
}
function getVerticalPadding(padding = 0) {
  const parsedPadding = parsePadding(padding);
  return parsedPadding[0] + parsedPadding[2];
}
function getBBoxWidth(bbox) {
  return bbox.max[0] - bbox.min[0];
}
function getBBoxHeight(bbox) {
  return bbox.max[1] - bbox.min[1];
}
function getBBoxSize$1(bbox) {
  return [getBBoxWidth(bbox), getBBoxHeight(bbox)];
}
function getNodeBBox(node, padding) {
  const bbox = isPoint(node) ? getPointBBox(node) : node.getShape("key").getBounds();
  return padding ? getExpandedBBox(bbox, padding) : bbox;
}
function getPointBBox(point2) {
  const [x2, y2, z2 = 0] = point2;
  const bbox = new AABB();
  bbox.setMinMax([x2, y2, z2], [x2, y2, z2]);
  return bbox;
}
function getExpandedBBox(bbox, padding) {
  const [top, right, bottom, left] = parsePadding(padding);
  const [minX, minY, minZ] = bbox.min;
  const [maxX, maxY, maxZ] = bbox.max;
  const eBbox = new AABB();
  eBbox.setMinMax([minX - left, minY - top, minZ], [maxX + right, maxY + bottom, maxZ]);
  return eBbox;
}
function getCombinedBBox(bboxes) {
  if (bboxes.length === 0)
    return new AABB();
  if (bboxes.length === 1)
    return bboxes[0];
  const bbox = new AABB();
  bbox.setMinMax(bboxes[0].min, bboxes[0].max);
  for (let i2 = 1; i2 < bboxes.length; i2++) {
    const b2 = bboxes[i2];
    bbox.setMinMax([Math.min(bbox.min[0], b2.min[0]), Math.min(bbox.min[1], b2.min[1]), Math.min(bbox.min[2], b2.min[2])], [Math.max(bbox.max[0], b2.max[0]), Math.max(bbox.max[1], b2.max[1]), Math.max(bbox.max[2], b2.max[2])]);
  }
  return bbox;
}
function isBBoxInside(bbox1, bbox2) {
  const [minX1, minY1] = bbox1.min;
  const [maxX1, maxY1] = bbox1.max;
  const [minX2, minY2] = bbox2.min;
  const [maxX2, maxY2] = bbox2.max;
  return minX1 >= minX2 && maxX1 <= maxX2 && minY1 >= minY2 && maxY1 <= maxY2;
}
function isPointInBBox(point2, bbox) {
  return isBetween(point2[0], bbox.min[0], bbox.max[0]) && isBetween(point2[1], bbox.min[1], bbox.max[1]);
}
function isPointOnBBoxBoundary(point2, bbox, extended = false) {
  const { min: [minX, minY], max: [maxX, maxY] } = bbox;
  const onTopOrBottomLine = (point2[1] === minY || point2[1] === maxY) && (extended || isBetween(point2[0], minX, maxX));
  const onLeftOrRightLine = (point2[0] === minX || point2[0] === maxX) && (extended || isBetween(point2[1], minY, maxY));
  return onTopOrBottomLine || onLeftOrRightLine;
}
function isPointOutsideBBox(point2, bbox) {
  return !isPointInBBox(point2, bbox);
}
function isPointBBoxCenter(point2, bbox) {
  const { center } = bbox;
  return point2[0] === center[0] && point2[1] === center[1];
}
function getNearestBoundarySide(p2, bbox) {
  const [x2, y2] = p2;
  const [minX, minY] = bbox.min;
  const [maxX, maxY] = bbox.max;
  const left = x2 - minX;
  const right = maxX - x2;
  const top = y2 - minY;
  const bottom = maxY - y2;
  const min2 = Math.min(left, right, top, bottom);
  return min2 === left ? "left" : min2 === right ? "right" : min2 === top ? "top" : min2 === bottom ? "bottom" : "left";
}
function getNearestBoundaryPoint(p2, bbox) {
  const ref = clone$1(p2);
  if (isPointInBBox(p2, bbox)) {
    const side = getNearestBoundarySide(p2, bbox);
    switch (side) {
      case "left":
        ref[0] = bbox.min[0];
        break;
      case "right":
        ref[0] = bbox.max[0];
        break;
      case "top":
        ref[1] = bbox.min[1];
        break;
      case "bottom":
        ref[1] = bbox.max[1];
        break;
    }
  } else {
    const [x2, y2] = p2;
    const [minX, minY] = bbox.min;
    const [maxX, maxY] = bbox.max;
    ref[0] = isBetween(x2, minX, maxX) ? x2 : x2 < minX ? minX : maxX;
    ref[1] = isBetween(y2, minY, maxY) ? y2 : y2 < minY ? minY : maxY;
  }
  return ref;
}
function getTriangleCenter(bbox, direction2) {
  const { center } = bbox;
  const [width2, height] = getBBoxSize$1(bbox);
  const x2 = direction2 === "up" || direction2 === "down" ? center[0] : direction2 === "right" ? center[0] - width2 / 6 : center[0] + width2 / 6;
  const y2 = direction2 === "left" || direction2 === "right" ? center[1] : direction2 === "down" ? center[1] - height / 6 : center[1] + height / 6;
  return [x2, y2];
}
function getIncircleRadius(bbox, direction2) {
  let [w2, h2] = getBBoxSize$1(bbox);
  [w2, h2] = direction2 === "up" || direction2 === "down" ? [w2, h2] : [h2, w2];
  return (Math.pow(h2, 2) - Math.pow(Math.sqrt(Math.pow(w2 / 2, 2) + Math.pow(h2, 2)) - w2 / 2, 2)) / (2 * h2);
}
function getBBoxSegments(bbox) {
  const { min: [minX, minY], max: [maxX, maxY] } = bbox;
  const topLeftCorner = [minX, maxY];
  const topRightCorner = [maxX, maxY];
  const bottomRightCorner = [maxX, minY];
  const bottomLeftCorner = [minX, minY];
  const top = [topLeftCorner, topRightCorner];
  const right = [topRightCorner, bottomRightCorner];
  const bottom = [bottomRightCorner, bottomLeftCorner];
  const left = [bottomLeftCorner, topLeftCorner];
  return [top, right, bottom, left];
}
var defaultComparator = function defaultComparator2(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  return false;
};
var LinkedListNode = (
  /** @class */
  function() {
    function LinkedListNode2(value, next) {
      if (next === void 0) {
        next = null;
      }
      this.value = value;
      this.next = next;
    }
    LinkedListNode2.prototype.toString = function(callback) {
      return callback ? callback(this.value) : "".concat(this.value);
    };
    return LinkedListNode2;
  }()
);
var LinkedList = (
  /** @class */
  function() {
    function LinkedList2(comparator) {
      if (comparator === void 0) {
        comparator = defaultComparator;
      }
      this.head = null;
      this.tail = null;
      this.compare = comparator;
    }
    LinkedList2.prototype.prepend = function(value) {
      var newNode = new LinkedListNode(value, this.head);
      this.head = newNode;
      if (!this.tail) {
        this.tail = newNode;
      }
      return this;
    };
    LinkedList2.prototype.append = function(value) {
      var newNode = new LinkedListNode(value);
      if (!this.head) {
        this.head = newNode;
        this.tail = newNode;
        return this;
      }
      this.tail.next = newNode;
      this.tail = newNode;
      return this;
    };
    LinkedList2.prototype.delete = function(value) {
      if (!this.head) {
        return null;
      }
      var deleteNode = null;
      while (this.head && this.compare(this.head.value, value)) {
        deleteNode = this.head;
        this.head = this.head.next;
      }
      var currentNode = this.head;
      if (currentNode !== null) {
        while (currentNode.next) {
          if (this.compare(currentNode.next.value, value)) {
            deleteNode = currentNode.next;
            currentNode.next = currentNode.next.next;
          } else {
            currentNode = currentNode.next;
          }
        }
      }
      if (this.compare(this.tail.value, value)) {
        this.tail = currentNode;
      }
      return deleteNode;
    };
    LinkedList2.prototype.find = function(_a3) {
      var _b = _a3.value, value = _b === void 0 ? void 0 : _b, _c = _a3.callback, callback = _c === void 0 ? void 0 : _c;
      if (!this.head) {
        return null;
      }
      var currentNode = this.head;
      while (currentNode) {
        if (callback && callback(currentNode.value)) {
          return currentNode;
        }
        if (value !== void 0 && this.compare(currentNode.value, value)) {
          return currentNode;
        }
        currentNode = currentNode.next;
      }
      return null;
    };
    LinkedList2.prototype.deleteTail = function() {
      var deletedTail = this.tail;
      if (this.head === this.tail) {
        this.head = null;
        this.tail = null;
        return deletedTail;
      }
      var currentNode = this.head;
      while (currentNode.next) {
        if (!currentNode.next.next) {
          currentNode.next = null;
        } else {
          currentNode = currentNode.next;
        }
      }
      this.tail = currentNode;
      return deletedTail;
    };
    LinkedList2.prototype.deleteHead = function() {
      if (!this.head) {
        return null;
      }
      var deletedHead = this.head;
      if (this.head.next) {
        this.head = this.head.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      return deletedHead;
    };
    LinkedList2.prototype.fromArray = function(values2) {
      var _this2 = this;
      values2.forEach(function(value) {
        return _this2.append(value);
      });
      return this;
    };
    LinkedList2.prototype.toArray = function() {
      var nodes = [];
      var currentNode = this.head;
      while (currentNode) {
        nodes.push(currentNode);
        currentNode = currentNode.next;
      }
      return nodes;
    };
    LinkedList2.prototype.reverse = function() {
      var currentNode = this.head;
      var prevNode = null;
      var nextNode = null;
      while (currentNode) {
        nextNode = currentNode.next;
        currentNode.next = prevNode;
        prevNode = currentNode;
        currentNode = nextNode;
      }
      this.tail = this.head;
      this.head = prevNode;
    };
    LinkedList2.prototype.toString = function(callback) {
      if (callback === void 0) {
        callback = void 0;
      }
      return this.toArray().map(function(node) {
        return node.toString(callback);
      }).toString();
    };
    return LinkedList2;
  }()
);
var getNeighbors = function getNeighbors2(nodeId, edges, type) {
  if (edges === void 0) {
    edges = [];
  }
  var currentEdges = edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
  if (type === "target") {
    var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
      return edge.source === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
      return edge.target;
    });
  }
  if (type === "source") {
    var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
      return edge.target === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
      return edge.source;
    });
  }
  var neighhborsConverter = function neighhborsConverter2(edge) {
    return edge.source === nodeId ? edge.target : edge.source;
  };
  return currentEdges.map(neighhborsConverter);
};
var getOutEdgesNodeId = function getOutEdgesNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId;
  });
};
var getEdgesByNodeId = function getEdgesByNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
};
var degree = function degree2(graphData) {
  var degrees = {};
  var _a3 = graphData.nodes, nodes = _a3 === void 0 ? [] : _a3, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  nodes.forEach(function(node) {
    degrees[node.id] = {
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
  });
  edges.forEach(function(edge) {
    degrees[edge.source].degree++;
    degrees[edge.source].outDegree++;
    degrees[edge.target].degree++;
    degrees[edge.target].inDegree++;
  });
  return degrees;
};
var toString$1 = {}.toString;
var isType = function(value, type) {
  return toString$1.call(value) === "[object " + type + "]";
};
const isFunction = function(value) {
  return isType(value, "Function");
};
const isArray$1 = function(value) {
  return Array.isArray ? Array.isArray(value) : isType(value, "Array");
};
const isObject$1 = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};
function each$1(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray$1(elements)) {
    for (var i2 = 0, len2 = elements.length; i2 < len2; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject$1(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
const isString = function(str2) {
  return isType(str2, "String");
};
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(value);
    }
  });
  return result;
};
const memoize = function(f2, resolver) {
  if (!isFunction(f2)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = f2.apply(this, args);
    cache.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};
var ctx$1;
memoize(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize2 = font.fontSize, fontFamily2 = font.fontFamily, fontWeight2 = font.fontWeight, fontStyle2 = font.fontStyle, fontVariant2 = font.fontVariant;
  if (!ctx$1) {
    ctx$1 = document.createElement("canvas").getContext("2d");
  }
  ctx$1.font = [fontStyle2, fontVariant2, fontWeight2, fontSize2 + "px", fontFamily2].join(" ");
  return ctx$1.measureText(isString(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values(font)).join("");
});
var minVertex = function minVertex2(D2, nodes, marks) {
  var minDis = Infinity;
  var minNode;
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var nodeId = nodes[i2].id;
    if (!marks[nodeId] && D2[nodeId] <= minDis) {
      minDis = D2[nodeId];
      minNode = nodes[i2];
    }
  }
  return minNode;
};
var dijkstra = function dijkstra2(graphData, source, directed, weightPropertyName) {
  var _a3 = graphData.nodes, nodes = _a3 === void 0 ? [] : _a3, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var marks = {};
  var D2 = {};
  var prevs = {};
  nodes.forEach(function(node, i3) {
    var id2 = node.id;
    D2[id2] = Infinity;
    if (id2 === source) D2[id2] = 0;
  });
  var nodeNum = nodes.length;
  var _loop_1 = function _loop_12(i3) {
    var minNode = minVertex(D2, nodes, marks);
    var minNodeId = minNode.id;
    marks[minNodeId] = true;
    if (D2[minNodeId] === Infinity) return "continue";
    var relatedEdges = [];
    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);
    else relatedEdges = getEdgesByNodeId(minNodeId, edges);
    relatedEdges.forEach(function(edge) {
      var edgeTarget = edge.target;
      var edgeSource = edge.source;
      var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
      if (D2[w2] > D2[minNode.id] + weight) {
        D2[w2] = D2[minNode.id] + weight;
        prevs[w2] = [minNode.id];
      } else if (D2[w2] === D2[minNode.id] + weight) {
        prevs[w2].push(minNode.id);
      }
    });
  };
  for (var i2 = 0; i2 < nodeNum; i2++) {
    _loop_1();
  }
  prevs[source] = [source];
  var paths = {};
  for (var target in D2) {
    if (D2[target] !== Infinity) {
      findAllPaths(source, target, prevs, paths);
    }
  }
  var path = {};
  for (var target in paths) {
    path[target] = paths[target][0];
  }
  return {
    length: D2,
    path,
    allPath: paths
  };
};
function findAllPaths(source, target, prevs, foundPaths) {
  if (source === target) {
    return [source];
  }
  if (foundPaths[target]) {
    return foundPaths[target];
  }
  var paths = [];
  for (var _i = 0, _a3 = prevs[target]; _i < _a3.length; _i++) {
    var prev = _a3[_i];
    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);
    if (!prevPaths) return;
    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
      var prePath = prevPaths_1[_b];
      if (isArray$1(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));
      else paths.push([prePath, target]);
    }
  }
  foundPaths[target] = paths;
  return foundPaths[target];
}
var findShortestPath = function findShortestPath2(graphData, start, end, directed, weightPropertyName) {
  var _a3 = dijkstra(graphData, start, directed, weightPropertyName), length2 = _a3.length, path = _a3.path, allPath = _a3.allPath;
  return {
    length: length2[end],
    path: path[end],
    allPath: allPath[end]
  };
};
var DistanceType;
(function(DistanceType2) {
  DistanceType2["EuclideanDistance"] = "euclideanDistance";
})(DistanceType || (DistanceType = {}));
var pageRank = function pageRank2(graphData, epsilon2, linkProb) {
  if (typeof epsilon2 !== "number") epsilon2 = 1e-6;
  if (typeof linkProb !== "number") linkProb = 0.85;
  var distance2 = 1;
  var leakedRank = 0;
  var maxIterations = 1e3;
  var _a3 = graphData.nodes, nodes = _a3 === void 0 ? [] : _a3, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodesCount = nodes.length;
  var currentRank;
  var curRanks = {};
  var prevRanks = {};
  for (var j = 0; j < nodesCount; ++j) {
    var node = nodes[j];
    var nodeId = node.id;
    curRanks[nodeId] = 1 / nodesCount;
    prevRanks[nodeId] = 1 / nodesCount;
  }
  var nodeDegree = degree(graphData);
  while (maxIterations > 0 && distance2 > epsilon2) {
    leakedRank = 0;
    for (var j = 0; j < nodesCount; ++j) {
      var node = nodes[j];
      var nodeId = node.id;
      currentRank = 0;
      if (nodeDegree[node.id].inDegree === 0) {
        curRanks[nodeId] = 0;
      } else {
        var neighbors = getNeighbors(nodeId, edges, "source");
        for (var i2 = 0; i2 < neighbors.length; ++i2) {
          var neighbor = neighbors[i2];
          var outDegree = nodeDegree[neighbor].outDegree;
          if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;
        }
        curRanks[nodeId] = linkProb * currentRank;
        leakedRank += curRanks[nodeId];
      }
    }
    leakedRank = (1 - leakedRank) / nodesCount;
    distance2 = 0;
    for (var j = 0; j < nodesCount; ++j) {
      var node = nodes[j];
      var nodeId = node.id;
      currentRank = curRanks[nodeId] + leakedRank;
      distance2 += Math.abs(currentRank - prevRanks[nodeId]);
      prevRanks[nodeId] = currentRank;
    }
    maxIterations -= 1;
  }
  return prevRanks;
};
(function() {
  function Stack(maxStep) {
    if (maxStep === void 0) {
      maxStep = 10;
    }
    this.linkedList = new LinkedList();
    this.maxStep = maxStep;
  }
  Object.defineProperty(Stack.prototype, "length", {
    get: function get2() {
      return this.linkedList.toArray().length;
    },
    enumerable: false,
    configurable: true
  });
  Stack.prototype.isEmpty = function() {
    return !this.linkedList.head;
  };
  Stack.prototype.isMaxStack = function() {
    return this.toArray().length >= this.maxStep;
  };
  Stack.prototype.peek = function() {
    if (this.isEmpty()) {
      return null;
    }
    return this.linkedList.head.value;
  };
  Stack.prototype.push = function(value) {
    this.linkedList.prepend(value);
    if (this.length > this.maxStep) {
      this.linkedList.deleteTail();
    }
  };
  Stack.prototype.pop = function() {
    var removeHead = this.linkedList.deleteHead();
    return removeHead ? removeHead.value : null;
  };
  Stack.prototype.toArray = function() {
    return this.linkedList.toArray().map(function(node) {
      return node.value;
    });
  };
  Stack.prototype.clear = function() {
    while (!this.isEmpty()) {
      this.pop();
    }
  };
  return Stack;
})();
function idOf(data2) {
  if (data2.id !== void 0)
    return data2.id;
  if (data2.source !== void 0 && data2.target !== void 0)
    return `${data2.source}-${data2.target}`;
  throw new Error(format("The datum does not have available id."));
}
function parentIdOf(data2) {
  return data2.combo;
}
function idsOf(data2, flat) {
  const ids = {
    nodes: (data2.nodes || []).map(idOf),
    edges: (data2.edges || []).map(idOf),
    combos: (data2.combos || []).map(idOf)
  };
  return flat ? Object.values(ids).flat() : ids;
}
const getNodeCentralities = (graphData, getRelatedEdgesData, centrality) => {
  var _a3;
  switch (centrality.type) {
    case "degree": {
      const centralityResult = /* @__PURE__ */ new Map();
      (_a3 = graphData.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((node) => {
        const degree3 = getRelatedEdgesData(idOf(node), centrality.direction).length;
        centralityResult.set(idOf(node), degree3);
      });
      return centralityResult;
    }
    case "betweenness":
      return computeNodeBetweennessCentrality(graphData, centrality.directed, centrality.weightPropertyName);
    case "closeness":
      return computeNodeClosenessCentrality(graphData, centrality.directed, centrality.weightPropertyName);
    case "eigenvector":
      return computeNodeEigenvectorCentrality(graphData, centrality.directed);
    case "pagerank":
      return computeNodePageRankCentrality(graphData, centrality.epsilon, centrality.linkProb);
    default:
      return initCentralityResult(graphData);
  }
};
const initCentralityResult = (graphData) => {
  var _a3;
  const centralityResult = /* @__PURE__ */ new Map();
  (_a3 = graphData.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((node) => {
    centralityResult.set(idOf(node), 0);
  });
  return centralityResult;
};
const computeNodeBetweennessCentrality = (graphData, directed, weightPropertyName) => {
  const centralityResult = initCentralityResult(graphData);
  const { nodes = [] } = graphData;
  nodes.forEach((source) => {
    nodes.forEach((target) => {
      if (source !== target) {
        const { allPath } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);
        const pathCount = allPath.length;
        allPath.flat().forEach((nodeId) => {
          if (nodeId !== idOf(source) && nodeId !== idOf(target)) {
            centralityResult.set(nodeId, centralityResult.get(nodeId) + 1 / pathCount);
          }
        });
      }
    });
  });
  return centralityResult;
};
const computeNodeClosenessCentrality = (graphData, directed, weightPropertyName) => {
  const centralityResult = /* @__PURE__ */ new Map();
  const { nodes = [] } = graphData;
  nodes.forEach((source) => {
    const totalLength = nodes.reduce((acc, target) => {
      if (source !== target) {
        const { length: length2 } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);
        acc += length2;
      }
      return acc;
    }, 0);
    centralityResult.set(idOf(source), 1 / totalLength);
  });
  return centralityResult;
};
const computeNodePageRankCentrality = (graphData, epsilon2, linkProb) => {
  var _a3;
  const centralityResult = /* @__PURE__ */ new Map();
  const data2 = pageRank(graphData, epsilon2, linkProb);
  (_a3 = graphData.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((node) => {
    centralityResult.set(idOf(node), data2[idOf(node)]);
  });
  return centralityResult;
};
const computeNodeEigenvectorCentrality = (graphData, directed) => {
  const { nodes = [] } = graphData;
  const adjacencyMatrix = createAdjacencyMatrix(graphData, directed);
  const eigenvector = powerIteration(adjacencyMatrix, nodes.length);
  const centralityResult = /* @__PURE__ */ new Map();
  nodes.forEach((node, index2) => {
    centralityResult.set(idOf(node), eigenvector[index2]);
  });
  return centralityResult;
};
const createAdjacencyMatrix = (graphData, directed) => {
  const { nodes = [], edges = [] } = graphData;
  const matrix3 = Array(nodes.length).fill(null).map(() => Array(nodes.length).fill(0));
  edges.forEach(({ source, target }) => {
    const uIndex = nodes.findIndex((node) => idOf(node) === source);
    const vIndex = nodes.findIndex((node) => idOf(node) === target);
    if (directed) {
      matrix3[uIndex][vIndex] = 1;
    } else {
      matrix3[uIndex][vIndex] = 1;
      matrix3[vIndex][uIndex] = 1;
    }
  });
  return matrix3;
};
const powerIteration = (matrix3, numNodes, maxIterations = 100, tolerance2 = 1e-6) => {
  let eigenvector = Array(numNodes).fill(1);
  let diff = Infinity;
  for (let iter = 0; iter < maxIterations && diff > tolerance2; iter++) {
    const newEigenvector = Array(numNodes).fill(0);
    for (let i2 = 0; i2 < numNodes; i2++) {
      for (let j = 0; j < numNodes; j++) {
        newEigenvector[i2] += matrix3[i2][j] * eigenvector[j];
      }
    }
    const norm = Math.sqrt(newEigenvector.reduce((sum, val) => sum + val * val, 0));
    for (let i2 = 0; i2 < numNodes; i2++) {
      newEigenvector[i2] /= norm;
    }
    diff = Math.sqrt(newEigenvector.reduce((sum, val, index2) => sum + (val - eigenvector[index2]) * val, 0));
    eigenvector = newEigenvector;
  }
  return eigenvector;
};
function arrayDiff(original, modified, key, comparator = isEqual$1) {
  const originalMap = new Map(original.map((d3) => [key(d3), d3]));
  const modifiedMap = new Map(modified.map((d3) => [key(d3), d3]));
  const originalSet = new Set(originalMap.keys());
  const modifiedSet = new Set(modifiedMap.keys());
  const enter = [];
  const update = [];
  const exit = [];
  const keep = [];
  modifiedSet.forEach((key2) => {
    if (originalSet.has(key2)) {
      if (!comparator(originalMap.get(key2), modifiedMap.get(key2))) {
        update.push(modifiedMap.get(key2));
      } else {
        keep.push(modifiedMap.get(key2));
      }
    } else {
      enter.push(modifiedMap.get(key2));
    }
  });
  originalSet.forEach((key2) => {
    if (!modifiedSet.has(key2)) {
      exit.push(originalMap.get(key2));
    }
  });
  return { enter, exit, keep, update };
}
function setVisibility(shape, value, filter2) {
  const callback = (node) => {
    if (filter2 && !filter2(node))
      return;
    node.style.visibility = value;
  };
  shape.forEach((node) => {
    callback(node);
  });
}
function parseExtensions(graph2, category, extensions) {
  const counter = {};
  const getKey = (type) => {
    if (!(type in counter))
      counter[type] = 0;
    return `${category}-${type}-${counter[type]++}`;
  };
  return extensions.map((extension) => {
    if (typeof extension === "string") {
      return { type: extension, key: getKey(extension) };
    }
    if (typeof extension === "function") {
      return extension.call(graph2);
    }
    if (extension.key)
      return extension;
    return Object.assign(Object.assign({}, extension), { key: getKey(extension.type) });
  });
}
class ExtensionController {
  constructor(context) {
    this.extensions = [];
    this.extensionMap = {};
    this.context = context;
  }
  setExtensions(extensions) {
    const stdExtensions = parseExtensions(this.context.graph, this.category, extensions);
    const { enter, update, exit, keep } = arrayDiff(this.extensions, stdExtensions, (extension) => extension.key);
    this.createExtensions(enter);
    this.updateExtensions([...update, ...keep]);
    this.destroyExtensions(exit);
    this.extensions = stdExtensions;
  }
  createExtension(extension) {
    const { category } = this;
    const { key, type } = extension;
    const Ctor = getExtension(category, type);
    if (!Ctor)
      return print.warn(`The extension ${type} of ${category} is not registered.`);
    const instance = new Ctor(this.context, extension);
    instance.initialized = true;
    this.extensionMap[key] = instance;
  }
  createExtensions(extensions) {
    extensions.forEach((extension) => this.createExtension(extension));
  }
  updateExtension(extension) {
    const { key } = extension;
    const instance = this.extensionMap[key];
    if (instance) {
      instance.update(extension);
    }
  }
  updateExtensions(extensions) {
    extensions.forEach((extension) => this.updateExtension(extension));
  }
  destroyExtension(key) {
    const instance = this.extensionMap[key];
    if (!instance)
      return;
    if (instance.initialized && !instance.destroyed) {
      instance.destroy();
    }
    delete this.extensionMap[key];
  }
  destroyExtensions(extensions) {
    extensions.forEach(({ key }) => this.destroyExtension(key));
  }
  destroy() {
    this.destroyExtensions(this.extensions);
    this.context = {};
    this.extensions = [];
    this.extensionMap = {};
  }
}
class BaseExtension {
  constructor(context, options) {
    this.events = [];
    this.initialized = false;
    this.destroyed = false;
    this.context = context;
    this.options = options;
  }
  update(options) {
    this.options = Object.assign(this.options, options);
  }
  destroy() {
    this.context = {};
    this.options = {};
    this.destroyed = true;
  }
}
class BaseBehavior extends BaseExtension {
}
class AutoAdaptLabel extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, AutoAdaptLabel.defaultOptions, options));
    this.isOverlapping = (bbox, bboxes) => {
      return bboxes.some((b2) => bbox.intersects(b2));
    };
    this.occupiedBounds = [];
    this.detectLabelCollision = (elements) => {
      const viewport = this.context.viewport;
      const res = { show: [], hide: [] };
      this.occupiedBounds = [];
      elements.forEach((element) => {
        const labelBounds = element.getShape("label").getRenderBounds();
        if (viewport.isInViewport(labelBounds, true) && !this.isOverlapping(labelBounds, this.occupiedBounds)) {
          res.show.push(element);
          this.occupiedBounds.push(getExpandedBBox(labelBounds, this.options.padding));
        } else {
          res.hide.push(element);
        }
      });
      return res;
    };
    this.hideLabelIfExceedViewport = (prevElementsInView, currentElementsInView) => {
      const { exit } = arrayDiff(prevElementsInView, currentElementsInView, (d3) => d3.id);
      exit === null || exit === void 0 ? void 0 : exit.forEach(this.hideLabel);
    };
    this.nodeCentralities = /* @__PURE__ */ new Map();
    this.sortNodesByCentrality = (nodes, centrality) => {
      const { model } = this.context;
      const graphData = model.getData();
      const getRelatedEdgesData = model.getRelatedEdgesData.bind(model);
      const nodesWithCentrality = nodes.map((node) => {
        if (!this.nodeCentralities.has(node.id)) {
          this.nodeCentralities = getNodeCentralities(graphData, getRelatedEdgesData, centrality);
        }
        return { node, centrality: this.nodeCentralities.get(node.id) };
      });
      return nodesWithCentrality.sort((a2, b2) => b2.centrality - a2.centrality).map((item) => item.node);
    };
    this.sortLabelElementsInView = (labelElements) => {
      const { sort: sort2, sortNode, sortCombo, sortEdge } = this.options;
      const { model } = this.context;
      if (isFunction$1(sort2))
        return labelElements.sort((a2, b2) => sort2(model.getElementDataById(a2.id), model.getElementDataById(b2.id)));
      const { node: nodes = [], edge: edges = [], combo: combos = [] } = groupBy$1(labelElements, (el) => el.type);
      const sortedCombos = isFunction$1(sortCombo) ? combos.sort((a2, b2) => sortCombo(...model.getComboData([a2.id, b2.id]))) : combos;
      const sortedNodes = isFunction$1(sortNode) ? nodes.sort((a2, b2) => sortNode(...model.getNodeData([a2.id, b2.id]))) : this.sortNodesByCentrality(nodes, sortNode);
      const sortedEdges = isFunction$1(sortEdge) ? edges.sort((a2, b2) => sortEdge(...model.getEdgeData([a2.id, b2.id]))) : edges;
      return [...sortedCombos, ...sortedNodes, ...sortedEdges];
    };
    this.labelElementsInView = [];
    this.isFirstRender = true;
    this.onToggleVisibility = (event) => {
      var _a3;
      if (((_a3 = event.data) === null || _a3 === void 0 ? void 0 : _a3.stage) === "zIndex")
        return;
      if (!this.validate(event)) {
        if (this.hiddenElements.size > 0) {
          this.hiddenElements.forEach(this.showLabel);
          this.hiddenElements.clear();
        }
        return;
      }
      const labelElementsInView = this.isFirstRender ? this.getLabelElements() : this.getLabelElementsInView();
      this.hideLabelIfExceedViewport(this.labelElementsInView, labelElementsInView);
      this.labelElementsInView = labelElementsInView;
      const sortedElements = this.sortLabelElementsInView(this.labelElementsInView);
      const { show: show2, hide: hide2 } = this.detectLabelCollision(sortedElements);
      for (let i2 = show2.length - 1; i2 >= 0; i2--) {
        this.showLabel(show2[i2]);
      }
      hide2.forEach(this.hideLabel);
    };
    this.hiddenElements = /* @__PURE__ */ new Map();
    this.hideLabel = (element) => {
      const label = element.getShape("label");
      if (label)
        setVisibility(label, "hidden");
      this.hiddenElements.set(element.id, element);
    };
    this.showLabel = (element) => {
      const label = element.getShape("label");
      if (label)
        setVisibility(label, "visible");
      element.toFront();
      this.hiddenElements.delete(element.id);
    };
    this.onTransform = throttle(this.onToggleVisibility, this.options.throttle, { leading: true });
    this.enableToggle = true;
    this.toggle = (event) => {
      if (!this.enableToggle)
        return;
      this.onToggleVisibility(event);
    };
    this.onBeforeRender = () => {
      this.enableToggle = false;
    };
    this.onAfterRender = (event) => {
      this.onToggleVisibility(event);
      this.enableToggle = true;
    };
    this.bindEvents();
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
    this.onToggleVisibility({});
  }
  getLabelElements() {
    const { elementMap } = this.context.element;
    const elements = [];
    for (const key in elementMap) {
      const element = elementMap[key];
      if (element.isVisible() && element.getShape("label")) {
        elements.push(element);
      }
    }
    return elements;
  }
  getLabelElementsInView() {
    const viewport = this.context.viewport;
    return this.getLabelElements().filter((node) => viewport.isInViewport(node.getShape("key").getRenderBounds()));
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.BEFORE_RENDER, this.onBeforeRender);
    graph2.on(GraphEvent.AFTER_RENDER, this.onAfterRender);
    graph2.on(GraphEvent.AFTER_DRAW, this.toggle);
    graph2.on(GraphEvent.AFTER_LAYOUT, this.toggle);
    graph2.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.BEFORE_RENDER, this.onBeforeRender);
    graph2.off(GraphEvent.AFTER_RENDER, this.onAfterRender);
    graph2.off(GraphEvent.AFTER_DRAW, this.toggle);
    graph2.off(GraphEvent.AFTER_LAYOUT, this.toggle);
    graph2.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
AutoAdaptLabel.defaultOptions = {
  enable: true,
  throttle: 100,
  padding: 0,
  sortNode: { type: "degree" }
};
const VECTOR_ZERO = [0, 0, 0];
function add$4(a2, b2) {
  return a2.map((v2, i2) => v2 + b2[i2]);
}
function subtract(a2, b2) {
  return a2.map((v2, i2) => v2 - b2[i2]);
}
function multiply(a2, b2) {
  if (typeof b2 === "number")
    return a2.map((v2) => v2 * b2);
  return a2.map((v2, i2) => v2 * b2[i2]);
}
function divide(a2, b2) {
  if (typeof b2 === "number")
    return a2.map((v2) => v2 / b2);
  return a2.map((v2, i2) => v2 / b2[i2]);
}
function dot$1(a2, b2) {
  return a2.reduce((sum, v2, i2) => sum + v2 * b2[i2], 0);
}
function cross$1(a2, b2) {
  const a22 = toVector3(a2);
  const b22 = toVector3(b2);
  return [a22[1] * b22[2] - a22[2] * b22[1], a22[2] * b22[0] - a22[0] * b22[2], a22[0] * b22[1] - a22[1] * b22[0]];
}
function scale$1(a2, s3) {
  return a2.map((v2) => v2 * s3);
}
function distance$3(a2, b2) {
  return Math.sqrt(a2.reduce((sum, v2, i2) => sum + Math.pow(v2 - b2[i2] || 0, 2), 0));
}
function manhattanDistance(a2, b2) {
  return a2.reduce((sum, v2, i2) => sum + Math.abs(v2 - b2[i2]), 0);
}
function normalize$4(a2) {
  const length2 = a2.reduce((sum, v2) => sum + Math.pow(v2, 2), 0);
  return a2.map((v2) => v2 / Math.sqrt(length2));
}
function angle(a2, b2, clockwise = false) {
  const determinant2 = a2[0] * b2[1] - a2[1] * b2[0];
  let angle2 = Math.acos(multiply(a2, b2).reduce((sum, v2) => sum + v2, 0) / (distance$3(a2, VECTOR_ZERO) * distance$3(b2, VECTOR_ZERO)));
  if (clockwise && determinant2 < 0) {
    angle2 = 2 * Math.PI - angle2;
  }
  return angle2;
}
function perpendicular(a2, clockwise = true) {
  return clockwise ? [-a2[1], a2[0]] : [a2[1], -a2[0]];
}
function mod(a2, b2) {
  return a2.map((v2) => v2 % b2);
}
function toVector2(a2) {
  return [a2[0], a2[1]];
}
function toVector3(a2) {
  return isVector2(a2) ? [a2[0], a2[1], 0] : a2;
}
function rad2(a2) {
  const [x2, y2] = a2;
  if (!x2 && !y2)
    return 0;
  return Math.atan2(y2, x2);
}
function rotate2(a2, angle2) {
  const [dx, dy] = a2;
  if (angle2 % 360 === 0)
    return [dx, dy];
  const rad3 = angle2 * Math.PI / 180;
  const cos = Math.cos(rad3);
  const sin = Math.sin(rad3);
  return [dx * cos - dy * sin, dx * sin + dy * cos];
}
function isLinesParallel(l1, l2) {
  const [p1, p2] = l1;
  const [p3, p4] = l2;
  const v1 = subtract(p1, p2);
  const v2 = subtract(p3, p4);
  return cross$1(v1, v2).every((v3) => v3 === 0);
}
function getLinesIntersection(l1, l2, extended = false) {
  if (isLinesParallel(l1, l2))
    return void 0;
  const [p1, p2] = l1;
  const [p3, p4] = l2;
  const t3 = ((p1[0] - p3[0]) * (p3[1] - p4[1]) - (p1[1] - p3[1]) * (p3[0] - p4[0])) / ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));
  const u2 = p4[0] - p3[0] ? (p1[0] - p3[0] + t3 * (p2[0] - p1[0])) / (p4[0] - p3[0]) : (p1[1] - p3[1] + t3 * (p2[1] - p1[1])) / (p4[1] - p3[1]);
  if (!extended && (!isBetween(t3, 0, 1) || !isBetween(u2, 0, 1)))
    return void 0;
  return [p1[0] + t3 * (p2[0] - p1[0]), p1[1] + t3 * (p2[1] - p1[1])];
}
function parsePlacement(placement) {
  if (Array.isArray(placement)) {
    return isBetween(placement[0], 0, 1) && isBetween(placement[1], 0, 1) ? placement : [0.5, 0.5];
  }
  const direction2 = placement.split("-");
  const x2 = direction2.includes("left") ? 0 : direction2.includes("right") ? 1 : 0.5;
  const y2 = direction2.includes("top") ? 0 : direction2.includes("bottom") ? 1 : 0.5;
  return [x2, y2];
}
function positionOf(datum) {
  const { x: x2 = 0, y: y2 = 0, z: z2 = 0 } = datum.style || {};
  return [+x2, +y2, +z2];
}
function hasPosition(datum) {
  const { x: x2, y: y2, z: z2 } = datum.style || {};
  return x2 !== void 0 || y2 !== void 0 || z2 !== void 0;
}
function getXYByRelativePlacement(bbox, placement) {
  const [x2, y2] = placement;
  const { min: min2, max: max2 } = bbox;
  return [min2[0] + x2 * (max2[0] - min2[0]), min2[1] + y2 * (max2[1] - min2[1])];
}
function getXYByPlacement$1(bbox, placement = "center") {
  const relativePlacement = parsePlacement(placement);
  return getXYByRelativePlacement(bbox, relativePlacement);
}
function parsePoint(point2) {
  var _a3;
  return [point2.x, point2.y, (_a3 = point2.z) !== null && _a3 !== void 0 ? _a3 : 0];
}
function toPointObject(point2) {
  var _a3;
  return { x: point2[0], y: point2[1], z: (_a3 = point2[2]) !== null && _a3 !== void 0 ? _a3 : 0 };
}
function round$1(point2, digits = 0) {
  return point2.map((p2) => parseFloat(p2.toFixed(digits)));
}
function moveTo(p2, ref, distance2, reverse = false) {
  if (isEqual$1(p2, ref))
    return p2;
  const direction2 = reverse ? subtract(p2, ref) : subtract(ref, p2);
  const normalizedDirection = normalize$4(direction2);
  const moveVector = [normalizedDirection[0] * distance2, normalizedDirection[1] * distance2];
  return add$4(toVector2(p2), moveVector);
}
function isHorizontal$1(p1, p2) {
  return p1[1] === p2[1];
}
function isVertical(p1, p2) {
  return p1[0] === p2[0];
}
function isOrthogonal(p1, p2) {
  return isHorizontal$1(p1, p2) || isVertical(p1, p2);
}
function isCollinear(p1, p2, p3) {
  return isLinesParallel([p1, p2], [p2, p3]);
}
function getSymmetricPoint(p2, center) {
  return [2 * center[0] - p2[0], 2 * center[1] - p2[1]];
}
function getPolygonIntersectPoint(p2, center, points, isRelativePos = true, useExtendedLine = false) {
  for (let i2 = 0; i2 < points.length; i2++) {
    let start = points[i2];
    let end = points[(i2 + 1) % points.length];
    if (isRelativePos) {
      start = add$4(center, start);
      end = add$4(center, end);
    }
    const refP = useExtendedLine ? getSymmetricPoint(p2, center) : p2;
    const intersect2 = getLinesIntersection([center, refP], [start, end]);
    if (intersect2) {
      return {
        point: intersect2,
        line: [start, end]
      };
    }
  }
  return {
    point: center,
    line: void 0
  };
}
function isPointInPolygon(point2, points, start, end) {
  const x2 = point2[0];
  const y2 = point2[1];
  let inside = false;
  if (start === void 0)
    start = 0;
  if (end === void 0)
    end = points.length;
  const len2 = end - start;
  for (let i2 = 0, j = len2 - 1; i2 < len2; j = i2++) {
    const xi = points[i2 + start][0];
    const yi = points[i2 + start][1];
    const xj = points[j + start][0];
    const yj = points[j + start][1];
    const intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect2)
      inside = !inside;
  }
  return inside;
}
function getRectIntersectPoint(p2, bbox, useExtendedLine = false) {
  const center = getXYByPlacement$1(bbox, "center");
  const corners = [
    getXYByPlacement$1(bbox, "left-top"),
    getXYByPlacement$1(bbox, "right-top"),
    getXYByPlacement$1(bbox, "right-bottom"),
    getXYByPlacement$1(bbox, "left-bottom")
  ];
  return getPolygonIntersectPoint(p2, center, corners, false, useExtendedLine).point;
}
function getEllipseIntersectPoint(p2, bbox, useExtendedLine = false) {
  const center = bbox.center;
  const refP = useExtendedLine ? getSymmetricPoint(p2, center) : p2;
  const vec = subtract(refP, bbox.center);
  const angle2 = Math.atan2(vec[1], vec[0]);
  if (isNaN(angle2))
    return center;
  const rx = getBBoxWidth(bbox) / 2;
  const ry = getBBoxHeight(bbox) / 2;
  const intersectX = center[0] + rx * Math.cos(angle2);
  const intersectY = center[1] + ry * Math.sin(angle2);
  return [intersectX, intersectY];
}
function findNearestPoints(group1, group2) {
  let minDistance = Infinity;
  let nearestPoints = [group1[0], group2[0]];
  group1.forEach((p1) => {
    group2.forEach((p2) => {
      const dist2 = distance$3(p1, p2);
      if (dist2 < minDistance) {
        minDistance = dist2;
        nearestPoints = [p1, p2];
      }
    });
  });
  return nearestPoints;
}
function findNearestLine(point2, lines) {
  let minDistance = Infinity;
  let nearestLine = [
    [0, 0],
    [0, 0]
  ];
  lines.forEach((line2) => {
    const distance2 = getDistanceToLine(point2, line2);
    if (distance2 < minDistance) {
      minDistance = distance2;
      nearestLine = line2;
    }
  });
  return nearestLine;
}
function getDistanceToLine(point2, line2) {
  const nearestPoint2 = findNearestPointOnLine(point2, line2);
  return distance$3(point2, nearestPoint2);
}
function findNearestPointOnLine(point2, line2) {
  const [x1, y1] = line2[0];
  const [x2, y2] = line2[1];
  const [x3, y3] = point2;
  const px2 = x2 - x1;
  const py = y2 - y1;
  if (px2 === 0 && py === 0) {
    return [x1, y1];
  }
  let u2 = ((x3 - x1) * px2 + (y3 - y1) * py) / (px2 * px2 + py * py);
  if (u2 > 1) {
    u2 = 1;
  } else if (u2 < 0) {
    u2 = 0;
  }
  const x4 = x1 + u2 * px2;
  const y4 = y1 + u2 * py;
  return [x4, y4];
}
function centerOf(points) {
  const totalPosition = points.reduce((acc, p2) => add$4(acc, p2), [0, 0]);
  return divide(totalPosition, points.length);
}
function sortByClockwise(points, clockwise = true) {
  const center = centerOf(points);
  return points.sort(([x1, y1], [x2, y2]) => {
    const angle1 = Math.atan2(y1 - center[1], x1 - center[0]);
    const angle2 = Math.atan2(y2 - center[1], x2 - center[0]);
    return clockwise ? angle2 - angle1 : angle1 - angle2;
  });
}
function getBoundingPoints(start, end) {
  return [start, [start[0], end[1]], end, [end[0], start[1]]];
}
class PinchHandler {
  constructor(emitter, phase, callback) {
    this.phase = phase;
    this.pointerByTouch = [];
    this.initialDistance = null;
    this.emitter = emitter;
    if (PinchHandler.instance) {
      PinchHandler.callbacks[this.phase].push(callback);
      return PinchHandler.instance;
    }
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.bindEvents();
    PinchHandler.instance = this;
    PinchHandler.callbacks[this.phase].push(callback);
  }
  bindEvents() {
    const { emitter } = this;
    emitter.on(CommonEvent.POINTER_DOWN, this.onPointerDown);
    emitter.on(CommonEvent.POINTER_MOVE, this.onPointerMove);
    emitter.on(CommonEvent.POINTER_UP, this.onPointerUp);
  }
  /**
   * <zh/> 
   *
   * <en/> Update position of specified pointer
   * @param pointerId - <zh/>  | <en/> Pointer unique identifier<sup>1</sup>
   * @param x - <zh/> X | <en/> New X coordinate
   * @param y - <zh/> Y | <en/> New Y coordinate
   */
  updatePointerPosition(pointerId, x2, y2) {
    const index2 = this.pointerByTouch.findIndex((p2) => p2.pointerId === pointerId);
    if (index2 >= 0) {
      this.pointerByTouch[index2] = { x: x2, y: y2, pointerId };
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Handle pointer down event
   * @param event - <zh/>  | <en/> Pointer event object
   * @remarks
   * <zh/> 
   *
   * <en/> Record initial distance when detecting two touch points
   */
  onPointerDown(event) {
    const { x: x2, y: y2 } = event.client || {};
    if (x2 === void 0 || y2 === void 0)
      return;
    this.pointerByTouch.push({ x: x2, y: y2, pointerId: event.pointerId });
    if (event.pointerType === "touch" && this.pointerByTouch.length === 2) {
      PinchHandler.isPinching = true;
      const dx = this.pointerByTouch[0].x - this.pointerByTouch[1].x;
      const dy = this.pointerByTouch[0].y - this.pointerByTouch[1].y;
      this.initialDistance = Math.sqrt(dx * dx + dy * dy);
      PinchHandler.callbacks.pinchstart.forEach((cb) => cb(event, { scale: 0 }));
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Handle pointer move event
   * @param event - <zh/>  | <en/> Pointer event object
   * @remarks
   * <zh/> 
   *
   * <en/> Calculate zoom ratio when two valid touch points exist
   */
  onPointerMove(event) {
    if (this.pointerByTouch.length !== 2 || this.initialDistance === null)
      return;
    const { x: x2, y: y2 } = event.client || {};
    if (x2 === void 0 || y2 === void 0)
      return;
    this.updatePointerPosition(event.pointerId, x2, y2);
    const dx = this.pointerByTouch[0].x - this.pointerByTouch[1].x;
    const dy = this.pointerByTouch[0].y - this.pointerByTouch[1].y;
    const currentDistance = Math.sqrt(dx * dx + dy * dy);
    const ratio = currentDistance / this.initialDistance;
    PinchHandler.callbacks.pinchmove.forEach((cb) => cb(event, { scale: (ratio - 1) * 5 }));
  }
  /**
   * <zh/> 
   *
   * <en/> Handle pointer up event
   * @param event
   * @remarks
   * <zh/> 
   *
   * <en/> Reset touch state and initial distance
   */
  onPointerUp(event) {
    var _a3;
    PinchHandler.callbacks.pinchend.forEach((cb) => cb(event, { scale: 0 }));
    PinchHandler.isPinching = false;
    this.initialDistance = null;
    this.pointerByTouch = [];
    (_a3 = PinchHandler.instance) === null || _a3 === void 0 ? void 0 : _a3.tryDestroy();
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy pinch gesture listeners
   * @remarks
   * <zh/> 
   *
   * <en/> Remove listeners for pointer down, move, and up events
   */
  destroy() {
    this.emitter.off(CommonEvent.POINTER_DOWN, this.onPointerDown);
    this.emitter.off(CommonEvent.POINTER_MOVE, this.onPointerMove);
    this.emitter.off(CommonEvent.POINTER_UP, this.onPointerUp);
    PinchHandler.instance = null;
  }
  /**
   * <zh/> 
   * <en/> Unregister gesture callback for specific phase
   * @param phase - <zh/> (pinchstart)/(pinchmove)/(pinchend) | <en/> Gesture phase: start/move/end
   * @param callback - <zh/>  | <en/> Callback function to unregister
   * @remarks
   * <zh/> 
   * <en/> Remove specific callback from the phase's callback list, auto-destroy event listeners when all callbacks are unregistered
   */
  off(phase, callback) {
    const index2 = PinchHandler.callbacks[phase].indexOf(callback);
    if (index2 > -1)
      PinchHandler.callbacks[phase].splice(index2, 1);
    this.tryDestroy();
  }
  /**
   * <zh/> 
   * <en/> Attempt to destroy the gesture handler
   * @remarks
   * <zh/> //
   * <en/> Perform actual destruction when all phase (pinchstart/pinchmove/pinchend) callback lists are empty
   * <zh/> 
   * <en/> Automatically remove event listeners and reset singleton instance
   */
  tryDestroy() {
    if (Object.values(PinchHandler.callbacks).every((arr) => arr.length === 0)) {
      this.destroy();
    }
  }
}
PinchHandler.isPinching = false;
PinchHandler.instance = null;
PinchHandler.callbacks = { pinchstart: [], pinchmove: [], pinchend: [] };
const lowerCaseKeys = (keys) => keys.map((key) => isString$1(key) ? key.toLocaleLowerCase() : key);
class Shortcut {
  constructor(emitter) {
    this.map = /* @__PURE__ */ new Map();
    this.boundHandlePinch = () => {
    };
    this.recordKey = /* @__PURE__ */ new Set();
    this.onKeyDown = (event) => {
      if (!(event === null || event === void 0 ? void 0 : event.key))
        return;
      this.recordKey.add(event.key);
      this.trigger(event);
    };
    this.onKeyUp = (event) => {
      if (!(event === null || event === void 0 ? void 0 : event.key))
        return;
      this.recordKey.delete(event.key);
    };
    this.onWheel = (event) => {
      this.triggerExtendKey(CommonEvent.WHEEL, event);
    };
    this.onDrag = (event) => {
      this.triggerExtendKey(CommonEvent.DRAG, event);
    };
    this.handlePinch = (event, options) => {
      this.triggerExtendKey(CommonEvent.PINCH, Object.assign(Object.assign({}, event), options));
    };
    this.onFocus = () => {
      this.recordKey.clear();
    };
    this.emitter = emitter;
    this.bindEvents();
  }
  bind(key, handler) {
    if (key.length === 0)
      return;
    if (key.includes(CommonEvent.PINCH) && !this.pinchHandler) {
      this.boundHandlePinch = this.handlePinch.bind(this);
      this.pinchHandler = new PinchHandler(this.emitter, "pinchmove", this.boundHandlePinch);
    }
    this.map.set(key, handler);
  }
  unbind(key, handler) {
    this.map.forEach((h2, k) => {
      if (isEqual$1(k, key)) {
        if (!handler || handler === h2)
          this.map.delete(k);
      }
    });
  }
  unbindAll() {
    this.map.clear();
  }
  match(key) {
    const recordKeyList = lowerCaseKeys(Array.from(this.recordKey)).sort();
    const keyList = lowerCaseKeys(key).sort();
    return isEqual$1(recordKeyList, keyList);
  }
  bindEvents() {
    var _a3;
    const { emitter } = this;
    emitter.on(CommonEvent.KEY_DOWN, this.onKeyDown);
    emitter.on(CommonEvent.KEY_UP, this.onKeyUp);
    emitter.on(CommonEvent.WHEEL, this.onWheel);
    emitter.on(CommonEvent.DRAG, this.onDrag);
    (_a3 = globalThis.addEventListener) === null || _a3 === void 0 ? void 0 : _a3.call(globalThis, "focus", this.onFocus);
  }
  trigger(event) {
    this.map.forEach((handler, key) => {
      if (this.match(key))
        handler(event);
    });
  }
  /**
   * <zh/>  wheel, drag 
   *
   * <en/> Extend wheel, drag operations
   * @param eventType - event name
   * @param event - event
   */
  triggerExtendKey(eventType, event) {
    this.map.forEach((handler, key) => {
      if (key.includes(eventType)) {
        if (isEqual$1(Array.from(this.recordKey), key.filter((k) => k !== eventType))) {
          handler(event);
        }
      }
    });
  }
  destroy() {
    var _a3, _b;
    this.unbindAll();
    this.emitter.off(CommonEvent.KEY_DOWN, this.onKeyDown);
    this.emitter.off(CommonEvent.KEY_UP, this.onKeyUp);
    this.emitter.off(CommonEvent.WHEEL, this.onWheel);
    this.emitter.off(CommonEvent.DRAG, this.onDrag);
    (_a3 = this.pinchHandler) === null || _a3 === void 0 ? void 0 : _a3.off("pinchmove", this.boundHandlePinch);
    (_b = globalThis.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(globalThis, "focus", this.onFocus);
  }
}
class BrushSelect extends BaseBehavior {
  constructor(context, options) {
    super(context, deepMix({}, BrushSelect.defaultOptions, options));
    this.shortcut = new Shortcut(context.graph);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.clearStates = this.clearStates.bind(this);
    this.bindEvents();
  }
  /**
   * Triggered when the pointer is pressed
   * @param event - Pointer event
   * @internal
   */
  onPointerDown(event) {
    if (!this.validate(event) || !this.isKeydown() || this.startPoint)
      return;
    const { canvas: canvas2, graph: graph2 } = this.context;
    const style = Object.assign({}, this.options.style);
    if (this.options.style.lineWidth) {
      style.lineWidth = +this.options.style.lineWidth / graph2.getZoom();
    }
    this.rectShape = new Rect$1({ id: "g6-brush-select", style });
    canvas2.appendChild(this.rectShape);
    this.startPoint = [event.canvas.x, event.canvas.y];
  }
  /**
   * Triggered when the pointer is moved
   * @param event - Pointer event
   * @internal
   */
  onPointerMove(event) {
    var _a3;
    if (!this.startPoint)
      return;
    const { immediately, mode } = this.options;
    this.endPoint = getCursorPoint(event, this.context.graph);
    (_a3 = this.rectShape) === null || _a3 === void 0 ? void 0 : _a3.attr({
      x: Math.min(this.endPoint[0], this.startPoint[0]),
      y: Math.min(this.endPoint[1], this.startPoint[1]),
      width: Math.abs(this.endPoint[0] - this.startPoint[0]),
      height: Math.abs(this.endPoint[1] - this.startPoint[1])
    });
    if (immediately && mode === "default")
      this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));
  }
  /**
   * Triggered when the pointer is released
   * @param event - Pointer event
   * @internal
   */
  onPointerUp(event) {
    if (!this.startPoint)
      return;
    if (!this.endPoint) {
      this.clearBrush();
      return;
    }
    this.endPoint = getCursorPoint(event, this.context.graph);
    this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));
    this.clearBrush();
  }
  /**
   * <zh/> 
   *
   * <en/> Clear state
   * @internal
   */
  clearStates() {
    if (this.endPoint)
      return;
    this.clearElementsStates();
  }
  /**
   * <zh/> 
   *
   * <en/> Clear the state of all elements on the canvas
   * @internal
   */
  clearElementsStates() {
    const { graph: graph2 } = this.context;
    const states = Object.values(graph2.getData()).reduce((acc, data2) => {
      return Object.assign({}, acc, data2.reduce((acc2, datum) => {
        var _a3;
        const restStates = (_a3 = datum.states || []) === null || _a3 === void 0 ? void 0 : _a3.filter((state) => state !== this.options.state);
        acc2[idOf(datum)] = restStates;
        return acc2;
      }, {}));
    }, {});
    graph2.setElementState(states, this.options.animation);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the state of the selected elements
   * @param points - <zh/>  | <en/> The vertex of the selection area
   * @internal
   */
  updateElementsStates(points) {
    const { graph: graph2 } = this.context;
    const { enableElements, state, mode, onSelect } = this.options;
    const selectedIds = this.selector(graph2, points, enableElements);
    const states = {};
    switch (mode) {
      case "union":
        selectedIds.forEach((id2) => {
          states[id2] = [...graph2.getElementState(id2), state];
        });
        break;
      case "diff":
        selectedIds.forEach((id2) => {
          const prevStates = graph2.getElementState(id2);
          states[id2] = prevStates.includes(state) ? prevStates.filter((s3) => s3 !== state) : [...prevStates, state];
        });
        break;
      case "intersect":
        selectedIds.forEach((id2) => {
          const prevStates = graph2.getElementState(id2);
          states[id2] = prevStates.includes(state) ? [state] : [];
        });
        break;
      case "default":
      default:
        selectedIds.forEach((id2) => {
          states[id2] = [state];
        });
        break;
    }
    if (isFunction$1(onSelect))
      onSelect(states);
    graph2.setElementState(states, this.options.animation);
  }
  /**
   * <zh/>  combo combo 
   *
   * <en/> Find the elements displayed in the specified area on the canvas. A node is selected if the center of its bbox is inside the rect; An edge is selected if both end nodes are inside the rect ;A combo is selected if the center of its bbox is inside the rect.
   * @param graph - <zh/>  | <en/> Graph instance
   * @param points - <zh/>  | <en/> The vertex of the selection area
   * @param itemTypes - <zh/>  | <en/> Element type
   * @returns <zh/>  ID  | <en/> Selected element ID array
   * @internal
   */
  selector(graph2, points, itemTypes) {
    if (!itemTypes || itemTypes.length === 0)
      return [];
    const elements = [];
    const graphData = graph2.getData();
    itemTypes.forEach((itemType) => {
      graphData[`${itemType}s`].forEach((datum) => {
        const id2 = idOf(datum);
        if (graph2.getElementVisibility(id2) !== "hidden" && isPointInPolygon(graph2.getElementPosition(id2), points)) {
          elements.push(id2);
        }
      });
    });
    if (itemTypes.includes("edge")) {
      const edges = graphData.edges;
      edges === null || edges === void 0 ? void 0 : edges.forEach((edge) => {
        const { source, target } = edge;
        if (elements.includes(source) && elements.includes(target)) {
          elements.push(idOf(edge));
        }
      });
    }
    return elements;
  }
  clearBrush() {
    var _a3;
    (_a3 = this.rectShape) === null || _a3 === void 0 ? void 0 : _a3.remove();
    this.rectShape = void 0;
    this.startPoint = void 0;
    this.endPoint = void 0;
  }
  /**
   * <zh/>  trigger 
   *
   * <en/> Is the current key consistent with the trigger configuration
   * @returns <zh/>  | <en/> Is consistent
   * @internal
   */
  isKeydown() {
    const { trigger } = this.options;
    const keys = Array.isArray(trigger) ? trigger : [trigger];
    return this.shortcut.match(keys.filter((key) => key !== "drag"));
  }
  /**
   * <zh/> 
   *
   * <en/> Verify whether brush select is enabled
   * @param event - <zh/>  | <en/> Event
   * @returns <zh/>  | <en/> Whether to enable
   * @internal
   */
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(CommonEvent.POINTER_DOWN, this.onPointerDown);
    graph2.on(CommonEvent.POINTER_MOVE, this.onPointerMove);
    graph2.on(CommonEvent.POINTER_UP, this.onPointerUp);
    graph2.on(CanvasEvent.CLICK, this.clearStates);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(CommonEvent.POINTER_DOWN, this.onPointerDown);
    graph2.off(CommonEvent.POINTER_MOVE, this.onPointerMove);
    graph2.off(CommonEvent.POINTER_UP, this.onPointerUp);
    graph2.off(CanvasEvent.CLICK, this.clearStates);
  }
  /**
   * <zh/> 
   *
   * <en/> Update configuration
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    this.options = deepMix(this.options, options);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy
   * @internal
   */
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
BrushSelect.defaultOptions = {
  animation: false,
  enable: true,
  enableElements: ["node", "combo", "edge"],
  immediately: false,
  mode: "default",
  state: "selected",
  trigger: ["shift"],
  style: {
    width: 0,
    height: 0,
    lineWidth: 1,
    fill: "#1677FF",
    stroke: "#1677FF",
    fillOpacity: 0.1,
    zIndex: 2,
    pointerEvents: "none"
  }
};
const getCursorPoint = (event, graph2) => {
  if ((event.targetType === "node" || event.targetType === "combo") && !(event.nativeEvent.target instanceof HTMLCanvasElement)) {
    const [x2, y2] = graph2.getCanvasByClient([event.client.x, event.client.y]);
    return [x2, y2];
  }
  return [event.canvas.x, event.canvas.y];
};
const ICON_SIZE_RATIO = 0.8;
const ELEMENT_TYPES = ["node", "edge", "combo"];
function dfs$3(node, visitor, navigator, mode, depth = 0) {
  if (mode === "TB")
    visitor(node, depth);
  const children = navigator(node);
  if (children) {
    for (const child of children) {
      dfs$3(child, visitor, navigator, mode, depth + 1);
    }
  }
  if (mode === "BT")
    visitor(node, depth);
}
function bfs(node, visitor, navigator) {
  const queue = [[node, 0]];
  while (queue.length) {
    const [current2, depth] = queue.shift();
    visitor(current2, depth);
    const children = navigator(current2);
    if (children) {
      for (const child of children) {
        queue.push([child, depth + 1]);
      }
    }
  }
}
function getElementNthDegreeIds(graph2, elementType, elementId, degree3, direction2 = "both") {
  if (elementType === "combo" || elementType === "node") {
    return getNodeNthDegreeIds(graph2, elementId, degree3, direction2);
  }
  const edgeData = graph2.getEdgeData(elementId);
  if (!edgeData)
    return [];
  const sourceRelations = getNodeNthDegreeIds(graph2, edgeData.source, degree3 - 1, direction2);
  const targetRelations = getNodeNthDegreeIds(graph2, edgeData.target, degree3 - 1, direction2);
  return Array.from(/* @__PURE__ */ new Set([...sourceRelations, ...targetRelations, elementId]));
}
function getNodeNthDegreeIds(graph2, startNodeId, degree3, direction2 = "both") {
  const visitedNodes = /* @__PURE__ */ new Set();
  const visitedEdges = /* @__PURE__ */ new Set();
  const relations = /* @__PURE__ */ new Set();
  bfs(startNodeId, (nodeId, depth) => {
    if (depth > degree3)
      return;
    relations.add(nodeId);
    graph2.getRelatedEdgesData(nodeId, direction2).forEach((edge) => {
      const edgeId = idOf(edge);
      if (!visitedEdges.has(edgeId) && depth < degree3) {
        relations.add(edgeId);
        visitedEdges.add(edgeId);
      }
    });
  }, (nodeId) => {
    return graph2.getRelatedEdgesData(nodeId, direction2).map((edge) => edge.source === nodeId ? edge.target : edge.source).filter((neighborNodeId) => {
      if (!visitedNodes.has(neighborNodeId)) {
        visitedNodes.add(neighborNodeId);
        return true;
      }
      return false;
    });
  });
  return Array.from(relations);
}
function statesOf(datum) {
  return datum.states || [];
}
var __awaiter$p = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ClickSelect extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, ClickSelect.defaultOptions, options));
    this.onClickSelect = (event) => __awaiter$p(this, void 0, void 0, function* () {
      var _a3, _b;
      if (!this.validate(event))
        return;
      yield this.updateState(event);
      (_b = (_a3 = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a3, event);
    });
    this.onClickCanvas = (event) => __awaiter$p(this, void 0, void 0, function* () {
      var _a3, _b;
      if (!this.validate(event))
        return;
      yield this.clearState();
      (_b = (_a3 = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a3, event);
    });
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    this.unbindEvents();
    ELEMENT_TYPES.forEach((type) => {
      graph2.on(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);
    });
    graph2.on(CanvasEvent.CLICK, this.onClickCanvas);
  }
  get isMultipleSelect() {
    const { multiple, trigger } = this.options;
    return multiple && this.shortcut.match(trigger);
  }
  getNeighborIds(event) {
    const { target, targetType } = event;
    const { graph: graph2 } = this.context;
    const { degree: degree3 } = this.options;
    return getElementNthDegreeIds(graph2, targetType, target.id, typeof degree3 === "function" ? degree3(event) : degree3).filter((id2) => id2 !== target.id);
  }
  updateState(event) {
    return __awaiter$p(this, void 0, void 0, function* () {
      const { state: selectState, unselectedState, neighborState, animation } = this.options;
      if (!selectState && !neighborState && !unselectedState)
        return;
      const { target } = event;
      const { graph: graph2 } = this.context;
      const datum = graph2.getElementData(target.id);
      const type = statesOf(datum).includes(selectState) ? "unselect" : "select";
      const states = {};
      const isMultipleSelect = this.isMultipleSelect;
      const click = [target.id];
      const neighbor = this.getNeighborIds(event);
      if (!isMultipleSelect) {
        if (type === "select") {
          Object.assign(states, this.getClearStates(!!unselectedState));
          const addState = (list2, state) => {
            list2.forEach((id2) => {
              if (!states[id2])
                states[id2] = graph2.getElementState(id2);
              states[id2].push(state);
            });
          };
          addState(click, selectState);
          addState(neighbor, neighborState);
          if (unselectedState) {
            Object.keys(states).forEach((id2) => {
              if (!click.includes(id2) && !neighbor.includes(id2))
                states[id2].push(unselectedState);
            });
          }
        } else
          Object.assign(states, this.getClearStates());
      } else {
        Object.assign(states, this.getDataStates());
        if (type === "select") {
          const addState = (list2, state) => {
            list2.forEach((id2) => {
              const dataStatesSet = new Set(graph2.getElementState(id2));
              dataStatesSet.add(state);
              dataStatesSet.delete(unselectedState);
              states[id2] = Array.from(dataStatesSet);
            });
          };
          addState(click, selectState);
          addState(neighbor, neighborState);
          if (unselectedState) {
            Object.keys(states).forEach((id2) => {
              const _states = states[id2];
              if (!_states.includes(selectState) && !_states.includes(neighborState) && !_states.includes(unselectedState)) {
                states[id2].push(unselectedState);
              }
            });
          }
        } else {
          const targetState = states[target.id];
          states[target.id] = targetState.filter((s3) => s3 !== selectState && s3 !== neighborState);
          if (!targetState.includes(unselectedState))
            states[target.id].push(unselectedState);
          neighbor.forEach((id2) => {
            states[id2] = states[id2].filter((s3) => s3 !== neighborState);
            if (!states[id2].includes(selectState))
              states[id2].push(unselectedState);
          });
        }
      }
      yield graph2.setElementState(states, animation);
    });
  }
  getDataStates() {
    const { graph: graph2 } = this.context;
    const { nodes, edges, combos } = graph2.getData();
    const states = {};
    [...nodes, ...edges, ...combos].forEach((data2) => {
      states[idOf(data2)] = statesOf(data2);
    });
    return states;
  }
  /**
   * <zh/> 
   *
   * <en/> Get the states that need to be cleared
   * @param complete - <zh/>  | <en/> Whether to return all states
   * @returns - <zh/>  | <en/> States that need to be cleared
   */
  getClearStates(complete = false) {
    const { graph: graph2 } = this.context;
    const { state, unselectedState, neighborState } = this.options;
    const statesToClear = /* @__PURE__ */ new Set([state, unselectedState, neighborState]);
    const { nodes, edges, combos } = graph2.getData();
    const states = {};
    [...nodes, ...edges, ...combos].forEach((data2) => {
      const datumStates = statesOf(data2);
      const newStates = datumStates.filter((s3) => !statesToClear.has(s3));
      if (complete)
        states[idOf(data2)] = newStates;
      else if (newStates.length !== datumStates.length)
        states[idOf(data2)] = newStates;
    });
    return states;
  }
  clearState() {
    return __awaiter$p(this, void 0, void 0, function* () {
      const { graph: graph2 } = this.context;
      yield graph2.setElementState(this.getClearStates(), this.options.animation);
    });
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    ELEMENT_TYPES.forEach((type) => {
      graph2.off(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);
    });
    graph2.off(CanvasEvent.CLICK, this.onClickCanvas);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
ClickSelect.defaultOptions = {
  animation: true,
  enable: true,
  multiple: false,
  trigger: ["shift"],
  state: "selected",
  neighborState: "selected",
  unselectedState: void 0,
  degree: 0
};
function isCollapsed(nodeLike) {
  var _a3;
  return !!((_a3 = nodeLike.style) === null || _a3 === void 0 ? void 0 : _a3.collapsed);
}
function startsWith$1(str2, prefix) {
  if (!str2.startsWith(prefix))
    return false;
  const nextChart = str2[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
}
function addPrefix$1(str2, prefix) {
  return `${prefix}${upperFirst(str2)}`;
}
function removePrefix$1(string, prefix, lowercaseFirstLetter = true) {
  if (!prefix)
    return string;
  if (!startsWith$1(string, prefix))
    return string;
  const str2 = string.slice(prefix.length);
  return lowercaseFirstLetter ? lowerFirst(str2) : str2;
}
function subStyleProps$1(style, prefix) {
  const subStyle = Object.entries(style).reduce((acc, [key, value]) => {
    if (key === "className" || key === "class")
      return acc;
    if (startsWith$1(key, prefix)) {
      Object.assign(acc, { [removePrefix$1(key, prefix)]: value });
    }
    return acc;
  }, {});
  if ("opacity" in style) {
    const subOpacityKey = addPrefix$1("opacity", prefix);
    const opacity2 = style.opacity;
    if (subOpacityKey in style) {
      const subOpacity = style[subOpacityKey];
      Object.assign(subStyle, { opacity: opacity2 * subOpacity });
    } else
      Object.assign(subStyle, { opacity: opacity2 });
  }
  return subStyle;
}
function subObject(obj, prefix) {
  const prefixLength = prefix.length;
  return Object.keys(obj).reduce((acc, key) => {
    if (key.startsWith(prefix)) {
      const newKey = key.slice(prefixLength);
      acc[newKey] = obj[key];
    }
    return acc;
  }, {});
}
function omitStyleProps(style, prefix) {
  const prefixArray = typeof prefix === "string" ? [prefix] : prefix;
  const omitStyle = {};
  Object.keys(style).forEach((key) => {
    if (!prefixArray.find((p2) => key.startsWith(p2))) {
      omitStyle[key] = style[key];
    }
  });
  return omitStyle;
}
function parseSize$1(size = 0) {
  if (typeof size === "number")
    return [size, size, size];
  const [x2, y2 = x2, z2 = x2] = size;
  return [x2, y2, z2];
}
var __rest$k = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
function computeElementCallbackStyle(callableStyle, context) {
  const { datum, graph: graph2 } = context;
  if (typeof callableStyle === "function")
    return callableStyle.call(graph2, datum);
  return Object.fromEntries(Object.entries(callableStyle).map(([key, style]) => {
    if (typeof style === "function")
      return [key, style.call(graph2, datum)];
    return [key, style];
  }));
}
function mergeOptions(defaultOptions2, modifiedOptions) {
  const s1 = (defaultOptions2 === null || defaultOptions2 === void 0 ? void 0 : defaultOptions2.style) || {};
  const s22 = (modifiedOptions === null || modifiedOptions === void 0 ? void 0 : modifiedOptions.style) || {};
  for (const key in s1) {
    if (!(key in s22))
      s22[key] = s1[key];
  }
  return Object.assign({}, defaultOptions2, modifiedOptions, {
    style: s22
  });
}
function getSubShapeStyle(style) {
  const { x: x2, y: y2, z: z2, class: cls, className, transform: transform2, transformOrigin: transformOrigin2, zIndex: zIndex2, visibility: visibility2 } = style, rest = __rest$k(style, ["x", "y", "z", "class", "className", "transform", "transformOrigin", "zIndex", "visibility"]);
  return rest;
}
function inferIconStyle(size, iconStyle) {
  const stdSize = parseSize$1(size);
  let style = {};
  if (iconStyle.text && !iconStyle.fontSize)
    style = { fontSize: Math.min(...stdSize) * 0.5 };
  if (iconStyle.src && (!iconStyle.width || !iconStyle.height))
    style = { width: stdSize[0] * 0.5, height: stdSize[1] * 0.5 };
  return style;
}
function parsePalette(palette) {
  if (!palette)
    return void 0;
  if (
    //  palette name
    typeof palette === "string" || //  interpolate function
    typeof palette === "function" || //  color array
    Array.isArray(palette)
  ) {
    return {
      type: "group",
      field: (d3) => d3.id,
      color: palette,
      invert: false
    };
  }
  return palette;
}
function assignColorByPalette(data2, palette) {
  if (!palette)
    return {};
  const { type, color: colorPalette, field, invert: invert2 } = palette;
  const assignColor = (args) => {
    const palette2 = typeof colorPalette === "string" ? getExtension("palette", colorPalette) : colorPalette;
    if (typeof palette2 === "function") {
      const result = {};
      args.forEach(([id2, value]) => {
        result[id2] = palette2(invert2 ? 1 - value : value);
      });
      return result;
    } else if (Array.isArray(palette2)) {
      const colors = invert2 ? [...palette2].reverse() : palette2;
      const result = {};
      args.forEach(([id2, index2]) => {
        result[id2] = colors[index2 % palette2.length];
      });
      return result;
    }
    return {};
  };
  const parseField = (field2, datum) => {
    var _a3;
    return typeof field2 === "string" ? (_a3 = datum.data) === null || _a3 === void 0 ? void 0 : _a3[field2] : field2 === null || field2 === void 0 ? void 0 : field2(datum);
  };
  if (type === "group") {
    const groupData = groupBy$1(data2, (datum) => {
      if (!field)
        return "default";
      const key = parseField(field, datum);
      return key ? String(key) : "default";
    });
    const groupKeys = Object.keys(groupData);
    const assignResult = assignColor(groupKeys.map((key, index2) => [key, index2]));
    const result = {};
    Object.entries(groupData).forEach(([groupKey, groupData2]) => {
      groupData2.forEach((datum) => {
        result[idOf(datum)] = assignResult[groupKey];
      });
    });
    return result;
  } else if (type === "value") {
    const [min2, max2] = data2.reduce(([min3, max3], datum) => {
      const value = parseField(field, datum);
      if (typeof value !== "number")
        throw new Error(format(`Palette field ${field} is not a number`));
      return [Math.min(min3, value), Math.max(max3, value)];
    }, [Infinity, -Infinity]);
    const range = max2 - min2;
    return assignColor(data2.map((datum) => [datum.id, (parseField(field, datum) - min2) / range]));
  }
}
function getPaletteColors(colorPalette) {
  const palette = typeof colorPalette === "string" ? getExtension("palette", colorPalette) : colorPalette;
  if (typeof palette === "function")
    return void 0;
  return palette;
}
function getWordWrapWidthWithBase(length2, maxWidth) {
  let wordWrapWidth = 2 * length2;
  if (typeof maxWidth === "string") {
    wordWrapWidth = length2 * Number(maxWidth.replace("%", "")) / 100;
  } else if (typeof maxWidth === "number") {
    wordWrapWidth = maxWidth;
  }
  if (isNaN(wordWrapWidth))
    wordWrapWidth = 2 * length2;
  return wordWrapWidth;
}
function getWordWrapWidthByBox(keyShapeBox, maxWidth, zoom = 1, enableBalanceShape = false) {
  const balanceZoom = enableBalanceShape ? zoom : 1;
  const keyShapeWidth = (keyShapeBox.max[0] - keyShapeBox.min[0]) * balanceZoom;
  return getWordWrapWidthWithBase(keyShapeWidth, maxWidth);
}
function getWordWrapWidthByEnds(points, maxWidth, zoom = 1) {
  const dist2 = distance$3(points[0], points[1]) * zoom;
  return getWordWrapWidthWithBase(dist2, maxWidth);
}
class BaseShape extends CustomElement {
  constructor(options) {
    applyTransform(options.style);
    super(options);
    this.shapeMap = {};
    this.animateMap = {};
    this.render(this.attributes, this);
    this.setVisibility();
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> parsed attributes
   * @returns <zh/>  | <en/> parsed attributes
   * @internal
   */
  get parsedAttributes() {
    return this.attributes;
  }
  /**
   * <zh/> 
   *
   * <en/> create, update or remove shape
   * @param className - <zh/>  | <en/> shape name
   * @param Ctor - <zh/>  | <en/> shape type
   * @param style - <zh/>  false | <en/> shape style. Pass false to remove the shape
   * @param container - <zh/>  | <en/> container
   * @param hooks - <zh/>  | <en/> hooks
   * @returns <zh/>  | <en/> shape instance
   */
  upsert(className, Ctor, style, container, hooks) {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    const target = this.shapeMap[className];
    if (style === false) {
      if (target) {
        (_a3 = hooks === null || hooks === void 0 ? void 0 : hooks.beforeDestroy) === null || _a3 === void 0 ? void 0 : _a3.call(hooks, target);
        container.removeChild(target);
        delete this.shapeMap[className];
        (_b = hooks === null || hooks === void 0 ? void 0 : hooks.afterDestroy) === null || _b === void 0 ? void 0 : _b.call(hooks, target);
      }
      return;
    }
    const _Ctor = typeof Ctor === "string" ? getExtension(ExtensionCategory.SHAPE, Ctor) : Ctor;
    if (!_Ctor) {
      throw new Error(format(`Shape ${Ctor} not found`));
    }
    if (!target || target.destroyed || !(target instanceof _Ctor)) {
      if (target) {
        (_c = hooks === null || hooks === void 0 ? void 0 : hooks.beforeDestroy) === null || _c === void 0 ? void 0 : _c.call(hooks, target);
        target === null || target === void 0 ? void 0 : target.destroy();
        (_d = hooks === null || hooks === void 0 ? void 0 : hooks.afterDestroy) === null || _d === void 0 ? void 0 : _d.call(hooks, target);
      }
      (_e = hooks === null || hooks === void 0 ? void 0 : hooks.beforeCreate) === null || _e === void 0 ? void 0 : _e.call(hooks);
      const instance = new _Ctor({ className, style });
      container.appendChild(instance);
      this.shapeMap[className] = instance;
      (_f = hooks === null || hooks === void 0 ? void 0 : hooks.afterCreate) === null || _f === void 0 ? void 0 : _f.call(hooks, instance);
      return instance;
    }
    (_g = hooks === null || hooks === void 0 ? void 0 : hooks.beforeUpdate) === null || _g === void 0 ? void 0 : _g.call(hooks, target);
    updateStyle(target, style);
    (_h = hooks === null || hooks === void 0 ? void 0 : hooks.afterUpdate) === null || _h === void 0 ? void 0 : _h.call(hooks, target);
    return target;
  }
  update(attr2 = {}) {
    const attributes = Object.assign({}, this.attributes, attr2);
    applyTransform(attributes);
    setAttributes(this, attributes);
    this.render(attributes, this);
    this.setVisibility();
  }
  bindEvents() {
  }
  /**
   * <zh/> 
   *
   * <en/> Extracts the shape styles from a given attribute object.
   * Removes specific styles like position, transformation, and class name.
   * @param style - <zh/>  | <en/> attribute object
   * @returns <zh/>  | <en/> An object containing only the style properties.
   */
  getGraphicStyle(style) {
    return getSubShapeStyle(style);
  }
  /**
   * Get the prefix pairs for composite shapes used to handle animation
   * @returns tuples array where each tuple contains a key corresponding to a method `get${key}Style` and its shape prefix
   * @internal
   */
  get compositeShapes() {
    return [
      ["badges", "badge-"],
      ["ports", "port-"]
    ];
  }
  animate(keyframes, options) {
    if (keyframes.length === 0)
      return null;
    const animationMap = [];
    if (keyframes[0].x !== void 0 || keyframes[0].y !== void 0 || keyframes[0].z !== void 0) {
      const { x: _x = 0, y: _y = 0, z: _z = 0 } = this.attributes;
      keyframes.forEach((keyframe) => {
        const { x: x2 = _x, y: y2 = _y, z: z2 = _z } = keyframe;
        Object.assign(keyframe, { transform: z2 ? [["translate3d", x2, y2, z2]] : [["translate", x2, y2]] });
      });
    }
    const result = super.animate(keyframes, options);
    if (result) {
      releaseAnimation(this, result);
      animationMap.push(result);
    }
    if (Array.isArray(keyframes) && keyframes.length > 0) {
      const skippedAttrs = ["transform", "transformOrigin", "x", "y", "z", "zIndex"];
      if (Object.keys(keyframes[0]).some((attr2) => !skippedAttrs.includes(attr2))) {
        Object.entries(this.shapeMap).forEach(([key, shape]) => {
          const methodName = `get${upperFirst(key)}Style`;
          const method = this[methodName];
          if (isFunction$1(method)) {
            const subKeyframes = keyframes.map((style) => method.call(this, Object.assign(Object.assign({}, this.attributes), style)));
            const result2 = shape.animate(preprocessKeyframes(subKeyframes), options);
            if (result2) {
              releaseAnimation(shape, result2);
              animationMap.push(result2);
            }
          }
        });
        const handleCompositeShapeAnimation = (shapeSet, name) => {
          if (!isEmpty(shapeSet)) {
            const methodName = `get${upperFirst(name)}Style`;
            const method = this[methodName];
            if (isFunction$1(method)) {
              const itemsKeyframes = keyframes.map((style) => method.call(this, Object.assign(Object.assign({}, this.attributes), style)));
              Object.entries(itemsKeyframes[0]).map(([key]) => {
                const subKeyframes = itemsKeyframes.map((styles) => styles[key]);
                const shape = shapeSet[key];
                if (shape) {
                  const result2 = shape.animate(preprocessKeyframes(subKeyframes), options);
                  if (result2) {
                    releaseAnimation(shape, result2);
                    animationMap.push(result2);
                  }
                }
              });
            }
          }
        };
        this.compositeShapes.forEach(([key, prefix]) => {
          const shapeSet = subObject(this.shapeMap, prefix);
          handleCompositeShapeAnimation(shapeSet, key);
        });
      }
    }
    return createAnimationsProxy(animationMap);
  }
  getShape(name) {
    return this.shapeMap[name];
  }
  setVisibility() {
    const { visibility: visibility2 } = this.attributes;
    setVisibility(this, visibility2);
  }
  destroy() {
    this.shapeMap = {};
    this.animateMap = {};
    super.destroy();
  }
}
function releaseAnimation(target, animation) {
  animation === null || animation === void 0 ? void 0 : animation.finished.then(() => {
    const index2 = target.activeAnimations.findIndex((_2) => _2 === animation);
    if (index2 > -1)
      target.activeAnimations.splice(index2, 1);
  });
}
function applyTransform(style) {
  if (!style)
    return {};
  if ("x" in style || "y" in style || "z" in style) {
    const { x: x2 = 0, y: y2 = 0, z: z2, transform: transform2 } = style;
    const newTransform = replaceTranslateInTransform(x2, y2, z2, transform2);
    if (newTransform)
      style.transform = newTransform;
  }
  return style;
}
var __rest$j = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class Label extends BaseShape {
  constructor(options) {
    super(mergeOptions({ style: Label.defaultStyleProps }, options));
  }
  isTextStyle(key) {
    return startsWith$1(key, "label");
  }
  isBackgroundStyle(key) {
    return startsWith$1(key, "background");
  }
  getTextStyle(attributes) {
    const _a3 = this.getGraphicStyle(attributes), { padding } = _a3, style = __rest$j(_a3, ["padding"]);
    return omitStyleProps(style, "background");
  }
  getBackgroundStyle(attributes) {
    if (attributes.background === false)
      return false;
    const style = this.getGraphicStyle(attributes);
    const { wordWrap, wordWrapWidth, padding } = style;
    const backgroundStyle = subStyleProps$1(style, "background");
    const { min: [minX, minY], center: [centerX, centerY], halfExtents: [halfWidth, halfHeight] } = this.shapeMap.text.getGeometryBounds();
    const [top, right, bottom, left] = parsePadding(padding);
    const totalWidth = halfWidth * 2 + left + right;
    const { width: width2, height } = backgroundStyle;
    if (width2 && height) {
      Object.assign(backgroundStyle, { x: centerX - Number(width2) / 2, y: centerY - Number(height) / 2 });
    } else {
      Object.assign(backgroundStyle, {
        x: minX - left,
        y: minY - top,
        width: wordWrap ? Math.min(totalWidth, wordWrapWidth + left + right) : totalWidth,
        height: halfHeight * 2 + top + bottom
      });
    }
    const { radius } = backgroundStyle;
    if (typeof radius === "string" && radius.endsWith("%")) {
      const percentage = Number(radius.replace("%", "")) / 100;
      backgroundStyle.radius = Math.min(+backgroundStyle.width, +backgroundStyle.height) * percentage;
    }
    return backgroundStyle;
  }
  render(attributes = this.parsedAttributes, container = this) {
    this.upsert("text", Text$1, this.getTextStyle(attributes), container);
    this.upsert("background", Rect$1, this.getBackgroundStyle(attributes), container);
  }
  getGeometryBounds() {
    const shape = this.getShape("background") || this.getShape("text");
    return shape.getGeometryBounds();
  }
}
Label.defaultStyleProps = {
  padding: 0,
  fontSize: 12,
  fontFamily: "system-ui, sans-serif",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: 128,
  textOverflow: "...",
  textBaseline: "middle",
  backgroundOpacity: 0.75,
  backgroundZIndex: -1,
  backgroundLineWidth: 0
};
class Badge extends BaseShape {
  constructor(options) {
    super(mergeOptions({ style: Badge.defaultStyleProps }, options));
  }
  getBadgeStyle(attributes) {
    return this.getGraphicStyle(attributes);
  }
  render(attributes = this.parsedAttributes, container = this) {
    this.upsert("label", Label, this.getBadgeStyle(attributes), container);
  }
  getGeometryBounds() {
    const labelShape = this.getShape("label");
    const shape = labelShape.getShape("background") || labelShape.getShape("text");
    return shape.getGeometryBounds();
  }
}
Badge.defaultStyleProps = {
  padding: [2, 4, 2, 4],
  fontSize: 10,
  wordWrap: false,
  backgroundRadius: "50%",
  backgroundOpacity: 1
};
function pointsToPath(points, isClose = true) {
  const path = [];
  points.forEach((point2, index2) => {
    path.push([index2 === 0 ? "M" : "L", ...point2]);
  });
  if (isClose) {
    path.push(["Z"]);
  }
  return path;
}
const PATH_COMMANDS = {
  M: ["x", "y"],
  m: ["dx", "dy"],
  H: ["x"],
  h: ["dx"],
  V: ["y"],
  v: ["dy"],
  L: ["x", "y"],
  l: ["dx", "dy"],
  Z: [],
  z: [],
  C: ["x1", "y1", "x2", "y2", "x", "y"],
  c: ["dx1", "dy1", "dx2", "dy2", "dx", "dy"],
  S: ["x2", "y2", "x", "y"],
  s: ["dx2", "dy2", "dx", "dy"],
  Q: ["x1", "y1", "x", "y"],
  q: ["dx1", "dy1", "dx", "dy"],
  T: ["x", "y"],
  t: ["dx", "dy"],
  A: ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"],
  a: ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"]
};
function parsePath(path) {
  const items = path.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").trim().split(/\s*,|\s+/);
  const segments = [];
  let currentCommand = "";
  let currentElement = {};
  while (items.length > 0) {
    let it = items.shift();
    if (it in PATH_COMMANDS) {
      currentCommand = it;
    } else {
      items.unshift(it);
    }
    currentElement = { type: currentCommand };
    PATH_COMMANDS[currentCommand].forEach((prop) => {
      it = items.shift();
      currentElement[prop] = it;
    });
    if (currentCommand === "M") {
      currentCommand = "L";
    } else if (currentCommand === "m") {
      currentCommand = "l";
    }
    const [type, ...values2] = Object.values(currentElement);
    segments.push([type, ...values2.map(Number)]);
  }
  return segments;
}
function pathToPoints(path) {
  const points = [];
  const segments = typeof path === "string" ? parsePath(path) : path;
  segments.forEach((seg) => {
    const command = seg[0];
    if (command === "Z") {
      points.push(points[0]);
      return;
    }
    if (command !== "A") {
      for (let i2 = 1; i2 < seg.length; i2 = i2 + 2) {
        points.push([seg[i2], seg[i2 + 1], 0]);
      }
    } else {
      const length2 = seg.length;
      points.push([seg[length2 - 2], seg[length2 - 1], 0]);
    }
  });
  return points;
}
const getClosedSpline = (points) => {
  if (points.length < 2)
    return [
      ["M", 0, 0],
      ["L", 0, 0]
    ];
  const first = points[0];
  const second = points[1];
  const last = points[points.length - 1];
  const lastSecond = points[points.length - 2];
  points.unshift(lastSecond, last);
  points.push(first, second);
  const closedPath = [["M", last[0], last[1]]];
  for (let i2 = 1; i2 < points.length - 2; i2 += 1) {
    const [x0, y0] = points[i2 - 1];
    const [x1, y1] = points[i2];
    const [x2, y2] = points[i2 + 1];
    const [x3, y3] = i2 !== points.length - 2 ? points[i2 + 2] : [x2, y2];
    const cp1x = x1 + (x2 - x0) / 6;
    const cp1y = y1 + (y2 - y0) / 6;
    const cp2x = x2 - (x3 - x1) / 6;
    const cp2y = y2 - (y3 - y1) / 6;
    closedPath.push(["C", cp1x, cp1y, cp2x, cp2y, x2, y2]);
  }
  return closedPath;
};
function getPolygonTextStyleByPlacement(bounds, placement, offsetX, offsetY, closeToContour, path, autoRotate) {
  const [x2, y2] = getXYByPlacement$1(bounds, placement);
  const style = {
    textAlign: placement === "left" ? "right" : placement === "right" ? "left" : "center",
    textBaseline: placement === "top" ? "bottom" : placement === "bottom" ? "top" : "middle",
    transform: [["translate", x2 + offsetX, y2 + offsetY]]
  };
  if (placement === "center" || !closeToContour)
    return style;
  const points = pathToPoints(path);
  if (!points || points.length <= 3)
    return style;
  const lines = points.map((point2, index2) => {
    const p1 = point2;
    const p2 = points[(index2 + 1) % points.length];
    if (isEqual$1(p1, p2))
      return null;
    return [p1, p2];
  }).filter(Boolean);
  const line2 = findNearestLine([x2, y2], lines);
  const intersection = findNearestPointOnLine([x2, y2], line2);
  if (intersection && line2) {
    style.transform = [["translate", intersection[0] + offsetX, intersection[1] + offsetY]];
    if (autoRotate) {
      const angle2 = Math.atan((line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0]));
      style.transform.push(["rotate", angle2 / Math.PI * 180]);
      style.textAlign = "center";
      if (placement === "right" || placement === "left") {
        if (angle2 > 0) {
          style.textBaseline = placement === "right" ? "bottom" : "top";
        } else {
          style.textBaseline = placement === "right" ? "top" : "bottom";
        }
      }
    }
  }
  return style;
}
var __rest$i = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class Contour extends BaseShape {
  constructor(options) {
    super(mergeOptions({ style: Contour.defaultStyleProps }, options));
  }
  getLabelStyle(attributes) {
    if (!attributes.label || !attributes.d || attributes.d.length === 0)
      return false;
    const _a3 = subStyleProps$1(this.getGraphicStyle(attributes), "label"), { maxWidth, offsetX, offsetY, autoRotate, placement, closeToPath } = _a3, labelStyle = __rest$i(_a3, ["maxWidth", "offsetX", "offsetY", "autoRotate", "placement", "closeToPath"]);
    const key = this.shapeMap.key;
    const keyBounds = key === null || key === void 0 ? void 0 : key.getRenderBounds();
    return Object.assign(getPolygonTextStyleByPlacement(keyBounds, placement, offsetX, offsetY, closeToPath, attributes.d, autoRotate), { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) }, labelStyle);
  }
  getKeyStyle(attributes) {
    return this.getGraphicStyle(attributes);
  }
  render(attributes, container) {
    this.upsert("key", Path, this.getKeyStyle(attributes), container);
    this.upsert("label", Label, this.getLabelStyle(attributes), container);
  }
}
Contour.defaultStyleProps = {
  label: true,
  labelPlacement: "bottom",
  labelCloseToPath: true,
  labelAutoRotate: true,
  labelOffsetX: 0,
  labelOffsetY: 0
};
function getDescendantShapes(shape) {
  const succeeds = [];
  const traverse2 = (shape2) => {
    if (shape2 === null || shape2 === void 0 ? void 0 : shape2.children.length) {
      shape2.children.forEach((child) => {
        succeeds.push(child);
        traverse2(child);
      });
    }
  };
  traverse2(shape);
  return succeeds;
}
function getAncestorShapes(shape) {
  const ancestors = [];
  let currentNode = shape.parentNode;
  while (currentNode) {
    ancestors.push(currentNode);
    currentNode = currentNode.parentNode;
  }
  return ancestors;
}
let Image$2 = class Image2 extends Image$3 {
  constructor(options) {
    super(options);
    this.onMounted = () => {
      this.handleRadius();
    };
    this.onAttrModified = () => {
      this.handleRadius();
    };
    current = this;
    this.isMutationObserved = true;
    this.addEventListener(ElementEvent.MOUNTED, this.onMounted);
    this.addEventListener(ElementEvent.ATTR_MODIFIED, this.onAttrModified);
  }
  handleRadius() {
    const { radius, clipPath, width: width2 = 0, height = 0 } = this.attributes;
    if (radius && width2 && height) {
      const [x2, y2] = this.getBounds().min;
      const clipPathStyle = { x: x2, y: y2, radius, width: width2, height };
      if (clipPath) {
        Object.assign(this.parsedStyle.clipPath.style, clipPathStyle);
      } else {
        const rect2 = new Rect$1({ style: clipPathStyle });
        this.style.clipPath = rect2;
      }
    } else {
      if (clipPath)
        this.style.clipPath = null;
    }
  }
};
const ImagesWeakMap = /* @__PURE__ */ new WeakMap();
let current = null;
const connectImage = (target) => {
  if (current && getAncestorShapes(current).includes(target)) {
    const images = ImagesWeakMap.get(target);
    if (images) {
      if (!images.includes(current))
        images.push(current);
    } else
      ImagesWeakMap.set(target, [current]);
  }
};
const dispatchPositionChange = (target) => {
  const image2 = ImagesWeakMap.get(target);
  if (image2) {
    image2.forEach((i2) => i2.handleRadius());
  }
};
class Icon extends BaseShape {
  constructor(options) {
    super(options);
  }
  isImage() {
    const { src } = this.attributes;
    return !!src;
  }
  getIconStyle(attributes = this.attributes) {
    const { width: width2 = 0, height = 0 } = attributes;
    const style = this.getGraphicStyle(attributes);
    if (this.isImage()) {
      return Object.assign({ x: -width2 / 2, y: -height / 2 }, style);
    }
    return Object.assign({ textBaseline: "middle", textAlign: "center" }, style);
  }
  render(attributes = this.attributes, container = this) {
    this.upsert("icon", this.isImage() ? Image$2 : Text$1, this.getIconStyle(attributes), container);
  }
}
class BaseElement extends BaseShape {
  get context() {
    return this.config.context;
  }
  get parsedAttributes() {
    return this.attributes;
  }
  /**
   * <zh/> 
   *
   * <en/> Animation frame execution function
   */
  onframe() {
  }
  animate(keyframes, options) {
    const animation = super.animate(keyframes, options);
    if (animation) {
      animation.onframe = () => this.onframe();
      animation.finished.then(() => this.onframe());
    }
    return animation;
  }
}
var __rest$h = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class BaseNode extends BaseElement {
  constructor(options) {
    super(mergeOptions({ style: BaseNode.defaultStyleProps }, options));
    this.type = "node";
  }
  getSize(attributes = this.attributes) {
    const { size } = attributes;
    return parseSize$1(size);
  }
  getKeyStyle(attributes) {
    const style = this.getGraphicStyle(attributes);
    return Object.assign(omitStyleProps(style, ["label", "halo", "icon", "badge", "port"]));
  }
  getLabelStyle(attributes) {
    if (attributes.label === false || !attributes.labelText)
      return false;
    const _a3 = subStyleProps$1(this.getGraphicStyle(attributes), "label"), { placement, maxWidth, offsetX, offsetY } = _a3, labelStyle = __rest$h(_a3, ["placement", "maxWidth", "offsetX", "offsetY"]);
    const keyBounds = this.getShape("key").getLocalBounds();
    return Object.assign(getTextStyleByPlacement(keyBounds, placement, offsetX, offsetY), { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) }, labelStyle);
  }
  getHaloStyle(attributes) {
    if (attributes.halo === false)
      return false;
    const _a3 = this.getKeyStyle(attributes), { fill } = _a3, keyStyle = __rest$h(_a3, ["fill"]);
    const haloStyle = subStyleProps$1(this.getGraphicStyle(attributes), "halo");
    return Object.assign(Object.assign(Object.assign({}, keyStyle), { stroke: fill }), haloStyle);
  }
  getIconStyle(attributes) {
    if (attributes.icon === false || !attributes.iconText && !attributes.iconSrc)
      return false;
    const iconStyle = subStyleProps$1(this.getGraphicStyle(attributes), "icon");
    return Object.assign(inferIconStyle(attributes.size, iconStyle), iconStyle);
  }
  getBadgesStyle(attributes) {
    var _a3;
    const badges = subObject(this.shapeMap, "badge-");
    const badgesShapeStyle = {};
    Object.keys(badges).forEach((key) => {
      badgesShapeStyle[key] = false;
    });
    if (attributes.badge === false || !((_a3 = attributes.badges) === null || _a3 === void 0 ? void 0 : _a3.length))
      return badgesShapeStyle;
    const { badges: badgeOptions = [], badgePalette, opacity: opacity2 = 1 } = attributes, restAttributes = __rest$h(attributes, ["badges", "badgePalette", "opacity"]);
    const colors = getPaletteColors(badgePalette);
    const badgeStyle = subStyleProps$1(this.getGraphicStyle(restAttributes), "badge");
    badgeOptions.forEach((option, i2) => {
      badgesShapeStyle[i2] = Object.assign(Object.assign({ backgroundFill: colors ? colors[i2 % (colors === null || colors === void 0 ? void 0 : colors.length)] : void 0, opacity: opacity2 }, badgeStyle), this.getBadgeStyle(option));
    });
    return badgesShapeStyle;
  }
  getBadgeStyle(style) {
    const keyShape = this.getShape("key");
    const { placement = "top", offsetX, offsetY } = style, restStyle = __rest$h(style, ["placement", "offsetX", "offsetY"]);
    const textStyle = getTextStyleByPlacement(keyShape.getLocalBounds(), placement, offsetX, offsetY, true);
    return Object.assign(Object.assign({}, textStyle), restStyle);
  }
  getPortsStyle(attributes) {
    var _a3;
    const ports = this.getPorts();
    const portsShapeStyle = {};
    Object.keys(ports).forEach((key) => {
      portsShapeStyle[key] = false;
    });
    if (attributes.port === false || !((_a3 = attributes.ports) === null || _a3 === void 0 ? void 0 : _a3.length))
      return portsShapeStyle;
    const portStyle = subStyleProps$1(this.getGraphicStyle(attributes), "port");
    const { ports: portOptions = [] } = attributes;
    portOptions.forEach((option, index2) => {
      const key = option.key || index2;
      const mergedStyle = Object.assign(Object.assign({}, portStyle), option);
      if (isSimplePort(mergedStyle)) {
        portsShapeStyle[key] = false;
      } else {
        const [x2, y2] = this.getPortXY(attributes, option);
        portsShapeStyle[key] = Object.assign({ transform: [["translate", x2, y2]] }, mergedStyle);
      }
    });
    return portsShapeStyle;
  }
  getPortXY(attributes, style) {
    const { placement = "left" } = style;
    const keyShape = this.getShape("key");
    return getPortXYByPlacement(getBoundsInOffscreen(this.context, keyShape), placement);
  }
  /**
   * Get the ports for the node.
   * @returns Ports shape map.
   */
  getPorts() {
    return subObject(this.shapeMap, "port-");
  }
  /**
   * Get the center point of the node.
   * @returns The center point of the node.
   */
  getCenter() {
    return this.getShape("key").getBounds().center;
  }
  /**
   * Get the point on the outer contour of the node that is the intersection with a line starting in the center the ending in the point `p`.
   * @param point - The point to intersect with the node.
   * @param useExtendedLine - Whether to use the extended line.
   * @returns The intersection point.
   */
  getIntersectPoint(point2, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getRectIntersectPoint(point2, keyShapeBounds, useExtendedLine);
  }
  drawHaloShape(attributes, container) {
    const style = this.getHaloStyle(attributes);
    const keyShape = this.getShape("key");
    this.upsert("halo", keyShape.constructor, style, container);
  }
  drawIconShape(attributes, container) {
    const style = this.getIconStyle(attributes);
    this.upsert("icon", Icon, style, container);
    connectImage(this);
  }
  drawBadgeShapes(attributes, container) {
    const badgesStyle = this.getBadgesStyle(attributes);
    Object.keys(badgesStyle).forEach((key) => {
      const style = badgesStyle[key];
      this.upsert(`badge-${key}`, Badge, style, container);
    });
  }
  drawPortShapes(attributes, container) {
    const portsStyle = this.getPortsStyle(attributes);
    Object.keys(portsStyle).forEach((key) => {
      const style = portsStyle[key];
      const shapeKey = `port-${key}`;
      this.upsert(shapeKey, Circle$2, style, container);
    });
  }
  drawLabelShape(attributes, container) {
    const style = this.getLabelStyle(attributes);
    this.upsert("label", Label, style, container);
  }
  //  / Used to decorate abstract methods
  _drawKeyShape(attributes, container) {
    return this.drawKeyShape(attributes, container);
  }
  render(attributes = this.parsedAttributes, container = this) {
    this._drawKeyShape(attributes, container);
    if (!this.getShape("key"))
      return;
    this.drawHaloShape(attributes, container);
    this.drawIconShape(attributes, container);
    this.drawBadgeShapes(attributes, container);
    this.drawLabelShape(attributes, container);
    this.drawPortShapes(attributes, container);
  }
  update(attr2) {
    super.update(attr2);
    if (attr2 && ("x" in attr2 || "y" in attr2 || "z" in attr2)) {
      dispatchPositionChange(this);
    }
  }
  onframe() {
    this.drawBadgeShapes(this.parsedAttributes, this);
    this.drawLabelShape(this.parsedAttributes, this);
  }
}
BaseNode.defaultStyleProps = {
  x: 0,
  y: 0,
  size: 32,
  droppable: true,
  draggable: true,
  port: true,
  ports: [],
  portZIndex: 2,
  portLinkToCenter: false,
  badge: true,
  badges: [],
  badgeZIndex: 3,
  halo: false,
  haloDroppable: false,
  haloLineDash: 0,
  haloLineWidth: 12,
  haloStrokeOpacity: 0.25,
  haloPointerEvents: "none",
  haloZIndex: -1,
  icon: true,
  iconZIndex: 1,
  label: true,
  labelIsBillboard: true,
  labelMaxWidth: "200%",
  labelPlacement: "bottom",
  labelWordWrap: false,
  labelZIndex: 0
};
function getBoundsInOffscreen(context, shape) {
  if (!context)
    return shape.getLocalBounds();
  const canvas2 = context.canvas.getLayer();
  const substitute2 = shape.cloneNode();
  setVisibility(substitute2, "hidden");
  canvas2.appendChild(substitute2);
  const bounds = substitute2.getLocalBounds();
  substitute2.destroy();
  return bounds;
}
let Circle$1 = class Circle extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: Circle.defaultStyleProps }, options));
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Circle$2, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    return Object.assign(Object.assign({}, keyStyle), { r: Math.min(...this.getSize(attributes)) / 2 });
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const { r: r2 } = this.getShape("key").attributes;
    const size = r2 * 2 * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size, height: size }, style) : false;
  }
  getIntersectPoint(point2, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getEllipseIntersectPoint(point2, keyShapeBounds, useExtendedLine);
  }
};
Circle$1.defaultStyleProps = {
  size: 32
};
class Polygon extends BaseNode {
  constructor(options) {
    super(options);
  }
  get parsedAttributes() {
    return this.attributes;
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Polygon$1, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    return Object.assign(Object.assign({}, keyStyle), { points: this.getPoints(attributes) });
  }
  getIntersectPoint(point2, useExtendedLine = false) {
    var _a3, _b;
    const { points } = this.getShape("key").attributes;
    const center = [+(((_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.x) || 0), +(((_b = this.attributes) === null || _b === void 0 ? void 0 : _b.y) || 0)];
    return getPolygonIntersectPoint(point2, center, points, true, useExtendedLine).point;
  }
}
class Diamond extends Polygon {
  constructor(options) {
    super(options);
  }
  getPoints(attributes) {
    const [width2, height] = this.getSize(attributes);
    return getDiamondPoints(width2, height);
  }
}
var __rest$g = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class Donut extends Circle$1 {
  constructor(options) {
    super(mergeOptions({ style: Donut.defaultStyleProps }, options));
  }
  parseOuterR() {
    const { size } = this.parsedAttributes;
    return Math.min(...parseSize$1(size)) / 2;
  }
  parseInnerR() {
    const { innerR } = this.parsedAttributes;
    return isString$1(innerR) ? parseInt(innerR) / 100 * this.parseOuterR() : innerR;
  }
  drawDonutShape(attributes, container) {
    const { donuts } = attributes;
    if (!(donuts === null || donuts === void 0 ? void 0 : donuts.length))
      return;
    const parsedDonuts = donuts.map((round2) => isNumber(round2) ? { value: round2 } : round2);
    const style = subStyleProps$1(this.getGraphicStyle(attributes), "donut");
    const colors = getPaletteColors(attributes.donutPalette);
    if (!colors)
      return;
    const sum = parsedDonuts.reduce((acc, cur) => {
      var _a3;
      return acc + ((_a3 = cur.value) !== null && _a3 !== void 0 ? _a3 : 0);
    }, 0);
    const outerR = this.parseOuterR();
    const innerR = this.parseInnerR();
    let start = 0;
    parsedDonuts.forEach((round2, index2) => {
      const { value = 0, color: color2 = colors[index2 % colors.length] } = round2, roundStyle = __rest$g(round2, ["value", "color"]);
      const angle2 = (sum === 0 ? 1 / parsedDonuts.length : value / sum) * 360;
      this.upsert(`round${index2}`, Path, Object.assign(Object.assign(Object.assign({}, style), { d: arc(outerR, innerR, start, start + angle2), fill: color2 }), roundStyle), container);
      start += angle2;
    });
  }
  render(attributes, container = this) {
    super.render(attributes, container);
    this.drawDonutShape(attributes, container);
  }
}
Donut.defaultStyleProps = {
  innerR: "50%",
  donuts: [],
  donutPalette: "tableau"
};
const point$2 = (x2, y2, r2, angel) => [x2 + Math.sin(angel) * r2, y2 - Math.cos(angel) * r2];
const full = (x2, y2, R2, r2) => {
  if (r2 <= 0 || R2 <= r2) {
    return [["M", x2 - R2, y2], ["A", R2, R2, 0, 1, 1, x2 + R2, y2], ["A", R2, R2, 0, 1, 1, x2 - R2, y2], ["Z"]];
  }
  return [
    ["M", x2 - R2, y2],
    ["A", R2, R2, 0, 1, 1, x2 + R2, y2],
    ["A", R2, R2, 0, 1, 1, x2 - R2, y2],
    ["Z"],
    ["M", x2 + r2, y2],
    ["A", r2, r2, 0, 1, 0, x2 - r2, y2],
    ["A", r2, r2, 0, 1, 0, x2 + r2, y2],
    ["Z"]
  ];
};
const part = (x2, y2, R2, r2, start, end) => {
  const [s3, e3] = [start / 360 * 2 * Math.PI, end / 360 * 2 * Math.PI];
  const P2 = [point$2(x2, y2, r2, s3), point$2(x2, y2, R2, s3), point$2(x2, y2, R2, e3), point$2(x2, y2, r2, e3)];
  const flag = e3 - s3 > Math.PI ? 1 : 0;
  return [
    ["M", P2[0][0], P2[0][1]],
    ["L", P2[1][0], P2[1][1]],
    ["A", R2, R2, 0, flag, 1, P2[2][0], P2[2][1]],
    ["L", P2[3][0], P2[3][1]],
    ["A", r2, r2, 0, flag, 0, P2[0][0], P2[0][1]],
    ["Z"]
  ];
};
const arc = (R2 = 0, r2 = 0, start, end) => {
  const [x2, y2] = [0, 0];
  if (Math.abs(start - end) % 360 < 1e-6)
    return full(x2, y2, R2, r2);
  return part(x2, y2, R2, r2, start, end);
};
class Ellipse extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: Ellipse.defaultStyleProps }, options));
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Ellipse$1, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    const [majorAxis, minorAxis] = this.getSize(attributes);
    return Object.assign(Object.assign({}, keyStyle), { rx: majorAxis / 2, ry: minorAxis / 2 });
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const { rx, ry } = this.getShape("key").attributes;
    const size = Math.min(+rx, +ry) * 2 * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size, height: size }, style) : false;
  }
  getIntersectPoint(point2, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getEllipseIntersectPoint(point2, keyShapeBounds, useExtendedLine);
  }
}
Ellipse.defaultStyleProps = {
  size: [45, 35]
};
class Hexagon extends Polygon {
  constructor(options) {
    super(options);
  }
  getOuterR(attributes) {
    return attributes.outerR || Math.min(...this.getSize(attributes)) / 2;
  }
  getPoints(attributes) {
    return getHexagonPoints(this.getOuterR(attributes));
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const size = this.getOuterR(attributes) * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size, height: size }, style) : false;
  }
}
function _classPrivateFieldBase(e3, t3) {
  if (!{}.hasOwnProperty.call(e3, t3)) throw new TypeError("attempted to use private field on non-instance");
  return e3;
}
var id = 0;
function _classPrivateFieldKey(e3) {
  return "__private_" + id++ + "_" + e3;
}
/*!
 * @antv/g-canvas
 * @description A renderer implemented by Canvas 2D API
 * @version 2.2.0
 * @date 12/24/2025, 11:55:53 AM
 * @author AntVis
 * @docs https://g.antv.antgroup.com/
 */
var _renderState = /* @__PURE__ */ _classPrivateFieldKey("renderState");
var CanvasRendererPlugin = /* @__PURE__ */ function() {
  function CanvasRendererPlugin2(canvasRendererPluginOptions) {
    _classCallCheck(this, CanvasRendererPlugin2);
    this.renderQueue = [];
    Object.defineProperty(this, _renderState, {
      writable: true,
      value: {
        restoreStack: [],
        prevObject: null,
        currentContext: /* @__PURE__ */ new Map()
      }
    });
    this.clearFullScreenLastFrame = false;
    this.clearFullScreen = false;
    this.vpMatrix = create$5();
    this.dprMatrix = create$5();
    this.tmpMat4 = create$5();
    this.vec3a = create$4();
    this.vec3b = create$4();
    this.vec3c = create$4();
    this.vec3d = create$4();
    this.canvasRendererPluginOptions = canvasRendererPluginOptions;
  }
  return _createClass(CanvasRendererPlugin2, [{
    key: "apply",
    value: function apply2(context, runtime2) {
      var _this2 = this;
      this.context = context;
      var _this$context = this.context, config = _this$context.config, camera = _this$context.camera, renderingService = _this$context.renderingService, renderingContext = _this$context.renderingContext, pathGeneratorFactory = _this$context.pathGeneratorFactory;
      var enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
      config.renderer.getConfig().enableDirtyCheck = false;
      config.renderer.getConfig().enableDirtyRectangleRendering = false;
      this.pathGeneratorFactory = pathGeneratorFactory;
      var contextService = context.contextService;
      var canvas2 = renderingContext.root.ownerDocument.defaultView;
      renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
        var dpr = contextService.getDPR();
        var width2 = config.width, height = config.height;
        var context2 = contextService.getContext();
        _this2.clearRect(context2, 0, 0, width2 * dpr, height * dpr, config.background);
      });
      renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
        _this2.renderQueue = [];
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: null
        };
      });
      var beforeDraw = function beforeDraw2() {
        var _canvas$context$rende;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        var width2 = config.width, height = config.height;
        var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
        var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
        var ratio = rendered / total;
        _this2.clearFullScreen = _this2.clearFullScreenLastFrame || // @ts-ignore
        !((_canvas$context$rende = canvas2.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
        if (!context2) {
          return;
        }
        if (typeof context2.resetTransform === "function") {
          context2.resetTransform();
        } else {
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
        if (_this2.clearFullScreen) {
          _this2.clearRect(context2, 0, 0, width2 * dpr, height * dpr, config.background);
        }
      };
      var renderByZIndex = function renderByZIndex2(object, context2) {
        var stack = [object];
        while (stack.length > 0) {
          var _currentObject$sortab;
          var currentObject = stack.pop();
          if (currentObject.isVisible() && !currentObject.isCulled()) {
            if (enableRenderingOptimization) {
              _this2.renderDisplayObjectOptimized(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            } else {
              _this2.renderDisplayObject(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          }
          var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
          for (var i2 = objects.length - 1; i2 >= 0; i2--) {
            stack.push(objects[i2]);
          }
        }
      };
      renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
        beforeDraw();
        if (renderingContext.root.childNodes.length === 0) {
          _this2.clearFullScreenLastFrame = true;
          return;
        }
        enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext
        };
        _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext.clear();
        _this2.clearFullScreenLastFrame = false;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
        multiply$3(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
        if (_this2.clearFullScreen) {
          if (enableRenderingOptimization) {
            context2.save();
            renderByZIndex(renderingContext.root, context2);
            context2.restore();
          } else {
            renderByZIndex(renderingContext.root, context2);
          }
        } else {
          var dirtyRenderBounds = _this2.safeMergeAABB(_this2.mergeDirtyAABBs(_this2.renderQueue));
          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this2.renderQueue = [];
            return;
          }
          var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
          var x2 = dirtyRect.x, y2 = dirtyRect.y, width2 = dirtyRect.width, height = dirtyRect.height;
          var tl = transformMat4$1(_this2.vec3a, [x2, y2, 0], _this2.vpMatrix);
          var tr = transformMat4$1(_this2.vec3b, [x2 + width2, y2, 0], _this2.vpMatrix);
          var bl = transformMat4$1(_this2.vec3c, [x2, y2 + height, 0], _this2.vpMatrix);
          var br = transformMat4$1(_this2.vec3d, [x2 + width2, y2 + height, 0], _this2.vpMatrix);
          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
          var ix = Math.floor(minx);
          var iy = Math.floor(miny);
          var iwidth = Math.ceil(maxx - minx);
          var iheight = Math.ceil(maxy - miny);
          context2.save();
          _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
          context2.beginPath();
          context2.rect(ix, iy, iwidth, iheight);
          context2.clip();
          context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
          var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
          if (enableDirtyRectangleRenderingDebug) {
            canvas2.dispatchEvent(new CustomEvent(CanvasEvent$1.DIRTY_RECTANGLE, {
              dirtyRect: {
                x: ix,
                y: iy,
                width: iwidth,
                height: iheight
              }
            }));
          }
          var _dirtyRenderBounds$ge = dirtyRenderBounds.getMin(), _dirtyRenderBounds$ge2 = _slicedToArray(_dirtyRenderBounds$ge, 2), minX = _dirtyRenderBounds$ge2[0], minY = _dirtyRenderBounds$ge2[1];
          var _dirtyRenderBounds$ge3 = dirtyRenderBounds.getMax(), _dirtyRenderBounds$ge4 = _slicedToArray(_dirtyRenderBounds$ge3, 2), maxX = _dirtyRenderBounds$ge4[0], maxY = _dirtyRenderBounds$ge4[1];
          var dirtyObjects = renderingContext.root.ownerDocument.elementsFromBBox(minX, minY, maxX, maxY);
          dirtyObjects.sort(function(a2, b2) {
            return a2.sortable.renderOrder - b2.sortable.renderOrder;
          }).forEach(function(object) {
            if (object && object.isVisible() && !object.isCulled()) {
              _this2.renderDisplayObject(object, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          });
          context2.restore();
          _this2.renderQueue.forEach(function(object) {
            _this2.saveDirtyAABB(object);
          });
          _this2.renderQueue = [];
        }
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack.forEach(function() {
          context2.restore();
        });
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack = [];
      });
      renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
        if (!_this2.clearFullScreen) {
          _this2.renderQueue.push(object);
        }
      });
    }
  }, {
    key: "clearRect",
    value: function clearRect(context, x2, y2, width2, height, background) {
      context.clearRect(x2, y2, width2, height);
      if (background) {
        context.fillStyle = background;
        context.fillRect(x2, y2, width2, height);
      }
    }
  }, {
    key: "renderDisplayObjectOptimized",
    value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var updateTransform = false;
      var clipDraw = false;
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        updateTransform = !renderState.prevObject || !exactEquals$1(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, clipPath);
          renderState.prevObject = null;
        }
        var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath) {
          context.save();
          clipDraw = true;
          context.beginPath();
          _generatePath(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        updateTransform = !renderState.prevObject || !exactEquals$1(object.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, object);
        }
        var forceUpdateStyle = !renderState.prevObject;
        if (!forceUpdateStyle) {
          var prevNodeName = renderState.prevObject.nodeName;
          if (nodeName === Shape.TEXT) {
            forceUpdateStyle = prevNodeName !== Shape.TEXT;
          } else if (nodeName === Shape.IMAGE) {
            forceUpdateStyle = prevNodeName !== Shape.IMAGE;
          } else {
            forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;
          }
        }
        styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);
        renderState.prevObject = object;
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.drawToContext(context, object, _classPrivateFieldBase(this, _renderState)[_renderState], this, runtime2);
      }
      if (clipDraw) {
        context.restore();
      }
      object.dirty(false);
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var parent = renderState.restoreStack[renderState.restoreStack.length - 1];
      if (parent && !(object.compareDocumentPosition(parent) & Node$1.DOCUMENT_POSITION_CONTAINS)) {
        context.restore();
        renderState.restoreStack.pop();
      }
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        this.applyWorldTransform(context, clipPath);
        var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath2) {
          context.save();
          renderState.restoreStack.push(object);
          context.beginPath();
          _generatePath2(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        this.applyWorldTransform(context, object);
        context.save();
        this.applyAttributesToContext(context, object);
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
        context.restore();
      }
      object.dirty(false);
    }
  }, {
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
      var _ref = object.parsedStyle, stroke = _ref.stroke, fill = _ref.fill, opacity2 = _ref.opacity, lineDash = _ref.lineDash, lineDashOffset = _ref.lineDashOffset;
      if (lineDash) {
        context.setLineDash(lineDash);
      }
      if (!isNil(lineDashOffset)) {
        context.lineDashOffset = lineDashOffset;
      }
      if (!isNil(opacity2)) {
        context.globalAlpha *= opacity2;
      }
      if (!isNil(stroke) && !Array.isArray(stroke) && !stroke.isNone) {
        context.strokeStyle = object.attributes.stroke;
      }
      if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
        context.fillStyle = object.attributes.fill;
      }
    }
  }, {
    key: "convertAABB2Rect",
    value: function convertAABB2Rect(aabb) {
      var min2 = aabb.getMin();
      var max2 = aabb.getMax();
      var minX = Math.floor(min2[0]);
      var minY = Math.floor(min2[1]);
      var maxX = Math.ceil(max2[0]);
      var maxY = Math.ceil(max2[1]);
      var width2 = maxX - minX;
      var height = maxY - minY;
      return {
        x: minX,
        y: minY,
        width: width2,
        height
      };
    }
    /**
     * TODO: merge dirty rectangles with some strategies.
     * For now, we just simply merge all the rectangles into one.
     * @see https://idom.me/articles/841.html
     */
  }, {
    key: "mergeDirtyAABBs",
    value: function mergeDirtyAABBs(dirtyObjects) {
      var aabb = new AABB();
      dirtyObjects.forEach(function(object) {
        var renderBounds = object.getRenderBounds();
        aabb.add(renderBounds);
        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
        if (dirtyRenderBounds) {
          aabb.add(dirtyRenderBounds);
        }
      });
      return aabb;
    }
  }, {
    key: "saveDirtyAABB",
    value: function saveDirtyAABB(object) {
      var renderable = object.renderable;
      if (!renderable.dirtyRenderBounds) {
        renderable.dirtyRenderBounds = new AABB();
      }
      var renderBounds = object.getRenderBounds();
      if (renderBounds) {
        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
      }
    }
  }, {
    key: "applyWorldTransform",
    value: function applyWorldTransform(context, object, matrix3) {
      if (matrix3) {
        copy$4(this.tmpMat4, object.getLocalTransform());
        multiply$3(this.tmpMat4, matrix3, this.tmpMat4);
        multiply$3(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      } else {
        copy$4(this.tmpMat4, object.getWorldTransform());
        multiply$3(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      }
      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
    }
  }, {
    key: "safeMergeAABB",
    value: function safeMergeAABB() {
      var merged = new AABB();
      for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
        aabbs[_key] = arguments[_key];
      }
      aabbs.forEach(function(aabb) {
        merged.add(aabb);
      });
      return merged;
    }
  }]);
}();
CanvasRendererPlugin.tag = "CanvasRenderer";
function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
  var $offscreenCanvas;
  var dpr;
  if (pattern.image.nodeName === "rect") {
    var _parsedStyle = pattern.image.parsedStyle, width2 = _parsedStyle.width, height = _parsedStyle.height;
    dpr = canvasContext.contextService.getDPR();
    var offscreenCanvas = canvasContext.config.offscreenCanvas;
    $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    $offscreenCanvas.width = width2 * dpr;
    $offscreenCanvas.height = height * dpr;
    var offscreenCanvasContext = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
    var renderState = {
      restoreStack: [],
      prevObject: null,
      currentContext: /* @__PURE__ */ new Map()
    };
    pattern.image.forEach(function(object2) {
      plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, renderState, runtime2);
    });
    renderState.restoreStack.forEach(function() {
      offscreenCanvasContext.restore();
    });
  }
  var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
    object.dirty();
    canvasContext.renderingService.dirty();
  });
  return canvasPattern;
}
function getColor(parsedColor, object, context, imagePool) {
  var color2;
  if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
    var bounds = object.getGeometryBounds();
    var width2 = bounds && bounds.halfExtents[0] * 2 || 1;
    var height = bounds && bounds.halfExtents[1] * 2 || 1;
    var min2 = bounds && bounds.min || [0, 0];
    color2 = imagePool.getOrCreateGradient(_objectSpread2(_objectSpread2({
      type: parsedColor.type
    }, parsedColor.value), {}, {
      min: min2,
      width: width2,
      height
    }), context);
  }
  return color2;
}
var SHADOW_NUMBER_STYLE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_STYLE = ["lineCap", "lineJoin", "miterLimit"];
var DEFAULT_STYLE = {
  // common
  globalAlpha: 1,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  filter: "none",
  globalCompositeOperation: "source-over",
  // stroke/fill
  strokeStyle: "#000",
  strokeOpacity: 1,
  lineWidth: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  fillStyle: "#000",
  fillOpacity: 1
  // image
};
var defaultParsedStyle = {};
function updateContextIfNotHitCache(context, key, value, cache) {
  var prevValue = cache.has(key) ? cache.get(key) : DEFAULT_STYLE[key];
  if (prevValue !== value) {
    if (key === "lineDash") {
      context.setLineDash(value);
    } else {
      context[key] = value;
    }
    cache.set(key, value);
  }
  return prevValue;
}
var OptimizedDefaultRenderer = /* @__PURE__ */ function() {
  function OptimizedDefaultRenderer2(imagePool) {
    _classCallCheck(this, OptimizedDefaultRenderer2);
    this.imagePool = imagePool;
  }
  return _createClass(OptimizedDefaultRenderer2, [{
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
    }
  }, {
    key: "render",
    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
    }
    // #region common style
  }, {
    key: "applyCommonStyleToContext",
    value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      if (forceUpdate || style.opacity !== prevStyle.opacity) {
        updateContextIfNotHitCache(context, "globalAlpha", !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);
      }
      if (forceUpdate || style.blend !== prevStyle.blend) {
        updateContextIfNotHitCache(
          context,
          "globalCompositeOperation",
          // @ts-ignore
          !isNil(style.blend) ? (
            // @ts-ignore
            style.blend
          ) : DEFAULT_STYLE.globalCompositeOperation,
          renderState.currentContext
        );
      }
    }
    // #endregion common style
    // #region stroke/fill style
  }, {
    key: "applyStrokeFillStyleToContext",
    value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      var _style$lineWidth = style.lineWidth, lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (hasStroke) {
        if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {
          var value = !isNil(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;
          updateContextIfNotHitCache(context, "strokeStyle", value, renderState.currentContext);
        }
        if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {
          updateContextIfNotHitCache(context, "lineWidth", !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);
        }
        if (forceUpdate || style.lineDash !== prevStyle.lineDash) {
          updateContextIfNotHitCache(context, "lineDash", style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);
        }
        if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {
          updateContextIfNotHitCache(context, "lineDashOffset", !isNil(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);
        }
        for (var i2 = 0; i2 < STROKE_STYLE.length; i2++) {
          var styleName = STROKE_STYLE[i2];
          if (forceUpdate || style[styleName] !== prevStyle[styleName]) {
            updateContextIfNotHitCache(context, styleName, !isNil(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
      }
      if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {
        var _value = !isNil(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;
        updateContextIfNotHitCache(context, "fillStyle", _value, renderState.currentContext);
      }
    }
    // #endregion stroke/fill style
  }, {
    key: "applyStyleToContext",
    value: function applyStyleToContext(context, object, forceUpdate, renderState) {
      var nodeName = object.nodeName;
      this.applyCommonStyleToContext(context, object, forceUpdate, renderState);
      if (nodeName === Shape.IMAGE) ;
      else {
        this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);
      }
    }
  }, {
    key: "applyShadowAndFilterStyleToContext",
    value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {
      var style = object.parsedStyle;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", style.shadowColor.toString(), renderState.currentContext);
        for (var i2 = 0; i2 < SHADOW_NUMBER_STYLE.length; i2++) {
          var styleName = SHADOW_NUMBER_STYLE[i2];
          updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (style.filter && style.filter.length) {
        updateContextIfNotHitCache(
          context,
          "filter",
          // use raw filter string
          object.attributes.filter,
          renderState.currentContext
        );
      }
    }
  }, {
    key: "clearShadowAndFilterStyleForContext",
    value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {
      var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", DEFAULT_STYLE.shadowColor, renderState.currentContext);
        for (var i2 = 0; i2 < SHADOW_NUMBER_STYLE.length; i2++) {
          var styleName = SHADOW_NUMBER_STYLE[i2];
          updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (hasFilter) {
        if (hasShadow && onlyClearShadowFilter) {
          var oldFilter = context.filter;
          if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            updateContextIfNotHitCache(context, "filter", oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || DEFAULT_STYLE.filter, renderState.currentContext);
          }
        } else {
          updateContextIfNotHitCache(context, "filter", DEFAULT_STYLE.filter, renderState.currentContext);
        }
      }
    }
  }, {
    key: "fillToContext",
    value: function fillToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var _object$parsedStyle = object.parsedStyle, fill = _object$parsedStyle.fill, fillRule = _object$parsedStyle.fillRule;
      var resetStyle = null;
      if (Array.isArray(fill) && fill.length > 0) {
        fill.forEach(function(gradient) {
          var prevStyle = updateContextIfNotHitCache(context, "fillStyle", getColor(gradient, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          if (fillRule) {
            context.fill(fillRule);
          } else {
            context.fill();
          }
        });
      } else {
        if (isPattern(fill)) {
          var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            context.fillStyle = pattern;
            resetStyle = true;
          }
        }
        if (fillRule) {
          context.fill(fillRule);
        } else {
          context.fill();
        }
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "fillStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "strokeToContext",
    value: function strokeToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var stroke = object.parsedStyle.stroke;
      var resetStyle = null;
      if (Array.isArray(stroke) && stroke.length > 0) {
        stroke.forEach(function(gradient) {
          var prevStyle2 = updateContextIfNotHitCache(context, "strokeStyle", getColor(gradient, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle2;
          context.stroke();
        });
      } else {
        if (isPattern(stroke)) {
          var pattern = getPattern(stroke, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            var prevStyle = updateContextIfNotHitCache(context, "strokeStyle", pattern, renderState.currentContext);
            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          }
        }
        context.stroke();
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "strokeStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      var _style$fill;
      var nodeName = object.nodeName;
      var style = object.parsedStyle;
      var _style$opacity = style.opacity, opacity2 = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity, _style$fillOpacity = style.fillOpacity, fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity, _style$strokeOpacity = style.strokeOpacity, strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity, _style$lineWidth2 = style.lineWidth, lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (!hasFill && !hasStroke) {
        return;
      }
      var hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;
      var isInnerShadow = style.shadowType === "inner";
      var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;
      var hasFilter = !!(style.filter && style.filter.length);
      var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      var originGlobalAlpha = null;
      if (hasFill) {
        if (!shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
        }
        var updateOpacity = opacity2 * fillOpacity;
        originGlobalAlpha = updateContextIfNotHitCache(context, "globalAlpha", updateOpacity, renderState.currentContext);
        this.fillToContext(context, object, renderState, plugin, runtime2);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (hasStroke) {
        var clearShadowAndFilter = false;
        var _updateOpacity = opacity2 * strokeOpacity;
        var prevOpacity = updateContextIfNotHitCache(context, "globalAlpha", _updateOpacity, renderState.currentContext);
        originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;
        if (shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
          clearShadowAndFilter = true;
          if (isInnerShadow) {
            var originBlend = context.globalCompositeOperation;
            context.globalCompositeOperation = "source-atop";
            this.strokeToContext(context, object, renderState, plugin, runtime2);
            context.globalCompositeOperation = originBlend;
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);
          }
        }
        this.strokeToContext(context, object, renderState, plugin, runtime2);
        if (clearShadowAndFilter) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (originGlobalAlpha !== null) {
        updateContextIfNotHitCache(context, "globalAlpha", originGlobalAlpha, renderState.currentContext);
      }
    }
  }]);
}();
var DefaultRenderer = /* @__PURE__ */ function(_OptimizedDefaultRend) {
  function DefaultRenderer2() {
    _classCallCheck(this, DefaultRenderer2);
    return _callSuper(this, DefaultRenderer2, arguments);
  }
  _inherits(DefaultRenderer2, _OptimizedDefaultRend);
  return _createClass(DefaultRenderer2, [{
    key: "render",
    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$opacity = parsedStyle.opacity, opacity2 = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, stroke = parsedStyle.stroke, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter2 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
      var hasFill = fill && !fill.isNone;
      var hasStroke = stroke && !stroke.isNone && lineWidth > 0;
      var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
      var hasFilter = !!(filter2 && filter2.length);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      var nodeName = object.nodeName;
      var isInnerShadow = shadowType === "inner";
      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      if (hasFill) {
        context.globalAlpha = opacity2 * fillOpacity;
        if (!shouldDrawShadowWithStroke) {
          setShadowAndFilter(object, context, hasShadow);
        }
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilter(context, hasFilter, hasShadow);
        }
      }
      if (hasStroke) {
        context.globalAlpha = opacity2 * strokeOpacity;
        context.lineWidth = lineWidth;
        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        if (!isNil(lineCap)) {
          context.lineCap = lineCap;
        }
        if (!isNil(lineJoin)) {
          context.lineJoin = lineJoin;
        }
        if (shouldDrawShadowWithStroke) {
          if (isInnerShadow) {
            context.globalCompositeOperation = "source-atop";
          }
          setShadowAndFilter(object, context, true);
          if (isInnerShadow) {
            applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool);
            context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;
            this.clearShadowAndFilter(context, hasFilter, true);
          }
        }
        applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool);
      }
    }
  }, {
    key: "clearShadowAndFilter",
    value: function clearShadowAndFilter(context, hasFilter, hasShadow) {
      if (hasShadow) {
        context.shadowColor = "transparent";
        context.shadowBlur = 0;
      }
      if (hasFilter) {
        var oldFilter = context.filter;
        if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
          context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
        }
      }
    }
  }]);
}(OptimizedDefaultRenderer);
function setShadowAndFilter(object, context, hasShadow) {
  var _object$parsedStyle = object.parsedStyle, filter2 = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
  if (filter2 && filter2.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool) {
  var skipFill = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  if (Array.isArray(fill)) {
    fill.forEach(function(gradient) {
      context.fillStyle = getColor(gradient, object, context, imagePool);
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    });
  } else {
    if (isPattern(fill)) {
      context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipFill) {
      fillRule ? context.fill(fillRule) : context.fill();
    }
  }
}
function applyStroke(context, object, stroke, canvasContext, plugin, runtime2, imagePool) {
  var skipStroke = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  if (Array.isArray(stroke)) {
    stroke.forEach(function(gradient) {
      context.strokeStyle = getColor(gradient, object, context, imagePool);
      if (!skipStroke) {
        context.stroke();
      }
    });
  } else {
    if (isPattern(stroke)) {
      context.strokeStyle = getPattern(stroke, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipStroke) {
      context.stroke();
    }
  }
}
function calculateOverlapRect(rect1, rect2) {
  var _rect = _slicedToArray(rect1, 4), x1 = _rect[0], y1 = _rect[1], w1 = _rect[2], h1 = _rect[3];
  var _rect2 = _slicedToArray(rect2, 4), x2 = _rect2[0], y2 = _rect2[1], w2 = _rect2[2], h2 = _rect2[3];
  var overlapLeft = Math.max(x1, x2);
  var overlapTop = Math.max(y1, y2);
  var overlapRight = Math.min(x1 + w1, x2 + w2);
  var overlapBottom = Math.min(y1 + h1, y2 + h2);
  if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {
    return null;
  }
  return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];
}
function transformRect(rect2, matrix3) {
  var tl = transformMat4$1(create$4(), [rect2[0], rect2[1], 0], matrix3);
  var tr = transformMat4$1(create$4(), [rect2[0] + rect2[2], rect2[1], 0], matrix3);
  var bl = transformMat4$1(create$4(), [rect2[0], rect2[1] + rect2[3], 0], matrix3);
  var br = transformMat4$1(create$4(), [rect2[0] + rect2[2], rect2[1] + rect2[3], 0], matrix3);
  return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];
}
var ImageRenderer = /* @__PURE__ */ function(_DefaultRenderer) {
  function ImageRenderer2() {
    _classCallCheck(this, ImageRenderer2);
    return _callSuper(this, ImageRenderer2, arguments);
  }
  _inherits(ImageRenderer2, _DefaultRenderer);
  return _createClass(ImageRenderer2, [{
    key: "renderDownSampled",
    value: function renderDownSampled(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache;
      if (!imageCache.downSampled) {
        this.imagePool.createDownSampledImage(src, object).then(function() {
          if (!object.ownerDocument) {
            return;
          }
          object.dirty();
          object.ownerDocument.defaultView.context.renderingService.dirty();
        })["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      context.drawImage(imageCache.downSampled, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }, {
    key: "renderTile",
    value: function renderTile(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache, imageRect = data2.imageRect, drawRect = data2.drawRect;
      var originalSize = imageCache.size;
      var _context$getTransform = context.getTransform(), a2 = _context$getTransform.a, b2 = _context$getTransform.b, c2 = _context$getTransform.c, d3 = _context$getTransform.d, e3 = _context$getTransform.e, f2 = _context$getTransform.f;
      context.resetTransform();
      if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {
        this.imagePool.createImageTiles(src, [], function() {
          if (!object.ownerDocument) {
            return;
          }
          object.dirty();
          object.ownerDocument.defaultView.context.renderingService.dirty();
        }, object)["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];
      var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];
      var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])], startTileX = _ref[0], endTileX = _ref[1];
      var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])], startTileY = _ref2[0], endTileY = _ref2[1];
      for (var tileY = startTileY; tileY <= endTileY; tileY++) {
        for (var tileX = startTileX; tileX <= endTileX; tileX++) {
          var item = imageCache.tiles[tileY][tileX];
          if (item) {
            var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];
            context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);
          }
        }
      }
      context.setTransform(a2, b2, c2, d3, e3, f2);
    }
  }, {
    key: "render",
    value: function render(context, parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x2 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y2 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, width2 = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var imageCache = this.imagePool.getImageSync(src, object);
      var image2 = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      var iw = width2;
      var ih = height;
      if (!image2) {
        return;
      }
      iw || (iw = image2.width);
      ih || (ih = image2.height);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      try {
        var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(), viewWidth = _object$ownerDocument.width, viewHeight = _object$ownerDocument.height;
        var currentTransform = context.getTransform();
        var a2 = currentTransform.a, b2 = currentTransform.b, c2 = currentTransform.c, d3 = currentTransform.d, e3 = currentTransform.e, f2 = currentTransform.f;
        var transformMatrix = fromValues$3(a2, c2, 0, 0, b2, d3, 0, 0, 0, 0, 1, 0, e3, f2, 0, 1);
        var imageRect = transformRect([x2, y2, iw, ih], transformMatrix);
        var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);
        if (!drawRect) {
          return;
        }
        if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image: image2,
            drawRect: [x2, y2, iw, ih]
          });
          return;
        }
        var sizeOfOrigin = imageRect[2] / imageCache.size[0];
        if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {
          this.renderDownSampled(context, parsedStyle, object, {
            src,
            imageCache,
            drawRect: [x2, y2, iw, ih]
          });
          return;
        }
        if (!ImagePool.isSupportTile) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image: image2,
            drawRect: [x2, y2, iw, ih]
          });
          return;
        }
        this.renderTile(context, parsedStyle, object, {
          src,
          imageCache,
          imageRect,
          drawRect
        });
      } catch (_unused) {
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object);
    }
  }], [{
    key: "renderFull",
    value: function renderFull(context, parsedStyle, object, data2) {
      context.drawImage(data2.image, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }]);
}(DefaultRenderer);
var TextRenderer = /* @__PURE__ */ function(_DefaultRenderer) {
  function TextRenderer2() {
    _classCallCheck(this, TextRenderer2);
    return _callSuper(this, TextRenderer2, arguments);
  }
  _inherits(TextRenderer2, _DefaultRenderer);
  return _createClass(TextRenderer2, [{
    key: "render",
    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      object.getBounds();
      var _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign2 = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$lineJoin = parsedStyle.lineJoin, lineJoin = _parsedStyle$lineJoin === void 0 ? "miter" : _parsedStyle$lineJoin, _parsedStyle$miterLim = parsedStyle.miterLimit, miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing2 = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, stroke = parsedStyle.stroke, fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$opacity = parsedStyle.opacity, opacity2 = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, metrics = parsedStyle.metrics, _parsedStyle$x = parsedStyle.x, x2 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y2 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, textDecorationLine2 = parsedStyle.textDecorationLine;
      var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight2 = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
      context.font = font;
      context.lineWidth = lineWidth;
      context.textAlign = textAlign2 === "middle" ? "center" : textAlign2;
      var formattedTextBaseline = textBaseline;
      if (formattedTextBaseline === "alphabetic") {
        formattedTextBaseline = "bottom";
      }
      context.lineJoin = lineJoin;
      if (!isNil(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      var linePositionY = y2;
      if (textBaseline === "middle") {
        linePositionY += -height / 2 - lineHeight2 / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        linePositionY += -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        linePositionY += -lineHeight2;
      }
      var offsetX = x2 + (dx || 0);
      linePositionY += dy || 0;
      if (lines.length === 1) {
        if (formattedTextBaseline === "bottom") {
          formattedTextBaseline = "middle";
          linePositionY -= 0.5 * height;
        } else if (formattedTextBaseline === "top") {
          formattedTextBaseline = "middle";
          linePositionY += 0.5 * height;
        }
      }
      context.textBaseline = formattedTextBaseline;
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      for (var i2 = 0; i2 < lines.length; i2++) {
        var linePositionX = lineWidth / 2 + offsetX;
        linePositionY += lineHeight2;
        if (!isNil(stroke) && !stroke.isNone && lineWidth) {
          this.drawLetterSpacing(context, object, lines[i2], lineMetrics[i2], textAlign2, linePositionX, linePositionY, letterSpacing2, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity2, true, canvasContext, plugin, runtime2);
        }
        if (!isNil(fill)) {
          this.drawLetterSpacing(context, object, lines[i2], lineMetrics[i2], textAlign2, linePositionX, linePositionY, letterSpacing2, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity2, false, canvasContext, plugin, runtime2);
        }
      }
      if (textDecorationLine2 && textDecorationLine2 !== "none") {
        this.drawTextDecorations(context, parsedStyle, object, lines, lineHeight2, offsetX, y2 + (dy || 0), canvasContext, plugin, runtime2);
      }
    }
  }, {
    key: "drawLetterSpacing",
    value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign2, x2, y2, letterSpacing2, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity2, isStroke, canvasContext, plugin, runtime2) {
      if (letterSpacing2 === 0) {
        if (isStroke) {
          this.strokeText(context, object, text, x2, y2, stroke, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, text, x2, y2, fill, fillRule, fillOpacity, opacity2, canvasContext, plugin, runtime2);
        }
        return;
      }
      var currentTextAlign = context.textAlign;
      context.textAlign = "left";
      var currentPosition = x2;
      if (textAlign2 === "center" || textAlign2 === "middle") {
        currentPosition = x2 - lineMetrics.width / 2;
      } else if (textAlign2 === "right" || textAlign2 === "end") {
        currentPosition = x2 - lineMetrics.width;
      }
      var stringArray = Array.from(text);
      var previousWidth = context.measureText(text).width;
      var currentWidth = 0;
      for (var i2 = 0; i2 < stringArray.length; ++i2) {
        var currentChar = stringArray[i2];
        if (isStroke) {
          this.strokeText(context, object, currentChar, currentPosition, y2, stroke, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, currentChar, currentPosition, y2, fill, fillRule, fillOpacity, opacity2, canvasContext, plugin, runtime2);
        }
        currentWidth = context.measureText(text.substring(i2 + 1)).width;
        currentPosition += previousWidth - currentWidth + letterSpacing2;
        previousWidth = currentWidth;
      }
      context.textAlign = currentTextAlign;
    }
  }, {
    key: "fillText",
    value: function fillText(context, object, text, x2, y2, fill, fillRule, fillOpacity, opacity2, canvasContext, plugin, runtime2) {
      applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = fillOpacity * opacity2;
      }
      context.fillText(text, x2, y2);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
  }, {
    key: "strokeText",
    value: function strokeText(context, object, text, x2, y2, stroke, strokeOpacity, canvasContext, plugin, runtime2) {
      applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = strokeOpacity;
      }
      context.strokeText(text, x2, y2);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
    /**
     * Draw text decoration lines (underline, overline, line-through)
     */
  }, {
    key: "drawTextDecorations",
    value: function drawTextDecorations(context, parsedStyle, object, lines, lineHeight2, offsetX, baseY, canvasContext, plugin, runtime2) {
      var textDecorationLine2 = parsedStyle.textDecorationLine, textDecorationColor2 = parsedStyle.textDecorationColor, textDecorationStyle = parsedStyle.textDecorationStyle, _parsedStyle$textDeco = parsedStyle.textDecorationThickness, textDecorationThickness = _parsedStyle$textDeco === void 0 ? 1 : _parsedStyle$textDeco, _parsedStyle$textAlig2 = parsedStyle.textAlign, textAlign2 = _parsedStyle$textAlig2 === void 0 ? "start" : _parsedStyle$textAlig2, _parsedStyle$lineWidt2 = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt2 === void 0 ? 1 : _parsedStyle$lineWidt2, metrics = parsedStyle.metrics;
      if (!textDecorationLine2 || textDecorationLine2 === "none") {
        return;
      }
      var lineMetrics = metrics.lineMetrics;
      var decorations = textDecorationLine2.split(" ");
      context.lineWidth = textDecorationThickness;
      if (textDecorationColor2) {
        context.strokeStyle = "rgba(".concat(textDecorationColor2.r, ", ").concat(textDecorationColor2.g, ", ").concat(textDecorationColor2.b, ", ").concat(textDecorationColor2.alpha, ")");
      }
      switch (textDecorationStyle) {
        case "dashed":
          context.setLineDash([5, 5]);
          break;
        case "dotted":
          context.setLineDash([2, 2]);
          break;
        case "wavy":
          context.setLineDash([]);
          break;
        default:
          context.setLineDash([]);
          break;
      }
      var linePositionY = baseY;
      var _parsedStyle$textBase2 = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase2 === void 0 ? "alphabetic" : _parsedStyle$textBase2;
      if (textBaseline === "middle") {
        linePositionY += -metrics.height / 2 - lineHeight2 / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        linePositionY += -metrics.height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        linePositionY += -lineHeight2;
      }
      for (var i2 = 0; i2 < lines.length; i2++) {
        linePositionY += lineHeight2;
        var lineMetric = lineMetrics[i2];
        if (!lineMetric) continue;
        var lineWidthOffset = lineWidth / 2;
        var startX = offsetX;
        var endX = offsetX + lineMetric.width;
        if (textAlign2 === "center" || textAlign2 === "middle") {
          startX = offsetX - lineMetric.width / 2;
          endX = offsetX + lineMetric.width / 2;
        } else if (textAlign2 === "right" || textAlign2 === "end") {
          startX = offsetX - lineMetric.width;
          endX = offsetX;
        }
        startX += lineWidthOffset;
        endX += lineWidthOffset;
        var _iterator = _createForOfIteratorHelper(decorations), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var decoration = _step.value;
            var decorationY = linePositionY;
            switch (decoration) {
              case "underline":
                decorationY += 2;
                break;
              case "overline":
                decorationY -= lineHeight2 - 2;
                break;
              case "line-through":
                decorationY -= lineHeight2 / 2;
                break;
              default:
                continue;
            }
            if (textDecorationStyle === "wavy") {
              this.drawWavyLine(context, startX, endX, decorationY);
            } else {
              context.beginPath();
              context.moveTo(startX, decorationY);
              context.lineTo(endX, decorationY);
              context.stroke();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      context.setLineDash([]);
    }
    /**
     * Draw a wavy line as an approximation of the wavy text decoration style
     */
  }, {
    key: "drawWavyLine",
    value: function drawWavyLine(context, startX, endX, y2) {
      var amplitude = 2;
      var wavelength = 10;
      var numWaves = Math.floor((endX - startX) / wavelength);
      context.beginPath();
      context.moveTo(startX, y2);
      for (var i2 = 0; i2 < numWaves; i2++) {
        var x1 = startX + i2 * wavelength + wavelength / 4;
        var y1 = y2 + amplitude;
        var x2 = startX + i2 * wavelength + wavelength / 2;
        var y22 = y2;
        context.quadraticCurveTo(x1, y1, x2, y22);
        var x3 = startX + i2 * wavelength + wavelength * 3 / 4;
        var y3 = y2 - amplitude;
        var x4 = startX + (i2 + 1) * wavelength;
        var y4 = y2;
        context.quadraticCurveTo(x3, y3, x4, y4);
      }
      context.stroke();
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime2);
    }
  }]);
}(DefaultRenderer);
var Plugin$2 = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin2);
    _this2 = _callSuper(this, Plugin2);
    _this2.name = "canvas-renderer";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init() {
      var _defaultStyleRenderer;
      var canvasRendererPluginOptions = _objectSpread2({
        dirtyObjectNumThreshold: 500,
        dirtyObjectRatioThreshold: 0.8
      }, this.options);
      var imagePool = this.context.imagePool;
      var defaultRenderer = new DefaultRenderer(imagePool);
      var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, void 0), _defineProperty$1(_defineProperty$1(_defineProperty$1(_defaultStyleRenderer, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
      this.context.styleRendererFactory = defaultStyleRendererFactory;
      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
      delete this.context.defaultStyleRendererFactory;
      delete this.context.styleRendererFactory;
    }
  }]);
}(AbstractRendererPlugin);
var tmpVec3a = create$4();
var tmpVec3b = create$4();
var tmpVec3c = create$4();
var tmpMat4 = create$5();
var CanvasPickerPlugin = /* @__PURE__ */ function() {
  function CanvasPickerPlugin2() {
    var _this2 = this;
    _classCallCheck(this, CanvasPickerPlugin2);
    this.isHit = function(displayObject, position2, worldTransform, isClipPath) {
      var pick2 = _this2.context.pointInPathPickerFactory[displayObject.nodeName];
      if (pick2) {
        var invertWorldMat = invert$1(tmpMat4, worldTransform);
        var localPosition = transformMat4$1(tmpVec3b, set$5(tmpVec3c, position2[0], position2[1], 0), invertWorldMat);
        if (pick2(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, _this2.context, _this2.runtime)) {
          return true;
        }
      }
      return false;
    };
    this.isPointInPath = function(displayObject, position2) {
      var context = _this2.runtime.offscreenCanvasCreator.getOrCreateContext(_this2.context.config.offscreenCanvas);
      var generatePath2 = _this2.context.pathGeneratorFactory[displayObject.nodeName];
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, displayObject.parsedStyle);
        context.closePath();
      }
      return context.isPointInPath(position2.x, position2.y);
    };
  }
  return _createClass(CanvasPickerPlugin2, [{
    key: "apply",
    value: function apply2(context, runtime2) {
      var _renderingContext$roo, _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      this.context = context;
      this.runtime = runtime2;
      var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(result) {
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this2.pick(document2, result));
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }());
      renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
        return _this2.pick(document2, result);
      });
    }
  }, {
    key: "pick",
    value: function pick2(document2, result) {
      var topmost = result.topmost, _result$position = result.position, x2 = _result$position.x, y2 = _result$position.y;
      var position2 = set$5(tmpVec3a, x2, y2, 0);
      var hitTestList = document2.elementsFromBBox(position2[0], position2[1], position2[0], position2[1]);
      var pickedDisplayObjects = [];
      var _iterator = _createForOfIteratorHelper(hitTestList), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _displayObject = _step.value;
          var worldTransform = _displayObject.getWorldTransform();
          var isHitOriginShape = this.isHit(_displayObject, position2, worldTransform, false);
          if (isHitOriginShape) {
            var clipped = findClosestClipPathTarget(_displayObject);
            if (clipped) {
              var clipPath = clipped.parsedStyle.clipPath;
              var isHitClipPath = this.isHit(clipPath, position2, clipPath.getWorldTransform(), true);
              if (isHitClipPath) {
                if (topmost) {
                  result.picked = [_displayObject];
                  return result;
                }
                pickedDisplayObjects.push(_displayObject);
              }
            } else {
              if (topmost) {
                result.picked = [_displayObject];
                return result;
              }
              pickedDisplayObjects.push(_displayObject);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      result.picked = pickedDisplayObjects;
      return result;
    }
  }]);
}();
CanvasPickerPlugin.tag = "CanvasPicker";
function isPointInPath$8(displayObject, position2, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, r2 = _ref.r, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var absDistance = distance$5(cx, cy, position2.x, position2.y);
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r2 + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r2;
  }
  if (hasStroke) {
    return absDistance >= r2 - halfLineWidth && absDistance <= r2 + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$7(displayObject, position2, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, rx = _ref.rx, ry = _ref.ry, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var x2 = position2.x, y2 = position2.y;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var squareX = (x2 - cx) * (x2 - cx);
  var squareY = (y2 - cy) * (y2 - cy);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function inBox(minX, minY, width2, height, x2, y2) {
  return x2 >= minX && x2 <= minX + width2 && y2 >= minY && y2 <= minY + height;
}
function inRect(minX, minY, width2, height, lineWidth, x2, y2) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width2, lineWidth, x2, y2) || // 
  inBox(minX + width2 - halfWidth, minY - halfWidth, lineWidth, height, x2, y2) || // 
  inBox(minX + halfWidth, minY + height - halfWidth, width2, lineWidth, x2, y2) || // 
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x2, y2);
}
function inArc(cx, cy, r2, startAngle, endAngle, lineWidth, x2, y2) {
  var angle2 = (Math.atan2(y2 - cy, x2 - cx) + Math.PI * 2) % (Math.PI * 2);
  var point2 = {
    x: cx + r2 * Math.cos(angle2),
    y: cy + r2 * Math.sin(angle2)
  };
  return distance$5(point2.x, point2.y, x2, y2) <= lineWidth / 2;
}
function inLine(x1, y1, x2, y2, lineWidth, x3, y3) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY + halfWidth)) {
    return false;
  }
  return pointToLine(x1, y1, x2, y2, x3, y3) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x2, y2, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i2 = 0; i2 < count - 1; i2++) {
    var x1 = points[i2][0];
    var y1 = points[i2][1];
    var x22 = points[i2 + 1][0];
    var y22 = points[i2 + 1][1];
    if (inLine(x1, y1, x22, y22, lineWidth, x2, y2)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last = points[count - 1];
    if (inLine(first[0], first[1], last[0], last[1], lineWidth, x2, y2)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x2) {
  if (Math.abs(x2) < tolerance) {
    return 0;
  }
  return x2 < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x2, y2) {
  var isHit = false;
  var n2 = points.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment(p1, p2, [x2, y2])) {
      return true;
    }
    if (dcmp(p1[1] - y2) > 0 !== dcmp(p2[1] - y2) > 0 && dcmp(x2 - (y2 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x2, y2) {
  var isHit = false;
  for (var i2 = 0; i2 < polygons.length; i2++) {
    var points = polygons[i2];
    isHit = inPolygon(points, x2, y2);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath$6(displayObject, position2, isClipPath) {
  var _ref = displayObject.parsedStyle, x1 = _ref.x1, y1 = _ref.y1, x2 = _ref.x2, y2 = _ref.y2, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x1, y1, x2, y2, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y);
}
function isPointInStroke(segments, lineWidth, px2, py, length2) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px2, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = pointDistance$3(
          prePoint[0],
          // ,  C 
          prePoint[1],
          params[1],
          // 'C' 12 34 56 
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px2,
          py,
          length2
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var _i = 0; _i < args.length; _i += 6) {
          var _cDistance = pointDistance$3(
            prePointInCubic[0],
            // ,  C 
            prePointInCubic[1],
            args[_i],
            args[_i + 1],
            args[_i + 2],
            args[_i + 3],
            args[_i + 4],
            args[_i + 5],
            px2,
            py,
            length2
          );
          prePointInCubic = [args[_i + 4], args[_i + 5]];
          isHit = _cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$5(displayObject, position2, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, stroke = _ref.stroke, fill = _ref.fill, d3 = _ref.d, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var segments = d3.segments, hasArc = d3.hasArc, polylines = d3.polylines, polygons = d3.polygons;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(
    pointerEvents,
    // Only a closed path can be filled.
    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
    stroke
  ), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(displayObject, position2);
    } else {
      isHit = inPolygons(polygons, position2.x, position2.y) || inPolygons(polylines, position2.x, position2.y);
    }
    return isHit;
  }
  if (hasStroke || isClipPath) {
    isHit = isPointInStroke(segments, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y, totalLength);
  }
  return isHit;
}
function isPointInPath$4(displayObject, position2, isClipPath) {
  var _ref = displayObject.parsedStyle, stroke = _ref.stroke, fill = _ref.fill, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position2.x, position2.y);
  }
  return isHit;
}
function isPointInPath$3(displayObject, position2, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y, false);
}
function isPointInPath$2(displayObject, position2, isClipPath, isPointInPath2, runtime2) {
  var _ref = displayObject.parsedStyle, radius = _ref.radius, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$x = _ref.x, x2 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y2 = _ref$y === void 0 ? 0 : _ref$y, width2 = _ref.width, height = _ref.height, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var hasRadius = radius && radius.some(function(r2) {
    return r2 !== 0;
  });
  var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(x2 - halfWidth, y2 - halfWidth, width2 + halfWidth, height + halfWidth, position2.x, position2.y);
    }
    if (hasFill) {
      return inBox(x2, y2, width2, height, position2.x, position2.y);
    }
    if (hasStroke) {
      return inRect(x2, y2, width2, height, lineWidthForHitTesting, position2.x, position2.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(x2, y2, width2, height, radius.map(function(r2) {
        return clamp$1(r2, 0, Math.min(Math.abs(width2) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position2.x, position2.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(displayObject, position2);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width2, height, radiusArray, lineWidth, x2, y2) {
  var _radiusArray = _slicedToArray(radiusArray, 4), tlr = _radiusArray[0], trr = _radiusArray[1], brr = _radiusArray[2], blr = _radiusArray[3];
  return inLine(minX + tlr, minY, minX + width2 - trr, minY, lineWidth, x2, y2) || inLine(minX + width2, minY + trr, minX + width2, minY + height - brr, lineWidth, x2, y2) || inLine(minX + width2 - brr, minY + height, minX + blr, minY + height, lineWidth, x2, y2) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x2, y2) || inArc(minX + width2 - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x2, y2) || inArc(minX + width2 - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x2, y2) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x2, y2) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x2, y2);
}
function isPointInPath$1(displayObject, position2, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, _ref$x = _ref.x, x2 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y2 = _ref$y === void 0 ? 0 : _ref$y, width2 = _ref.width, height = _ref.height;
  if (pointerEvents === "non-transparent-pixel") {
    var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
    var canvas2 = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
      willReadFrequently: true
    });
    canvas2.width = width2;
    canvas2.height = height;
    renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread2(_objectSpread2({}, displayObject.parsedStyle), {}, {
      x: 0,
      y: 0
    }), displayObject, void 0, void 0, void 0);
    var imagedata = context.getImageData(position2.x - x2, position2.y - y2, 1, 1).data;
    return imagedata.every(function(component) {
      return component !== 0;
    });
  }
  return true;
}
function isPointInPath(displayObject, position2, isClipPath, isPointInPath2) {
  var bounds = displayObject.getGeometryBounds();
  return position2.x >= bounds.min[0] && position2.y >= bounds.min[1] && position2.x <= bounds.max[0] && position2.y <= bounds.max[1];
}
var Plugin$1 = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    _classCallCheck(this, Plugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin2, [].concat(args));
    _this2.name = "canvas-picker";
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init() {
      var _pointInPathPickerFac;
      var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty$1(_defineProperty$1(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));
      this.context.pointInPathPickerFactory = pointInPathPickerFactory;
      this.addRenderingPlugin(new CanvasPickerPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.context.pointInPathPickerFactory;
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);
function generatePath$6(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, r2 = parsedStyle.r;
  context.arc(cx, cy, r2, 0, Math.PI * 2, false);
}
function generatePath$5(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, rx = parsedStyle.rx, ry = parsedStyle.ry;
  if (context.ellipse) {
    context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r2 = rx > ry ? rx : ry;
    var scaleX2 = rx > ry ? 1 : rx / ry;
    var scaleY2 = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX2, scaleY2);
    context.arc(cx, cy, r2, 0, Math.PI * 2);
  }
}
function generatePath$4(context, parsedStyle) {
  var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad3 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = x2 - x1;
    y3 = y2 - y1;
    rad3 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad3) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad3) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = x1 - x2;
    y3 = y1 - y2;
    rad3 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad3) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad3) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
  context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _parsedStyle$d = parsedStyle.d, absolutePath = _parsedStyle$d.absolutePath, segments = _parsedStyle$d.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad3 = 0;
  var x2;
  var y2;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _getStartTangent = markerStart.parentNode.getStartTangent(), _getStartTangent2 = _slicedToArray(_getStartTangent, 2), p1 = _getStartTangent2[0], p2 = _getStartTangent2[1];
    x2 = p1[0] - p2[0];
    y2 = p1[1] - p2[1];
    rad3 = Math.atan2(y2, x2);
    startOffsetX = Math.cos(rad3) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad3) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _getEndTangent = markerEnd.parentNode.getEndTangent(), _getEndTangent2 = _slicedToArray(_getEndTangent, 2), _p = _getEndTangent2[0], _p2 = _getEndTangent2[1];
    x2 = _p[0] - _p2[0];
    y2 = _p[1] - _p2[1];
    rad3 = Math.atan2(y2, x2);
    endOffsetX = Math.cos(rad3) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad3) * (markerEndOffset || 0);
  }
  for (var i2 = 0; i2 < absolutePath.length; i2++) {
    var params = absolutePath[i2];
    var command = params[0];
    var nextSegment = absolutePath[i2 + 1];
    var useStartOffset = i2 === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i2 === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
    var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
    switch (command) {
      case "M":
        context.moveTo(params[1] + startOffsetXTemp, params[2] + startOffsetYTemp);
        break;
      case "L":
        context.lineTo(params[1] + endOffsetXTemp, params[2] + endOffsetYTemp);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] + endOffsetXTemp, params[4] + endOffsetYTemp);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] + endOffsetXTemp, params[6] + endOffsetYTemp);
        break;
      case "A": {
        var arcParams = segments[i2].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r2 = rx > ry ? rx : ry;
          var scaleX2 = rx > ry ? 1 : rx / ry;
          var scaleY2 = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX2, scaleY2);
          context.arc(0, 0, r2, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX2, 1 / scaleY2);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        if (useEndOffset) {
          context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$2(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length2 = points.length;
  var x1 = points[0][0];
  var y1 = points[0][1];
  var x2 = points[length2 - 1][0];
  var y2 = points[length2 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad3 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad3 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad3) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad3) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length2 - 1][0] - points[0][0];
    y3 = points[length2 - 1][1] - points[0][1];
    rad3 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad3) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad3) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
  for (var i2 = 1; i2 < length2 - 1; i2++) {
    var point2 = points[i2];
    context.lineTo(point2[0], point2[1]);
  }
  context.lineTo(x2, y2);
}
function generatePath$1(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length2 = points.length;
  var x1 = points[0][0];
  var y1 = points[0][1];
  var x2 = points[length2 - 1][0];
  var y2 = points[length2 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad3 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad3 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad3) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad3) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length2 - 2][0] - points[length2 - 1][0];
    y3 = points[length2 - 2][1] - points[length2 - 1][1];
    rad3 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad3) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad3) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
  for (var i2 = 1; i2 < length2 - 1; i2++) {
    var point2 = points[i2];
    context.lineTo(point2[0], point2[1]);
  }
  context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
}
function generatePath(context, parsedStyle) {
  var _parsedStyle$x = parsedStyle.x, x2 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y2 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, radius = parsedStyle.radius, width2 = parsedStyle.width, height = parsedStyle.height;
  var w2 = width2;
  var h2 = height;
  var hasRadius = radius && radius.some(function(r2) {
    return r2 !== 0;
  });
  if (!hasRadius) {
    context.rect(x2, y2, w2, h2);
  } else {
    var signX = width2 > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _radius$map = radius.map(function(r2) {
      return clamp$1(r2, 0, Math.min(Math.abs(w2) / 2, Math.abs(h2) / 2));
    }), _radius$map2 = _slicedToArray(_radius$map, 4), tlr = _radius$map2[0], trr = _radius$map2[1], brr = _radius$map2[2], blr = _radius$map2[3];
    context.moveTo(signX * tlr + x2, y2);
    context.lineTo(w2 - signX * trr + x2, y2);
    if (trr !== 0) {
      context.arc(w2 - signX * trr + x2, signY * trr + y2, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w2 + x2, h2 - signY * brr + y2);
    if (brr !== 0) {
      context.arc(w2 - signX * brr + x2, h2 - signY * brr + y2, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr + x2, h2 + y2);
    if (blr !== 0) {
      context.arc(signX * blr + x2, h2 - signY * blr + y2, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(x2, signY * tlr + y2);
    if (tlr !== 0) {
      context.arc(signX * tlr + x2, signY * tlr + y2, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin$3 = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    _classCallCheck(this, Plugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin2, [].concat(args));
    _this2.name = "canvas-path-generator";
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init() {
      var _pathGeneratorFactory;
      var pathGeneratorFactory = (_pathGeneratorFactory = {}, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_pathGeneratorFactory, Shape.CIRCLE, generatePath$6), Shape.ELLIPSE, generatePath$5), Shape.RECT, generatePath), Shape.LINE, generatePath$4), Shape.POLYLINE, generatePath$1), Shape.POLYGON, generatePath$2), Shape.PATH, generatePath$3), Shape.TEXT, void 0), Shape.GROUP, void 0), Shape.IMAGE, void 0), _defineProperty$1(_defineProperty$1(_defineProperty$1(_pathGeneratorFactory, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.pathGeneratorFactory = pathGeneratorFactory;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.context.pathGeneratorFactory;
    }
  }]);
}(AbstractRendererPlugin);
var Canvas2DContextService = /* @__PURE__ */ function() {
  function Canvas2DContextService2(context) {
    _classCallCheck(this, Canvas2DContextService2);
    this.renderingContext = context.renderingContext;
    this.canvasConfig = context.config;
  }
  return _createClass(Canvas2DContextService2, [{
    key: "init",
    value: function init() {
      var _this$canvasConfig = this.canvasConfig, container = _this$canvasConfig.container, canvas2 = _this$canvasConfig.canvas;
      if (canvas2) {
        this.$canvas = canvas2;
        if (container && canvas2.parentElement !== container) {
          container.appendChild(canvas2);
        }
        this.$container = canvas2.parentElement;
        this.canvasConfig.container = this.$container;
      } else if (container) {
        this.$container = isString$1(container) ? document.getElementById(container) : container;
        if (this.$container) {
          var $canvas = document.createElement("canvas");
          this.$container.appendChild($canvas);
          if (!this.$container.style.position) {
            this.$container.style.position = "relative";
          }
          this.$canvas = $canvas;
        }
      }
      this.context = this.$canvas.getContext("2d");
      this.resize(this.canvasConfig.width, this.canvasConfig.height);
    }
  }, {
    key: "getContext",
    value: function getContext() {
      return this.context;
    }
  }, {
    key: "getDomElement",
    value: function getDomElement() {
      return this.$canvas;
    }
  }, {
    key: "getDPR",
    value: function getDPR() {
      return this.dpr;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      if (this.$canvas.getBoundingClientRect) {
        return this.$canvas.getBoundingClientRect();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.$container && this.$canvas && this.$canvas.parentNode) {
        this.$container.removeChild(this.$canvas);
      }
    }
  }, {
    key: "resize",
    value: function resize(width2, height) {
      var dpr = this.canvasConfig.devicePixelRatio;
      this.dpr = dpr;
      if (this.$canvas) {
        this.$canvas.width = this.dpr * width2;
        this.$canvas.height = this.dpr * height;
        setDOMSize(this.$canvas, width2, height);
      }
      this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "applyCursorStyle",
    value: function applyCursorStyle(cursor) {
      if (this.$container && this.$container.style) {
        this.$container.style.cursor = cursor;
      }
    }
  }, {
    key: "toDataURL",
    value: function() {
      var _toDataURL = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var options, type, encoderOptions, _args = arguments;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
              type = options.type, encoderOptions = options.encoderOptions;
              return _context.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function toDataURL() {
        return _toDataURL.apply(this, arguments);
      }
      return toDataURL;
    }()
  }]);
}();
var ContextRegisterPlugin = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function ContextRegisterPlugin2() {
    var _this2;
    _classCallCheck(this, ContextRegisterPlugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, ContextRegisterPlugin2, [].concat(args));
    _this2.name = "canvas-context-register";
    return _this2;
  }
  _inherits(ContextRegisterPlugin2, _AbstractRendererPlug);
  return _createClass(ContextRegisterPlugin2, [{
    key: "init",
    value: function init() {
      this.context.ContextService = Canvas2DContextService;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.context.ContextService;
    }
  }]);
}(AbstractRendererPlugin);
var Renderer = /* @__PURE__ */ function(_AbstractRenderer) {
  function Renderer2(config) {
    var _this2;
    _classCallCheck(this, Renderer2);
    _this2 = _callSuper(this, Renderer2, [config]);
    _this2.registerPlugin(new ContextRegisterPlugin());
    _this2.registerPlugin(new index$3.Plugin());
    _this2.registerPlugin(new Plugin$3());
    _this2.registerPlugin(new Plugin$2());
    _this2.registerPlugin(new index$1$1.Plugin());
    _this2.registerPlugin(new Plugin$1());
    _this2.registerPlugin(new index$2.Plugin());
    return _this2;
  }
  _inherits(Renderer2, _AbstractRenderer);
  return _createClass(Renderer2);
}(AbstractRenderer);
var __rest$f = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class HTML extends BaseNode {
  constructor(options) {
    super(Object.assign(Object.assign({}, options), { style: Object.assign({}, HTML.defaultStyleProps, options.style) }));
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.forwardEvents = (nativeEvent) => {
      const canvas2 = this.context.canvas;
      const iCanvas = canvas2.context.renderingContext.root.ownerDocument.defaultView;
      const normalizedEvents = this.normalizeToPointerEvent(nativeEvent, iCanvas);
      normalizedEvents.forEach((normalizedEvent) => {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvent, iCanvas, nativeEvent);
        set$1(canvas2.context.eventService, "mappingTable.pointerupoutside", []);
        canvas2.context.eventService.mapEvent(event);
      });
    };
  }
  get eventService() {
    return this.context.canvas.context.eventService;
  }
  get events() {
    return [
      CommonEvent.CLICK,
      CommonEvent.POINTER_DOWN,
      CommonEvent.POINTER_MOVE,
      CommonEvent.POINTER_UP,
      CommonEvent.POINTER_OVER,
      CommonEvent.POINTER_LEAVE
    ];
  }
  getDomElement() {
    return this.getShape("key").getDomElement();
  }
  /**
   * @override
   */
  render(attributes = this.parsedAttributes, container = this) {
    this.drawKeyShape(attributes, container);
    this.drawPortShapes(attributes, container);
  }
  getKeyStyle(attributes) {
    const _a3 = pick(attributes, ["dx", "dy", "innerHTML", "pointerEvents", "cursor"]), { dx = 0, dy = 0 } = _a3, style = __rest$f(_a3, ["dx", "dy"]);
    const [width2, height] = this.getSize(attributes);
    return Object.assign(Object.assign({ x: dx, y: dy }, style), { width: width2, height });
  }
  drawKeyShape(attributes, container) {
    const style = this.getKeyStyle(attributes);
    const { x: x2, y: y2, width: width2 = 0, height = 0 } = style;
    const bounds = this.upsert("key-container", Rect$1, { x: x2, y: y2, width: width2, height, opacity: 0 }, container);
    return this.upsert("key", HTML$1, style, bounds);
  }
  connectedCallback() {
    const renderer = this.context.canvas.getRenderer("main");
    const isCanvasRenderer = renderer instanceof Renderer;
    if (!isCanvasRenderer)
      return;
    const element = this.getDomElement();
    this.events.forEach((eventName) => {
      element.addEventListener(eventName, this.forwardEvents);
    });
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "zIndex" && oldValue !== newValue) {
      this.getDomElement().style.zIndex = newValue;
    }
  }
  destroy() {
    const element = this.getDomElement();
    this.events.forEach((eventName) => {
      element.removeEventListener(eventName, this.forwardEvents);
    });
    super.destroy();
  }
  normalizeToPointerEvent(event, canvas2) {
    const normalizedEvents = [];
    if (canvas2.isTouchEvent(event)) {
      for (let i2 = 0; i2 < event.changedTouches.length; i2++) {
        const touch = event.changedTouches[i2];
        if (isUndefined(touch.button))
          touch.button = 0;
        if (isUndefined(touch.buttons))
          touch.buttons = 1;
        if (isUndefined(touch.isPrimary)) {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (isUndefined(touch.width))
          touch.width = touch.radiusX || 1;
        if (isUndefined(touch.height))
          touch.height = touch.radiusY || 1;
        if (isUndefined(touch.tiltX))
          touch.tiltX = 0;
        if (isUndefined(touch.tiltY))
          touch.tiltY = 0;
        if (isUndefined(touch.pointerType))
          touch.pointerType = "touch";
        if (isUndefined(touch.pointerId))
          touch.pointerId = touch.identifier || 0;
        if (isUndefined(touch.pressure))
          touch.pressure = touch.force || 0.5;
        if (isUndefined(touch.twist))
          touch.twist = 0;
        if (isUndefined(touch.tangentialPressure))
          touch.tangentialPressure = 0;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (canvas2.isMouseEvent(event)) {
      const tempEvent = event;
      if (isUndefined(tempEvent.isPrimary))
        tempEvent.isPrimary = true;
      if (isUndefined(tempEvent.width))
        tempEvent.width = 1;
      if (isUndefined(tempEvent.height))
        tempEvent.height = 1;
      if (isUndefined(tempEvent.tiltX))
        tempEvent.tiltX = 0;
      if (isUndefined(tempEvent.tiltY))
        tempEvent.tiltY = 0;
      if (isUndefined(tempEvent.pointerType))
        tempEvent.pointerType = "mouse";
      if (isUndefined(tempEvent.pointerId))
        tempEvent.pointerId = 1;
      if (isUndefined(tempEvent.pressure))
        tempEvent.pressure = 0.5;
      if (isUndefined(tempEvent.twist))
        tempEvent.twist = 0;
      if (isUndefined(tempEvent.tangentialPressure))
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.metaKey = nativeEvent.metaKey;
    event.shiftKey = nativeEvent.shiftKey;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.screen.x = nativeEvent.screenX;
    event.screen.y = nativeEvent.screenY;
    event.relatedTarget = null;
  }
  bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
    event.view = view;
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = normalizedEvent.pointerId;
    event.width = normalizedEvent.width;
    event.height = normalizedEvent.height;
    event.isPrimary = normalizedEvent.isPrimary;
    event.pointerType = normalizedEvent.pointerType;
    event.pressure = normalizedEvent.pressure;
    event.tangentialPressure = normalizedEvent.tangentialPressure;
    event.tiltX = normalizedEvent.tiltX;
    event.tiltY = normalizedEvent.tiltY;
    event.twist = normalizedEvent.twist;
    this.transferMouseData(event, normalizedEvent);
    const { x: x2, y: y2 } = this.getViewportXY(normalizedEvent);
    event.viewport.x = x2;
    event.viewport.y = y2;
    const [canvasX, canvasY] = this.context.canvas.getCanvasByViewport([x2, y2]);
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    return event;
  }
  getViewportXY(nativeEvent) {
    let x2;
    let y2;
    const { offsetX, offsetY, clientX, clientY } = nativeEvent;
    if (!isNil(offsetX) && !isNil(offsetY)) {
      x2 = offsetX;
      y2 = offsetY;
    } else {
      const point2 = this.eventService.client2Viewport({ x: clientX, y: clientY });
      x2 = point2.x;
      y2 = point2.y;
    }
    return { x: x2, y: y2 };
  }
  onframe() {
    super.onframe();
    const { opacity: opacity2 } = this.attributes;
    this.getDomElement().style.opacity = `${opacity2}`;
  }
}
HTML.defaultStyleProps = {
  size: [160, 80],
  halo: false,
  icon: false,
  label: false,
  pointerEvents: "auto"
};
var __rest$e = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
let Image$1 = class Image3 extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: Image3.defaultStyleProps }, options));
  }
  getKeyStyle(attributes) {
    const [width2, height] = this.getSize(attributes);
    const _a3 = super.getKeyStyle(attributes), { fillOpacity, opacity: opacity2 = fillOpacity } = _a3, keyStyle = __rest$e(_a3, ["fillOpacity", "opacity"]);
    return Object.assign(Object.assign({ opacity: opacity2 }, keyStyle), {
      width: width2,
      height,
      x: -width2 / 2,
      y: -height / 2
    });
  }
  getBounds() {
    return this.getShape("key").getBounds();
  }
  getHaloStyle(attributes) {
    if (attributes.halo === false)
      return false;
    const _a3 = this.getShape("key").attributes, { fill: keyStyleFill, stroke: keyStyleStroke } = _a3;
    __rest$e(_a3, ["fill", "stroke"]);
    const haloStyle = subStyleProps$1(this.getGraphicStyle(attributes), "halo");
    const haloLineWidth = Number(haloStyle.lineWidth);
    const [width2, height] = add$4(this.getSize(attributes), [haloLineWidth, haloLineWidth]);
    const { lineWidth } = haloStyle;
    const recalculate = {
      fill: "transparent",
      lineWidth: lineWidth / 2,
      width: width2 - lineWidth / 2,
      height: height - lineWidth / 2,
      x: -(width2 - lineWidth / 2) / 2,
      y: -(height - lineWidth / 2) / 2
    };
    return Object.assign(Object.assign({}, haloStyle), recalculate);
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const [width2, height] = this.getSize(attributes);
    return style ? Object.assign({ width: width2 * ICON_SIZE_RATIO, height: height * ICON_SIZE_RATIO }, style) : false;
  }
  drawKeyShape(attributes, container) {
    const image2 = this.upsert("key", Image$2, this.getKeyStyle(attributes), container);
    connectImage(this);
    return image2;
  }
  drawHaloShape(attributes, container) {
    this.upsert("halo", Rect$1, this.getHaloStyle(attributes), container);
  }
  update(attr2) {
    super.update(attr2);
    if (attr2 && ("x" in attr2 || "y" in attr2 || "z" in attr2)) {
      dispatchPositionChange(this);
    }
  }
};
Image$1.defaultStyleProps = {
  size: 32
};
class Rect extends BaseNode {
  constructor(options) {
    super(options);
  }
  getKeyStyle(attributes) {
    const [width2, height] = this.getSize(attributes);
    return Object.assign(Object.assign({}, super.getKeyStyle(attributes)), {
      width: width2,
      height,
      x: -width2 / 2,
      y: -height / 2
    });
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const { width: width2, height } = this.getShape("key").attributes;
    return style ? Object.assign({ width: width2 * ICON_SIZE_RATIO, height: height * ICON_SIZE_RATIO }, style) : false;
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Rect$1, this.getKeyStyle(attributes), container);
  }
}
class Star extends Polygon {
  constructor(options) {
    super(options);
  }
  getInnerR(attributes) {
    return attributes.innerR || this.getOuterR(attributes) * 3 / 8;
  }
  getOuterR(attributes) {
    return Math.min(...this.getSize(attributes)) / 2;
  }
  getPoints(attributes) {
    return getStarPoints(this.getOuterR(attributes), this.getInnerR(attributes));
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const size = this.getInnerR(attributes) * 2 * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size, height: size }, style) : false;
  }
  getPortXY(attributes, style) {
    const { placement = "top" } = style;
    const bbox = this.getShape("key").getLocalBounds();
    const ports = getStarPorts(this.getOuterR(attributes), this.getInnerR(attributes));
    return getPortXYByPlacement(bbox, placement, ports, false);
  }
}
class Triangle extends Polygon {
  constructor(options) {
    super(mergeOptions({ style: Triangle.defaultStyleProps }, options));
  }
  getPoints(attributes) {
    const { direction: direction2 } = attributes;
    const [width2, height] = this.getSize(attributes);
    return getTrianglePoints(width2, height, direction2);
  }
  getPortXY(attributes, style) {
    const { direction: direction2 } = attributes;
    const { placement = "top" } = style;
    const bbox = this.getShape("key").getLocalBounds();
    const [width2, height] = this.getSize(attributes);
    const ports = getTrianglePorts(width2, height, direction2);
    return getPortXYByPlacement(bbox, placement, ports, false);
  }
  // icon 
  // icon is at the centroid of the triangle
  getIconStyle(attributes) {
    const { icon, iconText, iconSrc, direction: direction2 } = attributes;
    if (icon === false || isEmpty(iconText || iconSrc))
      return false;
    const iconStyle = subStyleProps$1(this.getGraphicStyle(attributes), "icon");
    const bbox = this.getShape("key").getLocalBounds();
    const [x2, y2] = getTriangleCenter(bbox, direction2);
    const size = getIncircleRadius(bbox, direction2) * 2 * ICON_SIZE_RATIO;
    return Object.assign({
      x: x2,
      y: y2,
      width: size,
      height: size
    }, iconStyle);
  }
}
Triangle.defaultStyleProps = {
  size: 40,
  direction: "up"
};
var __rest$d = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class BaseCombo extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: BaseCombo.defaultStyleProps }, options));
    this.type = "combo";
    this.updateComboPosition(this.parsedAttributes);
  }
  getKeySize(attributes) {
    const { collapsed, childrenNode = [] } = attributes;
    if (childrenNode.length === 0)
      return this.getEmptyKeySize(attributes);
    return collapsed ? this.getCollapsedKeySize(attributes) : this.getExpandedKeySize(attributes);
  }
  getEmptyKeySize(attributes) {
    const { padding, collapsedSize } = attributes;
    const [top, right, bottom, left] = parsePadding(padding);
    return add$4(parseSize$1(collapsedSize), [left + right, top + bottom, 0]);
  }
  getCollapsedKeySize(attributes) {
    return parseSize$1(attributes.collapsedSize);
  }
  getExpandedKeySize(attributes) {
    const contentBBox = this.getContentBBox(attributes);
    return [getBBoxWidth(contentBBox), getBBoxHeight(contentBBox), 0];
  }
  getContentBBox(attributes) {
    const { childrenNode = [], padding } = attributes;
    const children = childrenNode.map((id2) => this.context.element.getElement(id2)).filter(Boolean);
    if (children.length === 0) {
      const bbox = new AABB();
      const { x: x2 = 0, y: y2 = 0, size } = attributes;
      const [width2, height] = parseSize$1(size);
      bbox.setMinMax([x2 - width2 / 2, y2 - height / 2, 0], [x2 + width2 / 2, y2 + height / 2, 0]);
      return bbox;
    }
    const childrenBBox = getCombinedBBox(children.map((child) => child.getBounds()));
    if (!padding)
      return childrenBBox;
    return getExpandedBBox(childrenBBox, padding);
  }
  drawCollapsedMarkerShape(attributes, container) {
    const style = this.getCollapsedMarkerStyle(attributes);
    this.upsert("collapsed-marker", Icon, style, container);
    connectImage(this);
  }
  getCollapsedMarkerStyle(attributes) {
    if (!attributes.collapsed || !attributes.collapsedMarker)
      return false;
    const _a3 = subStyleProps$1(this.getGraphicStyle(attributes), "collapsedMarker"), { type } = _a3, collapsedMarkerStyle = __rest$d(_a3, ["type"]);
    const keyShape = this.getShape("key");
    const [x2, y2] = getXYByPlacement$1(keyShape.getLocalBounds(), "center");
    const style = Object.assign(Object.assign({}, collapsedMarkerStyle), { x: x2, y: y2 });
    if (type) {
      const text = this.getCollapsedMarkerText(type, attributes);
      Object.assign(style, { text });
    }
    return style;
  }
  getCollapsedMarkerText(type, attributes) {
    const { childrenData = [] } = attributes;
    const { model } = this.context;
    if (type === "descendant-count")
      return model.getDescendantsData(this.id).length.toString();
    if (type === "child-count")
      return childrenData.length.toString();
    if (type === "node-count")
      return model.getDescendantsData(this.id).filter((datum) => model.getElementType(idOf(datum)) === "node").length.toString();
    if (isFunction$1(type))
      return type(childrenData);
    return "";
  }
  getComboPosition(attributes) {
    const { x: x2 = 0, y: y2 = 0, collapsed, childrenData = [] } = attributes;
    if (childrenData.length === 0)
      return [+x2, +y2, 0];
    if (collapsed) {
      const { model } = this.context;
      const descendants = model.getDescendantsData(this.id).filter((datum) => !model.isCombo(idOf(datum)));
      if (descendants.length > 0 && descendants.some(hasPosition)) {
        const totalPosition = descendants.reduce((acc, datum) => add$4(acc, positionOf(datum)), [0, 0, 0]);
        return divide(totalPosition, descendants.length);
      }
      return [+x2, +y2, 0];
    }
    return this.getContentBBox(attributes).center;
  }
  getComboStyle(attributes) {
    const [x2, y2] = this.getComboPosition(attributes);
    return { x: x2, y: y2, transform: [["translate", x2, y2]] };
  }
  updateComboPosition(attributes) {
    const comboStyle = this.getComboStyle(attributes);
    Object.assign(this.style, comboStyle);
    const { x: x2, y: y2 } = comboStyle;
    this.context.model.syncNodeLikeDatum({ id: this.id, style: { x: x2, y: y2 } });
    dispatchPositionChange(this);
  }
  render(attributes, container = this) {
    super.render(attributes, container);
    this.drawCollapsedMarkerShape(attributes, container);
  }
  update(attr2 = {}) {
    super.update(attr2);
    this.updateComboPosition(this.parsedAttributes);
  }
  onframe() {
    super.onframe();
    if (!this.attributes.collapsed)
      this.updateComboPosition(this.parsedAttributes);
    this.drawKeyShape(this.parsedAttributes, this);
  }
  animate(keyframes, options) {
    const animation = super.animate(this.attributes.collapsed ? keyframes : (
      //  combo  x, y, z, transform 
      // If the current combo is in the expanded state, the animation is not affected by x, y, z, transform, and the position is determined only by the child elements
      keyframes.map((_a3) => {
        var { x: x2, y: y2, z: z2, transform: transform2 } = _a3, keyframe = __rest$d(_a3, ["x", "y", "z", "transform"]);
        return keyframe;
      })
    ), options);
    if (!animation)
      return animation;
    return new Proxy(animation, {
      set: (target, propKey, value) => {
        if (propKey === "currentTime")
          Promise.resolve().then(() => this.onframe());
        return Reflect.set(target, propKey, value);
      }
    });
  }
}
BaseCombo.defaultStyleProps = {
  childrenNode: [],
  droppable: true,
  draggable: true,
  collapsed: false,
  collapsedSize: 32,
  collapsedMarker: true,
  collapsedMarkerZIndex: 1,
  collapsedMarkerFontSize: 12,
  collapsedMarkerTextAlign: "center",
  collapsedMarkerTextBaseline: "middle",
  collapsedMarkerType: "child-count"
};
class CircleCombo extends BaseCombo {
  constructor(options) {
    super(options);
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Circle$2, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const { collapsed } = attributes;
    const keyStyle = super.getKeyStyle(attributes);
    const [width2] = this.getKeySize(attributes);
    return Object.assign(Object.assign(Object.assign({}, keyStyle), collapsed && subStyleProps$1(keyStyle, "collapsed")), { r: width2 / 2 });
  }
  getCollapsedKeySize(attributes) {
    const [collapsedWidth, collapsedHeight] = parseSize$1(attributes.collapsedSize);
    const collapsedR = Math.max(collapsedWidth, collapsedHeight) / 2;
    return [collapsedR * 2, collapsedR * 2, 0];
  }
  getExpandedKeySize(attributes) {
    const contentBBox = this.getContentBBox(attributes);
    const [width2, height] = getBBoxSize$1(contentBBox);
    const expandedR = Math.sqrt(Math.pow(width2, 2) + Math.pow(height, 2)) / 2;
    return [expandedR * 2, expandedR * 2, 0];
  }
  getIntersectPoint(point2, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getEllipseIntersectPoint(point2, keyShapeBounds, useExtendedLine);
  }
}
class RectCombo extends BaseCombo {
  constructor(options) {
    super(options);
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Rect$1, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    const [width2, height] = this.getKeySize(attributes);
    return Object.assign(Object.assign(Object.assign({}, keyStyle), attributes.collapsed && subStyleProps$1(keyStyle, "collapsed")), {
      width: width2,
      height,
      x: -width2 / 2,
      y: -height / 2
    });
  }
}
const defaultOptions$2 = {
  padding: 10
};
function orth(sourcePoint, targetPoint, sourceNode, targetNode, controlPoints, options) {
  const { padding } = Object.assign(defaultOptions$2, options);
  const sourceBBox = getNodeBBox(sourceNode, padding);
  const targetBBox = getNodeBBox(targetNode, padding);
  const points = [sourcePoint, ...controlPoints, targetPoint];
  let direction2 = null;
  const result = [];
  for (let fromIdx = 0, len2 = points.length; fromIdx < len2 - 1; fromIdx++) {
    const toIdx = fromIdx + 1;
    const from = points[fromIdx];
    const to = points[toIdx];
    const isOrth = isOrthogonal(from, to);
    let route = null;
    if (fromIdx === 0) {
      if (toIdx === len2 - 1) {
        if (sourceBBox.intersects(targetBBox)) {
          route = insideNode(from, to, sourceBBox, targetBBox);
        } else if (!isPointBBoxCenter(from, sourceBBox) && !isPointBBoxCenter(to, targetBBox)) {
          const fromWithPadding = getNearestBoundaryPoint(from, sourceBBox);
          const toWithPadding = getNearestBoundaryPoint(to, targetBBox);
          route = pointToPoint(fromWithPadding, toWithPadding, getDirection(fromWithPadding, toWithPadding));
          route.points.unshift(fromWithPadding);
          route.points.push(toWithPadding);
        } else if (!isOrth) {
          route = nodeToNode(from, to, sourceBBox, targetBBox);
        }
      } else {
        if (isPointInBBox(to, sourceBBox)) {
          route = insideNode(from, to, sourceBBox, getNodeBBox(to, padding), direction2);
        } else if (!isOrth) {
          route = nodeToPoint(from, to, sourceBBox);
        }
      }
    } else if (toIdx === len2 - 1) {
      if (isPointInBBox(from, targetBBox)) {
        route = insideNode(from, to, getNodeBBox(from, padding), targetBBox, direction2);
      } else if (!isOrth) {
        route = pointToNode(from, to, targetBBox, direction2);
      }
    } else if (!isOrth) {
      route = pointToPoint(from, to, direction2);
    }
    if (route) {
      result.push(...route.points);
      direction2 = route.direction;
    } else {
      direction2 = getDirection(from, to);
    }
    if (toIdx < len2 - 1)
      result.push(to);
  }
  return result.map(toVector2);
}
const opposites = {
  N: "S",
  S: "N",
  W: "E",
  E: "W"
};
const radians = {
  N: -Math.PI / 2,
  S: Math.PI / 2,
  E: 0,
  W: Math.PI
};
function getDirection(from, to) {
  const [fx, fy] = from;
  const [tx, ty] = to;
  if (fx === tx) {
    return fy > ty ? "N" : "S";
  }
  if (fy === ty) {
    return fx > tx ? "W" : "E";
  }
  return null;
}
function getBBoxSize(bbox, direction2) {
  return direction2 === "N" || direction2 === "S" ? getBBoxHeight(bbox) : getBBoxWidth(bbox);
}
function pointToPoint(from, to, direction2) {
  const p1 = [from[0], to[1]];
  const p2 = [to[0], from[1]];
  const d1 = getDirection(from, p1);
  const d22 = getDirection(from, p2);
  const opposite = direction2 ? opposites[direction2] : null;
  const p3 = d1 === direction2 || d1 !== opposite && d22 !== direction2 ? p1 : p2;
  return { points: [p3], direction: getDirection(p3, to) };
}
function nodeToPoint(from, to, fromBBox) {
  if (isPointBBoxCenter(from, fromBBox)) {
    const p2 = freeJoin(from, to, fromBBox);
    return { points: [p2], direction: getDirection(p2, to) };
  } else {
    const fromWithPadding = getNearestBoundaryPoint(from, fromBBox);
    const isHorizontal2 = ["left", "right"].includes(getNearestBoundarySide(from, fromBBox));
    const p2 = isHorizontal2 ? [to[0], fromWithPadding[1]] : [fromWithPadding[0], to[1]];
    return { points: [p2], direction: getDirection(p2, to) };
  }
}
function pointToNode(from, to, toBBox, direction2) {
  const toWithPadding = isPointBBoxCenter(to, toBBox) ? to : getNearestBoundaryPoint(to, toBBox);
  const points = [
    [toWithPadding[0], from[1]],
    [from[0], toWithPadding[1]]
  ];
  const freePoints = points.filter((p2) => isPointOutsideBBox(p2, toBBox) && !isPointOnBBoxBoundary(p2, toBBox, true));
  const freeDirectionPoints = freePoints.filter((p2) => getDirection(p2, from) !== direction2);
  if (freeDirectionPoints.length > 0) {
    const p2 = freeDirectionPoints.find((p3) => getDirection(from, p3) === direction2) || freeDirectionPoints[0];
    return {
      points: [p2],
      direction: getDirection(p2, to)
    };
  } else {
    const p2 = difference(points, freePoints)[0];
    const p22 = moveTo(to, p2, getBBoxSize(toBBox, direction2) / 2);
    const p1 = freeJoin(p22, from, toBBox);
    return {
      points: [p1, p22],
      direction: getDirection(p22, to)
    };
  }
}
function nodeToNode(from, to, fromBBox, toBBox) {
  let route = nodeToPoint(from, to, fromBBox);
  const p1 = toVector3(route.points[0]);
  if (isPointInBBox(p1, toBBox)) {
    route = nodeToPoint(to, from, toBBox);
    const p2 = toVector3(route.points[0]);
    if (isPointInBBox(p2, fromBBox)) {
      const fromBorder = moveTo(from, p1, getBBoxSize(fromBBox, getDirection(from, p1)) / 2);
      const toBorder = moveTo(to, p2, getBBoxSize(toBBox, getDirection(to, p2)) / 2);
      const midPoint2 = [(fromBorder[0] + toBorder[0]) / 2, (fromBorder[1] + toBorder[1]) / 2];
      const startRoute = nodeToPoint(from, midPoint2, fromBBox);
      const endRoute = pointToNode(midPoint2, to, toBBox, startRoute.direction);
      route.points = [startRoute.points[0], endRoute.points[0]];
      route.direction = endRoute.direction;
    }
  }
  return route;
}
function insideNode(from, to, fromBBox, toBBox, direction2) {
  const DEFAULT_OFFSET = 0.01;
  const boundary = getCombinedBBox([fromBBox, toBBox]);
  const reversed = distance$3(to, boundary.center) > distance$3(from, boundary.center);
  const [start, end] = reversed ? [to, from] : [from, to];
  const halfPerimeter = getBBoxHeight(boundary) + getBBoxWidth(boundary);
  let p1;
  if (direction2) {
    const ref = [
      start[0] + halfPerimeter * Math.cos(radians[direction2]),
      start[1] + halfPerimeter * Math.sin(radians[direction2])
    ];
    p1 = moveTo(getNearestBoundaryPoint(ref, boundary), ref, DEFAULT_OFFSET);
  } else {
    p1 = moveTo(getNearestBoundaryPoint(start, boundary), start, -DEFAULT_OFFSET);
  }
  let p2 = freeJoin(p1, end, boundary);
  let points = [round$1(p1, 2), round$1(p2, 2)];
  if (isEqual$1(round$1(p1), round$1(p2))) {
    const rad3 = angle(subtract(p1, start), [1, 0, 0]) + Math.PI / 2;
    p2 = [end[0] + halfPerimeter * Math.cos(rad3), end[1] + halfPerimeter * Math.sin(rad3), 0];
    p2 = round$1(moveTo(getNearestBoundaryPoint(p2, boundary), end, -DEFAULT_OFFSET), 2);
    const p3 = freeJoin(p1, p2, boundary);
    points = [p1, p3, p2];
  }
  return {
    points: reversed ? points.reverse() : points,
    direction: reversed ? getDirection(p1, to) : getDirection(p2, to)
  };
}
function freeJoin(p1, p2, bbox) {
  let p3 = [p1[0], p2[1]];
  if (isPointInBBox(p3, bbox)) {
    p3 = [p2[0], p1[1]];
  }
  return p3;
}
function getLabelPositionStyle(key, placement, autoRotate, offsetX, offsetY) {
  const START_RATIO = 0;
  const MIDDLE_RATIO = 0.5;
  const END_RATIO = 0.99;
  let ratio = typeof placement === "number" ? placement : MIDDLE_RATIO;
  if (placement === "start")
    ratio = START_RATIO;
  if (placement === "end")
    ratio = END_RATIO;
  const point2 = parsePoint(key.getPoint(ratio));
  const pointOffset = parsePoint(key.getPoint(ratio + 0.01));
  let textAlign2 = placement === "start" ? "left" : placement === "end" ? "right" : "center";
  if (isHorizontal$1(point2, pointOffset) || !autoRotate) {
    const [x3, y3] = getXYByPlacement(key, ratio, offsetX, offsetY);
    return { transform: [["translate", x3, y3]], textAlign: textAlign2 };
  }
  let angle2 = Math.atan2(pointOffset[1] - point2[1], pointOffset[0] - point2[0]);
  const isRevert = pointOffset[0] < point2[0];
  if (isRevert) {
    textAlign2 = textAlign2 === "center" ? textAlign2 : textAlign2 === "left" ? "right" : "left";
    offsetX *= -1;
    angle2 += Math.PI;
  }
  const [x2, y2] = getXYByPlacement(key, ratio, offsetX, offsetY, angle2);
  const transform2 = [
    ["translate", x2, y2],
    ["rotate", angle2 / Math.PI * 180]
  ];
  return {
    textAlign: textAlign2,
    transform: transform2
  };
}
function getBadgePositionStyle(shapeMap, placement, labelPlacement, offsetX, offsetY) {
  var _a3, _b;
  const badgeWidth = ((_a3 = shapeMap.badge) === null || _a3 === void 0 ? void 0 : _a3.getGeometryBounds().halfExtents[0]) * 2 || 0;
  const labelWidth = ((_b = shapeMap.label) === null || _b === void 0 ? void 0 : _b.getGeometryBounds().halfExtents[0]) * 2 || 0;
  return getLabelPositionStyle(shapeMap.key, labelPlacement, true, (labelWidth ? (labelWidth / 2 + badgeWidth / 2) * (placement === "suffix" ? 1 : -1) : 0) + offsetX, offsetY);
}
function getXYByPlacement(key, ratio, offsetX, offsetY, angle2) {
  const [pointX, pointY] = parsePoint(key.getPoint(ratio));
  let actualOffsetX = offsetX;
  let actualOffsetY = offsetY;
  if (angle2) {
    actualOffsetX = offsetX * Math.cos(angle2) - offsetY * Math.sin(angle2);
    actualOffsetY = offsetX * Math.sin(angle2) + offsetY * Math.cos(angle2);
  }
  return [pointX + actualOffsetX, pointY + actualOffsetY];
}
function getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset) {
  if (isEqual$1(sourcePoint, targetPoint))
    return sourcePoint;
  const lineVector = subtract(targetPoint, sourcePoint);
  const controlPoint = [
    sourcePoint[0] + curvePosition * lineVector[0],
    sourcePoint[1] + curvePosition * lineVector[1]
  ];
  const perpVector = normalize$4(perpendicular(lineVector, false));
  controlPoint[0] += curveOffset * perpVector[0];
  controlPoint[1] += curveOffset * perpVector[1];
  return controlPoint;
}
function parseCurveOffset(curveOffset) {
  if (isNumber(curveOffset))
    return [curveOffset, -curveOffset];
  return curveOffset;
}
function parseCurvePosition(curvePosition) {
  if (isNumber(curvePosition))
    return [curvePosition, 1 - curvePosition];
  return curvePosition;
}
function getQuadraticPath(sourcePoint, targetPoint, controlPoint) {
  return [
    ["M", sourcePoint[0], sourcePoint[1]],
    ["Q", controlPoint[0], controlPoint[1], targetPoint[0], targetPoint[1]]
  ];
}
function getCubicPath(sourcePoint, targetPoint, controlPoints) {
  return [
    ["M", sourcePoint[0], sourcePoint[1]],
    [
      "C",
      controlPoints[0][0],
      controlPoints[0][1],
      controlPoints[1][0],
      controlPoints[1][1],
      targetPoint[0],
      targetPoint[1]
    ]
  ];
}
function getPolylinePath(points, radius = 0, z2 = false) {
  const targetIndex = points.length - 1;
  const sourcePoint = points[0];
  const targetPoint = points[targetIndex];
  const controlPoints = points.slice(1, targetIndex);
  const pathArray = [["M", sourcePoint[0], sourcePoint[1]]];
  controlPoints.forEach((midPoint2, i2) => {
    const prevPoint = controlPoints[i2 - 1] || sourcePoint;
    const nextPoint = controlPoints[i2 + 1] || targetPoint;
    if (!isCollinear(prevPoint, midPoint2, nextPoint) && radius) {
      const [ps, pt] = getBorderRadiusPoints(prevPoint, midPoint2, nextPoint, radius);
      pathArray.push(["L", ps[0], ps[1]], ["Q", midPoint2[0], midPoint2[1], pt[0], pt[1]], ["L", pt[0], pt[1]]);
    } else {
      pathArray.push(["L", midPoint2[0], midPoint2[1]]);
    }
  });
  pathArray.push(["L", targetPoint[0], targetPoint[1]]);
  if (z2)
    pathArray.push(["Z"]);
  return pathArray;
}
function getBorderRadiusPoints(prevPoint, midPoint2, nextPoint, radius) {
  const d0 = manhattanDistance(prevPoint, midPoint2);
  const d1 = manhattanDistance(nextPoint, midPoint2);
  const r2 = Math.min(radius, Math.min(d0, d1) / 2);
  const ps = [
    midPoint2[0] - r2 / d0 * (midPoint2[0] - prevPoint[0]),
    midPoint2[1] - r2 / d0 * (midPoint2[1] - prevPoint[1])
  ];
  const pt = [
    midPoint2[0] - r2 / d1 * (midPoint2[0] - nextPoint[0]),
    midPoint2[1] - r2 / d1 * (midPoint2[1] - nextPoint[1])
  ];
  return [ps, pt];
}
const getRadians = (bbox) => {
  const halfPI = Math.PI / 2;
  const halfHeight = getBBoxHeight(bbox) / 2;
  const halfWidth = getBBoxWidth(bbox) / 2;
  const angleWithX = Math.atan2(halfHeight, halfWidth) / 2;
  const angleWithY = Math.atan2(halfWidth, halfHeight) / 2;
  return {
    top: [-halfPI - angleWithY, -halfPI + angleWithY],
    "top-right": [-halfPI + angleWithY, -angleWithX],
    "right-top": [-halfPI + angleWithY, -angleWithX],
    right: [-angleWithX, angleWithX],
    "bottom-right": [angleWithX, halfPI - angleWithY],
    "right-bottom": [angleWithX, halfPI - angleWithY],
    bottom: [halfPI - angleWithY, halfPI + angleWithY],
    "bottom-left": [halfPI + angleWithY, Math.PI - angleWithX],
    "left-bottom": [halfPI + angleWithY, Math.PI - angleWithX],
    left: [Math.PI - angleWithX, Math.PI + angleWithX],
    "top-left": [Math.PI + angleWithX, -halfPI - angleWithY],
    "left-top": [Math.PI + angleWithX, -halfPI - angleWithY]
  };
};
function getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort) {
  const bbox = getNodeBBox(node);
  const center = node.getCenter();
  let sourcePoint = sourcePort && getPortPosition(sourcePort);
  let targetPoint = targetPort && getPortPosition(targetPort);
  if (!sourcePoint || !targetPoint) {
    const radians2 = getRadians(bbox);
    const angle1 = radians2[placement][0];
    const angle2 = radians2[placement][1];
    const [width2, height] = getBBoxSize$1(bbox);
    const r2 = Math.max(width2, height);
    const point1 = add$4(center, [r2 * Math.cos(angle1), r2 * Math.sin(angle1), 0]);
    const point2 = add$4(center, [r2 * Math.cos(angle2), r2 * Math.sin(angle2), 0]);
    sourcePoint = getNodeConnectionPoint(node, point1);
    targetPoint = getNodeConnectionPoint(node, point2);
    if (!clockwise) {
      [sourcePoint, targetPoint] = [targetPoint, sourcePoint];
    }
  }
  return [sourcePoint, targetPoint];
}
function getCubicLoopPath(node, placement, clockwise, dist2, sourcePortKey, targetPortKey) {
  const sourcePort = node.getPorts()[sourcePortKey || targetPortKey];
  const targetPort = node.getPorts()[targetPortKey || sourcePortKey];
  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);
  const controlPoints = getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist2);
  if (sourcePort)
    sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);
  if (targetPort)
    targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));
  return getCubicPath(sourcePoint, targetPoint, controlPoints);
}
function getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist2) {
  const center = node.getCenter();
  if (isEqual$1(sourcePoint, targetPoint)) {
    const direction2 = subtract(sourcePoint, center);
    const adjustment = [
      dist2 * Math.sign(direction2[0]) || dist2 / 2,
      dist2 * Math.sign(direction2[1]) || -dist2 / 2,
      0
    ];
    return [add$4(sourcePoint, adjustment), add$4(targetPoint, multiply(adjustment, [1, -1, 1]))];
  }
  return [
    moveTo(center, sourcePoint, distance$3(center, sourcePoint) + dist2),
    moveTo(center, targetPoint, distance$3(center, targetPoint) + dist2)
  ];
}
function getPolylineLoopPath(node, radius, placement, clockwise, dist2, sourcePortKey, targetPortKey) {
  const allPortsMap = getAllPorts(node);
  const sourcePort = allPortsMap[sourcePortKey || targetPortKey];
  const targetPort = allPortsMap[targetPortKey || sourcePortKey];
  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);
  const controlPoints = getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist2);
  if (sourcePort)
    sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);
  if (targetPort)
    targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));
  return getPolylinePath([sourcePoint, ...controlPoints, targetPoint], radius);
}
function getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist2) {
  const controlPoints = [];
  const bbox = getNodeBBox(node);
  if (isEqual$1(sourcePoint, targetPoint)) {
    const side = getNearestBoundarySide(sourcePoint, bbox);
    switch (side) {
      case "left":
        controlPoints.push([sourcePoint[0] - dist2, sourcePoint[1]]);
        controlPoints.push([sourcePoint[0] - dist2, sourcePoint[1] + dist2]);
        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist2]);
        break;
      case "right":
        controlPoints.push([sourcePoint[0] + dist2, sourcePoint[1]]);
        controlPoints.push([sourcePoint[0] + dist2, sourcePoint[1] + dist2]);
        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist2]);
        break;
      case "top":
        controlPoints.push([sourcePoint[0], sourcePoint[1] - dist2]);
        controlPoints.push([sourcePoint[0] + dist2, sourcePoint[1] - dist2]);
        controlPoints.push([sourcePoint[0] + dist2, sourcePoint[1]]);
        break;
      case "bottom":
        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist2]);
        controlPoints.push([sourcePoint[0] + dist2, sourcePoint[1] + dist2]);
        controlPoints.push([sourcePoint[0] + dist2, sourcePoint[1]]);
        break;
    }
  } else {
    const sourceSide = getNearestBoundarySide(sourcePoint, bbox);
    const targetSide = getNearestBoundarySide(targetPoint, bbox);
    if (sourceSide === targetSide) {
      const side = sourceSide;
      let x2, y2;
      switch (side) {
        case "left":
          x2 = Math.min(sourcePoint[0], targetPoint[0]) - dist2;
          controlPoints.push([x2, sourcePoint[1]]);
          controlPoints.push([x2, targetPoint[1]]);
          break;
        case "right":
          x2 = Math.max(sourcePoint[0], targetPoint[0]) + dist2;
          controlPoints.push([x2, sourcePoint[1]]);
          controlPoints.push([x2, targetPoint[1]]);
          break;
        case "top":
          y2 = Math.min(sourcePoint[1], targetPoint[1]) - dist2;
          controlPoints.push([sourcePoint[0], y2]);
          controlPoints.push([targetPoint[0], y2]);
          break;
        case "bottom":
          y2 = Math.max(sourcePoint[1], targetPoint[1]) + dist2;
          controlPoints.push([sourcePoint[0], y2]);
          controlPoints.push([targetPoint[0], y2]);
          break;
      }
    } else {
      const getPointOffSide = (side, point2) => {
        return {
          left: [point2[0] - dist2, point2[1]],
          right: [point2[0] + dist2, point2[1]],
          top: [point2[0], point2[1] - dist2],
          bottom: [point2[0], point2[1] + dist2]
        }[side];
      };
      const p1 = getPointOffSide(sourceSide, sourcePoint);
      const p2 = getPointOffSide(targetSide, targetPoint);
      const p3 = freeJoin(p1, p2, bbox);
      controlPoints.push(p1, p3, p2);
    }
  }
  return controlPoints;
}
function getSubgraphRelatedEdges(ids, getRelatedEdges) {
  const edges = /* @__PURE__ */ new Set();
  const internal = /* @__PURE__ */ new Set();
  const external = /* @__PURE__ */ new Set();
  ids.forEach((id2) => {
    const relatedEdges = getRelatedEdges(id2);
    relatedEdges.forEach((edge) => {
      edges.add(edge);
      if (ids.includes(edge.source) && ids.includes(edge.target))
        internal.add(edge);
      else
        external.add(edge);
    });
  });
  return { edges: Array.from(edges), internal: Array.from(internal), external: Array.from(external) };
}
function findActualConnectNodeData(node, getParentData) {
  const path = [];
  let current2 = node;
  while (current2) {
    path.push(current2);
    const parent = getParentData(idOf(current2));
    if (parent)
      current2 = parent;
    else
      break;
  }
  if (path.some((n2) => {
    var _a3;
    return (_a3 = n2.style) === null || _a3 === void 0 ? void 0 : _a3.collapsed;
  })) {
    const index2 = path.reverse().findIndex(isCollapsed);
    return path[index2] || path.at(-1);
  }
  return node;
}
function getArrowSize(lineWidth, size) {
  if (size)
    return size;
  if (lineWidth < 4)
    return 10;
  if (lineWidth === 4)
    return 12;
  return lineWidth * 2.5;
}
const circle$1 = (width2, height) => {
  const r2 = Math.max(width2, height) / 2;
  return [["M", -width2 / 2, 0], ["A", r2, r2, 0, 1, 0, 2 * r2 - width2 / 2, 0], ["A", r2, r2, 0, 1, 0, -width2 / 2, 0], ["Z"]];
};
const triangle$1 = (width2, height) => {
  return [["M", -width2 / 2, 0], ["L", width2 / 2, -height / 2], ["L", width2 / 2, height / 2], ["Z"]];
};
const diamond$1 = (width2, height) => {
  return [["M", -width2 / 2, 0], ["L", 0, -height / 2], ["L", width2 / 2, 0], ["L", 0, height / 2], ["Z"]];
};
const vee = (width2, height) => {
  return [
    ["M", -width2 / 2, 0],
    ["L", width2 / 2, -height / 2],
    ["L", 4 * width2 / 5 - width2 / 2, 0],
    ["L", width2 / 2, height / 2],
    ["Z"]
  ];
};
const rect = (width2, height) => {
  return [
    ["M", -width2 / 2, -height / 2],
    ["L", width2 / 2, -height / 2],
    ["L", width2 / 2, height / 2],
    ["L", -width2 / 2, height / 2],
    ["Z"]
  ];
};
const triangleRect = (width2, height) => {
  const tWidth = width2 / 2;
  const rWidth = width2 / 7;
  const rBeginX = width2 - rWidth;
  return [
    ["M", -tWidth, 0],
    ["L", 0, -height / 2],
    ["L", 0, height / 2],
    ["Z"],
    ["M", rBeginX - tWidth, -height / 2],
    ["L", rBeginX + rWidth - tWidth, -height / 2],
    ["L", rBeginX + rWidth - tWidth, height / 2],
    ["L", rBeginX - tWidth, height / 2],
    ["Z"]
  ];
};
const simple = (width2, height) => {
  return [
    ["M", width2 / 2, -height / 2],
    ["L", -width2 / 2, 0],
    ["L", width2 / 2, 0],
    ["L", -width2 / 2, 0],
    ["L", width2 / 2, height / 2]
  ];
};
const Symbol$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: circle$1,
  diamond: diamond$1,
  rect,
  simple,
  triangle: triangle$1,
  triangleRect,
  vee
}, Symbol.toStringTag, { value: "Module" }));
var __rest$c = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class BaseEdge extends BaseElement {
  constructor(options) {
    super(mergeOptions({ style: BaseEdge.defaultStyleProps }, options));
    this.type = "edge";
  }
  get sourceNode() {
    const { sourceNode: source } = this.parsedAttributes;
    return this.context.element.getElement(source);
  }
  get targetNode() {
    const { targetNode: target } = this.parsedAttributes;
    return this.context.element.getElement(target);
  }
  getKeyStyle(attributes) {
    const _a3 = this.getGraphicStyle(attributes), { loop } = _a3, style = __rest$c(_a3, ["loop"]);
    const { sourceNode, targetNode } = this;
    const d3 = loop && isSameNode(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);
    const keyStyle = { d: d3 };
    Path.PARSED_STYLE_LIST.forEach((key) => {
      if (key in style)
        keyStyle[key] = style[key];
    });
    return keyStyle;
  }
  getLoopPath(attributes) {
    const { sourcePort, targetPort } = attributes;
    const node = this.sourceNode;
    const bbox = getNodeBBox(node);
    const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox));
    const { placement, clockwise, dist: dist2 = defaultDist } = subStyleProps$1(this.getGraphicStyle(attributes), "loop");
    return getCubicLoopPath(node, placement, clockwise, dist2, sourcePort, targetPort);
  }
  getEndpoints(attributes, optimize = true, controlPoints = []) {
    const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;
    const { sourceNode, targetNode } = this;
    const [sourcePort, targetPort] = findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey);
    if (!optimize) {
      const sourcePoint2 = sourcePort ? getPortPosition(sourcePort) : sourceNode.getCenter();
      const targetPoint2 = targetPort ? getPortPosition(targetPort) : targetNode.getCenter();
      return [sourcePoint2, targetPoint2];
    }
    const _controlPoints = typeof controlPoints === "function" ? controlPoints() : controlPoints;
    const sourcePoint = getConnectionPoint(sourcePort || sourceNode, _controlPoints[0] || targetPort || targetNode);
    const targetPoint = getConnectionPoint(targetPort || targetNode, _controlPoints[_controlPoints.length - 1] || sourcePort || sourceNode);
    return [sourcePoint, targetPoint];
  }
  getHaloStyle(attributes) {
    if (attributes.halo === false)
      return false;
    const keyStyle = this.getKeyStyle(attributes);
    const haloStyle = subStyleProps$1(this.getGraphicStyle(attributes), "halo");
    return Object.assign(Object.assign({}, keyStyle), haloStyle);
  }
  getLabelStyle(attributes) {
    if (attributes.label === false || !attributes.labelText)
      return false;
    const labelStyle = subStyleProps$1(this.getGraphicStyle(attributes), "label");
    const { placement, offsetX, offsetY, autoRotate, maxWidth } = labelStyle, restStyle = __rest$c(labelStyle, ["placement", "offsetX", "offsetY", "autoRotate", "maxWidth"]);
    const labelPositionStyle = getLabelPositionStyle(this.shapeMap.key, placement, autoRotate, offsetX, offsetY);
    const bbox = this.shapeMap.key.getLocalBounds();
    const wordWrapWidth = getWordWrapWidthByEnds([bbox.min, bbox.max], maxWidth);
    return Object.assign({ wordWrapWidth }, labelPositionStyle, restStyle);
  }
  getBadgeStyle(attributes) {
    if (attributes.badge === false || !attributes.badgeText)
      return false;
    const _a3 = subStyleProps$1(attributes, "badge"), { offsetX, offsetY, placement } = _a3, badgeStyle = __rest$c(_a3, ["offsetX", "offsetY", "placement"]);
    return Object.assign(badgeStyle, getBadgePositionStyle(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY));
  }
  drawArrow(attributes, type) {
    var _a3;
    const isStart = type === "start";
    const arrowType = type === "start" ? "startArrow" : "endArrow";
    const enable = attributes[arrowType];
    const keyShape = this.shapeMap.key;
    if (enable) {
      const arrowStyle = this.getArrowStyle(attributes, isStart);
      const [marker, markerOffset, arrowOffset] = isStart ? ["markerStart", "markerStartOffset", "startArrowOffset"] : ["markerEnd", "markerEndOffset", "endArrowOffset"];
      const arrow2 = keyShape.parsedStyle[marker];
      if (arrow2)
        arrow2.attr(arrowStyle);
      else {
        const Ctor = arrowStyle.src ? Image$3 : Path;
        const arrowShape = new Ctor({ style: arrowStyle });
        keyShape.style[marker] = arrowShape;
      }
      keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;
    } else {
      const marker = isStart ? "markerStart" : "markerEnd";
      (_a3 = keyShape.style[marker]) === null || _a3 === void 0 ? void 0 : _a3.destroy();
      keyShape.style[marker] = null;
    }
  }
  getArrowStyle(attributes, isStart) {
    const keyStyle = this.getShape("key").attributes;
    const arrowType = isStart ? "startArrow" : "endArrow";
    const _a3 = subStyleProps$1(this.getGraphicStyle(attributes), arrowType), { size, type } = _a3, arrowStyle = __rest$c(_a3, ["size", "type"]);
    const [width2, height] = parseSize$1(getArrowSize(keyStyle.lineWidth, size));
    const arrowFn = isFunction$1(type) ? type : Symbol$1[type] || triangle$1;
    const d3 = arrowFn(width2, height);
    return Object.assign(pick(keyStyle, ["stroke", "strokeOpacity", "fillOpacity"]), { width: width2, height }, Object.assign({}, d3 && { d: d3, fill: type === "simple" ? "" : keyStyle.stroke }), arrowStyle);
  }
  drawLabelShape(attributes, container) {
    const style = this.getLabelStyle(attributes);
    this.upsert("label", Label, style, container);
  }
  drawHaloShape(attributes, container) {
    const style = this.getHaloStyle(attributes);
    this.upsert("halo", Path, style, container);
  }
  drawBadgeShape(attributes, container) {
    const style = this.getBadgeStyle(attributes);
    this.upsert("badge", Badge, style, container);
  }
  drawSourceArrow(attributes) {
    this.drawArrow(attributes, "start");
  }
  drawTargetArrow(attributes) {
    this.drawArrow(attributes, "end");
  }
  drawKeyShape(attributes, container) {
    const style = this.getKeyStyle(attributes);
    return this.upsert("key", Path, style, container);
  }
  render(attributes = this.parsedAttributes, container = this) {
    this.drawKeyShape(attributes, container);
    if (!this.getShape("key"))
      return;
    this.drawSourceArrow(attributes);
    this.drawTargetArrow(attributes);
    this.drawLabelShape(attributes, container);
    this.drawHaloShape(attributes, container);
    this.drawBadgeShape(attributes, container);
  }
  onframe() {
    this.drawKeyShape(this.parsedAttributes, this);
    this.drawSourceArrow(this.parsedAttributes);
    this.drawTargetArrow(this.parsedAttributes);
    this.drawHaloShape(this.parsedAttributes, this);
    this.drawLabelShape(this.parsedAttributes, this);
    this.drawBadgeShape(this.parsedAttributes, this);
  }
  animate(keyframes, options) {
    const animation = super.animate(keyframes, options);
    if (!animation)
      return animation;
    return new Proxy(animation, {
      set: (target, propKey, value) => {
        if (propKey === "currentTime")
          Promise.resolve().then(() => this.onframe());
        return Reflect.set(target, propKey, value);
      }
    });
  }
}
BaseEdge.defaultStyleProps = {
  badge: true,
  badgeOffsetX: 0,
  badgeOffsetY: 0,
  badgePlacement: "suffix",
  isBillboard: true,
  label: true,
  labelAutoRotate: true,
  labelIsBillboard: true,
  labelMaxWidth: "80%",
  labelOffsetX: 4,
  labelOffsetY: 0,
  labelPlacement: "center",
  labelTextBaseline: "middle",
  labelWordWrap: false,
  halo: false,
  haloDroppable: false,
  haloLineDash: 0,
  haloLineWidth: 12,
  haloPointerEvents: "none",
  haloStrokeOpacity: 0.25,
  haloZIndex: -1,
  loop: true,
  startArrow: false,
  startArrowLineDash: 0,
  startArrowLineJoin: "round",
  startArrowLineWidth: 1,
  startArrowTransformOrigin: "center",
  startArrowType: "vee",
  endArrow: false,
  endArrowLineDash: 0,
  endArrowLineJoin: "round",
  endArrowLineWidth: 1,
  endArrowTransformOrigin: "center",
  endArrowType: "vee",
  loopPlacement: "top",
  loopClockwise: true
};
class Cubic2 extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: Cubic2.defaultStyleProps }, options));
  }
  /**
   * @inheritdoc
   */
  getKeyPath(attributes) {
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
    const { controlPoints, curvePosition, curveOffset } = attributes;
    const actualControlPoints = this.getControlPoints(sourcePoint, targetPoint, parseCurvePosition(curvePosition), parseCurveOffset(curveOffset), controlPoints);
    return getCubicPath(sourcePoint, targetPoint, actualControlPoints);
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset, controlPoints) {
    return (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) === 2 ? controlPoints : [
      getCurveControlPoint(sourcePoint, targetPoint, curvePosition[0], curveOffset[0]),
      getCurveControlPoint(sourcePoint, targetPoint, curvePosition[1], curveOffset[1])
    ];
  }
}
Cubic2.defaultStyleProps = {
  curvePosition: 0.5,
  curveOffset: 20
};
class CubicHorizontal extends Cubic2 {
  constructor(options) {
    super(mergeOptions({ style: CubicHorizontal.defaultStyleProps }, options));
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
    const xDist = targetPoint[0] - sourcePoint[0];
    return [
      [sourcePoint[0] + xDist * curvePosition[0] + curveOffset[0], sourcePoint[1]],
      [targetPoint[0] - xDist * curvePosition[1] + curveOffset[1], targetPoint[1]]
    ];
  }
}
CubicHorizontal.defaultStyleProps = {
  curvePosition: [0.5, 0.5],
  curveOffset: [0, 0]
};
class CubicRadial extends Cubic2 {
  constructor(options) {
    super(mergeOptions({ style: CubicRadial.defaultStyleProps }, options));
  }
  get ref() {
    return this.context.model.getRootsData()[0];
  }
  getEndpoints(attributes) {
    if (this.sourceNode.id === this.ref.id) {
      return super.getEndpoints(attributes);
    }
    const refPoint = positionOf(this.ref);
    const sourcePoint = this.sourceNode.getIntersectPoint(refPoint, true);
    const targetPoint = this.targetNode.getIntersectPoint(refPoint);
    return [sourcePoint, targetPoint];
  }
  toRadialCoordinate(p2) {
    const refPoint = positionOf(this.ref);
    const r2 = distance$3(p2, refPoint);
    const radian = rad2(subtract(p2, refPoint));
    return [r2, radian];
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
    const [r1, rad1] = this.toRadialCoordinate(sourcePoint);
    const [r2] = this.toRadialCoordinate(targetPoint);
    const rDist = r2 - r1;
    return [
      [
        sourcePoint[0] + (rDist * curvePosition[0] + curveOffset[0]) * Math.cos(rad1),
        sourcePoint[1] + (rDist * curvePosition[0] + curveOffset[0]) * Math.sin(rad1)
      ],
      [
        targetPoint[0] - (rDist * curvePosition[1] - curveOffset[0]) * Math.cos(rad1),
        targetPoint[1] - (rDist * curvePosition[1] - curveOffset[0]) * Math.sin(rad1)
      ]
    ];
  }
}
CubicRadial.defaultStyleProps = {
  curvePosition: 0.5,
  curveOffset: 20
};
class CubicVertical extends Cubic2 {
  constructor(options) {
    super(mergeOptions({ style: CubicVertical.defaultStyleProps }, options));
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
    const yDist = targetPoint[1] - sourcePoint[1];
    return [
      [sourcePoint[0], sourcePoint[1] + yDist * curvePosition[0] + curveOffset[0]],
      [targetPoint[0], targetPoint[1] - yDist * curvePosition[1] + curveOffset[1]]
    ];
  }
}
CubicVertical.defaultStyleProps = {
  curvePosition: [0.5, 0.5],
  curveOffset: [0, 0]
};
let Line$1 = class Line extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: Line.defaultStyleProps }, options));
  }
  getKeyPath(attributes) {
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
    return [
      ["M", sourcePoint[0], sourcePoint[1]],
      ["L", targetPoint[0], targetPoint[1]]
    ];
  }
};
Line$1.defaultStyleProps = {};
const defaultCfg = {
  enableObstacleAvoidance: false,
  offset: 10,
  maxAllowedDirectionChange: Math.PI / 2,
  maximumLoops: 3e3,
  gridSize: 5,
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    right: { stepX: 1, stepY: 0 },
    left: { stepX: -1, stepY: 0 },
    bottom: { stepX: 0, stepY: 1 },
    top: { stepX: 0, stepY: -1 }
  },
  penalties: { 0: 0, 90: 0 },
  distFunc: manhattanDistance
};
const keyOf = (point2) => `${Math.round(point2[0])}|||${Math.round(point2[1])}`;
function alignToGrid(p2, gridSize) {
  const align = (value) => Math.round(value / gridSize);
  if (isNumber(p2))
    return align(p2);
  return p2.map(align);
}
function getAngleDiff(angle1, angle2) {
  const directionChange = Math.abs(angle1 - angle2);
  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;
}
function getDirectionAngle(p1, p2) {
  const deltaX = p2[0] - p1[0];
  const deltaY = p2[1] - p1[1];
  if (!deltaX && !deltaY)
    return 0;
  return Math.atan2(deltaY, deltaX);
}
function getDirectionChange(current2, neighbor, cameFrom, scaleStartPoint) {
  const directionAngle = getDirectionAngle(current2, neighbor);
  const currentCameFrom = cameFrom[keyOf(current2)];
  const prev = !currentCameFrom ? scaleStartPoint : currentCameFrom;
  const prevDirectionAngle = getDirectionAngle(prev, current2);
  return getAngleDiff(prevDirectionAngle, directionAngle);
}
const getObstacleMap = (nodes, options) => {
  const { offset, gridSize } = options;
  const obstacleMap = {};
  nodes.forEach((item) => {
    if (!item || item.destroyed || !item.isVisible())
      return;
    const bbox = getExpandedBBox(item.getRenderBounds(), offset);
    for (let x2 = alignToGrid(bbox.min[0], gridSize); x2 <= alignToGrid(bbox.max[0], gridSize); x2 += 1) {
      for (let y2 = alignToGrid(bbox.min[1], gridSize); y2 <= alignToGrid(bbox.max[1], gridSize); y2 += 1) {
        obstacleMap[`${x2}|||${y2}`] = true;
      }
    }
  });
  return obstacleMap;
};
function estimateCost(from, anchors, distFunc) {
  return Math.min(...anchors.map((anchor) => distFunc(from, anchor)));
}
function getNearestPoint(points, refPoint, distFunc) {
  let nearestPoint2 = points[0];
  let minDistance = distFunc(points[0], refPoint);
  for (let i2 = 0; i2 < points.length; i2++) {
    const point2 = points[i2];
    const dis = distFunc(point2, refPoint);
    if (dis < minDistance) {
      nearestPoint2 = point2;
      minDistance = dis;
    }
  }
  return nearestPoint2;
}
const getBoxPoints = (point2, node, directions2, options) => {
  if (!node)
    return [point2];
  const { directionMap, offset } = options;
  const expandedBBox = getExpandedBBox(node.getRenderBounds(), offset);
  const points = Object.keys(directionMap).reduce((res, directionKey) => {
    if (directions2.includes(directionKey)) {
      const direction2 = directionMap[directionKey];
      const [width2, height] = getBBoxSize$1(expandedBBox);
      const otherPoint = [point2[0] + direction2.stepX * width2, point2[1] + direction2.stepY * height];
      const segments = getBBoxSegments(expandedBBox);
      for (let i2 = 0; i2 < segments.length; i2++) {
        const intersectP = getLinesIntersection([point2, otherPoint], segments[i2]);
        if (intersectP && isPointOnBBoxBoundary(intersectP, expandedBBox)) {
          res.push(intersectP);
        }
      }
    }
    return res;
  }, []);
  if (!isPointInBBox(point2, expandedBBox)) {
    points.push(point2);
  }
  return points.map((point3) => alignToGrid(point3, options.gridSize));
};
const getControlPoints$1 = (current2, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize) => {
  const controlPoints = [];
  let pointZero = [
    scaleEndPoint[0] === endPoint[0] ? endPoint[0] : current2[0] * gridSize,
    scaleEndPoint[1] === endPoint[1] ? endPoint[1] : current2[1] * gridSize
  ];
  controlPoints.unshift(pointZero);
  let _current = current2;
  let _currentCameFrom = cameFrom[keyOf(_current)];
  while (_currentCameFrom) {
    const prePoint = _currentCameFrom;
    const point2 = _current;
    const directionChange = getDirectionChange(prePoint, point2, cameFrom, scaleStartPoint);
    if (directionChange) {
      pointZero = [
        prePoint[0] === point2[0] ? pointZero[0] : prePoint[0] * gridSize,
        prePoint[1] === point2[1] ? pointZero[1] : prePoint[1] * gridSize
      ];
      controlPoints.unshift(pointZero);
    }
    _currentCameFrom = cameFrom[keyOf(prePoint)];
    _current = prePoint;
  }
  const realStartPoints = startPoints.map((point2) => [point2[0] * gridSize, point2[1] * gridSize]);
  const startPoint = getNearestPoint(realStartPoints, pointZero, manhattanDistance);
  controlPoints.unshift(startPoint);
  return controlPoints;
};
function aStarSearch(sourceNode, targetNode, nodes, config) {
  const startPoint = toVector2(sourceNode.getCenter());
  const endPoint = toVector2(targetNode.getCenter());
  const options = Object.assign(defaultCfg, config);
  const { gridSize } = options;
  const obstacles = options.enableObstacleAvoidance ? nodes : [sourceNode, targetNode];
  const obstacleMap = getObstacleMap(obstacles, options);
  const scaleStartPoint = alignToGrid(startPoint, gridSize);
  const scaleEndPoint = alignToGrid(endPoint, gridSize);
  const startPoints = getBoxPoints(startPoint, sourceNode, options.startDirections, options);
  const endPoints = getBoxPoints(endPoint, targetNode, options.endDirections, options);
  startPoints.forEach((point2) => delete obstacleMap[keyOf(point2)]);
  endPoints.forEach((point2) => delete obstacleMap[keyOf(point2)]);
  const openList = {};
  const closedList = {};
  const cameFrom = {};
  const gScore = {};
  const fScore = {};
  const sortedOpenSet = new SortedArray();
  for (let i2 = 0; i2 < startPoints.length; i2++) {
    const firstStep = startPoints[i2];
    const key = keyOf(firstStep);
    openList[key] = firstStep;
    gScore[key] = 0;
    fScore[key] = estimateCost(firstStep, endPoints, options.distFunc);
    sortedOpenSet.add({
      id: key,
      value: fScore[key]
    });
  }
  const endPointsKeys = endPoints.map((point2) => keyOf(point2));
  let remainLoops = options.maximumLoops;
  let current2;
  let curCost = Infinity;
  for (const [id2, value] of Object.entries(openList)) {
    if (fScore[id2] <= curCost) {
      curCost = fScore[id2];
      current2 = value;
    }
  }
  while (Object.keys(openList).length > 0 && remainLoops > 0) {
    const minId = sortedOpenSet.minId(false);
    if (minId) {
      current2 = openList[minId];
    } else {
      break;
    }
    const key = keyOf(current2);
    if (endPointsKeys.includes(key)) {
      return getControlPoints$1(current2, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize);
    }
    delete openList[key];
    sortedOpenSet.remove(key);
    closedList[key] = true;
    for (const dir of Object.values(options.directionMap)) {
      const neighbor = add$4(current2, [dir.stepX, dir.stepY]);
      const neighborId = keyOf(neighbor);
      if (closedList[neighborId])
        continue;
      const directionChange = getDirectionChange(current2, neighbor, cameFrom, scaleStartPoint);
      if (directionChange > options.maxAllowedDirectionChange)
        continue;
      if (obstacleMap[neighborId])
        continue;
      if (!openList[neighborId]) {
        openList[neighborId] = neighbor;
      }
      const directionPenalties = options.penalties[directionChange];
      const neighborCost = options.distFunc(current2, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);
      const costFromStart = gScore[key] + neighborCost;
      const neighborGScore = gScore[neighborId];
      if (neighborGScore && costFromStart >= neighborGScore)
        continue;
      cameFrom[neighborId] = current2;
      gScore[neighborId] = costFromStart;
      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, options.distFunc);
      sortedOpenSet.add({
        id: neighborId,
        value: fScore[neighborId]
      });
    }
    remainLoops -= 1;
  }
  return [];
}
class SortedArray {
  constructor() {
    this.arr = [];
    this.map = {};
    this.arr = [];
    this.map = {};
  }
  _innerAdd(item, length2) {
    let low = 0, high = length2 - 1;
    while (high - low > 1) {
      const mid = Math.floor((low + high) / 2);
      if (this.arr[mid].value > item.value) {
        high = mid;
      } else if (this.arr[mid].value < item.value) {
        low = mid;
      } else {
        this.arr.splice(mid, 0, item);
        this.map[item.id] = true;
        return;
      }
    }
    this.arr.splice(high, 0, item);
    this.map[item.id] = true;
  }
  /**
   * <zh/> 
   *
   * <en/> Add the new item to the appropriate index
   * @param item - <zh/>  | <en/> new item
   */
  add(item) {
    delete this.map[item.id];
    const length2 = this.arr.length;
    if (!length2 || this.arr[length2 - 1].value < item.value) {
      this.arr.push(item);
      this.map[item.id] = true;
      return;
    }
    this._innerAdd(item, length2);
  }
  remove(id2) {
    if (!this.map[id2])
      return;
    delete this.map[id2];
  }
  _clearAndGetMinId() {
    let res;
    for (let i2 = this.arr.length - 1; i2 >= 0; i2--) {
      if (this.map[this.arr[i2].id])
        res = this.arr[i2].id;
      else
        this.arr.splice(i2, 1);
    }
    return res;
  }
  _findFirstId() {
    while (this.arr.length) {
      const first = this.arr.shift();
      if (this.map[first.id])
        return first.id;
    }
  }
  minId(clear) {
    if (clear) {
      return this._clearAndGetMinId();
    } else {
      return this._findFirstId();
    }
  }
}
class Polyline extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: Polyline.defaultStyleProps }, options));
  }
  getControlPoints(attributes) {
    const { router } = attributes;
    const { sourceNode, targetNode } = this;
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes, false);
    let controlPoints = [];
    if (!router) {
      controlPoints = attributes.controlPoints;
    } else {
      if (router.type === "shortest-path") {
        const nodes = this.context.element.getNodes();
        controlPoints = aStarSearch(sourceNode, targetNode, nodes, router);
        if (!controlPoints.length) {
          controlPoints = orth(sourcePoint, targetPoint, sourceNode, targetNode, attributes.controlPoints, {
            padding: router.offset
          });
        }
      } else if (router.type === "orth") {
        controlPoints = orth(sourcePoint, targetPoint, sourceNode, targetNode, attributes.controlPoints, router);
      }
    }
    return controlPoints;
  }
  getPoints(attributes) {
    const controlPoints = this.getControlPoints(attributes);
    const [newSourcePoint, newTargetPoint] = this.getEndpoints(attributes, true, controlPoints);
    return [newSourcePoint, ...controlPoints, newTargetPoint];
  }
  getKeyPath(attributes) {
    const points = this.getPoints(attributes);
    return getPolylinePath(points, attributes.radius);
  }
  getLoopPath(attributes) {
    const { sourcePort: sourcePortKey, targetPort: targetPortKey, radius } = attributes;
    const node = this.sourceNode;
    const bbox = getNodeBBox(node);
    const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox)) / 4;
    const { placement, clockwise, dist: dist2 = defaultDist } = subStyleProps$1(this.getGraphicStyle(attributes), "loop");
    return getPolylineLoopPath(node, radius, placement, clockwise, dist2, sourcePortKey, targetPortKey);
  }
}
Polyline.defaultStyleProps = {
  radius: 0,
  controlPoints: [],
  router: false
};
class Quadratic extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: Quadratic.defaultStyleProps }, options));
  }
  getKeyPath(attributes) {
    const { curvePosition, curveOffset } = attributes;
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
    const controlPoint = attributes.controlPoint || getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset);
    return getQuadraticPath(sourcePoint, targetPoint, controlPoint);
  }
}
Quadratic.defaultStyleProps = {
  curvePosition: 0.5,
  curveOffset: 30
};
var __rest$b = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
function isNode(shape) {
  return shape instanceof BaseNode && shape.type === "node";
}
function isEdge(shape) {
  return shape instanceof BaseEdge;
}
function isCombo(shape) {
  return shape instanceof BaseCombo;
}
function isElement(shape) {
  return isNode(shape) || isEdge(shape) || isCombo(shape);
}
function isSameNode(node1, node2) {
  if (!node1 || !node2)
    return false;
  return node1 === node2;
}
const PORT_MAP = {
  top: [0.5, 0],
  right: [1, 0.5],
  bottom: [0.5, 1],
  left: [0, 0.5],
  "left-top": [0, 0],
  "top-left": [0, 0],
  "left-bottom": [0, 1],
  "bottom-left": [0, 1],
  "right-top": [1, 0],
  "top-right": [1, 0],
  "right-bottom": [1, 1],
  "bottom-right": [1, 1],
  default: [0.5, 0.5]
};
function getPortXYByPlacement(bbox, placement, portMap = PORT_MAP, isRelative = true) {
  const DEFAULT2 = [0.5, 0.5];
  const p2 = isString$1(placement) ? get$1(portMap, placement.toLocaleLowerCase(), DEFAULT2) : placement;
  if (!isRelative && isString$1(placement))
    return p2;
  const [x2, y2] = p2 || DEFAULT2;
  return [bbox.min[0] + getBBoxWidth(bbox) * x2, bbox.min[1] + getBBoxHeight(bbox) * y2];
}
function getAllPorts(node) {
  if (!node)
    return {};
  const ports = node.getPorts();
  const portsStyle = node.attributes.ports || [];
  portsStyle.forEach((portStyle, i2) => {
    var _a3;
    const { key, placement } = portStyle;
    if (isSimplePort(portStyle)) {
      ports[_a3 = key || i2] || (ports[_a3] = getXYByPlacement$1(node.getShape("key").getBounds(), placement));
    }
  });
  return ports;
}
function isSimplePort(portStyle) {
  const { r: r2 } = portStyle;
  return !r2 || Number(r2) === 0;
}
function getPortPosition(port) {
  return isPoint(port) ? port : port.getPosition();
}
function findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey) {
  const sourcePort = findPort(sourceNode, targetNode, sourcePortKey, targetPortKey);
  const targetPort = findPort(targetNode, sourceNode, targetPortKey, sourcePortKey);
  return [sourcePort, targetPort];
}
function findPort(node, oppositeNode, portKey, oppositePortKey) {
  const portsMap = getAllPorts(node);
  if (portKey)
    return portsMap[portKey];
  const ports = Object.values(portsMap);
  if (ports.length === 0)
    return void 0;
  const positions = ports.map((port) => getPortPosition(port));
  const oppositePositions = findConnectionPoints(oppositeNode, oppositePortKey);
  const [nearestPosition] = findNearestPoints(positions, oppositePositions);
  return ports.find((port) => getPortPosition(port) === nearestPosition);
}
function findConnectionPoints(node, portKey) {
  const allPortsMap = getAllPorts(node);
  if (portKey)
    return [getPortPosition(allPortsMap[portKey])];
  const oppositePorts = Object.values(allPortsMap);
  return oppositePorts.length > 0 ? oppositePorts.map((port) => getPortPosition(port)) : [node.getCenter()];
}
function getConnectionPoint(node, opposite) {
  return isCombo(node) || isNode(node) ? getNodeConnectionPoint(node, opposite) : getPortConnectionPoint(node, opposite);
}
function getPortConnectionPoint(port, opposite) {
  if (!port || !opposite)
    return [0, 0, 0];
  if (isPoint(port))
    return port;
  if (port.attributes.linkToCenter)
    return port.getPosition();
  const oppositePosition = isPoint(opposite) ? opposite : isNode(opposite) ? opposite.getCenter() : opposite.getPosition();
  return getEllipseIntersectPoint(oppositePosition, port.getBounds());
}
function getNodeConnectionPoint(nodeLike, opposite) {
  if (!nodeLike || !opposite)
    return [0, 0, 0];
  const oppositePosition = isPoint(opposite) ? opposite : isNode(opposite) ? opposite.getCenter() : opposite.getPosition();
  return nodeLike.getIntersectPoint(oppositePosition) || nodeLike.getCenter();
}
function getTextStyleByPlacement(bbox, placement = "bottom", offsetX = 0, offsetY = 0, isReverseBaseline = false) {
  const direction2 = placement.split("-");
  const [x2, y2] = getXYByPlacement$1(bbox, placement);
  const [top, bottom] = isReverseBaseline ? ["bottom", "top"] : ["top", "bottom"];
  const textBaseline = direction2.includes("top") ? bottom : direction2.includes("bottom") ? top : "middle";
  const textAlign2 = direction2.includes("left") ? "right" : direction2.includes("right") ? "left" : "center";
  return {
    transform: [["translate", x2 + offsetX, y2 + offsetY]],
    textBaseline,
    textAlign: textAlign2
  };
}
function getStarPoints(outerR, innerR) {
  return [
    [0, -outerR],
    [innerR * Math.cos(3 * Math.PI / 10), -innerR * Math.sin(3 * Math.PI / 10)],
    [outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)],
    [innerR * Math.cos(Math.PI / 10), innerR * Math.sin(Math.PI / 10)],
    [outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)],
    [0, innerR],
    [-outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)],
    [-innerR * Math.cos(Math.PI / 10), innerR * Math.sin(Math.PI / 10)],
    [-outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)],
    [-innerR * Math.cos(3 * Math.PI / 10), -innerR * Math.sin(3 * Math.PI / 10)]
  ];
}
function getStarPorts(outerR, innerR) {
  const r2 = {};
  r2["top"] = [0, -outerR];
  r2["left"] = [-outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)];
  r2["left-bottom"] = [-outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)];
  r2["bottom"] = [0, innerR];
  r2["right-bottom"] = [outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)];
  r2["right"] = r2["default"] = [outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)];
  return r2;
}
function getTrianglePoints(width2, height, direction2) {
  const halfHeight = height / 2;
  const halfWidth = width2 / 2;
  const MAP = {
    up: [
      [-halfWidth, halfHeight],
      [halfWidth, halfHeight],
      [0, -halfHeight]
    ],
    left: [
      [-halfWidth, 0],
      [halfWidth, halfHeight],
      [halfWidth, -halfHeight]
    ],
    right: [
      [-halfWidth, halfHeight],
      [-halfWidth, -halfHeight],
      [halfWidth, 0]
    ],
    down: [
      [-halfWidth, -halfHeight],
      [halfWidth, -halfHeight],
      [0, halfHeight]
    ]
  };
  return MAP[direction2] || MAP["up"];
}
function getTrianglePorts(width2, height, direction2) {
  const halfHeight = height / 2;
  const halfWidth = width2 / 2;
  const ports = {};
  if (direction2 === "down") {
    ports["bottom"] = ports["default"] = [0, halfHeight];
    ports["right"] = [halfWidth, -halfHeight];
    ports["left"] = [-halfWidth, -halfHeight];
  } else if (direction2 === "left") {
    ports["top"] = [halfWidth, -halfHeight];
    ports["bottom"] = [halfWidth, halfHeight];
    ports["left"] = ports["default"] = [-halfWidth, 0];
  } else if (direction2 === "right") {
    ports["top"] = [-halfWidth, -halfHeight];
    ports["bottom"] = [-halfWidth, halfHeight];
    ports["right"] = ports["default"] = [halfWidth, 0];
  } else {
    ports["left"] = [-halfWidth, halfHeight];
    ports["top"] = ports["default"] = [0, -halfHeight];
    ports["right"] = [halfWidth, halfHeight];
  }
  return ports;
}
function getDiamondPoints(width2, height) {
  return [
    [0, -height / 2],
    [width2 / 2, 0],
    [0, height / 2],
    [-width2 / 2, 0]
  ];
}
function isVisible(element) {
  return get$1(element, ["style", "visibility"]) !== "hidden";
}
function setAttributes(element, style) {
  const { zIndex: zIndex2, transform: transform2, transformOrigin: transformOrigin2, visibility: visibility2, cursor, clipPath, component } = style, rest = __rest$b(style, ["zIndex", "transform", "transformOrigin", "visibility", "cursor", "clipPath", "component"]);
  Object.assign(element.attributes, rest);
  if (transform2)
    element.setAttribute("transform", transform2);
  if (isNumber(zIndex2))
    element.setAttribute("zIndex", zIndex2);
  if (transformOrigin2)
    element.setAttribute("transformOrigin", transformOrigin2);
  if (visibility2)
    element.setAttribute("visibility", visibility2);
  if (cursor)
    element.setAttribute("cursor", cursor);
  if (clipPath)
    element.setAttribute("clipPath", clipPath);
  if (component)
    element.setAttribute("component", component);
}
function updateStyle(shape, style) {
  if ("update" in shape)
    shape.update(style);
  else
    shape.attr(style);
}
function getHexagonPoints(outerR) {
  return [
    [0, outerR],
    [outerR * Math.sqrt(3) / 2, outerR / 2],
    [outerR * Math.sqrt(3) / 2, -outerR / 2],
    [0, -outerR],
    [-outerR * Math.sqrt(3) / 2, -outerR / 2],
    [-outerR * Math.sqrt(3) / 2, outerR / 2]
  ];
}
function markToBeDestroyed(element) {
  set$1(element, "__to_be_destroyed__", true);
}
function isToBeDestroyed(element) {
  return get$1(element, "__to_be_destroyed__", false);
}
var __awaiter$o = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class CollapseExpand extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, CollapseExpand.defaultOptions, options));
    this.onCollapseExpand = (event) => __awaiter$o(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { target } = event;
      if (!isElement(target))
        return;
      const id2 = target.id;
      const { model, graph: graph2 } = this.context;
      const data2 = model.getElementDataById(id2);
      if (!data2)
        return false;
      const { onCollapse, onExpand, animation, align } = this.options;
      if (isCollapsed(data2)) {
        yield graph2.expandElement(id2, { animation, align });
        onExpand === null || onExpand === void 0 ? void 0 : onExpand(id2);
      } else {
        yield graph2.collapseElement(id2, { animation, align });
        onCollapse === null || onCollapse === void 0 ? void 0 : onCollapse(id2);
      }
    });
    this.bindEvents();
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    const { trigger } = this.options;
    graph2.on(`node:${trigger}`, this.onCollapseExpand);
    graph2.on(`combo:${trigger}`, this.onCollapseExpand);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    const { trigger } = this.options;
    graph2.off(`node:${trigger}`, this.onCollapseExpand);
    graph2.off(`combo:${trigger}`, this.onCollapseExpand);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
CollapseExpand.defaultOptions = {
  enable: true,
  animation: true,
  trigger: CommonEvent.DBLCLICK,
  align: true
};
var __rest$a = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
function mergeElementsData(original, modified) {
  const { data: originalData, style: originalStyle } = original, originalAttrs = __rest$a(original, ["data", "style"]);
  const { data: modifiedData, style: modifiedStyle } = modified, modifiedAttrs = __rest$a(modified, ["data", "style"]);
  const result = Object.assign(Object.assign({}, originalAttrs), modifiedAttrs);
  if (originalData || modifiedData) {
    Object.assign(result, { data: Object.assign(Object.assign({}, originalData), modifiedData) });
  }
  if (originalStyle || modifiedStyle) {
    Object.assign(result, { style: Object.assign(Object.assign({}, originalStyle), modifiedStyle) });
  }
  return result;
}
function cloneElementData(data2) {
  const { data: customData, style } = data2, restAttrs = __rest$a(data2, ["data", "style"]);
  const clonedData = restAttrs;
  if (customData)
    clonedData.data = Object.assign({}, customData);
  if (style)
    clonedData.style = Object.assign({}, style);
  return clonedData;
}
function isElementDataEqual(original = {}, modified = {}) {
  const { states: originalStates = [], data: originalData = {}, style: originalStyle = {}, children: originalChildren = [] } = original, originalAttrs = __rest$a(original, ["states", "data", "style", "children"]);
  const { states: modifiedStates = [], data: modifiedData = {}, style: modifiedStyle = {}, children: modifiedChildren = [] } = modified, modifiedAttrs = __rest$a(modified, ["states", "data", "style", "children"]);
  const isArrayEqual = (arr1, arr2) => {
    if (arr1.length !== arr2.length)
      return false;
    return arr1.every((item, index2) => item === arr2[index2]);
  };
  const isObjectEqual = (obj1, obj2) => {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
      return false;
    return keys1.every((key) => obj1[key] === obj2[key]);
  };
  if (!isObjectEqual(originalAttrs, modifiedAttrs))
    return false;
  if (!isArrayEqual(originalChildren, modifiedChildren))
    return false;
  if (!isArrayEqual(originalStates, modifiedStates))
    return false;
  if (!isObjectEqual(originalData, modifiedData))
    return false;
  if (!isObjectEqual(originalStyle, modifiedStyle))
    return false;
  return true;
}
const OVERRIDE_KEY = "__internal_override__";
function isOverridable(datum) {
  return datum[OVERRIDE_KEY] !== false;
}
var __awaiter$n = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ASSIST_EDGE_ID = "g6-create-edge-assist-edge-id";
const ASSIST_NODE_ID = "g6-create-edge-assist-node-id";
class CreateEdge extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, CreateEdge.defaultOptions, options));
    this.drop = (event) => __awaiter$n(this, void 0, void 0, function* () {
      const { targetType } = event;
      if (["combo", "node"].includes(targetType) && this.source) {
        yield this.handleCreateEdge(event);
      } else {
        yield this.cancelEdge();
      }
    });
    this.handleCreateEdge = (event) => __awaiter$n(this, void 0, void 0, function* () {
      var _a3, _b, _c;
      if (!this.validate(event))
        return;
      const { graph: graph2, canvas: canvas2, batch, element } = this.context;
      const { style } = this.options;
      if (this.source) {
        this.createEdge(event);
        yield this.cancelEdge();
        return;
      }
      batch.startBatch();
      canvas2.setCursor("crosshair");
      this.source = this.getSelectedNodeIDs([event.target.id])[0];
      const sourceNode = graph2.getElementData(this.source);
      graph2.addNodeData([
        {
          id: ASSIST_NODE_ID,
          type: "circle",
          [OVERRIDE_KEY]: false,
          style: {
            size: 1,
            visibility: "hidden",
            ports: [{ key: "port-1", placement: [0.5, 0.5] }],
            x: (_a3 = sourceNode.style) === null || _a3 === void 0 ? void 0 : _a3.x,
            y: (_b = sourceNode.style) === null || _b === void 0 ? void 0 : _b.y
          }
        }
      ]);
      graph2.addEdgeData([
        {
          id: ASSIST_EDGE_ID,
          source: this.source,
          target: ASSIST_NODE_ID,
          style: Object.assign({ pointerEvents: "none" }, style)
        }
      ]);
      yield (_c = element.draw({ animation: false })) === null || _c === void 0 ? void 0 : _c.finished;
    });
    this.updateAssistEdge = (event) => __awaiter$n(this, void 0, void 0, function* () {
      var _a3;
      if (!this.source)
        return;
      const { model, element } = this.context;
      model.translateNodeTo(ASSIST_NODE_ID, [event.client.x, event.client.y]);
      yield (_a3 = element.draw({ animation: false, silence: true })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
    this.createEdge = (event) => {
      var _a3, _b;
      const { graph: graph2 } = this.context;
      const { style, onFinish, onCreate } = this.options;
      const targetId = (_a3 = event.target) === null || _a3 === void 0 ? void 0 : _a3.id;
      if (targetId === void 0 || this.source === void 0)
        return;
      const target = (_b = this.getSelectedNodeIDs([event.target.id])) === null || _b === void 0 ? void 0 : _b[0];
      const id2 = `${this.source}-${target}-${uniqueId$1()}`;
      const edgeData = onCreate({ id: id2, source: this.source, target, style });
      if (edgeData) {
        graph2.addEdgeData([edgeData]);
        onFinish(edgeData);
      }
    };
    this.cancelEdge = () => __awaiter$n(this, void 0, void 0, function* () {
      var _a3;
      if (!this.source)
        return;
      const { graph: graph2, element, batch } = this.context;
      graph2.removeNodeData([ASSIST_NODE_ID]);
      this.source = void 0;
      yield (_a3 = element.draw({ animation: false })) === null || _a3 === void 0 ? void 0 : _a3.finished;
      batch.endBatch();
    });
    this.bindEvents();
  }
  /**
   * Update options
   * @param options - The options to update
   * @internal
   */
  update(options) {
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    const { trigger } = this.options;
    this.unbindEvents();
    if (trigger === "click") {
      graph2.on(NodeEvent.CLICK, this.handleCreateEdge);
      graph2.on(ComboEvent.CLICK, this.handleCreateEdge);
      graph2.on(CanvasEvent.CLICK, this.cancelEdge);
      graph2.on(EdgeEvent.CLICK, this.cancelEdge);
    } else {
      graph2.on(NodeEvent.DRAG_START, this.handleCreateEdge);
      graph2.on(ComboEvent.DRAG_START, this.handleCreateEdge);
      graph2.on(CommonEvent.POINTER_UP, this.drop);
    }
    graph2.on(CommonEvent.POINTER_MOVE, this.updateAssistEdge);
  }
  getSelectedNodeIDs(currTarget) {
    return Array.from(new Set(this.context.graph.getElementDataByState("node", this.options.state).map((node) => node.id).concat(currTarget)));
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(NodeEvent.CLICK, this.handleCreateEdge);
    graph2.off(ComboEvent.CLICK, this.handleCreateEdge);
    graph2.off(CanvasEvent.CLICK, this.cancelEdge);
    graph2.off(EdgeEvent.CLICK, this.cancelEdge);
    graph2.off(NodeEvent.DRAG_START, this.handleCreateEdge);
    graph2.off(ComboEvent.DRAG_START, this.handleCreateEdge);
    graph2.off(CommonEvent.POINTER_UP, this.drop);
    graph2.off(CommonEvent.POINTER_MOVE, this.updateAssistEdge);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
CreateEdge.defaultOptions = {
  animation: true,
  enable: true,
  style: {},
  trigger: "drag",
  onCreate: (data2) => data2,
  onFinish: () => {
  }
};
var __awaiter$m = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DragCanvas extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, DragCanvas.defaultOptions, options));
    this.isDragging = false;
    this.onDragStart = (event) => {
      if (!this.validate(event))
        return;
      this.isDragging = true;
      this.context.canvas.setCursor("grabbing");
    };
    this.onDrag = (event) => {
      var _a3, _b, _c, _d;
      if (!this.isDragging || PinchHandler.isPinching)
        return;
      const x2 = (_b = (_a3 = event.movement) === null || _a3 === void 0 ? void 0 : _a3.x) !== null && _b !== void 0 ? _b : event.dx;
      const y2 = (_d = (_c = event.movement) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : event.dy;
      if ((x2 | y2) !== 0) {
        this.translate([x2, y2], false);
      }
    };
    this.onDragEnd = () => {
      var _a3, _b;
      this.isDragging = false;
      this.context.canvas.setCursor(this.defaultCursor);
      (_b = (_a3 = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a3);
    };
    this.invokeOnFinish = debounce(() => {
      var _a3, _b;
      (_b = (_a3 = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a3);
    }, 300);
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
    this.defaultCursor = this.context.canvas.getConfig().cursor || "default";
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { trigger } = this.options;
    if (isObject$2(trigger)) {
      const { up = [], down = [], left = [], right = [] } = trigger;
      this.shortcut.bind(up, (event) => this.onTranslate([0, 1], event));
      this.shortcut.bind(down, (event) => this.onTranslate([0, -1], event));
      this.shortcut.bind(left, (event) => this.onTranslate([1, 0], event));
      this.shortcut.bind(right, (event) => this.onTranslate([-1, 0], event));
    } else {
      const { graph: graph2 } = this.context;
      graph2.on(CommonEvent.DRAG_START, this.onDragStart);
      graph2.on(CommonEvent.DRAG, this.onDrag);
      graph2.on(CommonEvent.DRAG_END, this.onDragEnd);
    }
  }
  onTranslate(value, event) {
    return __awaiter$m(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { sensitivity } = this.options;
      const delta = sensitivity * -1;
      yield this.translate(multiply(value, delta), this.options.animation);
      this.invokeOnFinish();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Translate canvas
   * @param offset - <zh/>  | <en/> Translation distance
   * @param animation - <zh/>  | <en/> Animation configuration
   * @internal
   */
  translate(offset, animation) {
    return __awaiter$m(this, void 0, void 0, function* () {
      offset = this.clampByDirection(offset);
      offset = this.clampByRange(offset);
      offset = this.clampByRotation(offset);
      yield this.context.graph.translateBy(offset, animation);
    });
  }
  clampByRotation([dx, dy]) {
    const rotation = this.context.graph.getRotation();
    return rotate2([dx, dy], rotation);
  }
  clampByDirection([dx, dy]) {
    const { direction: direction2 } = this.options;
    if (direction2 === "x") {
      dy = 0;
    } else if (direction2 === "y") {
      dx = 0;
    }
    return [dx, dy];
  }
  clampByRange([dx, dy]) {
    const { viewport, canvas: canvas2 } = this.context;
    const [canvasWidth, canvasHeight] = canvas2.getSize();
    const [top, right, bottom, left] = parsePadding(this.options.range);
    const range = [canvasHeight * top, canvasWidth * right, canvasHeight * bottom, canvasWidth * left];
    const draggableArea = getExpandedBBox(getPointBBox(viewport.getCanvasCenter()), range);
    const nextViewportCenter = subtract(viewport.getViewportCenter(), [dx, dy, 0]);
    if (!isPointInBBox(nextViewportCenter, draggableArea)) {
      const { min: [minX, minY], max: [maxX, maxY] } = draggableArea;
      if (nextViewportCenter[0] < minX && dx > 0 || nextViewportCenter[0] > maxX && dx < 0) {
        dx = 0;
      }
      if (nextViewportCenter[1] < minY && dy > 0 || nextViewportCenter[1] > maxY && dy < 0) {
        dy = 0;
      }
    }
    return [dx, dy];
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (typeof enable === "function")
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    this.shortcut.unbindAll();
    const { graph: graph2 } = this.context;
    graph2.off(CommonEvent.DRAG_START, this.onDragStart);
    graph2.off(CommonEvent.DRAG, this.onDrag);
    graph2.off(CommonEvent.DRAG_END, this.onDragEnd);
  }
  destroy() {
    this.shortcut.destroy();
    this.unbindEvents();
    this.context.canvas.setCursor(this.defaultCursor);
    super.destroy();
  }
}
DragCanvas.defaultOptions = {
  enable: (event) => {
    if ("targetType" in event)
      return event.targetType === "canvas";
    return true;
  },
  sensitivity: 10,
  direction: "both",
  range: Infinity
};
var __awaiter$l = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DragElement extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, DragElement.defaultOptions, options));
    this.enable = false;
    this.enableElements = ["node", "combo"];
    this.target = [];
    this.shadowOrigin = [0, 0];
    this.hiddenEdges = [];
    this.isDragging = false;
    this.onDrop = (event) => __awaiter$l(this, void 0, void 0, function* () {
      var _a3;
      if (this.options.dropEffect !== "link")
        return;
      const { model, element } = this.context;
      const modifiedParentId = event.target.id;
      this.target.forEach((id2) => {
        const originalParent = model.getParentData(id2, COMBO_KEY);
        if (originalParent && idOf(originalParent) === modifiedParentId) {
          model.refreshComboData(modifiedParentId);
        }
        model.setParent(id2, modifiedParentId, COMBO_KEY);
      });
      yield (_a3 = element === null || element === void 0 ? void 0 : element.draw({ animation: true })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
    this.setCursor = (event) => {
      if (this.isDragging)
        return;
      const { type } = event;
      const { canvas: canvas2 } = this.context;
      const { cursor } = this.options;
      if (type === CommonEvent.POINTER_ENTER)
        canvas2.setCursor((cursor === null || cursor === void 0 ? void 0 : cursor.grab) || "grab");
      else
        canvas2.setCursor((cursor === null || cursor === void 0 ? void 0 : cursor.default) || "default");
    };
    this.shortcut = new Shortcut(context.graph);
    this.onDragStart = this.onDragStart.bind(this);
    this.onDrag = this.onDrag.bind(this);
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onDrop = this.onDrop.bind(this);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update the element dragging configuration
   * @param options - <zh/>  | <en/> options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2, canvas: canvas2 } = this.context;
    const $canvas = canvas2.getLayer().getContextService().$canvas;
    if ($canvas) {
      $canvas.addEventListener("blur", this.onDragEnd);
      $canvas.addEventListener("contextmenu", this.onDragEnd);
    }
    this.enableElements.forEach((type) => {
      graph2.on(`${type}:${CommonEvent.DRAG_START}`, this.onDragStart);
      graph2.on(`${type}:${CommonEvent.DRAG}`, this.onDrag);
      graph2.on(`${type}:${CommonEvent.DRAG_END}`, this.onDragEnd);
      graph2.on(`${type}:${CommonEvent.POINTER_ENTER}`, this.setCursor);
      graph2.on(`${type}:${CommonEvent.POINTER_LEAVE}`, this.setCursor);
    });
    if (["link"].includes(this.options.dropEffect)) {
      graph2.on(ComboEvent.DROP, this.onDrop);
      graph2.on(CanvasEvent.DROP, this.onDrop);
    }
  }
  /**
   * <zh/>  id 
   *
   * <en/> Get the id collection of the currently selected node
   * @param currTarget - <zh/>  id  | <en/> The id collection of the current drag target element
   * @returns <zh/>  id  | <en/> The id collection of the currently selected node
   * @internal
   */
  getSelectedNodeIDs(currTarget) {
    return Array.from(new Set(this.context.graph.getElementDataByState("node", this.options.state).map((node) => node.id).concat(currTarget)));
  }
  /**
   * Get the delta of the drag
   * @param event - drag event object
   * @returns delta
   * @internal
   */
  getDelta(event) {
    const zoom = this.context.graph.getZoom();
    return divide([event.dx, event.dy], zoom);
  }
  /**
   * <zh/> 
   *
   * <en/> Callback when dragging starts
   * @param event - <zh/>  | <en/> drag event object
   * @internal
   */
  onDragStart(event) {
    var _a3;
    this.enable = this.validate(event);
    if (!this.enable)
      return;
    const { batch, canvas: canvas2, graph: graph2 } = this.context;
    canvas2.setCursor(((_a3 = this.options.cursor) === null || _a3 === void 0 ? void 0 : _a3.grabbing) || "grabbing");
    this.isDragging = true;
    batch.startBatch();
    const id2 = event.target.id;
    const states = graph2.getElementState(id2);
    if (states.includes(this.options.state))
      this.target = this.getSelectedNodeIDs([id2]);
    else
      this.target = [id2];
    this.hideEdge();
    this.context.graph.frontElement(this.target);
    if (this.options.shadow)
      this.createShadow(this.target);
  }
  /**
   * <zh/> 
   *
   * <en/> Callback when dragging
   * @param event - <zh/>  | <en/> drag event object
   * @internal
   */
  onDrag(event) {
    if (!this.enable)
      return;
    const delta = this.getDelta(event);
    if (this.options.shadow)
      this.moveShadow(delta);
    else
      this.moveElement(this.target, delta);
  }
  /**
   * <zh/> 
   *
   * <en/> Callback when dragging ends
   * @internal
   */
  onDragEnd() {
    var _a3, _b, _c;
    if (!this.enable)
      return;
    this.enable = false;
    if (this.options.shadow) {
      if (!this.shadow)
        return;
      this.shadow.style.visibility = "hidden";
      const { x: x2 = 0, y: y2 = 0 } = this.shadow.attributes;
      const [dx, dy] = subtract([+x2, +y2], this.shadowOrigin);
      this.moveElement(this.target, [dx, dy]);
    }
    this.showEdges();
    (_b = (_a3 = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a3, this.target);
    const { batch, canvas: canvas2 } = this.context;
    batch.endBatch();
    canvas2.setCursor(((_c = this.options.cursor) === null || _c === void 0 ? void 0 : _c.grab) || "grab");
    this.isDragging = false;
    this.target = [];
  }
  /**
   * <zh/>  trigger 
   *
   * <en/> Is the current key consistent with the trigger configuration
   * @returns <zh/>  | <en/> Is consistent
   * @internal
   */
  isKeydown() {
    const { trigger } = this.options;
    if (!(trigger === null || trigger === void 0 ? void 0 : trigger.length))
      return true;
    return this.shortcut.match(trigger);
  }
  /**
   * <zh/> 
   *
   * <en/> Verify if the element is allowed to be dragged
   * @param event - <zh/>  | <en/> drag event object
   * @returns <zh/>  | <en/> Whether to allow dragging
   * @internal
   */
  validate(event) {
    if (this.destroyed || isToBeDestroyed(event.target) || // @ts-expect-error private property
    // combo/node
    this.context.graph.isCollapsingExpanding || !this.isKeydown())
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  clampByRotation([dx, dy]) {
    const rotation = this.context.graph.getRotation();
    return rotate2([dx, dy], rotation);
  }
  /**
   * <zh/> 
   *
   * <en/> Move the element
   * @param ids - <zh/>  id  | <en/> element id collection
   * @param offset <zh/>  | <en/> offset
   * @internal
   */
  moveElement(ids, offset) {
    return __awaiter$l(this, void 0, void 0, function* () {
      const { graph: graph2, model } = this.context;
      const { dropEffect } = this.options;
      if (dropEffect === "move")
        ids.forEach((id2) => model.refreshComboData(id2));
      graph2.translateElementBy(Object.fromEntries(ids.map((id2) => [id2, this.clampByRotation(offset)])), false);
    });
  }
  moveShadow(offset) {
    if (!this.shadow)
      return;
    const { x: x2 = 0, y: y2 = 0 } = this.shadow.attributes;
    const [dx, dy] = offset;
    this.shadow.attr({ x: +x2 + dx, y: +y2 + dy });
  }
  createShadow(target) {
    const shadowStyle = subStyleProps$1(this.options, "shadow");
    const bbox = getCombinedBBox(target.map((id2) => this.context.element.getElement(id2).getBounds()));
    const [x2, y2] = bbox.min;
    this.shadowOrigin = [x2, y2];
    const [width2, height] = getBBoxSize$1(bbox);
    const positionStyle = { width: width2, height, x: x2, y: y2 };
    if (this.shadow) {
      this.shadow.attr(Object.assign(Object.assign(Object.assign({}, shadowStyle), positionStyle), { visibility: "visible" }));
    } else {
      this.shadow = new Rect$1({
        style: Object.assign(Object.assign(Object.assign({
          // @ts-ignore $layer is not in the type definition
          $layer: "transient"
        }, shadowStyle), positionStyle), { pointerEvents: "none" })
      });
      this.context.canvas.appendChild(this.shadow);
    }
  }
  showEdges() {
    if (this.options.shadow || this.hiddenEdges.length === 0)
      return;
    this.context.graph.showElement(this.hiddenEdges);
    this.hiddenEdges = [];
  }
  /**
   * Hide the edge
   * @internal
   */
  hideEdge() {
    const { hideEdge, shadow } = this.options;
    if (hideEdge === "none" || shadow)
      return;
    const { graph: graph2 } = this.context;
    if (hideEdge === "all")
      this.hiddenEdges = graph2.getEdgeData().map(idOf);
    else {
      this.hiddenEdges = Array.from(new Set(this.target.map((id2) => graph2.getRelatedEdgesData(id2, hideEdge).map(idOf)).flat()));
    }
    graph2.hideElement(this.hiddenEdges);
  }
  unbindEvents() {
    const { graph: graph2, canvas: canvas2 } = this.context;
    const $canvas = canvas2.getLayer().getContextService().$canvas;
    if ($canvas) {
      $canvas.removeEventListener("blur", this.onDragEnd);
      $canvas.removeEventListener("contextmenu", this.onDragEnd);
    }
    this.enableElements.forEach((type) => {
      graph2.off(`${type}:${CommonEvent.DRAG_START}`, this.onDragStart);
      graph2.off(`${type}:${CommonEvent.DRAG}`, this.onDrag);
      graph2.off(`${type}:${CommonEvent.DRAG_END}`, this.onDragEnd);
      graph2.off(`${type}:${CommonEvent.POINTER_ENTER}`, this.setCursor);
      graph2.off(`${type}:${CommonEvent.POINTER_LEAVE}`, this.setCursor);
    });
    graph2.off(`combo:${CommonEvent.DROP}`, this.onDrop);
    graph2.off(`canvas:${CommonEvent.DROP}`, this.onDrop);
  }
  destroy() {
    var _a3;
    this.unbindEvents();
    (_a3 = this.shadow) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    super.destroy();
  }
}
DragElement.defaultOptions = {
  animation: true,
  enable: (event) => ["node", "combo"].includes(event.targetType),
  trigger: [],
  dropEffect: "move",
  state: "selected",
  hideEdge: "none",
  shadow: false,
  shadowZIndex: 100,
  shadowFill: "#F3F9FF",
  shadowFillOpacity: 0.5,
  shadowStroke: "#1890FF",
  shadowStrokeOpacity: 0.9,
  shadowLineDash: [5, 5],
  cursor: {
    default: "default",
    grab: "grab",
    grabbing: "grabbing"
  }
};
var WILDCARD = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this2 = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length2 = es.length;
        for (var i2 = 0; i2 < length2; i2++) {
          if (!es[i2]) {
            continue;
          }
          var _a3 = es[i2], callback = _a3.callback, once = _a3.once;
          if (once) {
            es.splice(i2, 1);
            if (es.length === 0) {
              delete _this2._events[evt];
            }
            length2--;
            i2--;
          }
          callback.apply(_this2, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i2 = 0; i2 < length_1; i2++) {
            if (events[i2].callback === callback) {
              events.splice(i2, 1);
              length_1--;
              i2--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }()
);
function doBFS(queue, visited, fn, navigator) {
  while (queue.length) {
    const node = queue.shift();
    const abort = fn(node);
    if (abort) {
      return true;
    }
    visited.add(node.id);
    navigator(node.id).forEach((n2) => {
      if (!visited.has(n2.id)) {
        visited.add(n2.id);
        queue.push(n2);
      }
    });
  }
  return false;
}
function doDFS$1(node, visited, fn, navigator) {
  const abort = fn(node);
  if (abort) {
    return true;
  }
  visited.add(node.id);
  for (const n2 of navigator(node.id)) {
    if (!visited.has(n2.id)) {
      if (doDFS$1(n2, visited, fn, navigator)) {
        return true;
      }
    }
  }
  return false;
}
const defaultFilter = () => true;
class GraphView {
  constructor(options) {
    __publicField(this, "graph");
    __publicField(this, "nodeFilter");
    __publicField(this, "edgeFilter");
    // caches
    __publicField(this, "cacheEnabled");
    __publicField(this, "inEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "outEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "bothEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "allNodesMap", /* @__PURE__ */ new Map());
    __publicField(this, "allEdgesMap", /* @__PURE__ */ new Map());
    /**
     * Clear all cache data. Therefore `getAllNodes()` will return `[]`.
     * If you want to disable caching, use `graphView.cacheEnabled = false` instead.
     */
    __publicField(this, "clearCache", () => {
      this.inEdgesMap.clear();
      this.outEdgesMap.clear();
      this.bothEdgesMap.clear();
      this.allNodesMap.clear();
      this.allEdgesMap.clear();
    });
    /**
     * Fully refresh all cache data to the current graph state.
     */
    __publicField(this, "refreshCache", () => {
      this.clearCache();
      this.updateCache(this.graph.getAllNodes().map((node) => node.id));
    });
    /**
     * Instead of a fully refreshment, this method partially update the cache data by specifying
     * involved(added, removed, updated) nodes. It's more efficient when handling small changes
     * on a large graph.
     */
    __publicField(this, "updateCache", (involvedNodeIds) => {
      const involvedEdgeIds = /* @__PURE__ */ new Set();
      involvedNodeIds.forEach((id2) => {
        const oldEdgesSet = this.bothEdgesMap.get(id2);
        if (oldEdgesSet) {
          oldEdgesSet.forEach((edge) => involvedEdgeIds.add(edge.id));
        }
        if (!this.hasNode(id2)) {
          this.inEdgesMap.delete(id2);
          this.outEdgesMap.delete(id2);
          this.bothEdgesMap.delete(id2);
          this.allNodesMap.delete(id2);
        } else {
          const inEdges = this.graph.getRelatedEdges(id2, "in").filter(this.edgeFilter);
          const outEdges = this.graph.getRelatedEdges(id2, "out").filter(this.edgeFilter);
          const bothEdges = Array.from(/* @__PURE__ */ new Set([...inEdges, ...outEdges]));
          bothEdges.forEach((edge) => involvedEdgeIds.add(edge.id));
          this.inEdgesMap.set(id2, inEdges);
          this.outEdgesMap.set(id2, outEdges);
          this.bothEdgesMap.set(id2, bothEdges);
          this.allNodesMap.set(id2, this.graph.getNode(id2));
        }
      });
      involvedEdgeIds.forEach((id2) => {
        if (this.hasEdge(id2)) {
          this.allEdgesMap.set(id2, this.graph.getEdge(id2));
        } else {
          this.allEdgesMap.delete(id2);
        }
      });
    });
    __publicField(this, "handleGraphChanged", (event) => {
      const involvedNodeIds = /* @__PURE__ */ new Set();
      event.changes.forEach((change) => {
        switch (change.type) {
          case "NodeAdded":
            involvedNodeIds.add(change.value.id);
            break;
          case "NodeDataUpdated":
            involvedNodeIds.add(change.id);
            break;
          case "EdgeAdded":
            involvedNodeIds.add(change.value.source);
            involvedNodeIds.add(change.value.target);
            break;
          case "EdgeUpdated":
            if (change.propertyName === "source" || change.propertyName === "target") {
              involvedNodeIds.add(change.oldValue);
              involvedNodeIds.add(change.newValue);
            }
            break;
          case "EdgeDataUpdated":
            if (event.graph.hasEdge(change.id)) {
              const edge = event.graph.getEdge(change.id);
              involvedNodeIds.add(edge.source);
              involvedNodeIds.add(edge.target);
            }
            break;
          case "EdgeRemoved":
            involvedNodeIds.add(change.value.source);
            involvedNodeIds.add(change.value.target);
            break;
          case "NodeRemoved":
            involvedNodeIds.add(change.value.id);
            break;
        }
      });
      this.updateCache(involvedNodeIds);
    });
    this.graph = options.graph;
    const nodeFilter = options.nodeFilter || defaultFilter;
    const edgeFilter = options.edgeFilter || defaultFilter;
    this.nodeFilter = nodeFilter;
    this.edgeFilter = (edge) => {
      const { source, target } = this.graph.getEdgeDetail(edge.id);
      if (!nodeFilter(source) || !nodeFilter(target)) {
        return false;
      }
      return edgeFilter(edge, source, target);
    };
    if (options.cache === "auto") {
      this.cacheEnabled = true;
      this.startAutoCache();
    } else if (options.cache === "manual") {
      this.cacheEnabled = true;
    } else {
      this.cacheEnabled = false;
    }
  }
  startAutoCache() {
    this.refreshCache();
    this.graph.on("changed", this.handleGraphChanged);
  }
  stopAutoCache() {
    this.graph.off("changed", this.handleGraphChanged);
  }
  // ================= Node =================
  checkNodeExistence(id2) {
    this.getNode(id2);
  }
  hasNode(id2) {
    if (!this.graph.hasNode(id2))
      return false;
    const node = this.graph.getNode(id2);
    return this.nodeFilter(node);
  }
  areNeighbors(firstNodeId, secondNodeId) {
    this.checkNodeExistence(firstNodeId);
    return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
  }
  getNode(id2) {
    const node = this.graph.getNode(id2);
    if (!this.nodeFilter(node)) {
      throw new Error("Node not found for id: " + id2);
    }
    return node;
  }
  getRelatedEdges(id2, direction2) {
    this.checkNodeExistence(id2);
    if (this.cacheEnabled) {
      if (direction2 === "in") {
        return this.inEdgesMap.get(id2);
      } else if (direction2 === "out") {
        return this.outEdgesMap.get(id2);
      } else {
        return this.bothEdgesMap.get(id2);
      }
    }
    const edges = this.graph.getRelatedEdges(id2, direction2);
    return edges.filter(this.edgeFilter);
  }
  getDegree(id2, direction2) {
    return this.getRelatedEdges(id2, direction2).length;
  }
  getSuccessors(id2) {
    const outEdges = this.getRelatedEdges(id2, "out");
    const targets = outEdges.map((edge) => this.getNode(edge.target));
    return Array.from(new Set(targets));
  }
  getPredecessors(id2) {
    const inEdges = this.getRelatedEdges(id2, "in");
    const sources = inEdges.map((edge) => this.getNode(edge.source));
    return Array.from(new Set(sources));
  }
  getNeighbors(id2) {
    const predecessors = this.getPredecessors(id2);
    const successors = this.getSuccessors(id2);
    return Array.from(/* @__PURE__ */ new Set([...predecessors, ...successors]));
  }
  // ================= Edge =================
  hasEdge(id2) {
    if (!this.graph.hasEdge(id2))
      return false;
    const edge = this.graph.getEdge(id2);
    return this.edgeFilter(edge);
  }
  getEdge(id2) {
    const edge = this.graph.getEdge(id2);
    if (!this.edgeFilter(edge)) {
      throw new Error("Edge not found for id: " + id2);
    }
    return edge;
  }
  getEdgeDetail(id2) {
    const edge = this.getEdge(id2);
    return {
      edge,
      source: this.getNode(edge.source),
      target: this.getNode(edge.target)
    };
  }
  // ================= Tree =================
  hasTreeStructure(treeKey) {
    return this.graph.hasTreeStructure(treeKey);
  }
  getRoots(treeKey) {
    return this.graph.getRoots(treeKey).filter(this.nodeFilter);
  }
  getChildren(id2, treeKey) {
    this.checkNodeExistence(id2);
    return this.graph.getChildren(id2, treeKey).filter(this.nodeFilter);
  }
  getParent(id2, treeKey) {
    this.checkNodeExistence(id2);
    const parent = this.graph.getParent(id2, treeKey);
    if (!parent || !this.nodeFilter(parent))
      return null;
    return parent;
  }
  // ================= Graph =================
  getAllNodes() {
    if (this.cacheEnabled) {
      return Array.from(this.allNodesMap.values());
    }
    return this.graph.getAllNodes().filter(this.nodeFilter);
  }
  getAllEdges() {
    if (this.cacheEnabled) {
      return Array.from(this.allEdgesMap.values());
    }
    return this.graph.getAllEdges().filter(this.edgeFilter);
  }
  bfs(id2, fn, direction2 = "out") {
    const navigator = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction2];
    doBFS([this.getNode(id2)], /* @__PURE__ */ new Set(), fn, navigator);
  }
  dfs(id2, fn, direction2 = "out") {
    const navigator = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction2];
    doDFS$1(this.getNode(id2), /* @__PURE__ */ new Set(), fn, navigator);
  }
}
let Graph$9 = class Graph extends EventEmitter {
  /**
   * Create a new Graph instance.
   * @param options - The options to initialize a graph. See {@link GraphOptions}.
   *
   * ```ts
   * const graph = new Graph({
   *   // Optional, initial nodes.
   *   nodes: [
   *     // Each node has a unique ID.
   *     { id: 'A', foo: 1 },
   *     { id: 'B', foo: 1 },
   *   ],
   *   // Optional, initial edges.
   *   edges: [
   *     { id: 'C', source: 'B', target: 'B', weight: 1 },
   *   ],
   *   // Optional, called with a GraphChangedEvent.
   *   onChanged: (event) => {
   *     console.log(event);
   *   }
   * });
   * ```
   */
  constructor(options) {
    super();
    __publicField(this, "nodeMap", /* @__PURE__ */ new Map());
    __publicField(this, "edgeMap", /* @__PURE__ */ new Map());
    __publicField(this, "inEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "outEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "bothEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "treeIndices", /* @__PURE__ */ new Map());
    __publicField(this, "changes", []);
    __publicField(this, "batchCount", 0);
    /**
     * This function is called with a {@link GraphChangedEvent} each time a graph change happened.
     *
     * `event.changes` contains all the graph changes in order since last `onChanged`.
     */
    __publicField(this, "onChanged", () => {
    });
    /**
     * Batch several graph changes into one.
     *
     * Make several changes, but dispatch only one ChangedEvent at the end of batch:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.addEdges([]);
     * });
     * ```
     *
     * Batches can be nested. Only the outermost batch will dispatch a ChangedEvent:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.batch(() => {
     *     graph.addEdges([]);
     *   });
     * });
     * ```
     */
    __publicField(this, "batch", (fn) => {
      this.batchCount += 1;
      fn();
      this.batchCount -= 1;
      if (!this.batchCount) {
        this.commit();
      }
    });
    if (!options)
      return;
    if (options.nodes)
      this.addNodes(options.nodes);
    if (options.edges)
      this.addEdges(options.edges);
    if (options.tree)
      this.addTree(options.tree);
    if (options.onChanged)
      this.onChanged = options.onChanged;
  }
  /**
   * Reset changes and dispatch a ChangedEvent.
   */
  commit() {
    const changes = this.changes;
    this.changes = [];
    const event = {
      graph: this,
      changes
    };
    this.emit("changed", event);
    this.onChanged(event);
  }
  /**
   * Reduce the number of ordered graph changes by dropping or merging unnecessary changes.
   *
   * For example, if we update a node and remove it in a batch:
   *
   * ```ts
   * graph.batch(() => {
   *   graph.updateNodeData('A', 'foo', 2);
   *   graph.removeNode('A');
   * });
   * ```
   *
   * We get 2 atomic graph changes like
   *
   * ```ts
   * [
   *   { type: 'NodeDataUpdated', id: 'A', propertyName: 'foo', oldValue: 1, newValue: 2 },
   *   { type: 'NodeRemoved', value: { id: 'A', data: { foo: 2 } },
   * ]
   * ```
   *
   * Since node 'A' has been removed, we actually have no need to handle with NodeDataUpdated change.
   *
   * `reduceChanges()` here helps us remove such changes.
   */
  reduceChanges(changes) {
    let mergedChanges = [];
    changes.forEach((change) => {
      switch (change.type) {
        case "NodeRemoved": {
          let isNewlyAdded = false;
          mergedChanges = mergedChanges.filter((pastChange) => {
            if (pastChange.type === "NodeAdded") {
              const sameId = pastChange.value.id === change.value.id;
              if (sameId) {
                isNewlyAdded = true;
              }
              return !sameId;
            } else if (pastChange.type === "NodeDataUpdated") {
              return pastChange.id !== change.value.id;
            } else if (pastChange.type === "TreeStructureChanged") {
              return pastChange.nodeId !== change.value.id;
            }
            return true;
          });
          if (!isNewlyAdded) {
            mergedChanges.push(change);
          }
          break;
        }
        case "EdgeRemoved": {
          let isNewlyAdded = false;
          mergedChanges = mergedChanges.filter((pastChange) => {
            if (pastChange.type === "EdgeAdded") {
              const sameId = pastChange.value.id === change.value.id;
              if (sameId) {
                isNewlyAdded = true;
              }
              return !sameId;
            } else if (pastChange.type === "EdgeDataUpdated" || pastChange.type === "EdgeUpdated") {
              return pastChange.id !== change.value.id;
            }
            return true;
          });
          if (!isNewlyAdded) {
            mergedChanges.push(change);
          }
          break;
        }
        case "NodeDataUpdated":
        case "EdgeDataUpdated":
        case "EdgeUpdated": {
          const index2 = mergedChanges.findIndex((pastChange) => {
            return pastChange.type === change.type && pastChange.id === change.id && (change.propertyName === void 0 || pastChange.propertyName === change.propertyName);
          });
          const existingChange = mergedChanges[index2];
          if (existingChange) {
            if (change.propertyName !== void 0) {
              existingChange.newValue = change.newValue;
            } else {
              mergedChanges.splice(index2, 1);
              mergedChanges.push(change);
            }
          } else {
            mergedChanges.push(change);
          }
          break;
        }
        case "TreeStructureDetached": {
          mergedChanges = mergedChanges.filter((pastChange) => {
            if (pastChange.type === "TreeStructureAttached") {
              return pastChange.treeKey !== change.treeKey;
            } else if (pastChange.type === "TreeStructureChanged") {
              return pastChange.treeKey !== change.treeKey;
            }
            return true;
          });
          mergedChanges.push(change);
          break;
        }
        case "TreeStructureChanged": {
          const existingChange = mergedChanges.find((pastChange) => {
            return pastChange.type === "TreeStructureChanged" && pastChange.treeKey === change.treeKey && pastChange.nodeId === change.nodeId;
          });
          if (existingChange) {
            existingChange.newParentId = change.newParentId;
          } else {
            mergedChanges.push(change);
          }
          break;
        }
        default:
          mergedChanges.push(change);
          break;
      }
    });
    return mergedChanges;
  }
  // ================= Node =================
  checkNodeExistence(id2) {
    this.getNode(id2);
  }
  /**
   * Check if a node exists in the graph.
   * @group NodeMethods
   */
  hasNode(id2) {
    return this.nodeMap.has(id2);
  }
  /**
   * Tell if two nodes are neighbors.
   * @group NodeMethods
   */
  areNeighbors(firstNodeId, secondNodeId) {
    return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
  }
  /**
   * Get the node data with given ID.
   * @group NodeMethods
   */
  getNode(id2) {
    const node = this.nodeMap.get(id2);
    if (!node) {
      throw new Error("Node not found for id: " + id2);
    }
    return node;
  }
  /**
   * Given a node ID, find all edges of the node.
   * @param id - ID of the node
   * @param direction - Edge direction, defaults to 'both'.
   * @group NodeMethods
   */
  getRelatedEdges(id2, direction2) {
    this.checkNodeExistence(id2);
    if (direction2 === "in") {
      const inEdges = this.inEdgesMap.get(id2);
      return Array.from(inEdges);
    } else if (direction2 === "out") {
      const outEdges = this.outEdgesMap.get(id2);
      return Array.from(outEdges);
    } else {
      const bothEdges = this.bothEdgesMap.get(id2);
      return Array.from(bothEdges);
    }
  }
  /**
   * Get the degree of the given node.
   * @group NodeMethods
   */
  getDegree(id2, direction2) {
    return this.getRelatedEdges(id2, direction2).length;
  }
  /**
   * Get all successors of the given node.
   */
  getSuccessors(id2) {
    const outEdges = this.getRelatedEdges(id2, "out");
    const targets = outEdges.map((edge) => this.getNode(edge.target));
    return Array.from(new Set(targets));
  }
  /**
   * Get all predecessors of the given node.
   */
  getPredecessors(id2) {
    const inEdges = this.getRelatedEdges(id2, "in");
    const sources = inEdges.map((edge) => this.getNode(edge.source));
    return Array.from(new Set(sources));
  }
  /**
   * Given a node ID, find its neighbors.
   * @param id - ID of the node
   * @group NodeMethods
   */
  getNeighbors(id2) {
    const predecessors = this.getPredecessors(id2);
    const successors = this.getSuccessors(id2);
    return Array.from(/* @__PURE__ */ new Set([...predecessors, ...successors]));
  }
  doAddNode(node) {
    if (this.hasNode(node.id)) {
      throw new Error("Node already exists: " + node.id);
    }
    this.nodeMap.set(node.id, node);
    this.inEdgesMap.set(node.id, /* @__PURE__ */ new Set());
    this.outEdgesMap.set(node.id, /* @__PURE__ */ new Set());
    this.bothEdgesMap.set(node.id, /* @__PURE__ */ new Set());
    this.treeIndices.forEach((tree) => {
      tree.childrenMap.set(node.id, /* @__PURE__ */ new Set());
    });
    this.changes.push({ type: "NodeAdded", value: node });
  }
  /**
   * Add all nodes of the given array, or iterable, into the graph.
   * @group NodeMethods
   */
  addNodes(nodes) {
    this.batch(() => {
      for (const node of nodes) {
        this.doAddNode(node);
      }
    });
  }
  /**
   * Add a single node into the graph.
   * @group NodeMethods
   */
  addNode(node) {
    this.addNodes([node]);
  }
  doRemoveNode(id2) {
    const node = this.getNode(id2);
    const bothEdges = this.bothEdgesMap.get(id2);
    bothEdges == null ? void 0 : bothEdges.forEach((edge) => this.doRemoveEdge(edge.id));
    this.nodeMap.delete(id2);
    this.treeIndices.forEach((tree) => {
      var _a3, _b;
      (_a3 = tree.childrenMap.get(id2)) == null ? void 0 : _a3.forEach((child) => {
        tree.parentMap.delete(child.id);
      });
      const parent = tree.parentMap.get(id2);
      if (parent)
        (_b = tree.childrenMap.get(parent.id)) == null ? void 0 : _b.delete(node);
      tree.parentMap.delete(id2);
      tree.childrenMap.delete(id2);
    });
    this.bothEdgesMap.delete(id2);
    this.inEdgesMap.delete(id2);
    this.outEdgesMap.delete(id2);
    this.changes.push({ type: "NodeRemoved", value: node });
  }
  /**
   * Remove nodes and their attached edges from the graph.
   * @group NodeMethods
   */
  removeNodes(idList) {
    this.batch(() => {
      idList.forEach((id2) => this.doRemoveNode(id2));
    });
  }
  /**
   * Remove a single node and its attached edges from the graph.
   * @group NodeMethods
   */
  removeNode(id2) {
    this.removeNodes([id2]);
  }
  updateNodeDataProperty(id2, propertyName, value) {
    const node = this.getNode(id2);
    this.batch(() => {
      const oldValue = node.data[propertyName];
      const newValue = value;
      node.data[propertyName] = newValue;
      this.changes.push({
        type: "NodeDataUpdated",
        id: id2,
        propertyName,
        oldValue,
        newValue
      });
    });
  }
  /**
   * Like Object.assign, merge all properties of `path` to the node data.
   * @param id Node ID.
   * @param patch A data object to merge.
   */
  mergeNodeData(id2, patch) {
    this.batch(() => {
      Object.entries(patch).forEach(([propertyName, value]) => {
        this.updateNodeDataProperty(id2, propertyName, value);
      });
    });
  }
  updateNodeData(...args) {
    const id2 = args[0];
    const node = this.getNode(id2);
    if (typeof args[1] === "string") {
      this.updateNodeDataProperty(id2, args[1], args[2]);
      return;
    }
    let data2;
    if (typeof args[1] === "function") {
      const update = args[1];
      data2 = update(node.data);
    } else if (typeof args[1] === "object") {
      data2 = args[1];
    }
    this.batch(() => {
      const oldValue = node.data;
      const newValue = data2;
      node.data = data2;
      this.changes.push({
        type: "NodeDataUpdated",
        id: id2,
        oldValue,
        newValue
      });
    });
  }
  // ================= Edge =================
  checkEdgeExistence(id2) {
    if (!this.hasEdge(id2)) {
      throw new Error("Edge not found for id: " + id2);
    }
  }
  /**
   * Check if an edge exists in the graph.
   * @group NodeMethods
   */
  hasEdge(id2) {
    return this.edgeMap.has(id2);
  }
  /**
   * Get the edge data with given ID.
   * @group EdgeMethods
   */
  getEdge(id2) {
    this.checkEdgeExistence(id2);
    return this.edgeMap.get(id2);
  }
  /**
   * Get the edge, the source node, and the target node by an edge ID.
   * @group EdgeMethods
   */
  getEdgeDetail(id2) {
    const edge = this.getEdge(id2);
    return {
      edge,
      source: this.getNode(edge.source),
      target: this.getNode(edge.target)
    };
  }
  doAddEdge(edge) {
    if (this.hasEdge(edge.id)) {
      throw new Error("Edge already exists: " + edge.id);
    }
    this.checkNodeExistence(edge.source);
    this.checkNodeExistence(edge.target);
    this.edgeMap.set(edge.id, edge);
    const inEdges = this.inEdgesMap.get(edge.target);
    const outEdges = this.outEdgesMap.get(edge.source);
    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
    inEdges.add(edge);
    outEdges.add(edge);
    bothEdgesOfSource.add(edge);
    bothEdgesOfTarget.add(edge);
    this.changes.push({ type: "EdgeAdded", value: edge });
  }
  /**
   * Add all edges of the given iterable(an array, a set, etc.) into the graph.
   * @group EdgeMethods
   */
  addEdges(edges) {
    this.batch(() => {
      for (const edge of edges) {
        this.doAddEdge(edge);
      }
    });
  }
  /**
   * Add a single edge pointing from `source` to `target` into the graph.
   *
   * ```ts
   * graph.addNode({ id: 'NodeA' });
   * graph.addNode({ id: 'NodeB' });
   * graph.addEdge({ id: 'EdgeA', source: 'NodeA', target: 'NodeB' });
   * ```
   *
   * If `source` or `target` were not found in the current graph, it throws an Error.
   * @group EdgeMethods
   */
  addEdge(edge) {
    this.addEdges([edge]);
  }
  doRemoveEdge(id2) {
    const edge = this.getEdge(id2);
    const outEdges = this.outEdgesMap.get(edge.source);
    const inEdges = this.inEdgesMap.get(edge.target);
    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
    outEdges.delete(edge);
    inEdges.delete(edge);
    bothEdgesOfSource.delete(edge);
    bothEdgesOfTarget.delete(edge);
    this.edgeMap.delete(id2);
    this.changes.push({ type: "EdgeRemoved", value: edge });
  }
  /**
   * Remove edges whose id was included in the given id list.
   * @group EdgeMethods
   */
  removeEdges(idList) {
    this.batch(() => {
      idList.forEach((id2) => this.doRemoveEdge(id2));
    });
  }
  /**
   * Remove a single edge of the given id.
   * @group EdgeMethods
   */
  removeEdge(id2) {
    this.removeEdges([id2]);
  }
  /**
   * Change the source of an edge. The source must be found in current graph.
   * @group EdgeMethods
   */
  updateEdgeSource(id2, source) {
    const edge = this.getEdge(id2);
    this.checkNodeExistence(source);
    const oldSource = edge.source;
    const newSource = source;
    this.outEdgesMap.get(oldSource).delete(edge);
    this.bothEdgesMap.get(oldSource).delete(edge);
    this.outEdgesMap.get(newSource).add(edge);
    this.bothEdgesMap.get(newSource).add(edge);
    edge.source = source;
    this.batch(() => {
      this.changes.push({
        type: "EdgeUpdated",
        id: id2,
        propertyName: "source",
        oldValue: oldSource,
        newValue: newSource
      });
    });
  }
  /**
   * Change the target of an edge. The target must be found in current graph.
   * @group EdgeMethods
   */
  updateEdgeTarget(id2, target) {
    const edge = this.getEdge(id2);
    this.checkNodeExistence(target);
    const oldTarget = edge.target;
    const newTarget = target;
    this.inEdgesMap.get(oldTarget).delete(edge);
    this.bothEdgesMap.get(oldTarget).delete(edge);
    this.inEdgesMap.get(newTarget).add(edge);
    this.bothEdgesMap.get(newTarget).add(edge);
    edge.target = target;
    this.batch(() => {
      this.changes.push({
        type: "EdgeUpdated",
        id: id2,
        propertyName: "target",
        oldValue: oldTarget,
        newValue: newTarget
      });
    });
  }
  updateEdgeDataProperty(id2, propertyName, value) {
    const edge = this.getEdge(id2);
    this.batch(() => {
      const oldValue = edge.data[propertyName];
      const newValue = value;
      edge.data[propertyName] = newValue;
      this.changes.push({
        type: "EdgeDataUpdated",
        id: id2,
        propertyName,
        oldValue,
        newValue
      });
    });
  }
  updateEdgeData(...args) {
    const id2 = args[0];
    const edge = this.getEdge(id2);
    if (typeof args[1] === "string") {
      this.updateEdgeDataProperty(id2, args[1], args[2]);
      return;
    }
    let data2;
    if (typeof args[1] === "function") {
      const update = args[1];
      data2 = update(edge.data);
    } else if (typeof args[1] === "object") {
      data2 = args[1];
    }
    this.batch(() => {
      const oldValue = edge.data;
      const newValue = data2;
      edge.data = data2;
      this.changes.push({
        type: "EdgeDataUpdated",
        id: id2,
        oldValue,
        newValue
      });
    });
  }
  /**
   * @group EdgeMethods
   */
  mergeEdgeData(id2, patch) {
    this.batch(() => {
      Object.entries(patch).forEach(([propertyName, value]) => {
        this.updateEdgeDataProperty(id2, propertyName, value);
      });
    });
  }
  // ================= Tree =================
  checkTreeExistence(treeKey) {
    if (!this.hasTreeStructure(treeKey)) {
      throw new Error("Tree structure not found for treeKey: " + treeKey);
    }
  }
  hasTreeStructure(treeKey) {
    return this.treeIndices.has(treeKey);
  }
  /**
   * Attach a new tree structure representing the hierarchy of all nodes in the graph.
   * @param treeKey A unique key of the tree structure. You can attach multiple tree structures with different keys.
   *
   * ```ts
   * const graph = new Graph({
   *   nodes: [{ id: 1 }, { id: 2 }, { id: 3 }],
   * });
   * graph.attachTreeStructure('Inheritance');
   * graph.setParent(2, 1, 'Inheritance');
   * graph.setParent(3, 1, 'Inheritance');
   * graph.getRoots('Inheritance'); // [1]
   * graph.getChildren(1, 'Inheritance'); // [2,3]
   * ```
   * @group TreeMethods
   */
  attachTreeStructure(treeKey) {
    if (this.treeIndices.has(treeKey)) {
      return;
    }
    this.treeIndices.set(treeKey, {
      parentMap: /* @__PURE__ */ new Map(),
      childrenMap: /* @__PURE__ */ new Map()
    });
    this.batch(() => {
      this.changes.push({
        type: "TreeStructureAttached",
        treeKey
      });
    });
  }
  /**
   * Detach the tree structure of the given tree key from the graph.
   *
   * ```ts
   * graph.detachTreeStructure('Inheritance');
   * graph.getRoots('Inheritance'); // Error!
   * ```
   * @group TreeMethods
   */
  detachTreeStructure(treeKey) {
    this.checkTreeExistence(treeKey);
    this.treeIndices.delete(treeKey);
    this.batch(() => {
      this.changes.push({
        type: "TreeStructureDetached",
        treeKey
      });
    });
  }
  /**
   * Traverse the given tree data, add each node into the graph, then attach the tree structure.
   *
   * ```ts
   * graph.addTree({
   *   id: 1,
   *   children: [
   *     { id: 2 },
   *     { id: 3 },
   *   ],
   * }, 'Inheritance');
   * graph.getRoots('Inheritance'); // [1]
   * graph.getChildren(1, 'Inheritance'); // [2, 3]
   * graph.getAllNodes(); // [1, 2, 3]
   * graph.getAllEdges(); // []
   * ```
   * @group TreeMethods
   */
  addTree(tree, treeKey) {
    this.batch(() => {
      this.attachTreeStructure(treeKey);
      const nodes = [];
      const stack = Array.isArray(tree) ? tree : [tree];
      while (stack.length) {
        const node = stack.shift();
        nodes.push(node);
        if (node.children) {
          stack.push(...node.children);
        }
      }
      this.addNodes(nodes);
      nodes.forEach((parent) => {
        var _a3;
        (_a3 = parent.children) == null ? void 0 : _a3.forEach((child) => {
          this.setParent(child.id, parent.id, treeKey);
        });
      });
    });
  }
  /**
   * Get the root nodes of an attached tree structure.
   *
   * Consider a graph with the following tree structure attached:
   * ```
   * Tree structure:
   *    O     3
   *   / \    |
   *  1   2   4
   * ```
   * `graph.getRoots()` takes all nodes without a parent, therefore [0, 3] was returned.
   *
   * Newly added nodes are also unparented. So they are counted as roots.
   * ```ts
   * graph.addNode({ id: 5 });
   * graph.getRoots(); // [0, 3, 5]
   * ```
   *
   * Here is how the tree structure looks like:
   * ```
   * Tree structure:
   *    O     3  5
   *   / \    |
   *  1   2   4
   * ```
   *
   * By setting a parent, a root node no more be a root.
   * ```ts
   * graph.setParent(5, 2);
   * graph.getRoots(); // [0, 3]
   * ```
   *
   * The tree structure now becomes:
   * ```
   * Tree structure:
   *    O     3
   *   / \    |
   *  1   2   4
   *      |
   *      5
   * ```
   *
   * Removing a node forces its children to be unparented, or roots.
   * ```ts
   * graph.removeNode(0);
   * graph.getRoots(); // [1, 2, 3]
   * ```
   *
   * You might draw the the structure as follow:
   * ```
   * Tree structure:
   *  1   2  3
   *      |  |
   *      5  4
   * ```
   * @group TreeMethods
   */
  getRoots(treeKey) {
    this.checkTreeExistence(treeKey);
    return this.getAllNodes().filter((node) => !this.getParent(node.id, treeKey));
  }
  /**
   * Given a node ID and an optional tree key, get the children of the node in the specified tree structure.
   * @group TreeMethods
   */
  getChildren(id2, treeKey) {
    this.checkNodeExistence(id2);
    this.checkTreeExistence(treeKey);
    const tree = this.treeIndices.get(treeKey);
    const children = tree.childrenMap.get(id2);
    return Array.from(children || []);
  }
  /**
   * Given a node ID and an optional tree key, get the parent of the node in the specified tree structure.
   * If the given node is one of the tree roots, this returns null.
   * @group TreeMethods
   */
  getParent(id2, treeKey) {
    this.checkNodeExistence(id2);
    this.checkTreeExistence(treeKey);
    const tree = this.treeIndices.get(treeKey);
    return tree.parentMap.get(id2) || null;
  }
  /**
   * Returns an array of all the ancestor nodes, staring from the parent to the root.
   */
  getAncestors(id2, treeKey) {
    const ancestors = [];
    let current2 = this.getNode(id2);
    let parent;
    while (parent = this.getParent(current2.id, treeKey)) {
      ancestors.push(parent);
      current2 = parent;
    }
    return ancestors;
  }
  /**
   * Set node parent. If this operation causes a circle, it fails with an error.
   * @param id - ID of the child node.
   * @param parent - ID of the parent node. If it is undefined or null, means unset parent for node with id.
   * @param treeKey - Which tree structure the relation is applied to.
   * @group TreeMethods
   */
  setParent(id2, parent, treeKey) {
    var _a3, _b;
    this.checkTreeExistence(treeKey);
    const tree = this.treeIndices.get(treeKey);
    if (!tree)
      return;
    const node = this.getNode(id2);
    const oldParent = tree.parentMap.get(id2);
    if ((oldParent == null ? void 0 : oldParent.id) === parent)
      return;
    if (parent === void 0 || parent === null) {
      if (oldParent) {
        (_a3 = tree.childrenMap.get(oldParent.id)) == null ? void 0 : _a3.delete(node);
      }
      tree.parentMap.delete(id2);
      return;
    }
    const newParent = this.getNode(parent);
    tree.parentMap.set(id2, newParent);
    if (oldParent) {
      (_b = tree.childrenMap.get(oldParent.id)) == null ? void 0 : _b.delete(node);
    }
    let children = tree.childrenMap.get(newParent.id);
    if (!children) {
      children = /* @__PURE__ */ new Set();
      tree.childrenMap.set(newParent.id, children);
    }
    children.add(node);
    this.batch(() => {
      this.changes.push({
        type: "TreeStructureChanged",
        treeKey,
        nodeId: id2,
        oldParentId: oldParent == null ? void 0 : oldParent.id,
        newParentId: newParent.id
      });
    });
  }
  dfsTree(id2, fn, treeKey) {
    const navigator = (nodeId) => this.getChildren(nodeId, treeKey);
    return doDFS$1(this.getNode(id2), /* @__PURE__ */ new Set(), fn, navigator);
  }
  bfsTree(id2, fn, treeKey) {
    const navigator = (nodeId) => this.getChildren(nodeId, treeKey);
    return doBFS([this.getNode(id2)], /* @__PURE__ */ new Set(), fn, navigator);
  }
  // ================= Graph =================
  /**
   * Get all nodes in the graph as an array.
   */
  getAllNodes() {
    return Array.from(this.nodeMap.values());
  }
  /**
   * Get all edges in the graph as an array.
   */
  getAllEdges() {
    return Array.from(this.edgeMap.values());
  }
  bfs(id2, fn, direction2 = "out") {
    const navigator = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction2];
    return doBFS([this.getNode(id2)], /* @__PURE__ */ new Set(), fn, navigator);
  }
  dfs(id2, fn, direction2 = "out") {
    const navigator = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction2];
    return doDFS$1(this.getNode(id2), /* @__PURE__ */ new Set(), fn, navigator);
  }
  clone() {
    const newNodes = this.getAllNodes().map((oldNode) => {
      return { ...oldNode, data: { ...oldNode.data } };
    });
    const newEdges = this.getAllEdges().map((oldEdge) => {
      return { ...oldEdge, data: { ...oldEdge.data } };
    });
    const newGraph = new Graph({
      nodes: newNodes,
      edges: newEdges
    });
    this.treeIndices.forEach(({ parentMap: oldParentMap, childrenMap: oldChildrenMap }, treeKey) => {
      const parentMap = /* @__PURE__ */ new Map();
      oldParentMap.forEach((parent, key) => {
        parentMap.set(key, newGraph.getNode(parent.id));
      });
      const childrenMap = /* @__PURE__ */ new Map();
      oldChildrenMap.forEach((children, key) => {
        childrenMap.set(key, new Set(Array.from(children).map((n2) => newGraph.getNode(n2.id))));
      });
      newGraph.treeIndices.set(treeKey, {
        parentMap,
        childrenMap
      });
    });
    return newGraph;
  }
  toJSON() {
    return JSON.stringify({
      nodes: this.getAllNodes(),
      edges: this.getAllEdges()
      // FIXME: And tree structures?
    });
  }
  createView(options) {
    return new GraphView({
      graph: this,
      ...options
    });
  }
};
class BaseLayout {
  constructor(context, options) {
    this.context = context;
    this.options = options || {};
  }
}
var __awaiter$k = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$9 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
function isTreeLayout(options) {
  const { type } = options;
  return ["compact-box", "mindmap", "dendrogram", "indented"].includes(type);
}
function isPreLayout(options) {
  return !Array.isArray(options) && (options === null || options === void 0 ? void 0 : options.preLayout);
}
function layoutMapping2GraphData(layoutMapping) {
  const { nodes, edges } = layoutMapping;
  const data2 = { nodes: [], edges: [], combos: [] };
  nodes.forEach((nodeLike) => {
    const target = nodeLike.data._isCombo ? data2.combos : data2.nodes;
    const { x: x2, y: y2, z: z2 = 0 } = nodeLike.data;
    target === null || target === void 0 ? void 0 : target.push({
      id: nodeLike.id,
      style: { x: x2, y: y2, z: z2 }
    });
  });
  edges.forEach((edge) => {
    const { id: id2, source, target, data: { points = [], controlPoints = points.slice(1, points.length - 1) } } = edge;
    data2.edges.push({
      id: id2,
      source,
      target,
      style: Object.assign({}, (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) ? { controlPoints: controlPoints.map(parsePoint) } : {})
    });
  });
  return data2;
}
function layoutAdapter(Ctor, context) {
  class AdaptLayout extends BaseLayout {
    constructor(context2, options) {
      super(context2, options);
      this.instance = new Ctor({});
      this.id = this.instance.id;
      if ("stop" in this.instance && "tick" in this.instance) {
        const instance = this.instance;
        this.stop = instance.stop.bind(instance);
        this.tick = (iterations) => {
          const tickResult = instance.tick(iterations);
          return layoutMapping2GraphData(tickResult);
        };
      }
    }
    execute(model, options) {
      return __awaiter$k(this, void 0, void 0, function* () {
        return layoutMapping2GraphData(yield this.instance.execute(this.graphData2LayoutModel(model), this.transformOptions(deepMix({}, this.options, options))));
      });
    }
    transformOptions(options) {
      if (!("onTick" in options))
        return options;
      const onTick = options.onTick;
      options.onTick = (data2) => onTick(layoutMapping2GraphData(data2));
      return options;
    }
    graphData2LayoutModel(data2) {
      const { nodes = [], edges = [], combos = [] } = data2;
      const nodesToLayout = nodes.map((datum) => {
        const id2 = idOf(datum);
        const { data: data3, style, combo } = datum, rest = __rest$9(datum, ["data", "style", "combo"]);
        const result = {
          id: id2,
          data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, data3), { data: data3 }), combo ? { parentId: combo } : {}), { style }), rest)
        };
        if (style === null || style === void 0 ? void 0 : style.x)
          Object.assign(result.data, { x: style.x });
        if (style === null || style === void 0 ? void 0 : style.y)
          Object.assign(result.data, { y: style.y });
        if (style === null || style === void 0 ? void 0 : style.z)
          Object.assign(result.data, { z: style.z });
        return result;
      });
      const nodesIdMap = new Map(nodesToLayout.map((node) => [node.id, node]));
      const edgesToLayout = edges.filter((edge) => {
        const { source, target } = edge;
        return nodesIdMap.has(source) && nodesIdMap.has(target);
      }).map((edge) => {
        const { source, target, data: data3, style } = edge;
        return { id: idOf(edge), source, target, data: Object.assign({}, data3), style: Object.assign({}, style) };
      });
      const combosToLayout = combos.map((combo) => {
        return { id: idOf(combo), data: Object.assign({ _isCombo: true }, combo.data), style: Object.assign({}, combo.style) };
      });
      const layoutModel = new Graph$9({
        nodes: [...nodesToLayout, ...combosToLayout],
        edges: edgesToLayout
      });
      if (context.model.model.hasTreeStructure(COMBO_KEY)) {
        layoutModel.attachTreeStructure(COMBO_KEY);
        nodesToLayout.forEach((node) => {
          const parent = context.model.model.getParent(node.id, COMBO_KEY);
          if (parent && layoutModel.hasNode(parent.id)) {
            layoutModel.setParent(node.id, parent.id, COMBO_KEY);
          }
        });
      }
      return layoutModel;
    }
  }
  return AdaptLayout;
}
function invokeLayoutMethod(layout2, method, ...args) {
  if (method in layout2) {
    return layout2[method](...args);
  }
  if ("instance" in layout2) {
    const instance = layout2.instance;
    if (method in instance)
      return instance[method](...args);
  }
  return null;
}
function getLayoutProperty(layout2, name) {
  if (name in layout2)
    return layout2[name];
  if ("instance" in layout2) {
    const instance = layout2.instance;
    if (name in instance)
      return instance[name];
  }
  return null;
}
var __awaiter$j = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DragElementForce extends DragElement {
  get forceLayoutInstance() {
    return this.context.layout.getLayoutInstance().find((layout2) => ["d3-force", "d3-force-3d"].includes(layout2 === null || layout2 === void 0 ? void 0 : layout2.id));
  }
  /**
   * Whether the behavior is enabled
   * @param event - The event object
   * @returns Is the behavior enabled
   * @internal
   */
  validate(event) {
    if (!this.context.layout)
      return false;
    if (!this.forceLayoutInstance) {
      print.warn("DragElementForce only works with d3-force or d3-force-3d layout");
      return false;
    }
    return super.validate(event);
  }
  /**
   * Move selected elements by offset
   * @param ids - The selected element IDs
   * @param offset - The offset to move
   * @internal
   */
  moveElement(ids, offset) {
    return __awaiter$j(this, void 0, void 0, function* () {
      const layout2 = this.forceLayoutInstance;
      this.context.graph.getNodeData(ids).forEach((element, index2) => {
        const { x: x2 = 0, y: y2 = 0 } = element.style || {};
        if (layout2)
          invokeLayoutMethod(layout2, "setFixedPosition", ids[index2], [...add$4([+x2, +y2], this.clampByRotation(offset))]);
      });
    });
  }
  /**
   * Triggered when the drag starts
   * @param event - The event object
   * @internal
   */
  onDragStart(event) {
    this.enable = this.validate(event);
    if (!this.enable)
      return;
    this.target = this.getSelectedNodeIDs([event.target.id]);
    this.hideEdge();
    this.context.graph.frontElement(this.target);
    const layout2 = this.forceLayoutInstance;
    if (layout2)
      getLayoutProperty(layout2, "simulation").alphaTarget(0.3).restart();
    this.context.graph.getNodeData(this.target).forEach((element) => {
      const { x: x2 = 0, y: y2 = 0 } = element.style || {};
      if (layout2)
        invokeLayoutMethod(layout2, "setFixedPosition", idOf(element), [+x2, +y2]);
    });
  }
  /**
   * Triggered when dragging
   * @param event - The event object
   * @internal
   */
  onDrag(event) {
    if (!this.enable)
      return;
    const delta = this.getDelta(event);
    this.moveElement(this.target, delta);
  }
  /**
   * Triggered when the drag ends
   * @internal
   */
  onDragEnd() {
    const layout2 = this.forceLayoutInstance;
    if (layout2)
      getLayoutProperty(layout2, "simulation").alphaTarget(0);
    if (this.options.fixed)
      return;
    this.context.graph.getNodeData(this.target).forEach((element) => {
      if (layout2)
        invokeLayoutMethod(layout2, "setFixedPosition", idOf(element), [null, null, null]);
    });
  }
}
var __awaiter$i = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class FixElementSize extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, FixElementSize.defaultOptions, options));
    this.isZoomEvent = (event) => Boolean(event.data && "scale" in event.data);
    this.relatedEdgeToUpdate = /* @__PURE__ */ new Set();
    this.zoom = this.context.graph.getZoom();
    this.fixElementSize = (event) => __awaiter$i(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { graph: graph2 } = this.context;
      const { state, nodeFilter, edgeFilter, comboFilter } = this.options;
      const nodeData = (state ? graph2.getElementDataByState("node", state) : graph2.getNodeData()).filter(nodeFilter);
      const edgeData = (state ? graph2.getElementDataByState("edge", state) : graph2.getEdgeData()).filter(edgeFilter);
      const comboData = (state ? graph2.getElementDataByState("combo", state) : graph2.getComboData()).filter(comboFilter);
      const currentScale = this.isZoomEvent(event) ? this.zoom = Math.max(0.01, Math.min(event.data.scale, 10)) : this.zoom;
      const nodeLikeData = [...nodeData, ...comboData];
      if (nodeLikeData.length > 0) {
        nodeLikeData.forEach((datum) => this.fixNodeLike(datum, currentScale));
      }
      this.updateRelatedEdges();
      if (edgeData.length > 0) {
        edgeData.forEach((datum) => this.fixEdge(datum, currentScale));
      }
    });
    this.cachedStyles = /* @__PURE__ */ new Map();
    this.getOriginalFieldValue = (id2, shape, field) => {
      var _a3;
      const shapesStyle = this.cachedStyles.get(id2) || [];
      const shapeStyle = ((_a3 = shapesStyle.find((style) => style.shape === shape)) === null || _a3 === void 0 ? void 0 : _a3.style) || {};
      if (!(field in shapeStyle)) {
        shapeStyle[field] = shape.attributes[field];
        this.cachedStyles.set(id2, [
          ...shapesStyle.filter((style) => style.shape !== shape),
          { shape, style: shapeStyle }
        ]);
      }
      return shapeStyle[field];
    };
    this.scaleEntireElement = (id2, el, currentScale) => {
      el.setLocalScale(1 / currentScale);
      const shapesStyle = this.cachedStyles.get(id2) || [];
      shapesStyle.push({ shape: el });
      this.cachedStyles.set(id2, shapesStyle);
    };
    this.scaleSpecificShapes = (el, currentScale, config) => {
      const descendantShapes = getDescendantShapes(el);
      const configs = Array.isArray(config) ? config : [config];
      configs.forEach((config2) => {
        const { shape: shapeFilter, fields } = config2;
        const shape = typeof shapeFilter === "function" ? shapeFilter(descendantShapes) : el.getShape(shapeFilter);
        if (!shape)
          return;
        if (!fields) {
          this.scaleEntireElement(el.id, shape, currentScale);
          return;
        }
        fields.forEach((field) => {
          const oriFieldValue = this.getOriginalFieldValue(el.id, shape, field);
          if (!isNumber(oriFieldValue))
            return;
          shape.style[field] = oriFieldValue / currentScale;
        });
      });
    };
    this.skipIfExceedViewport = (el) => {
      const { viewport } = this.context;
      return !(viewport === null || viewport === void 0 ? void 0 : viewport.isInViewport(el.getRenderBounds(), false, 30));
    };
    this.fixNodeLike = (datum, currentScale) => {
      const id2 = idOf(datum);
      const { element, model } = this.context;
      const el = element.getElement(id2);
      if (!el || this.skipIfExceedViewport(el))
        return;
      const edges = model.getRelatedEdgesData(id2);
      edges.forEach((edge) => this.relatedEdgeToUpdate.add(idOf(edge)));
      const config = this.options[el.type];
      if (!config) {
        this.scaleEntireElement(id2, el, currentScale);
        return;
      }
      this.scaleSpecificShapes(el, currentScale, config);
    };
    this.fixEdge = (datum, currentScale) => {
      const id2 = idOf(datum);
      const el = this.context.element.getElement(id2);
      if (!el || this.skipIfExceedViewport(el))
        return;
      const config = this.options.edge;
      if (!config) {
        el.style.transformOrigin = "center";
        this.scaleEntireElement(id2, el, currentScale);
        return;
      }
      this.scaleSpecificShapes(el, currentScale, config);
    };
    this.updateRelatedEdges = () => {
      const { element } = this.context;
      if (this.relatedEdgeToUpdate.size > 0) {
        this.relatedEdgeToUpdate.forEach((id2) => {
          const edge = element.getElement(id2);
          edge === null || edge === void 0 ? void 0 : edge.update({});
        });
      }
      this.relatedEdgeToUpdate.clear();
    };
    this.resetTransform = (event) => __awaiter$i(this, void 0, void 0, function* () {
      var _a3;
      if ((_a3 = event.data) === null || _a3 === void 0 ? void 0 : _a3.firstRender)
        return;
      if (this.options.reset) {
        this.restoreCachedStyles();
      } else {
        this.fixElementSize({ data: { scale: this.zoom } });
      }
    });
    this.bindEvents();
  }
  restoreCachedStyles() {
    if (this.cachedStyles.size > 0) {
      this.cachedStyles.forEach((shapesStyle) => {
        shapesStyle.forEach(({ shape, style }) => {
          if (isEmpty(style)) {
            shape.setLocalScale(1);
          } else {
            if (this.options.state)
              return;
            Object.entries(style).forEach(([field, value]) => shape.style[field] = value);
          }
        });
      });
      const { graph: graph2, element } = this.context;
      const nodeIds = Object.keys(Object.fromEntries(this.cachedStyles)).filter((id2) => id2 && graph2.getElementType(id2) === "node");
      if (nodeIds.length > 0) {
        const edgeIds = /* @__PURE__ */ new Set();
        nodeIds.forEach((id2) => {
          graph2.getRelatedEdgesData(id2).forEach((edge) => edgeIds.add(idOf(edge)));
        });
        edgeIds.forEach((id2) => {
          const edge = element === null || element === void 0 ? void 0 : element.getElement(id2);
          edge === null || edge === void 0 ? void 0 : edge.update({});
        });
      }
    }
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.AFTER_DRAW, this.resetTransform);
    graph2.on(GraphEvent.AFTER_TRANSFORM, this.fixElementSize);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.AFTER_DRAW, this.resetTransform);
    graph2.off(GraphEvent.AFTER_TRANSFORM, this.fixElementSize);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
FixElementSize.defaultOptions = {
  enable: (event) => event.data.scale < 1,
  nodeFilter: () => true,
  edgeFilter: () => true,
  comboFilter: () => true,
  edge: [{ shape: "key", fields: ["lineWidth"] }, { shape: "halo", fields: ["lineWidth"] }, { shape: "label" }],
  reset: false
};
var __awaiter$h = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class FocusElement extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, FocusElement.defaultOptions, options));
    this.focus = (event) => __awaiter$h(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { graph: graph2 } = this.context;
      yield graph2.focusElement(event.target.id, this.options.animation);
    });
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    this.unbindEvents();
    ELEMENT_TYPES.forEach((type) => {
      graph2.on(`${type}:${CommonEvent.CLICK}`, this.focus);
    });
  }
  validate(event) {
    if (this.destroyed || !this.isKeydown())
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  /**
   * <zh/>  trigger 
   *
   * <en/> Is the current key consistent with the trigger configuration
   * @returns <zh/>  | <en/> Is consistent
   * @internal
   */
  isKeydown() {
    const { trigger } = this.options;
    if (!(trigger === null || trigger === void 0 ? void 0 : trigger.length))
      return true;
    return this.shortcut.match(trigger);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    ELEMENT_TYPES.forEach((type) => {
      graph2.off(`${type}:${CommonEvent.CLICK}`, this.focus);
    });
  }
  destroy() {
    this.unbindEvents();
    this.shortcut.destroy();
    super.destroy();
  }
}
FocusElement.defaultOptions = {
  animation: {
    easing: "ease-in",
    duration: 500
  },
  enable: true,
  trigger: []
};
class HoverActivate extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, HoverActivate.defaultOptions, options));
    this.isFrozen = false;
    this.toggleFrozen = (e3) => {
      this.isFrozen = e3.type === "dragstart";
    };
    this.hoverElement = (event) => {
      if (!this.validate(event))
        return;
      const isEnter = event.type === CommonEvent.POINTER_ENTER;
      this.updateElementsState(event, isEnter);
      const { onHover, onHoverEnd } = this.options;
      if (isEnter)
        onHover === null || onHover === void 0 ? void 0 : onHover(event);
      else
        onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd(event);
    };
    this.updateElementsState = (event, add2) => {
      if (!this.options.state && !this.options.inactiveState)
        return;
      const { graph: graph2 } = this.context;
      const { state, animation, inactiveState } = this.options;
      const activeIds = this.getActiveIds(event);
      const states = {};
      if (state) {
        Object.assign(states, this.getElementsState(activeIds, state, add2));
      }
      if (inactiveState) {
        const inactiveIds = idsOf(graph2.getData(), true).filter((id2) => !activeIds.includes(id2));
        Object.assign(states, this.getElementsState(inactiveIds, inactiveState, add2));
      }
      graph2.setElementState(states, animation);
    };
    this.getElementsState = (ids, state, add2) => {
      const { graph: graph2 } = this.context;
      const states = {};
      ids.forEach((id2) => {
        const currentState = graph2.getElementState(id2);
        if (add2) {
          states[id2] = currentState.includes(state) ? currentState : [...currentState, state];
        } else {
          states[id2] = currentState.filter((s3) => s3 !== state);
        }
      });
      return states;
    };
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    this.unbindEvents();
    ELEMENT_TYPES.forEach((type) => {
      graph2.on(`${type}:${CommonEvent.POINTER_ENTER}`, this.hoverElement);
      graph2.on(`${type}:${CommonEvent.POINTER_LEAVE}`, this.hoverElement);
    });
    const canvas2 = this.context.canvas.document;
    canvas2.addEventListener(`${CommonEvent.DRAG_START}`, this.toggleFrozen);
    canvas2.addEventListener(`${CommonEvent.DRAG_END}`, this.toggleFrozen);
  }
  getActiveIds(event) {
    const { graph: graph2 } = this.context;
    const { degree: degree3, direction: direction2 } = this.options;
    const elementId = event.target.id;
    return degree3 ? getElementNthDegreeIds(graph2, event.targetType, elementId, typeof degree3 === "function" ? degree3(event) : degree3, direction2) : [elementId];
  }
  validate(event) {
    if (this.destroyed || this.isFrozen || isToBeDestroyed(event.target) || // @ts-expect-error private property
    // combo/node
    this.context.graph.isCollapsingExpanding)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    ELEMENT_TYPES.forEach((type) => {
      graph2.off(`${type}:${CommonEvent.POINTER_ENTER}`, this.hoverElement);
      graph2.off(`${type}:${CommonEvent.POINTER_LEAVE}`, this.hoverElement);
    });
    const canvas2 = this.context.canvas.document;
    canvas2.removeEventListener(`${CommonEvent.DRAG_START}`, this.toggleFrozen);
    canvas2.removeEventListener(`${CommonEvent.DRAG_END}`, this.toggleFrozen);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
HoverActivate.defaultOptions = {
  animation: false,
  enable: true,
  degree: 0,
  direction: "both",
  state: "active",
  inactiveState: void 0
};
class LassoSelect extends BrushSelect {
  /**
   * Triggered when the mouse is pressed
   * @param event - mouse event
   * @internal
   */
  onPointerDown(event) {
    if (!super.validate(event) || !super.isKeydown() || this.points)
      return;
    const { canvas: canvas2, graph: graph2 } = this.context;
    this.pathShape = new Path({
      id: "g6-lasso-select",
      style: this.options.style
    });
    canvas2.appendChild(this.pathShape);
    this.points = [getCursorPoint(event, graph2)];
  }
  /**
   * Triggered when the mouse is moved
   * @param event - mouse event
   * @internal
   */
  onPointerMove(event) {
    var _a3;
    if (!this.points)
      return;
    const { immediately, mode } = this.options;
    this.points.push(getCursorPoint(event, this.context.graph));
    (_a3 = this.pathShape) === null || _a3 === void 0 ? void 0 : _a3.setAttribute("d", pointsToPath(this.points));
    if (immediately && mode === "default" && this.points.length > 2)
      super.updateElementsStates(this.points);
  }
  /**
   * Triggered when the mouse is released
   * @internal
   */
  onPointerUp() {
    if (!this.points)
      return;
    if (this.points.length < 2) {
      this.clearLasso();
      return;
    }
    super.updateElementsStates(this.points);
    this.clearLasso();
  }
  clearLasso() {
    var _a3;
    (_a3 = this.pathShape) === null || _a3 === void 0 ? void 0 : _a3.remove();
    this.pathShape = void 0;
    this.points = void 0;
  }
}
class OptimizeViewportTransform extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, OptimizeViewportTransform.defaultOptions, options));
    this.hiddenShapes = [];
    this.isVisible = true;
    this.setElementsVisibility = (elements, visibility2, filter2) => {
      elements.filter(Boolean).forEach((element) => {
        if (visibility2 === "hidden" && !element.isVisible()) {
          this.hiddenShapes.push(element);
        } else if (visibility2 === "visible" && this.hiddenShapes.includes(element)) {
          this.hiddenShapes.splice(this.hiddenShapes.indexOf(element), 1);
        } else {
          setVisibility(element, visibility2, filter2);
        }
      });
    };
    this.filterShapes = (type, filter2) => {
      if (isFunction$1(filter2))
        return (shape) => !filter2(type, shape);
      const includesClassnames = filter2 === null || filter2 === void 0 ? void 0 : filter2[type];
      return (shape) => {
        if (!shape.className)
          return true;
        return !(includesClassnames === null || includesClassnames === void 0 ? void 0 : includesClassnames.includes(shape.className));
      };
    };
    this.hideShapes = (event) => {
      if (!this.validate(event) || !this.isVisible)
        return;
      const { element } = this.context;
      const { shapes = {} } = this.options;
      this.setElementsVisibility(element.getNodes(), "hidden", this.filterShapes("node", shapes));
      this.setElementsVisibility(element.getEdges(), "hidden", this.filterShapes("edge", shapes));
      this.setElementsVisibility(element.getCombos(), "hidden", this.filterShapes("combo", shapes));
      this.isVisible = false;
    };
    this.showShapes = debounce((event) => {
      if (!this.validate(event) || this.isVisible)
        return;
      const { element } = this.context;
      this.setElementsVisibility(element.getNodes(), "visible");
      this.setElementsVisibility(element.getEdges(), "visible");
      this.setElementsVisibility(element.getCombos(), "visible");
      this.isVisible = true;
    }, this.options.debounce);
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.BEFORE_TRANSFORM, this.hideShapes);
    graph2.on(GraphEvent.AFTER_TRANSFORM, this.showShapes);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.BEFORE_TRANSFORM, this.hideShapes);
    graph2.off(GraphEvent.AFTER_TRANSFORM, this.showShapes);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
OptimizeViewportTransform.defaultOptions = {
  enable: true,
  debounce: 200,
  shapes: (type) => type === "node"
};
var __awaiter$g = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ScrollCanvas extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, ScrollCanvas.defaultOptions, options));
    this.onWheel = (event) => __awaiter$g(this, void 0, void 0, function* () {
      if (this.options.preventDefault)
        event.preventDefault();
      const diffX = event.deltaX;
      const diffY = event.deltaY;
      yield this.scroll([-diffX, -diffY], event);
    });
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    var _a3, _b;
    const { trigger } = this.options;
    this.shortcut.unbindAll();
    if (isObject$2(trigger)) {
      (_a3 = this.graphDom) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(CommonEvent.WHEEL, this.onWheel);
      const { up = [], down = [], left = [], right = [] } = trigger;
      this.shortcut.bind(up, (event) => this.scroll([0, -10], event));
      this.shortcut.bind(down, (event) => this.scroll([0, 10], event));
      this.shortcut.bind(left, (event) => this.scroll([-10, 0], event));
      this.shortcut.bind(right, (event) => this.scroll([10, 0], event));
    } else {
      (_b = this.graphDom) === null || _b === void 0 ? void 0 : _b.addEventListener(CommonEvent.WHEEL, this.onWheel, { passive: false });
    }
  }
  get graphDom() {
    return this.context.graph.getCanvas().getContextService().getDomElement();
  }
  formatDisplacement(d3) {
    const { sensitivity } = this.options;
    d3 = multiply(d3, sensitivity);
    d3 = this.clampByDirection(d3);
    d3 = this.clampByRange(d3);
    return d3;
  }
  clampByDirection([dx, dy]) {
    const { direction: direction2 } = this.options;
    if (direction2 === "x") {
      dy = 0;
    } else if (direction2 === "y") {
      dx = 0;
    }
    return [dx, dy];
  }
  clampByRange([dx, dy]) {
    const { viewport, canvas: canvas2 } = this.context;
    const [canvasWidth, canvasHeight] = canvas2.getSize();
    const [top, right, bottom, left] = parsePadding(this.options.range);
    const range = [canvasHeight * top, canvasWidth * right, canvasHeight * bottom, canvasWidth * left];
    const scrollableArea = getExpandedBBox(getPointBBox(viewport.getCanvasCenter()), range);
    const nextViewportCenter = subtract(viewport.getViewportCenter(), [dx, dy, 0]);
    if (!isPointInBBox(nextViewportCenter, scrollableArea)) {
      const { min: [minX, minY], max: [maxX, maxY] } = scrollableArea;
      if (nextViewportCenter[0] < minX && dx > 0 || nextViewportCenter[0] > maxX && dx < 0) {
        dx = 0;
      }
      if (nextViewportCenter[1] < minY && dy > 0 || nextViewportCenter[1] > maxY && dy < 0) {
        dy = 0;
      }
    }
    return [dx, dy];
  }
  scroll(value, event) {
    return __awaiter$g(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { onFinish } = this.options;
      const graph2 = this.context.graph;
      const formattedValue = this.formatDisplacement(value);
      yield graph2.translateBy(formattedValue, false);
      onFinish === null || onFinish === void 0 ? void 0 : onFinish();
    });
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the canvas scrolling
   */
  destroy() {
    var _a3;
    this.shortcut.destroy();
    (_a3 = this.graphDom) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(CommonEvent.WHEEL, this.onWheel);
    super.destroy();
  }
}
ScrollCanvas.defaultOptions = {
  enable: true,
  sensitivity: 1,
  preventDefault: true,
  range: Infinity
};
var __awaiter$f = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ZoomCanvas extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, ZoomCanvas.defaultOptions, options));
    this.zoom = (value, event, animation) => __awaiter$f(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { graph: graph2 } = this.context;
      let origin = this.options.origin;
      if (!origin && "viewport" in event) {
        origin = parsePoint(event.viewport);
      }
      const { sensitivity, onFinish } = this.options;
      const ratio = 1 + clamp$1(value, -50, 50) * sensitivity / 100;
      const zoom = graph2.getZoom();
      yield graph2.zoomTo(zoom * ratio, animation, origin);
      onFinish === null || onFinish === void 0 ? void 0 : onFinish();
    });
    this.onReset = () => __awaiter$f(this, void 0, void 0, function* () {
      yield this.context.graph.zoomTo(1, this.options.animation);
    });
    this.preventDefault = (event) => {
      if (this.options.preventDefault)
        event.preventDefault();
    };
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { trigger } = this.options;
    this.shortcut.unbindAll();
    if (Array.isArray(trigger)) {
      if (trigger.includes(CommonEvent.PINCH)) {
        this.shortcut.bind([CommonEvent.PINCH], (event) => {
          this.zoom(event.scale, event, false);
        });
      } else {
        const container = this.context.canvas.getContainer();
        container === null || container === void 0 ? void 0 : container.addEventListener(CommonEvent.WHEEL, this.preventDefault);
        this.shortcut.bind([...trigger, CommonEvent.WHEEL], (event) => {
          const { deltaX, deltaY } = event;
          this.zoom(-(deltaY !== null && deltaY !== void 0 ? deltaY : deltaX), event, false);
        });
      }
    }
    if (typeof trigger === "object") {
      const { zoomIn = [], zoomOut = [], reset = [] } = trigger;
      this.shortcut.bind(zoomIn, (event) => this.zoom(10, event, this.options.animation));
      this.shortcut.bind(zoomOut, (event) => this.zoom(-10, event, this.options.animation));
      this.shortcut.bind(reset, this.onReset);
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Verify whether it can be zoomed
   * @param event - <zh/>  | <en/> Event object
   * @returns <zh/>  | <en/> Whether it can be zoomed
   * @internal
   */
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction$1(enable))
      return enable(event);
    return !!enable;
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy zoom canvas
   */
  destroy() {
    var _a3;
    this.shortcut.destroy();
    (_a3 = this.context.canvas.getContainer()) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(CommonEvent.WHEEL, this.preventDefault);
    super.destroy();
  }
}
ZoomCanvas.defaultOptions = {
  animation: { duration: 200 },
  enable: true,
  sensitivity: 1,
  trigger: [],
  preventDefault: true
};
function t(t3, e3, i2, n2 = "height") {
  const h2 = t3[n2], r2 = e3[n2];
  return "center" === i2 ? (h2 + r2) / 2 : t3.height;
}
const e = Object.assign, i = { getId: (t3) => t3.id || t3.name, getPreH: (t3) => t3.preH || 0, getPreV: (t3) => t3.preV || 0, getHGap: (t3) => t3.hgap || 18, getVGap: (t3) => t3.vgap || 18, getChildren: (t3) => t3.children, getHeight: (t3) => t3.height || 36, getWidth(t3) {
  const e3 = t3.label || " ";
  return t3.width || 18 * e3.split("").length;
} };
class n {
  constructor(t3, e3) {
    if (this.x = 0, this.y = 0, this.depth = 0, this.children = [], this.hgap = 0, this.vgap = 0, t3 instanceof n || "x" in t3 && "y" in t3 && "children" in t3) {
      const e4 = t3;
      return this.data = e4.data, this.id = e4.id, this.x = e4.x, this.y = e4.y, this.width = e4.width, this.height = e4.height, this.depth = e4.depth, this.children = e4.children, this.parent = e4.parent, this.hgap = e4.hgap, this.vgap = e4.vgap, this.preH = e4.preH, void (this.preV = e4.preV);
    }
    this.data = t3;
    const i2 = e3.getHGap(t3), h2 = e3.getVGap(t3);
    this.preH = e3.getPreH(t3), this.preV = e3.getPreV(t3), this.width = e3.getWidth(t3), this.height = e3.getHeight(t3), this.width += this.preH, this.height += this.preV, this.id = e3.getId(t3), this.addGap(i2, h2);
  }
  isRoot() {
    return 0 === this.depth;
  }
  isLeaf() {
    return 0 === this.children.length;
  }
  addGap(t3, e3) {
    this.hgap += t3, this.vgap += e3, this.width += 2 * t3, this.height += 2 * e3;
  }
  eachNode(t3) {
    let e3, i2 = [this];
    for (; e3 = i2.shift(); ) t3(e3), i2 = e3.children.concat(i2);
  }
  DFTraverse(t3) {
    this.eachNode(t3);
  }
  BFTraverse(t3) {
    let e3, i2 = [this];
    for (; e3 = i2.shift(); ) t3(e3), i2 = i2.concat(e3.children);
  }
  getBoundingBox() {
    const t3 = { left: Number.MAX_VALUE, top: Number.MAX_VALUE, width: 0, height: 0 };
    return this.eachNode((e3) => {
      t3.left = Math.min(t3.left, e3.x), t3.top = Math.min(t3.top, e3.y), t3.width = Math.max(t3.width, e3.x + e3.width), t3.height = Math.max(t3.height, e3.y + e3.height);
    }), t3;
  }
  translate(t3 = 0, e3 = 0) {
    this.eachNode((i2) => {
      i2.x += t3, i2.y += e3, i2.x += i2.preH, i2.y += i2.preV;
    });
  }
  right2left() {
    const t3 = this.getBoundingBox();
    this.eachNode((e3) => {
      e3.x = e3.x - 2 * (e3.x - t3.left) - e3.width;
    }), this.translate(t3.width, 0);
  }
  bottom2top() {
    const t3 = this.getBoundingBox();
    this.eachNode((e3) => {
      e3.y = e3.y - 2 * (e3.y - t3.top) - e3.height;
    }), this.translate(0, t3.height);
  }
}
function h(t3, h2 = {}, r2) {
  h2 = e({}, i, h2);
  const o2 = new n(t3, h2), s3 = [o2];
  let c2;
  if (!r2 && !t3.collapsed) {
    for (; c2 = s3.shift(); ) if (!c2.data.collapsed) {
      const t4 = h2.getChildren(c2.data), e3 = t4 ? t4.length : 0;
      if (c2.children = new Array(e3), t4 && e3) for (let i2 = 0; i2 < e3; i2++) {
        const e4 = new n(t4[i2], h2);
        c2.children[i2] = e4, s3.push(e4), e4.parent = c2, e4.depth = c2.depth + 1;
      }
    }
  }
  return o2;
}
class r {
  constructor(t3, e3 = {}) {
    this.options = e3, this.rootNode = h(t3, e3);
  }
  execute() {
    throw new Error("please override this method");
  }
}
let o = class t2 {
  constructor(t3 = 0, e3 = 0, i2 = 0, n2 = []) {
    this.x = 0, this.prelim = 0, this.mod = 0, this.shift = 0, this.change = 0, this.tl = null, this.tr = null, this.el = null, this.er = null, this.msel = 0, this.mser = 0, this.w = t3 || 0, this.h = e3 || 0, this.y = i2 || 0, this.c = n2 || [], this.cs = n2.length;
  }
  static fromNode(e3, i2) {
    if (!e3) return null;
    const n2 = [];
    return e3.children.forEach((e4) => {
      const h2 = t2.fromNode(e4, i2);
      h2 && n2.push(h2);
    }), i2 ? new t2(e3.height, e3.width, e3.x, n2) : new t2(e3.width, e3.height, e3.y, n2);
  }
};
function s2(t3, e3, i2) {
  i2 ? t3.y += e3 : t3.x += e3, t3.children.forEach((t4) => {
    s2(t4, e3, i2);
  });
}
function c$2(t3, e3) {
  let i2 = e3 ? t3.y : t3.x;
  return t3.children.forEach((t4) => {
    i2 = Math.min(c$2(t4, e3), i2);
  }), i2;
}
function l(t3, e3) {
  s2(t3, -c$2(t3, e3), e3);
}
function a$2(t3, e3, i2) {
  i2 ? e3.y = t3.x : e3.x = t3.x, t3.c.forEach((t4, n2) => {
    a$2(t4, e3.children[n2], i2);
  });
}
function d2(t3, e3, i2 = 0) {
  e3 ? (t3.x = i2, i2 += t3.width) : (t3.y = i2, i2 += t3.height), t3.children.forEach((t4) => {
    d2(t4, e3, i2);
  });
}
function f(t3, e3 = {}) {
  const i2 = e3.isHorizontal;
  function n2(t4) {
    0 === t4.cs ? (t4.el = t4, t4.er = t4, t4.msel = t4.mser = 0) : (t4.el = t4.c[0].el, t4.msel = t4.c[0].msel, t4.er = t4.c[t4.cs - 1].er, t4.mser = t4.c[t4.cs - 1].mser);
  }
  function h2(t4, e4, i3) {
    let n3 = t4.c[e4 - 1], h3 = n3.mod, o2 = t4.c[e4], l2 = o2.mod;
    for (; null !== n3 && null !== o2; ) {
      i3 && f2(n3) > i3.low && (i3 = i3.nxt);
      const a2 = h3 + n3.prelim + n3.w - (l2 + o2.prelim);
      a2 > 0 && (l2 += a2, i3 && r2(t4, e4, i3.index, a2));
      const d3 = f2(n3), g3 = f2(o2);
      d3 <= g3 && (n3 = c2(n3), null !== n3 && (h3 += n3.mod)), d3 >= g3 && (o2 = s3(o2), null !== o2 && (l2 += o2.mod));
    }
    !n3 && o2 ? function(t5, e6, i4, n4) {
      const h4 = t5.c[0].el;
      h4.tl = i4;
      const r3 = n4 - i4.mod - t5.c[0].msel;
      h4.mod += r3, h4.prelim -= r3, t5.c[0].el = t5.c[e6].el, t5.c[0].msel = t5.c[e6].msel;
    }(t4, e4, o2, l2) : n3 && !o2 && function(t5, e6, i4, n4) {
      const h4 = t5.c[e6].er;
      h4.tr = i4;
      const r3 = n4 - i4.mod - t5.c[e6].mser;
      h4.mod += r3, h4.prelim -= r3, t5.c[e6].er = t5.c[e6 - 1].er, t5.c[e6].mser = t5.c[e6 - 1].mser;
    }(t4, e4, n3, h3);
  }
  function r2(t4, e4, i3, n3) {
    t4.c[e4].mod += n3, t4.c[e4].msel += n3, t4.c[e4].mser += n3, function(t5, e6, i4, n4) {
      if (i4 !== e6 - 1) {
        const h3 = e6 - i4;
        t5.c[i4 + 1].shift += n4 / h3, t5.c[e6].shift -= n4 / h3, t5.c[e6].change -= n4 - n4 / h3;
      }
    }(t4, e4, i3, n3);
  }
  function s3(t4) {
    return 0 === t4.cs ? t4.tl : t4.c[0];
  }
  function c2(t4) {
    return 0 === t4.cs ? t4.tr : t4.c[t4.cs - 1];
  }
  function f2(t4) {
    return t4.y + t4.h;
  }
  function g2(t4, e4, i3) {
    for (; null !== i3 && t4 >= i3.low; ) i3 = i3.nxt;
    return { low: t4, index: e4, nxt: i3 };
  }
  d2(t3, i2);
  const u2 = o.fromNode(t3, i2);
  return u2 && (!function t4(e4) {
    if (0 === e4.cs) return void n2(e4);
    t4(e4.c[0]);
    let i3 = g2(f2(e4.c[0].el), 0, null);
    for (let n3 = 1; n3 < e4.cs; ++n3) {
      t4(e4.c[n3]);
      const r3 = f2(e4.c[n3].er);
      h2(e4, n3, i3), i3 = g2(r3, n3, i3);
    }
    !function(t5) {
      t5.prelim = (t5.c[0].prelim + t5.c[0].mod + t5.c[t5.cs - 1].mod + t5.c[t5.cs - 1].prelim + t5.c[t5.cs - 1].w) / 2 - t5.w / 2;
    }(e4), n2(e4);
  }(u2), function t4(e4, i3) {
    i3 += e4.mod, e4.x = e4.prelim + i3, function(t5) {
      let e6 = 0, i4 = 0;
      for (let n3 = 0; n3 < t5.cs; n3++) e6 += t5.c[n3].shift, i4 += e6 + t5.c[n3].change, t5.c[n3].mod += i4;
    }(e4);
    for (let n3 = 0; n3 < e4.cs; n3++) t4(e4.c[n3], i3);
  }(u2, 0), a$2(u2, t3, i2), l(t3, i2)), t3;
}
function g(t3, e3) {
  const i2 = h(t3.data, e3, true), n2 = h(t3.data, e3, true), r2 = t3.children.length, o2 = Math.round(r2 / 2), s3 = e3.getSide || function(t4, e4) {
    return e4 < o2 ? "right" : "left";
  };
  for (let h2 = 0; h2 < r2; h2++) {
    const e4 = t3.children[h2];
    "right" === s3(e4, h2) ? n2.children.push(e4) : i2.children.push(e4);
  }
  return i2.eachNode((t4) => {
    t4.isRoot() || (t4.side = "left");
  }), n2.eachNode((t4) => {
    t4.isRoot() || (t4.side = "right");
  }), { left: i2, right: n2 };
}
const u = ["LR", "RL", "TB", "BT", "H", "V"], p = ["LR", "RL", "H"], x$3 = u[0];
function y$3(t3, e3, i2) {
  const n2 = e3.direction || x$3;
  if (e3.isHorizontal = ((t4) => p.indexOf(t4) > -1)(n2), -1 === u.indexOf(n2)) throw new TypeError(`Invalid direction: ${n2}`);
  if (n2 === u[0]) i2(t3, e3);
  else if (n2 === u[1]) i2(t3, e3), t3.right2left();
  else if (n2 === u[2]) i2(t3, e3);
  else if (n2 === u[3]) i2(t3, e3), t3.bottom2top();
  else if (n2 === u[4] || n2 === u[5]) {
    const { left: n3, right: h3 } = g(t3, e3);
    i2(n3, e3), i2(h3, e3), e3.isHorizontal ? n3.right2left() : n3.bottom2top(), h3.translate(n3.x - h3.x, n3.y - h3.y), t3.x = n3.x, t3.y = h3.y;
    const r2 = t3.getBoundingBox();
    e3.isHorizontal ? r2.top < 0 && t3.translate(0, -r2.top) : r2.left < 0 && t3.translate(-r2.left, 0);
  }
  let h2 = e3.fixedRoot;
  return void 0 === h2 && (h2 = true), h2 && t3.translate(-(t3.x + t3.width / 2 + t3.hgap), -(t3.y + t3.height / 2 + t3.vgap)), function(t4, e4) {
    if (e4.radial) {
      const [i3, n3] = e4.isHorizontal ? ["x", "y"] : ["y", "x"], h3 = { x: 1 / 0, y: 1 / 0 }, r2 = { x: -1 / 0, y: -1 / 0 };
      let o2 = 0;
      t4.DFTraverse((t5) => {
        o2++;
        const { x: e6, y: i4 } = t5;
        h3.x = Math.min(h3.x, e6), h3.y = Math.min(h3.y, i4), r2.x = Math.max(r2.x, e6), r2.y = Math.max(r2.y, i4);
      });
      const s3 = r2[n3] - h3[n3];
      if (0 === s3) return;
      const c2 = 2 * Math.PI / o2;
      t4.DFTraverse((e6) => {
        const r3 = e6[n3], o3 = h3[n3], l2 = e6[i3], a2 = t4[i3], d3 = (r3 - o3) / s3 * (2 * Math.PI - c2) + c2, f2 = l2 - a2;
        e6.x = Math.cos(d3) * f2, e6.y = Math.sin(d3) * f2;
      });
    }
  }(t3, e3), t3;
}
let m$2 = class m extends r {
  execute() {
    return y$3(this.rootNode, this.options, f);
  }
};
const w = {};
function H(t3, i2) {
  const n2 = e({}, w, i2);
  return new m$2(t3, n2).execute();
}
let N$1 = class N {
  constructor(t3 = 0, e3 = []) {
    this.x = 0, this.y = 0, this.leftChild = null, this.rightChild = null, this.isLeaf = false, this.height = t3, this.children = e3;
  }
};
const v = { isHorizontal: true, nodeSep: 20, nodeSize: 20, rankSep: 200, subTreeSep: 10 };
function M(t3, e3, i2) {
  i2 ? (e3.x = t3.x, e3.y = t3.y) : (e3.x = t3.y, e3.y = t3.x), t3.children.forEach((t4, n2) => {
    M(t4, e3.children[n2], i2);
  });
}
function E$1(t3, i2 = {}) {
  const n2 = e({}, v, i2);
  let h2 = 0;
  let r2 = null;
  const o2 = function t4(e3) {
    e3.width = 0, e3.depth && e3.depth > h2 && (h2 = e3.depth);
    const i3 = e3.children, n3 = i3.length, r3 = new N$1(0, []);
    return i3.forEach((e4, i4) => {
      const h3 = t4(e4);
      r3.children.push(h3), 0 === i4 && (r3.leftChild = h3), i4 === n3 - 1 && (r3.rightChild = h3);
    }), r3.originNode = e3, r3.isLeaf = e3.isLeaf(), r3;
  }(t3);
  return function t4(e3) {
    if (e3.isLeaf || 0 === e3.children.length) e3.drawingDepth = h2;
    else {
      const i3 = e3.children.map((e4) => t4(e4)), n3 = Math.min(...i3);
      e3.drawingDepth = n3 - 1;
    }
    return e3.drawingDepth;
  }(o2), function t4(e3) {
    e3.x = e3.drawingDepth * n2.rankSep, e3.isLeaf ? (e3.y = 0, r2 && (e3.y = r2.y + r2.height + n2.nodeSep, e3.originNode.parent !== r2.originNode.parent && (e3.y += n2.subTreeSep)), r2 = e3) : (e3.children.forEach((e4) => {
      t4(e4);
    }), e3.y = (e3.leftChild.y + e3.rightChild.y) / 2);
  }(o2), M(o2, t3, n2.isHorizontal), t3;
}
class B3 extends r {
  execute() {
    return this.rootNode.width = 0, y$3(this.rootNode, this.options, E$1);
  }
}
const T = {};
function S$1(t3, i2) {
  const n2 = e({}, T, i2);
  return new B3(t3, n2).execute();
}
function b(e3, i2, n2, h2) {
  let r2 = null;
  e3.eachNode((e4) => {
    !function(e6, i3, n3, h3, r3) {
      const o2 = ("function" == typeof n3 ? n3(e6) : n3) * e6.depth;
      if (!h3) try {
        if (e6.parent && e6.id === e6.parent.children[0].id) return e6.x += o2, void (e6.y = i3 ? i3.y : 0);
      } catch {
      }
      if (e6.x += o2, i3) {
        if (e6.y = i3.y + t(i3, e6, r3), i3.parent && e6.parent && e6.parent.id !== i3.parent.id) {
          const n4 = i3.parent, h4 = n4.y + t(n4, e6, r3);
          e6.y = h4 > e6.y ? h4 : e6.y;
        }
      } else e6.y = 0;
    }(e4, r2, i2, n2, h2), r2 = e4;
  });
}
const L = ["LR", "RL", "H"], V = L[0];
class R extends r {
  execute() {
    const t3 = this.options, e3 = this.rootNode;
    t3.isHorizontal = true;
    const { indent: i2 = 20, dropCap: n2 = true, direction: h2 = V, align: r2 } = t3;
    if (h2 && -1 === L.indexOf(h2)) throw new TypeError(`Invalid direction: ${h2}`);
    if (h2 === L[0]) b(e3, i2, n2, r2);
    else if (h2 === L[1]) b(e3, i2, n2, r2), e3.right2left();
    else if (h2 === L[2]) {
      const { left: h3, right: o2 } = g(e3, t3);
      b(h3, i2, n2, r2), h3.right2left(), b(o2, i2, n2, r2);
      const s3 = h3.getBoundingBox();
      o2.translate(s3.width, 0), e3.x = o2.x - e3.width / 2;
    }
    return e3;
  }
}
const z$1 = {};
function C2(t3, i2) {
  const n2 = e({}, z$1, i2);
  return new R(t3, n2).execute();
}
function D(t3, e3) {
  let i2 = 0;
  return t3.children.length ? t3.children.forEach((t4) => {
    i2 += D(t4, e3);
  }) : i2 = t3.height, t3._subTreeSep = e3.getSubTreeSep(t3.data), t3.totalHeight = Math.max(t3.height, i2) + 2 * t3._subTreeSep, t3.totalHeight;
}
function Y(t3) {
  const e3 = t3.children, i2 = e3.length;
  if (i2) {
    e3.forEach((t4) => {
      Y(t4);
    });
    const n2 = e3[0], h2 = e3[i2 - 1], r2 = h2.y - n2.y + h2.height;
    let o2 = 0;
    if (e3.forEach((t4) => {
      o2 += t4.totalHeight;
    }), r2 > t3.height) t3.y = n2.y + r2 / 2 - t3.height / 2;
    else if (1 !== e3.length || t3.height > o2) {
      const i3 = t3.y + (t3.height - r2) / 2 - n2.y;
      e3.forEach((t4) => {
        t4.translate(0, i3);
      });
    } else t3.y = (n2.y + n2.height / 2 + h2.y + h2.height / 2) / 2 - t3.height / 2;
  }
}
const G = { getSubTreeSep: () => 0 };
function I(t3, i2 = {}) {
  return i2 = e({}, G, i2), t3.parent = { x: 0, width: 0, height: 0, y: 0 }, t3.BFTraverse((t4) => {
    t4.x = t4.parent.x + t4.parent.width;
  }), t3.parent = void 0, D(t3, i2), t3.startY = 0, t3.y = t3.totalHeight / 2 - t3.height / 2, t3.eachNode((t4) => {
    const e3 = t4.children, i3 = e3.length;
    if (i3) {
      const n2 = e3[0];
      if (n2.startY = t4.startY + t4._subTreeSep, 1 === i3) n2.y = t4.y + t4.height / 2 - n2.height / 2;
      else {
        n2.y = n2.startY + n2.totalHeight / 2 - n2.height / 2;
        for (let t5 = 1; t5 < i3; t5++) {
          const i4 = e3[t5];
          i4.startY = e3[t5 - 1].startY + e3[t5 - 1].totalHeight, i4.y = i4.startY + i4.totalHeight / 2 - i4.height / 2;
        }
      }
    }
  }), Y(t3), t3;
}
class P extends r {
  execute() {
    return y$3(this.rootNode, this.options, I);
  }
}
const A2 = {};
function F(t3, i2) {
  const n2 = e({}, A2, i2);
  return new P(t3, n2).execute();
}
const filterOutLinks$1 = (k, v2) => {
  if (k !== "next" && k !== "prev") {
    return v2;
  }
};
const unlink$1 = (entry) => {
  entry.prev.next = entry.next;
  entry.next.prev = entry.prev;
  delete entry.next;
  delete entry.prev;
};
let List$3 = class List {
  constructor() {
    const shortcut = {};
    shortcut.prev = shortcut;
    shortcut.next = shortcut.prev;
    this.shortcut = shortcut;
  }
  dequeue() {
    const shortcut = this.shortcut;
    const entry = shortcut.prev;
    if (entry && entry !== shortcut) {
      unlink$1(entry);
      return entry;
    }
  }
  enqueue(entry) {
    const shortcut = this.shortcut;
    if (entry.prev && entry.next) {
      unlink$1(entry);
    }
    entry.next = shortcut.next;
    shortcut.next.prev = entry;
    shortcut.next = entry;
    entry.prev = shortcut;
  }
  toString() {
    const strs = [];
    const sentinel = this.shortcut;
    let curr = sentinel.prev;
    while (curr !== sentinel) {
      strs.push(JSON.stringify(curr, filterOutLinks$1));
      curr = curr === null || curr === void 0 ? void 0 : curr.prev;
    }
    return `[${strs.join(", ")}]`;
  }
};
let List$2 = class List2 extends List$3 {
};
const DEFAULT_WEIGHT_FN$1 = () => 1;
const greedyFAS$2 = (g2, weightFn) => {
  var _a3;
  if (g2.getAllNodes().length <= 1)
    return [];
  const state = buildState$1(g2, weightFn || DEFAULT_WEIGHT_FN$1);
  const results = doGreedyFAS$1(state.graph, state.buckets, state.zeroIdx);
  return (_a3 = results.map((e3) => g2.getRelatedEdges(e3.v, "out").filter(({ target }) => target === e3.w))) === null || _a3 === void 0 ? void 0 : _a3.flat();
};
const doGreedyFAS$1 = (g2, buckets, zeroIdx) => {
  let results = [];
  const sources = buckets[buckets.length - 1];
  const sinks = buckets[0];
  let entry;
  while (g2.getAllNodes().length) {
    while (entry = sinks.dequeue()) {
      removeNode$1(g2, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode$1(g2, buckets, zeroIdx, entry);
    }
    if (g2.getAllNodes().length) {
      for (let i2 = buckets.length - 2; i2 > 0; --i2) {
        entry = buckets[i2].dequeue();
        if (entry) {
          results = results.concat(removeNode$1(g2, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
};
const removeNode$1 = (g2, buckets, zeroIdx, entry, collectPredecessors) => {
  var _a3, _b;
  const results = [];
  if (g2.hasNode(entry.v)) {
    (_a3 = g2.getRelatedEdges(entry.v, "in")) === null || _a3 === void 0 ? void 0 : _a3.forEach((edge) => {
      const weight = edge.data.weight;
      const uEntry = g2.getNode(edge.source);
      if (collectPredecessors) {
        results.push({ v: edge.source, w: edge.target, in: 0, out: 0 });
      }
      if (uEntry.data.out === void 0)
        uEntry.data.out = 0;
      uEntry.data.out -= weight;
      assignBucket$1(buckets, zeroIdx, Object.assign({ v: uEntry.id }, uEntry.data));
    });
    (_b = g2.getRelatedEdges(entry.v, "out")) === null || _b === void 0 ? void 0 : _b.forEach((edge) => {
      const weight = edge.data.weight;
      const w2 = edge.target;
      const wEntry = g2.getNode(w2);
      if (wEntry.data.in === void 0)
        wEntry.data.in = 0;
      wEntry.data.in -= weight;
      assignBucket$1(buckets, zeroIdx, Object.assign({ v: wEntry.id }, wEntry.data));
    });
    g2.removeNode(entry.v);
  }
  return collectPredecessors ? results : void 0;
};
const buildState$1 = (g2, weightFn) => {
  const fasGraph = new Graph$9();
  let maxIn = 0;
  let maxOut = 0;
  g2.getAllNodes().forEach((v2) => {
    fasGraph.addNode({
      id: v2.id,
      data: { v: v2.id, in: 0, out: 0 }
    });
  });
  g2.getAllEdges().forEach((e3) => {
    const edge = fasGraph.getRelatedEdges(e3.source, "out").find((edge2) => edge2.target === e3.target);
    const weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e3)) || 1;
    if (!edge) {
      fasGraph.addEdge({
        id: e3.id,
        source: e3.source,
        target: e3.target,
        data: {
          weight
        }
      });
    } else {
      fasGraph.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + weight }));
    }
    maxOut = Math.max(maxOut, fasGraph.getNode(e3.source).data.out += weight);
    maxIn = Math.max(maxIn, fasGraph.getNode(e3.target).data.in += weight);
  });
  const buckets = [];
  const rangeMax = maxOut + maxIn + 3;
  for (let i2 = 0; i2 < rangeMax; i2++) {
    buckets.push(new List$2());
  }
  const zeroIdx = maxIn + 1;
  fasGraph.getAllNodes().forEach((v2) => {
    assignBucket$1(buckets, zeroIdx, Object.assign({ v: v2.id }, fasGraph.getNode(v2.id).data));
  });
  return { buckets, zeroIdx, graph: fasGraph };
};
const assignBucket$1 = (buckets, zeroIdx, entry) => {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
};
const run$5 = (g2, acyclicer) => {
  const weightFn = (g3) => {
    return (e3) => e3.data.weight || 1;
  };
  const fas = greedyFAS$2(g2, weightFn());
  fas === null || fas === void 0 ? void 0 : fas.forEach((e3) => {
    const label = e3.data;
    g2.removeEdge(e3.id);
    label.forwardName = e3.data.name;
    label.reversed = true;
    g2.addEdge({
      id: e3.id,
      source: e3.target,
      target: e3.source,
      data: Object.assign({}, label)
    });
  });
};
const undo$5 = (g2) => {
  g2.getAllEdges().forEach((e3) => {
    const label = e3.data;
    if (label.reversed) {
      g2.removeEdge(e3.id);
      const forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g2.addEdge({
        id: e3.id,
        source: e3.target,
        target: e3.source,
        data: Object.assign(Object.assign({}, label), { forwardName })
      });
    }
  });
};
const safeSort = (valueA, valueB) => {
  return Number(valueA) - Number(valueB);
};
const addDummyNode$1 = (g2, type, data2, name) => {
  let v2;
  do {
    v2 = `${name}${Math.random()}`;
  } while (g2.hasNode(v2));
  data2.dummy = type;
  g2.addNode({
    id: v2,
    data: data2
  });
  return v2;
};
const simplify$2 = (g2) => {
  const simplified = new Graph$9();
  g2.getAllNodes().forEach((v2) => {
    simplified.addNode(Object.assign({}, v2));
  });
  g2.getAllEdges().forEach((e3) => {
    const edge = simplified.getRelatedEdges(e3.source, "out").find((edge2) => edge2.target === e3.target);
    if (!edge) {
      simplified.addEdge({
        id: e3.id,
        source: e3.source,
        target: e3.target,
        data: {
          weight: e3.data.weight || 0,
          minlen: e3.data.minlen || 1
        }
      });
    } else {
      simplified.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + e3.data.weight || 0, minlen: Math.max(edge.data.minlen, e3.data.minlen || 1) }));
    }
  });
  return simplified;
};
const asNonCompoundGraph$1 = (g2) => {
  const simplified = new Graph$9();
  g2.getAllNodes().forEach((node) => {
    if (!g2.getChildren(node.id).length) {
      simplified.addNode(Object.assign({}, node));
    }
  });
  g2.getAllEdges().forEach((edge) => {
    simplified.addEdge(edge);
  });
  return simplified;
};
const zipObject = (keys, values2) => {
  return keys === null || keys === void 0 ? void 0 : keys.reduce((obj, key, i2) => {
    obj[key] = values2[i2];
    return obj;
  }, {});
};
const intersectRect$1 = (rect2, point2) => {
  const x2 = Number(rect2.x);
  const y2 = Number(rect2.y);
  const dx = Number(point2.x) - x2;
  const dy = Number(point2.y) - y2;
  let w2 = Number(rect2.width) / 2;
  let h2 = Number(rect2.height) / 2;
  if (!dx && !dy) {
    return { x: 0, y: 0 };
  }
  let sx;
  let sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
    if (dy < 0) {
      h2 = -h2;
    }
    sx = h2 * dx / dy;
    sy = h2;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
};
const buildLayerMatrix$1 = (g2) => {
  const layeringNodes = [];
  const rankMax = maxRank$1(g2) + 1;
  for (let i2 = 0; i2 < rankMax; i2++) {
    layeringNodes.push([]);
  }
  g2.getAllNodes().forEach((node) => {
    const rank2 = node.data.rank;
    if (rank2 !== void 0 && layeringNodes[rank2]) {
      layeringNodes[rank2].push(node.id);
    }
  });
  for (let i2 = 0; i2 < rankMax; i2++) {
    layeringNodes[i2] = layeringNodes[i2].sort((va, vb) => safeSort(g2.getNode(va).data.order, g2.getNode(vb).data.order));
  }
  return layeringNodes;
};
const normalizeRanks$2 = (g2) => {
  const nodeRanks = g2.getAllNodes().filter((v2) => v2.data.rank !== void 0).map((v2) => v2.data.rank);
  const min2 = Math.min(...nodeRanks);
  g2.getAllNodes().forEach((v2) => {
    if (v2.data.hasOwnProperty("rank") && min2 !== Infinity) {
      v2.data.rank -= min2;
    }
  });
};
const removeEmptyRanks$2 = (g2, nodeRankFactor = 0) => {
  const nodes = g2.getAllNodes();
  const nodeRanks = nodes.filter((v2) => v2.data.rank !== void 0).map((v2) => v2.data.rank);
  const offset = Math.min(...nodeRanks);
  const layers = [];
  nodes.forEach((v2) => {
    const rank2 = (v2.data.rank || 0) - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v2.id);
  });
  let delta = 0;
  for (let i2 = 0; i2 < layers.length; i2++) {
    const vs = layers[i2];
    if (vs === void 0) {
      if (i2 % nodeRankFactor !== 0) {
        delta -= 1;
      }
    } else if (delta) {
      vs === null || vs === void 0 ? void 0 : vs.forEach((v2) => {
        const node = g2.getNode(v2);
        if (node) {
          node.data.rank = node.data.rank || 0;
          node.data.rank += delta;
        }
      });
    }
  }
};
const addBorderNode$3 = (g2, prefix, rank2, order2) => {
  const node = {
    width: 0,
    height: 0
  };
  if (isNumber(rank2) && isNumber(order2)) {
    node.rank = rank2;
    node.order = order2;
  }
  return addDummyNode$1(g2, "border", node, prefix);
};
const maxRank$1 = (g2) => {
  let maxRank2;
  g2.getAllNodes().forEach((v2) => {
    const rank2 = v2.data.rank;
    if (rank2 !== void 0) {
      if (maxRank2 === void 0 || rank2 > maxRank2) {
        maxRank2 = rank2;
      }
    }
  });
  if (!maxRank2) {
    maxRank2 = 0;
  }
  return maxRank2;
};
const partition$1 = (collection, fn) => {
  const result = { lhs: [], rhs: [] };
  collection === null || collection === void 0 ? void 0 : collection.forEach((value) => {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
};
const minBy = (array, func) => {
  return array.reduce((a2, b2) => {
    const valA = func(a2);
    const valB = func(b2);
    return valA > valB ? b2 : a2;
  });
};
const doDFS = (graph2, node, postorder2, visited, navigator, result) => {
  if (!visited.includes(node.id)) {
    visited.push(node.id);
    if (!postorder2) {
      result.push(node.id);
    }
    navigator(node.id).forEach((n2) => doDFS(graph2, n2, postorder2, visited, navigator, result));
    if (postorder2) {
      result.push(node.id);
    }
  }
};
const dfs$2 = (graph2, node, order2, isDirected) => {
  const nodes = Array.isArray(node) ? node : [node];
  const navigator = (n2) => graph2.getNeighbors(n2);
  const results = [];
  const visited = [];
  nodes.forEach((node2) => {
    if (!graph2.hasNode(node2.id)) {
      throw new Error(`Graph does not have node: ${node2}`);
    } else {
      doDFS(graph2, node2, order2 === "post", visited, navigator, results);
    }
  });
  return results;
};
const addBorderSegments$2 = (g2) => {
  const dfs2 = (v2) => {
    const children = g2.getChildren(v2);
    const node = g2.getNode(v2);
    if (children === null || children === void 0 ? void 0 : children.length) {
      children.forEach((child) => dfs2(child.id));
    }
    if (node.data.hasOwnProperty("minRank")) {
      node.data.borderLeft = [];
      node.data.borderRight = [];
      for (let rank2 = node.data.minRank, maxRank2 = node.data.maxRank + 1; rank2 < maxRank2; rank2 += 1) {
        addBorderNode$2(g2, "borderLeft", "_bl", v2, node, rank2);
        addBorderNode$2(g2, "borderRight", "_br", v2, node, rank2);
      }
    }
  };
  g2.getRoots().forEach((child) => dfs2(child.id));
};
const addBorderNode$2 = (g2, prop, prefix, sg, sgNode, rank2) => {
  const label = { rank: rank2, borderType: prop, width: 0, height: 0 };
  const prev = sgNode.data[prop][rank2 - 1];
  const curr = addDummyNode$1(g2, "border", label, prefix);
  sgNode.data[prop][rank2] = curr;
  g2.setParent(curr, sg);
  if (prev) {
    g2.addEdge({
      id: `e${Math.random()}`,
      source: prev,
      target: curr,
      data: { weight: 1 }
    });
  }
};
const adjust$1 = (g2, rankdir) => {
  const rd = rankdir.toLowerCase();
  if (rd === "lr" || rd === "rl") {
    swapWidthHeight$1(g2);
  }
};
const undo$4 = (g2, rankdir) => {
  const rd = rankdir.toLowerCase();
  if (rd === "bt" || rd === "rl") {
    reverseY$1(g2);
  }
  if (rd === "lr" || rd === "rl") {
    swapXY$1(g2);
    swapWidthHeight$1(g2);
  }
};
const swapWidthHeight$1 = (g2) => {
  g2.getAllNodes().forEach((v2) => {
    swapWidthHeightOne$1(v2);
  });
  g2.getAllEdges().forEach((e3) => {
    swapWidthHeightOne$1(e3);
  });
};
const swapWidthHeightOne$1 = (node) => {
  const w2 = node.data.width;
  node.data.width = node.data.height;
  node.data.height = w2;
};
const reverseY$1 = (g2) => {
  g2.getAllNodes().forEach((v2) => {
    reverseYOne$1(v2.data);
  });
  g2.getAllEdges().forEach((edge) => {
    var _a3;
    (_a3 = edge.data.points) === null || _a3 === void 0 ? void 0 : _a3.forEach((point2) => reverseYOne$1(point2));
    if (edge.data.hasOwnProperty("y")) {
      reverseYOne$1(edge.data);
    }
  });
};
const reverseYOne$1 = (node) => {
  if (node === null || node === void 0 ? void 0 : node.y) {
    node.y = -node.y;
  }
};
const swapXY$1 = (g2) => {
  g2.getAllNodes().forEach((v2) => {
    swapXYOne$1(v2.data);
  });
  g2.getAllEdges().forEach((edge) => {
    var _a3;
    (_a3 = edge.data.points) === null || _a3 === void 0 ? void 0 : _a3.forEach((point2) => swapXYOne$1(point2));
    if (edge.data.hasOwnProperty("x")) {
      swapXYOne$1(edge.data);
    }
  });
};
const swapXYOne$1 = (node) => {
  const x2 = node.x;
  node.x = node.y;
  node.y = x2;
};
const run$4 = (g2) => {
  const root2 = addDummyNode$1(g2, "root", {}, "_root");
  const depths = treeDepths$1(g2);
  let maxDepth = Math.max(...Object.values(depths));
  if (Math.abs(maxDepth) === Infinity) {
    maxDepth = 1;
  }
  const height = maxDepth - 1;
  const nodeSep = 2 * height + 1;
  g2.getAllEdges().forEach((e3) => {
    e3.data.minlen *= nodeSep;
  });
  const weight = sumWeights$1(g2) + 1;
  g2.getRoots().forEach((child) => {
    dfs$1(g2, root2, nodeSep, weight, height, depths, child.id);
  });
  return {
    nestingRoot: root2,
    nodeRankFactor: nodeSep
  };
};
const dfs$1 = (g2, root2, nodeSep, weight, height, depths, v2) => {
  const children = g2.getChildren(v2);
  if (!(children === null || children === void 0 ? void 0 : children.length)) {
    if (v2 !== root2) {
      g2.addEdge({
        id: `e${Math.random()}`,
        source: root2,
        target: v2,
        data: { weight: 0, minlen: nodeSep }
      });
    }
    return;
  }
  const top = addBorderNode$3(g2, "_bt");
  const bottom = addBorderNode$3(g2, "_bb");
  const label = g2.getNode(v2);
  g2.setParent(top, v2);
  label.data.borderTop = top;
  g2.setParent(bottom, v2);
  label.data.borderBottom = bottom;
  children === null || children === void 0 ? void 0 : children.forEach((childNode) => {
    dfs$1(g2, root2, nodeSep, weight, height, depths, childNode.id);
    const childTop = childNode.data.borderTop ? childNode.data.borderTop : childNode.id;
    const childBottom = childNode.data.borderBottom ? childNode.data.borderBottom : childNode.id;
    const thisWeight = childNode.data.borderTop ? weight : 2 * weight;
    const minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
    g2.addEdge({
      id: `e${Math.random()}`,
      source: top,
      target: childTop,
      data: {
        minlen,
        weight: thisWeight,
        nestingEdge: true
      }
    });
    g2.addEdge({
      id: `e${Math.random()}`,
      source: childBottom,
      target: bottom,
      data: {
        minlen,
        weight: thisWeight,
        nestingEdge: true
      }
    });
  });
  if (!g2.getParent(v2)) {
    g2.addEdge({
      id: `e${Math.random()}`,
      source: root2,
      target: top,
      data: {
        weight: 0,
        minlen: height + depths[v2]
      }
    });
  }
};
const treeDepths$1 = (g2) => {
  const depths = {};
  const dfs2 = (v2, depth) => {
    const children = g2.getChildren(v2);
    children === null || children === void 0 ? void 0 : children.forEach((child) => dfs2(child.id, depth + 1));
    depths[v2] = depth;
  };
  g2.getRoots().forEach((v2) => dfs2(v2.id, 1));
  return depths;
};
const sumWeights$1 = (g2) => {
  let result = 0;
  g2.getAllEdges().forEach((e3) => {
    result += e3.data.weight;
  });
  return result;
};
const cleanup$1 = (g2, nestingRoot) => {
  if (nestingRoot) {
    g2.removeNode(nestingRoot);
  }
  g2.getAllEdges().forEach((e3) => {
    if (e3.data.nestingEdge) {
      g2.removeEdge(e3.id);
    }
  });
};
const DUMMY_NODE_EDGE = "edge";
const DUMMY_NODE_EDGE_LABEL = "edge-label";
const run$3 = (g2, dummyChains) => {
  g2.getAllEdges().forEach((edge) => normalizeEdge$1(g2, edge, dummyChains));
};
const normalizeEdge$1 = (g2, e3, dummyChains) => {
  let v2 = e3.source;
  let vRank = g2.getNode(v2).data.rank;
  const w2 = e3.target;
  const wRank = g2.getNode(w2).data.rank;
  const labelRank = e3.data.labelRank;
  if (wRank === vRank + 1)
    return;
  g2.removeEdge(e3.id);
  let dummy;
  let nodeData;
  let i2;
  for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
    e3.data.points = [];
    nodeData = {
      originalEdge: e3,
      width: 0,
      height: 0,
      rank: vRank
    };
    dummy = addDummyNode$1(g2, DUMMY_NODE_EDGE, nodeData, "_d");
    if (vRank === labelRank) {
      nodeData.width = e3.data.width;
      nodeData.height = e3.data.height;
      nodeData.dummy = DUMMY_NODE_EDGE_LABEL;
      nodeData.labelpos = e3.data.labelpos;
    }
    g2.addEdge({
      id: `e${Math.random()}`,
      source: v2,
      target: dummy,
      data: { weight: e3.data.weight }
    });
    if (i2 === 0) {
      dummyChains.push(dummy);
    }
    v2 = dummy;
  }
  g2.addEdge({
    id: `e${Math.random()}`,
    source: v2,
    target: w2,
    data: { weight: e3.data.weight }
  });
};
const undo$3 = (g2, dummyChains) => {
  dummyChains.forEach((v2) => {
    let node = g2.getNode(v2);
    const { data: data2 } = node;
    const originalEdge = data2.originalEdge;
    let w2;
    if (originalEdge) {
      g2.addEdge(originalEdge);
    }
    let currentV = v2;
    while (node.data.dummy) {
      w2 = g2.getSuccessors(currentV)[0];
      g2.removeNode(currentV);
      originalEdge.data.points.push({
        x: node.data.x,
        y: node.data.y
      });
      if (node.data.dummy === DUMMY_NODE_EDGE_LABEL) {
        originalEdge.data.x = node.data.x;
        originalEdge.data.y = node.data.y;
        originalEdge.data.width = node.data.width;
        originalEdge.data.height = node.data.height;
      }
      currentV = w2.id;
      node = g2.getNode(currentV);
    }
  });
};
const addSubgraphConstraints$2 = (g2, cg, vs) => {
  const prev = {};
  let rootPrev;
  vs === null || vs === void 0 ? void 0 : vs.forEach((v2) => {
    let child = g2.getParent(v2);
    let parent;
    let prevChild;
    while (child) {
      parent = g2.getParent(child.id);
      if (parent) {
        prevChild = prev[parent.id];
        prev[parent.id] = child.id;
      } else {
        prevChild = rootPrev;
        rootPrev = child.id;
      }
      if (prevChild && prevChild !== child.id) {
        if (!cg.hasNode(prevChild)) {
          cg.addNode({
            id: prevChild,
            data: {}
          });
        }
        if (!cg.hasNode(child.id)) {
          cg.addNode({
            id: child.id,
            data: {}
          });
        }
        if (!cg.hasEdge(`e${prevChild}-${child.id}`)) {
          cg.addEdge({
            id: `e${prevChild}-${child.id}`,
            source: prevChild,
            target: child.id,
            data: {}
          });
        }
        return;
      }
      child = parent;
    }
  });
};
const buildLayerGraph$2 = (g2, rank2, direction2) => {
  const root2 = createRootNode$1(g2);
  const result = new Graph$9({
    tree: [
      {
        id: root2,
        children: [],
        data: {}
      }
    ]
  });
  g2.getAllNodes().forEach((v2) => {
    const parent = g2.getParent(v2.id);
    if (v2.data.rank === rank2 || v2.data.minRank <= rank2 && rank2 <= v2.data.maxRank) {
      if (!result.hasNode(v2.id)) {
        result.addNode(Object.assign({}, v2));
      }
      if ((parent === null || parent === void 0 ? void 0 : parent.id) && !result.hasNode(parent === null || parent === void 0 ? void 0 : parent.id)) {
        result.addNode(Object.assign({}, parent));
      }
      result.setParent(v2.id, (parent === null || parent === void 0 ? void 0 : parent.id) || root2);
      g2.getRelatedEdges(v2.id, direction2).forEach((e3) => {
        const u2 = e3.source === v2.id ? e3.target : e3.source;
        if (!result.hasNode(u2)) {
          result.addNode(Object.assign({}, g2.getNode(u2)));
        }
        const edge = result.getRelatedEdges(u2, "out").find(({ target }) => target === v2.id);
        const weight = edge !== void 0 ? edge.data.weight : 0;
        if (!edge) {
          result.addEdge({
            id: e3.id,
            source: u2,
            target: v2.id,
            data: {
              weight: e3.data.weight + weight
            }
          });
        } else {
          result.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: e3.data.weight + weight }));
        }
      });
      if (v2.data.hasOwnProperty("minRank")) {
        result.updateNodeData(v2.id, Object.assign(Object.assign({}, v2.data), { borderLeft: v2.data.borderLeft[rank2], borderRight: v2.data.borderRight[rank2] }));
      }
    }
  });
  return result;
};
const createRootNode$1 = (g2) => {
  let v2;
  while (g2.hasNode(v2 = `_root${Math.random()}`))
    ;
  return v2;
};
const twoLayerCrossCount$1 = (g2, northLayer, southLayer) => {
  const southPos = zipObject(southLayer, southLayer.map((v2, i2) => i2));
  const unflat = northLayer.map((v2) => {
    const unsort = g2.getRelatedEdges(v2, "out").map((e3) => {
      return { pos: southPos[e3.target] || 0, weight: e3.data.weight };
    });
    return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a2, b2) => a2.pos - b2.pos);
  });
  const southEntries = unflat.flat().filter((entry) => entry !== void 0);
  let firstIndex = 1;
  while (firstIndex < southLayer.length)
    firstIndex <<= 1;
  const treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  const tree = Array(treeSize).fill(0, 0, treeSize);
  let cc = 0;
  southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach((entry) => {
    if (entry) {
      let index2 = entry.pos + firstIndex;
      tree[index2] += entry.weight;
      let weightSum = 0;
      while (index2 > 0) {
        if (index2 % 2) {
          weightSum += tree[index2 + 1];
        }
        index2 = index2 - 1 >> 1;
        tree[index2] += entry.weight;
      }
      cc += entry.weight * weightSum;
    }
  });
  return cc;
};
const crossCount$2 = (g2, layering) => {
  let cc = 0;
  for (let i2 = 1; i2 < (layering === null || layering === void 0 ? void 0 : layering.length); i2 += 1) {
    cc += twoLayerCrossCount$1(g2, layering[i2 - 1], layering[i2]);
  }
  return cc;
};
const initOrder$2 = (g2) => {
  const visited = {};
  const simpleNodes = g2.getAllNodes();
  const nodeRanks = simpleNodes.map((v2) => {
    var _a3;
    return (_a3 = v2.data.rank) !== null && _a3 !== void 0 ? _a3 : -Infinity;
  });
  const maxRank2 = Math.max(...nodeRanks);
  const layers = [];
  for (let i2 = 0; i2 < maxRank2 + 1; i2++) {
    layers.push([]);
  }
  const orderedVs = simpleNodes.sort((a2, b2) => g2.getNode(a2.id).data.rank - g2.getNode(b2.id).data.rank);
  const beforeSort = orderedVs.filter((n2) => {
    return g2.getNode(n2.id).data.fixorder !== void 0;
  });
  const fixOrderNodes = beforeSort.sort((a2, b2) => g2.getNode(a2.id).data.fixorder - g2.getNode(b2.id).data.fixorder);
  fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach((n2) => {
    if (!isNaN(g2.getNode(n2.id).data.rank)) {
      layers[g2.getNode(n2.id).data.rank].push(n2.id);
    }
    visited[n2.id] = true;
  });
  orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach((n2) => g2.dfsTree(n2.id, (node) => {
    if (visited.hasOwnProperty(node.id))
      return true;
    visited[node.id] = true;
    if (!isNaN(node.data.rank)) {
      layers[node.data.rank].push(node.id);
    }
  }));
  return layers;
};
const barycenter$2 = (g2, movable) => {
  return movable.map((v2) => {
    const inV = g2.getRelatedEdges(v2, "in");
    if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
      return { v: v2 };
    }
    const result = { sum: 0, weight: 0 };
    inV === null || inV === void 0 ? void 0 : inV.forEach((e3) => {
      const nodeU = g2.getNode(e3.source);
      result.sum += e3.data.weight * nodeU.data.order;
      result.weight += e3.data.weight;
    });
    return {
      v: v2,
      barycenter: result.sum / result.weight,
      weight: result.weight
    };
  });
};
const resolveConflicts$2 = (entries, cg) => {
  var _a3, _b, _c;
  const mappedEntries = {};
  entries === null || entries === void 0 ? void 0 : entries.forEach((entry, i2) => {
    mappedEntries[entry.v] = {
      i: i2,
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v]
    };
    const tmp2 = mappedEntries[entry.v];
    if (entry.barycenter !== void 0) {
      tmp2.barycenter = entry.barycenter;
      tmp2.weight = entry.weight;
    }
  });
  (_a3 = cg.getAllEdges()) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => {
    const entryV = mappedEntries[e3.source];
    const entryW = mappedEntries[e3.target];
    if (entryV !== void 0 && entryW !== void 0) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e3.target]);
    }
  });
  const sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, (entry) => !entry.indegree);
  return doResolveConflicts$1(sourceSet);
};
const doResolveConflicts$1 = (sourceSet) => {
  var _a3, _b;
  const entries = [];
  const handleIn = (vEntry) => {
    return (uEntry) => {
      if (uEntry.merged)
        return;
      if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries$1(vEntry, uEntry);
      }
    };
  };
  const handleOut = (vEntry) => {
    return (wEntry) => {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  };
  while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
    const entry = sourceSet.pop();
    entries.push(entry);
    (_a3 = entry["in"].reverse()) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => handleIn(entry)(e3));
    (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach((e3) => handleOut(entry)(e3));
  }
  const filtered = entries.filter((entry) => !entry.merged);
  const keys = [
    "vs",
    "i",
    "barycenter",
    "weight"
  ];
  return filtered.map((entry) => {
    const picked = {};
    keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
      if (entry[key] === void 0)
        return;
      picked[key] = entry[key];
    });
    return picked;
  });
};
const mergeEntries$1 = (target, source) => {
  var _a3;
  let sum = 0;
  let weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = (_a3 = source.vs) === null || _a3 === void 0 ? void 0 : _a3.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
};
const sort$2 = (entries, biasRight, usePrev, keepNodeOrder) => {
  const parts = partition$1(entries, (entry) => {
    const hasFixOrder = entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder);
    if (keepNodeOrder) {
      return !hasFixOrder && entry.hasOwnProperty("barycenter");
    }
    return hasFixOrder || entry.hasOwnProperty("barycenter");
  });
  const sortable = parts.lhs;
  const unsortable = parts.rhs.sort((a2, b2) => -a2.i - -b2.i);
  const vs = [];
  let sum = 0;
  let weight = 0;
  let vsIndex = 0;
  sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias$1(!!biasRight, !!usePrev));
  vsIndex = consumeUnsortable$1(vs, unsortable, vsIndex);
  sortable === null || sortable === void 0 ? void 0 : sortable.forEach((entry) => {
    var _a3;
    vsIndex += (_a3 = entry.vs) === null || _a3 === void 0 ? void 0 : _a3.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable$1(vs, unsortable, vsIndex);
  });
  const result = {
    vs: vs.flat()
  };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
};
const consumeUnsortable$1 = (vs, unsortable, index2) => {
  let iindex = index2;
  let last;
  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= iindex) {
    unsortable.pop();
    vs === null || vs === void 0 ? void 0 : vs.push(last.vs);
    iindex++;
  }
  return iindex;
};
const compareWithBias$1 = (bias, usePrev) => {
  return (entryV, entryW) => {
    if (entryV.fixorder !== void 0 && entryW.fixorder !== void 0) {
      return entryV.fixorder - entryW.fixorder;
    }
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    }
    if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    if (usePrev && entryV.order !== void 0 && entryW.order !== void 0) {
      if (entryV.order < entryW.order) {
        return -1;
      }
      if (entryV.order > entryW.order) {
        return 1;
      }
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
};
const sortSubgraph$2 = (g2, v2, cg, biasRight, usePrev, keepNodeOrder) => {
  var _a3, _b, _c, _d;
  let movable = g2.getChildren(v2).map((n2) => n2.id);
  const node = g2.getNode(v2);
  const bl = node ? node.data.borderLeft : void 0;
  const br = node ? node.data.borderRight : void 0;
  const subgraphs = {};
  if (bl) {
    movable = movable === null || movable === void 0 ? void 0 : movable.filter((w2) => {
      return w2 !== bl && w2 !== br;
    });
  }
  const barycenters = barycenter$2(g2, movable || []);
  barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach((entry) => {
    var _a4;
    if ((_a4 = g2.getChildren(entry.v)) === null || _a4 === void 0 ? void 0 : _a4.length) {
      const subgraphResult = sortSubgraph$2(g2, entry.v, cg, biasRight, keepNodeOrder);
      subgraphs[entry.v] = subgraphResult;
      if (subgraphResult.hasOwnProperty("barycenter")) {
        mergeBarycenters$1(entry, subgraphResult);
      }
    }
  });
  const entries = resolveConflicts$2(barycenters, cg);
  expandSubgraphs$1(entries, subgraphs);
  (_a3 = entries.filter((e3) => e3.vs.length > 0)) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => {
    const node2 = g2.getNode(e3.vs[0]);
    if (node2) {
      e3.fixorder = node2.data.fixorder;
      e3.order = node2.data.order;
    }
  });
  const result = sort$2(entries, biasRight, usePrev, keepNodeOrder);
  if (bl) {
    result.vs = [bl, result.vs, br].flat();
    if ((_b = g2.getPredecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
      const blPred = g2.getNode(((_c = g2.getPredecessors(bl)) === null || _c === void 0 ? void 0 : _c[0].id) || "");
      const brPred = g2.getNode(((_d = g2.getPredecessors(br)) === null || _d === void 0 ? void 0 : _d[0].id) || "");
      if (!result.hasOwnProperty("barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.data.order + brPred.data.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
};
const expandSubgraphs$1 = (entries, subgraphs) => {
  entries === null || entries === void 0 ? void 0 : entries.forEach((entry) => {
    var _a3;
    const vss = (_a3 = entry.vs) === null || _a3 === void 0 ? void 0 : _a3.map((v2) => {
      if (subgraphs[v2]) {
        return subgraphs[v2].vs;
      }
      return v2;
    });
    entry.vs = vss.flat();
  });
};
const mergeBarycenters$1 = (target, other) => {
  if (target.barycenter !== void 0) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
};
const order$2 = (g2, keepNodeOrder) => {
  const mxRank = maxRank$1(g2);
  const range1 = [];
  const range2 = [];
  for (let i2 = 1; i2 < mxRank + 1; i2++)
    range1.push(i2);
  for (let i2 = mxRank - 1; i2 > -1; i2--)
    range2.push(i2);
  const downLayerGraphs = buildLayerGraphs$1(g2, range1, "in");
  const upLayerGraphs = buildLayerGraphs$1(g2, range2, "out");
  let layering = initOrder$2(g2);
  assignOrder$1(g2, layering);
  let bestCC = Number.POSITIVE_INFINITY;
  let best;
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs$1(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, false, keepNodeOrder);
    layering = buildLayerMatrix$1(g2);
    const cc = crossCount$2(g2, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = clone$1(layering);
      bestCC = cc;
    }
  }
  layering = initOrder$2(g2);
  assignOrder$1(g2, layering);
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs$1(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, true, keepNodeOrder);
    layering = buildLayerMatrix$1(g2);
    const cc = crossCount$2(g2, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = clone$1(layering);
      bestCC = cc;
    }
  }
  assignOrder$1(g2, best);
};
const buildLayerGraphs$1 = (g2, ranks, direction2) => {
  return ranks.map((rank2) => {
    return buildLayerGraph$2(g2, rank2, direction2);
  });
};
const sweepLayerGraphs$1 = (layerGraphs, biasRight, usePrev, keepNodeOrder) => {
  const cg = new Graph$9();
  layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach((lg) => {
    var _a3;
    const root2 = lg.getRoots()[0].id;
    const sorted = sortSubgraph$2(lg, root2, cg, biasRight, usePrev, keepNodeOrder);
    for (let i2 = 0; i2 < ((_a3 = sorted.vs) === null || _a3 === void 0 ? void 0 : _a3.length) || 0; i2++) {
      const lnode = lg.getNode(sorted.vs[i2]);
      if (lnode) {
        lnode.data.order = i2;
      }
    }
    addSubgraphConstraints$2(lg, cg, sorted.vs);
  });
};
const assignOrder$1 = (g2, layering) => {
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2, i2) => {
      g2.getNode(v2).data.order = i2;
    });
  });
};
const initDataOrder = (g2, nodeOrder) => {
  const simpleNodes = g2.getAllNodes().filter((v2) => {
    var _a3;
    return !((_a3 = g2.getChildren(v2.id)) === null || _a3 === void 0 ? void 0 : _a3.length);
  });
  const ranks = simpleNodes.map((v2) => v2.data.rank);
  const maxRank2 = Math.max(...ranks);
  const layers = [];
  for (let i2 = 0; i2 < maxRank2 + 1; i2++) {
    layers[i2] = [];
  }
  nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach((n2) => {
    const node = g2.getNode(n2);
    if (!node || node.data.dummy) {
      return;
    }
    if (!isNaN(node.data.rank)) {
      node.data.fixorder = layers[node.data.rank].length;
      layers[node.data.rank].push(n2);
    }
  });
};
const dfsBothOrder = (g2) => {
  const result = {};
  let lim = 0;
  const dfs2 = (v2) => {
    const low = lim;
    g2.getChildren(v2).forEach((n2) => dfs2(n2.id));
    result[v2] = { low, lim: lim++ };
  };
  g2.getRoots().forEach((n2) => dfs2(n2.id));
  return result;
};
const findPath$1 = (g2, postorderNums, v2, w2) => {
  var _a3, _b;
  const vPath = [];
  const wPath = [];
  const low = Math.min(postorderNums[v2].low, postorderNums[w2].low);
  const lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim);
  let parent;
  let lca;
  parent = v2;
  do {
    parent = (_a3 = g2.getParent(parent)) === null || _a3 === void 0 ? void 0 : _a3.id;
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w2;
  while (parent && parent !== lca) {
    wPath.push(parent);
    parent = (_b = g2.getParent(parent)) === null || _b === void 0 ? void 0 : _b.id;
  }
  return { lca, path: vPath.concat(wPath.reverse()) };
};
const parentDummyChains$2 = (g2, dummyChains) => {
  const postorderNums = dfsBothOrder(g2);
  dummyChains.forEach((startV) => {
    var _a3, _b;
    let v2 = startV;
    let node = g2.getNode(v2);
    const originalEdge = node.data.originalEdge;
    if (!originalEdge)
      return;
    const pathData = findPath$1(g2, postorderNums, originalEdge.source, originalEdge.target);
    const path = pathData.path;
    const lca = pathData.lca;
    let pathIdx = 0;
    let pathV = path[pathIdx];
    let ascending = true;
    while (v2 !== originalEdge.target) {
      node = g2.getNode(v2);
      if (ascending) {
        while (pathV !== lca && ((_a3 = g2.getNode(pathV)) === null || _a3 === void 0 ? void 0 : _a3.data.maxRank) < node.data.rank) {
          pathIdx++;
          pathV = path[pathIdx];
        }
        if (pathV === lca) {
          ascending = false;
        }
      }
      if (!ascending) {
        while (pathIdx < path.length - 1 && ((_b = g2.getNode(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.data.minRank) <= node.data.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }
      if (g2.hasNode(pathV)) {
        g2.setParent(v2, pathV);
      }
      v2 = g2.getSuccessors(v2)[0].id;
    }
  });
};
const findType1Conflicts$1 = (g2, layering) => {
  const conflicts = {};
  const visitLayer = (prevLayer, layer) => {
    let k0 = 0;
    let scanPos = 0;
    const prevLayerLength = prevLayer.length;
    const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2, i2) => {
      var _a3;
      const w2 = findOtherInnerSegmentNode$1(g2, v2);
      const k1 = w2 ? g2.getNode(w2.id).data.order : prevLayerLength;
      if (w2 || v2 === lastNode) {
        (_a3 = layer.slice(scanPos, i2 + 1)) === null || _a3 === void 0 ? void 0 : _a3.forEach((scanNode) => {
          var _a4;
          (_a4 = g2.getPredecessors(scanNode)) === null || _a4 === void 0 ? void 0 : _a4.forEach((u2) => {
            var _a5;
            const uLabel = g2.getNode(u2.id);
            const uPos = uLabel.data.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.data.dummy && ((_a5 = g2.getNode(scanNode)) === null || _a5 === void 0 ? void 0 : _a5.data.dummy))) {
              addConflict$1(conflicts, u2.id, scanNode);
            }
          });
        });
        scanPos = i2 + 1;
        k0 = k1;
      }
    });
    return layer;
  };
  if (layering === null || layering === void 0 ? void 0 : layering.length) {
    layering.reduce(visitLayer);
  }
  return conflicts;
};
const findType2Conflicts$1 = (g2, layering) => {
  const conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var _a3, _b;
    let v2;
    for (let i2 = southPos; i2 < southEnd; i2++) {
      v2 = south[i2];
      if ((_a3 = g2.getNode(v2)) === null || _a3 === void 0 ? void 0 : _a3.data.dummy) {
        (_b = g2.getPredecessors(v2)) === null || _b === void 0 ? void 0 : _b.forEach((u2) => {
          const uNode = g2.getNode(u2.id);
          if (uNode.data.dummy && (uNode.data.order < prevNorthBorder || uNode.data.order > nextNorthBorder)) {
            addConflict$1(conflicts, u2.id, v2);
          }
        });
      }
    }
  }
  function getScannedKey(params) {
    return JSON.stringify(params.slice(1));
  }
  function scanIfNeeded(params, scanCache) {
    const cacheKey = getScannedKey(params);
    if (scanCache.get(cacheKey))
      return;
    scan(...params);
    scanCache.set(cacheKey, true);
  }
  const visitLayer = (north, south) => {
    let prevNorthPos = -1;
    let nextNorthPos;
    let southPos = 0;
    const scanned = /* @__PURE__ */ new Map();
    south === null || south === void 0 ? void 0 : south.forEach((v2, southLookahead) => {
      var _a3;
      if (((_a3 = g2.getNode(v2)) === null || _a3 === void 0 ? void 0 : _a3.data.dummy) === "border") {
        const predecessors = g2.getPredecessors(v2) || [];
        if (predecessors.length) {
          nextNorthPos = g2.getNode(predecessors[0].id).data.order;
          scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
    });
    return south;
  };
  if (layering === null || layering === void 0 ? void 0 : layering.length) {
    layering.reduce(visitLayer);
  }
  return conflicts;
};
const findOtherInnerSegmentNode$1 = (g2, v2) => {
  var _a3, _b;
  if ((_a3 = g2.getNode(v2)) === null || _a3 === void 0 ? void 0 : _a3.data.dummy) {
    return (_b = g2.getPredecessors(v2)) === null || _b === void 0 ? void 0 : _b.find((u2) => g2.getNode(u2.id).data.dummy);
  }
};
const addConflict$1 = (conflicts, v2, w2) => {
  let vv = v2;
  let ww = w2;
  if (vv > ww) {
    const tmp2 = vv;
    vv = ww;
    ww = tmp2;
  }
  let conflictsV = conflicts[vv];
  if (!conflictsV) {
    conflicts[vv] = conflictsV = {};
  }
  conflictsV[ww] = true;
};
const hasConflict$1 = (conflicts, v2, w2) => {
  let vv = v2;
  let ww = w2;
  if (vv > ww) {
    const tmp2 = v2;
    vv = ww;
    ww = tmp2;
  }
  return !!conflicts[vv];
};
const verticalAlignment$1 = (g2, layering, conflicts, neighborFn) => {
  const root2 = {};
  const align = {};
  const pos = {};
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2, order2) => {
      root2[v2] = v2;
      align[v2] = v2;
      pos[v2] = order2;
    });
  });
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    let prevIdx = -1;
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2) => {
      let ws = neighborFn(v2).map((n2) => n2.id);
      if (ws.length) {
        ws = ws.sort((a2, b2) => pos[a2] - pos[b2]);
        const mp = (ws.length - 1) / 2;
        for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
          const w2 = ws[i2];
          if (align[v2] === v2 && prevIdx < pos[w2] && !hasConflict$1(conflicts, v2, w2)) {
            align[w2] = v2;
            align[v2] = root2[v2] = root2[w2];
            prevIdx = pos[w2];
          }
        }
      }
    });
  });
  return { root: root2, align };
};
const horizontalCompaction$1 = (g2, layering, root2, align, nodesep, edgesep, reverseSep) => {
  var _a3;
  const xs = {};
  const blockG = buildBlockGraph$1(g2, layering, root2, nodesep, edgesep, reverseSep);
  const borderType = reverseSep ? "borderLeft" : "borderRight";
  const iterate = (setXsFunc, nextNodesFunc) => {
    let stack = blockG.getAllNodes();
    let elem = stack.pop();
    const visited = {};
    while (elem) {
      if (visited[elem.id]) {
        setXsFunc(elem.id);
      } else {
        visited[elem.id] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem.id));
      }
      elem = stack.pop();
    }
  };
  const pass1 = (elem) => {
    xs[elem] = (blockG.getRelatedEdges(elem, "in") || []).reduce((acc, e3) => {
      return Math.max(acc, (xs[e3.source] || 0) + e3.data.weight);
    }, 0);
  };
  const pass2 = (elem) => {
    const min2 = (blockG.getRelatedEdges(elem, "out") || []).reduce((acc, e3) => {
      return Math.min(acc, (xs[e3.target] || 0) - e3.data.weight);
    }, Number.POSITIVE_INFINITY);
    const node = g2.getNode(elem);
    if (min2 !== Number.POSITIVE_INFINITY && node.data.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min2);
    }
  };
  iterate(pass1, blockG.getPredecessors.bind(blockG));
  iterate(pass2, blockG.getSuccessors.bind(blockG));
  (_a3 = Object.values(align)) === null || _a3 === void 0 ? void 0 : _a3.forEach((v2) => {
    xs[v2] = xs[root2[v2]];
  });
  return xs;
};
const buildBlockGraph$1 = (g2, layering, root2, nodesep, edgesep, reverseSep) => {
  const blockGraph = new Graph$9();
  const sepFn = sep$1(nodesep, edgesep, reverseSep);
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    let u2;
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2) => {
      const vRoot = root2[v2];
      if (!blockGraph.hasNode(vRoot)) {
        blockGraph.addNode({
          id: vRoot,
          data: {}
        });
      }
      if (u2) {
        const uRoot = root2[u2];
        const edge = blockGraph.getRelatedEdges(uRoot, "out").find((edge2) => edge2.target === vRoot);
        if (!edge) {
          blockGraph.addEdge({
            id: `e${Math.random()}`,
            source: uRoot,
            target: vRoot,
            data: {
              weight: Math.max(sepFn(g2, v2, u2), 0)
            }
          });
        } else {
          blockGraph.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: Math.max(sepFn(g2, v2, u2), edge.data.weight || 0) }));
        }
      }
      u2 = v2;
    });
  });
  return blockGraph;
};
const findSmallestWidthAlignment$1 = (g2, xss) => {
  return minBy(Object.values(xss), (xs) => {
    var _a3;
    let max2 = Number.NEGATIVE_INFINITY;
    let min2 = Number.POSITIVE_INFINITY;
    (_a3 = Object.keys(xs)) === null || _a3 === void 0 ? void 0 : _a3.forEach((v2) => {
      const x2 = xs[v2];
      const halfWidth = width$1(g2, v2) / 2;
      max2 = Math.max(x2 + halfWidth, max2);
      min2 = Math.min(x2 - halfWidth, min2);
    });
    return max2 - min2;
  });
};
function alignCoordinates$1(xss, alignTo) {
  const alignToVals = Object.values(alignTo);
  const alignToMin = Math.min(...alignToVals);
  const alignToMax = Math.max(...alignToVals);
  ["u", "d"].forEach((vert) => {
    ["l", "r"].forEach((horiz) => {
      const alignment = vert + horiz;
      const xs = xss[alignment];
      let delta;
      if (xs === alignTo)
        return;
      const xsVals = Object.values(xs);
      delta = horiz === "l" ? alignToMin - Math.min(...xsVals) : alignToMax - Math.max(...xsVals);
      if (delta) {
        xss[alignment] = {};
        Object.keys(xs).forEach((key) => {
          xss[alignment][key] = xs[key] + delta;
        });
      }
    });
  });
}
const balance$1 = (xss, align) => {
  const result = {};
  Object.keys(xss.ul).forEach((key) => {
    if (align) {
      result[key] = xss[align.toLowerCase()][key];
    } else {
      const values2 = Object.values(xss).map((x2) => x2[key]);
      result[key] = (values2[0] + values2[1]) / 2;
    }
  });
  return result;
};
const sep$1 = (nodeSep, edgeSep, reverseSep) => {
  return (g2, v2, w2) => {
    const vLabel = g2.getNode(v2);
    const wLabel = g2.getNode(w2);
    let sum = 0;
    let delta = 0;
    sum += vLabel.data.width / 2;
    if (vLabel.data.hasOwnProperty("labelpos")) {
      switch ((vLabel.data.labelpos || "").toLowerCase()) {
        case "l":
          delta = -vLabel.data.width / 2;
          break;
        case "r":
          delta = vLabel.data.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.data.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.data.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.data.width / 2;
    if (wLabel.data.labelpos) {
      switch ((wLabel.data.labelpos || "").toLowerCase()) {
        case "l":
          delta = wLabel.data.width / 2;
          break;
        case "r":
          delta = -wLabel.data.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
};
const width$1 = (g2, v2) => g2.getNode(v2).data.width || 0;
const positionY$1 = (g2, options) => {
  const { ranksep = 0 } = options || {};
  const layering = buildLayerMatrix$1(g2);
  let prevY = 0;
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    const heights = layer.map((v2) => g2.getNode(v2).data.height);
    const maxHeight = Math.max(...heights, 0);
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2) => {
      g2.getNode(v2).data.y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + ranksep;
  });
};
const positionX$2 = (g2, options) => {
  const { align: graphAlign, nodesep = 0, edgesep = 0 } = options || {};
  const layering = buildLayerMatrix$1(g2);
  const conflicts = Object.assign(findType1Conflicts$1(g2, layering), findType2Conflicts$1(g2, layering));
  const xss = {};
  let adjustedLayering = [];
  ["u", "d"].forEach((vert) => {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
    ["l", "r"].forEach((horiz) => {
      if (horiz === "r") {
        adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
      }
      const neighborFn = (vert === "u" ? g2.getPredecessors : g2.getSuccessors).bind(g2);
      const align = verticalAlignment$1(g2, adjustedLayering, conflicts, neighborFn);
      const xs = horizontalCompaction$1(g2, adjustedLayering, align.root, align.align, nodesep, edgesep, horiz === "r");
      if (horiz === "r") {
        Object.keys(xs).forEach((xsKey) => xs[xsKey] = -xs[xsKey]);
      }
      xss[vert + horiz] = xs;
    });
  });
  const smallestWidth = findSmallestWidthAlignment$1(g2, xss);
  smallestWidth && alignCoordinates$1(xss, smallestWidth);
  return balance$1(xss, graphAlign);
};
const position$2 = (g2, options) => {
  var _a3;
  const ng = asNonCompoundGraph$1(g2);
  positionY$1(ng, options);
  const xs = positionX$2(ng, options);
  (_a3 = Object.keys(xs)) === null || _a3 === void 0 ? void 0 : _a3.forEach((key) => {
    ng.getNode(key).data.x = xs[key];
  });
};
const longestPath$2 = (g2) => {
  const visited = {};
  const dfs2 = (v2) => {
    var _a3;
    const label = g2.getNode(v2);
    if (!label)
      return 0;
    if (visited[v2]) {
      return label.data.rank;
    }
    visited[v2] = true;
    let rank2;
    (_a3 = g2.getRelatedEdges(v2, "out")) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => {
      const wRank = dfs2(e3.target);
      const minLen = e3.data.minlen;
      const r2 = wRank - minLen;
      if (r2) {
        if (rank2 === void 0 || r2 < rank2) {
          rank2 = r2;
        }
      }
    });
    if (!rank2) {
      rank2 = 0;
    }
    label.data.rank = rank2;
    return rank2;
  };
  g2.getAllNodes().filter((n2) => g2.getRelatedEdges(n2.id, "in").length === 0).forEach((source) => dfs2(source.id));
};
const longestPathWithLayer = (g2) => {
  const visited = {};
  let minRank;
  const dfs2 = (v2) => {
    var _a3;
    const label = g2.getNode(v2);
    if (!label)
      return 0;
    if (visited[v2]) {
      return label.data.rank;
    }
    visited[v2] = true;
    let rank2;
    (_a3 = g2.getRelatedEdges(v2, "out")) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => {
      const wRank = dfs2(e3.target);
      const minLen = e3.data.minlen;
      const r2 = wRank - minLen;
      if (r2) {
        if (rank2 === void 0 || r2 < rank2) {
          rank2 = r2;
        }
      }
    });
    if (!rank2) {
      rank2 = 0;
    }
    if (minRank === void 0 || rank2 < minRank) {
      minRank = rank2;
    }
    label.data.rank = rank2;
    return rank2;
  };
  g2.getAllNodes().filter((n2) => g2.getRelatedEdges(n2.id, "in").length === 0).forEach((source) => {
    if (source)
      dfs2(source.id);
  });
  if (minRank === void 0) {
    minRank = 0;
  }
  const forwardVisited = {};
  const dfsForward = (v2, nextRank) => {
    var _a3;
    const label = g2.getNode(v2);
    const currRank = !isNaN(label.data.layer) ? label.data.layer : nextRank;
    if (label.data.rank === void 0 || label.data.rank < currRank) {
      label.data.rank = currRank;
    }
    if (forwardVisited[v2])
      return;
    forwardVisited[v2] = true;
    (_a3 = g2.getRelatedEdges(v2, "out")) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => {
      dfsForward(e3.target, currRank + e3.data.minlen);
    });
  };
  g2.getAllNodes().forEach((n2) => {
    const label = n2.data;
    if (!label)
      return;
    if (!isNaN(label.layer)) {
      dfsForward(n2.id, label.layer);
    } else {
      label.rank -= minRank;
    }
  });
};
const slack$3 = (g2, e3) => {
  return g2.getNode(e3.target).data.rank - g2.getNode(e3.source).data.rank - e3.data.minlen;
};
const feasibleTree$3 = (g2) => {
  const t3 = new Graph$9({
    tree: []
  });
  const start = g2.getAllNodes()[0];
  const size = g2.getAllNodes().length;
  t3.addNode(start);
  let edge;
  let delta;
  while (tightTree$1(t3, g2) < size) {
    edge = findMinSlackEdge$1(t3, g2);
    delta = t3.hasNode(edge.source) ? slack$3(g2, edge) : -slack$3(g2, edge);
    shiftRanks$1(t3, g2, delta);
  }
  return t3;
};
const tightTree$1 = (t3, g2) => {
  const dfs2 = (v2) => {
    g2.getRelatedEdges(v2, "both").forEach((e3) => {
      const edgeV = e3.source;
      const w2 = v2 === edgeV ? e3.target : edgeV;
      if (!t3.hasNode(w2) && !slack$3(g2, e3)) {
        t3.addNode({
          id: w2,
          data: {}
        });
        t3.addEdge({
          id: e3.id,
          source: v2,
          target: w2,
          data: {}
        });
        dfs2(w2);
      }
    });
  };
  t3.getAllNodes().forEach((n2) => dfs2(n2.id));
  return t3.getAllNodes().length;
};
const feasibleTreeWithLayer = (g2) => {
  const t3 = new Graph$9({ tree: [] });
  const start = g2.getAllNodes()[0];
  const size = g2.getAllNodes().length;
  t3.addNode(start);
  let edge;
  let delta;
  while (tightTreeWithLayer(t3, g2) < size) {
    edge = findMinSlackEdge$1(t3, g2);
    delta = t3.hasNode(edge.source) ? slack$3(g2, edge) : -slack$3(g2, edge);
    shiftRanks$1(t3, g2, delta);
  }
  return t3;
};
const tightTreeWithLayer = (t3, g2) => {
  const dfs2 = (v2) => {
    var _a3;
    (_a3 = g2.getRelatedEdges(v2, "both")) === null || _a3 === void 0 ? void 0 : _a3.forEach((e3) => {
      const edgeV = e3.source;
      const w2 = v2 === edgeV ? e3.target : edgeV;
      if (!t3.hasNode(w2) && (g2.getNode(w2).data.layer !== void 0 || !slack$3(g2, e3))) {
        t3.addNode({
          id: w2,
          data: {}
        });
        t3.addEdge({
          id: e3.id,
          source: v2,
          target: w2,
          data: {}
        });
        dfs2(w2);
      }
    });
  };
  t3.getAllNodes().forEach((n2) => dfs2(n2.id));
  return t3.getAllNodes().length;
};
const findMinSlackEdge$1 = (t3, g2) => {
  return minBy(g2.getAllEdges(), (e3) => {
    if (t3.hasNode(e3.source) !== t3.hasNode(e3.target)) {
      return slack$3(g2, e3);
    }
    return Infinity;
  });
};
const shiftRanks$1 = (t3, g2, delta) => {
  t3.getAllNodes().forEach((tn) => {
    const v2 = g2.getNode(tn.id);
    if (!v2.data.rank)
      v2.data.rank = 0;
    v2.data.rank += delta;
  });
};
const networkSimplex$2 = (og) => {
  const g2 = simplify$2(og);
  longestPath$2(g2);
  const t3 = feasibleTree$3(g2);
  initLowLimValues$1(t3);
  initCutValues$1(t3, g2);
  let e3;
  let f2;
  while (e3 = leaveEdge$1(t3)) {
    f2 = enterEdge$1(t3, g2, e3);
    exchangeEdges$1(t3, g2, e3, f2);
  }
};
const initCutValues$1 = (t3, g2) => {
  let vs = dfs$2(t3, t3.getAllNodes(), "post");
  vs = vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
  vs.forEach((v2) => {
    assignCutValue$1(t3, g2, v2);
  });
};
const assignCutValue$1 = (t3, g2, child) => {
  const childLab = t3.getNode(child);
  const parent = childLab.data.parent;
  const edge = t3.getRelatedEdges(child, "both").find((e3) => e3.target === parent || e3.source === parent);
  edge.data.cutvalue = calcCutValue$1(t3, g2, child);
};
const calcCutValue$1 = (t3, g2, child) => {
  const childLab = t3.getNode(child);
  const parent = childLab.data.parent;
  let childIsTail = true;
  let graphEdge = g2.getRelatedEdges(child, "out").find((e3) => e3.target === parent);
  let cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g2.getRelatedEdges(parent, "out").find((e3) => e3.target === child);
  }
  cutValue = graphEdge.data.weight;
  g2.getRelatedEdges(child, "both").forEach((e3) => {
    const isOutEdge = e3.source === child;
    const other = isOutEdge ? e3.target : e3.source;
    if (other !== parent) {
      const pointsToHead = isOutEdge === childIsTail;
      const otherWeight = e3.data.weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge$1(t3, child, other)) {
        const otherCutValue = t3.getRelatedEdges(child, "both").find((e4) => e4.source === other || e4.target === other).data.cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
};
const initLowLimValues$1 = (tree, root2 = tree.getAllNodes()[0].id) => {
  dfsAssignLowLim$1(tree, {}, 1, root2);
};
const dfsAssignLowLim$1 = (tree, visited, nextLim, v2, parent) => {
  var _a3;
  const low = nextLim;
  let useNextLim = nextLim;
  const label = tree.getNode(v2);
  visited[v2] = true;
  (_a3 = tree.getNeighbors(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach((w2) => {
    if (!visited[w2.id]) {
      useNextLim = dfsAssignLowLim$1(tree, visited, useNextLim, w2.id, v2);
    }
  });
  label.data.low = low;
  label.data.lim = useNextLim++;
  if (parent) {
    label.data.parent = parent;
  } else {
    delete label.data.parent;
  }
  return useNextLim;
};
const leaveEdge$1 = (tree) => {
  return tree.getAllEdges().find((e3) => {
    return e3.data.cutvalue < 0;
  });
};
const enterEdge$1 = (t3, g2, edge) => {
  let v2 = edge.source;
  let w2 = edge.target;
  if (!g2.getRelatedEdges(v2, "out").find((e3) => e3.target === w2)) {
    v2 = edge.target;
    w2 = edge.source;
  }
  const vLabel = t3.getNode(v2);
  const wLabel = t3.getNode(w2);
  let tailLabel = vLabel;
  let flip = false;
  if (vLabel.data.lim > wLabel.data.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  const candidates = g2.getAllEdges().filter((edge2) => {
    return flip === isDescendant$1(t3.getNode(edge2.source), tailLabel) && flip !== isDescendant$1(t3.getNode(edge2.target), tailLabel);
  });
  return minBy(candidates, (edge2) => {
    return slack$3(g2, edge2);
  });
};
const exchangeEdges$1 = (t3, g2, e3, f2) => {
  const existed = t3.getRelatedEdges(e3.source, "both").find((edge) => edge.source === e3.target || edge.target === e3.target);
  if (existed) {
    t3.removeEdge(existed.id);
  }
  t3.addEdge({
    id: `e${Math.random()}`,
    source: f2.source,
    target: f2.target,
    data: {}
  });
  initLowLimValues$1(t3);
  initCutValues$1(t3, g2);
  updateRanks$1(t3, g2);
};
const updateRanks$1 = (t3, g2) => {
  const root2 = t3.getAllNodes().find((v2) => {
    return !v2.data.parent;
  });
  let vs = dfs$2(t3, root2, "pre");
  vs = vs.slice(1);
  vs.forEach((v2) => {
    const parent = t3.getNode(v2).data.parent;
    let edge = g2.getRelatedEdges(v2, "out").find((e3) => e3.target === parent);
    let flipped = false;
    if (!edge && g2.hasNode(parent)) {
      edge = g2.getRelatedEdges(parent, "out").find((e3) => e3.target === v2);
      flipped = true;
    }
    g2.getNode(v2).data.rank = (g2.hasNode(parent) && g2.getNode(parent).data.rank || 0) + (flipped ? edge === null || edge === void 0 ? void 0 : edge.data.minlen : -(edge === null || edge === void 0 ? void 0 : edge.data.minlen));
  });
};
const isTreeEdge$1 = (tree, u2, v2) => {
  return tree.getRelatedEdges(u2, "both").find((e3) => e3.source === v2 || e3.target === v2);
};
const isDescendant$1 = (vLabel, rootLabel) => {
  return rootLabel.data.low <= vLabel.data.lim && vLabel.data.lim <= rootLabel.data.lim;
};
const rank$2 = (g2, ranker) => {
  switch (ranker) {
    case "network-simplex":
      networkSimplexRanker$1(g2);
      break;
    case "tight-tree":
      tightTreeRanker$1(g2);
      break;
    case "longest-path":
      longestPathRanker$1(g2);
      break;
    default:
      tightTreeRanker$1(g2);
  }
};
const longestPathRanker$1 = longestPath$2;
const tightTreeRanker$1 = (g2) => {
  longestPathWithLayer(g2);
  feasibleTreeWithLayer(g2);
};
const networkSimplexRanker$1 = (g2) => {
  networkSimplex$2(g2);
};
const layout$1 = (g2, options) => {
  const { edgeLabelSpace, keepNodeOrder, prevGraph, rankdir, ranksep } = options;
  if (!keepNodeOrder && prevGraph) {
    inheritOrder(g2, prevGraph);
  }
  const layoutGraph = buildLayoutGraph$1(g2);
  if (!!edgeLabelSpace) {
    options.ranksep = makeSpaceForEdgeLabels$1(layoutGraph, {
      rankdir,
      ranksep
    });
  }
  let dimension;
  try {
    dimension = runLayout$1(layoutGraph, options);
  } catch (e3) {
    if (e3.message === "Not possible to find intersection inside of the rectangle") {
      console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e3);
      return;
    }
    throw e3;
  }
  updateInputGraph$1(g2, layoutGraph);
  return dimension;
};
const runLayout$1 = (g2, options) => {
  const { ranker, rankdir = "tb", nodeOrder, keepNodeOrder, align, nodesep = 50, edgesep = 20, ranksep = 50 } = options;
  removeSelfEdges$1(g2);
  run$5(g2);
  const { nestingRoot, nodeRankFactor } = run$4(g2);
  rank$2(asNonCompoundGraph$1(g2), ranker);
  injectEdgeLabelProxies$1(g2);
  removeEmptyRanks$2(g2, nodeRankFactor);
  cleanup$1(g2, nestingRoot);
  normalizeRanks$2(g2);
  assignRankMinMax$1(g2);
  removeEdgeLabelProxies$1(g2);
  const dummyChains = [];
  run$3(g2, dummyChains);
  parentDummyChains$2(g2, dummyChains);
  addBorderSegments$2(g2);
  if (keepNodeOrder) {
    initDataOrder(g2, nodeOrder);
  }
  order$2(g2, keepNodeOrder);
  insertSelfEdges$1(g2);
  adjust$1(g2, rankdir);
  position$2(g2, {
    align,
    nodesep,
    edgesep,
    ranksep
  });
  positionSelfEdges$1(g2);
  removeBorderNodes$1(g2);
  undo$3(g2, dummyChains);
  fixupEdgeLabelCoords$1(g2);
  undo$4(g2, rankdir);
  const { width: width2, height } = translateGraph$1(g2);
  assignNodeIntersects$1(g2);
  reversePointsForReversedEdges$1(g2);
  undo$5(g2);
  return { width: width2, height };
};
const inheritOrder = (currG, prevG) => {
  currG.getAllNodes().forEach((n2) => {
    const node = currG.getNode(n2.id);
    if (prevG.hasNode(n2.id)) {
      const prevNode = prevG.getNode(n2.id);
      node.data.fixorder = prevNode.data._order;
      delete prevNode.data._order;
    } else {
      delete node.data.fixorder;
    }
  });
};
const updateInputGraph$1 = (inputGraph, layoutGraph) => {
  inputGraph.getAllNodes().forEach((v2) => {
    var _a3;
    const inputLabel = inputGraph.getNode(v2.id);
    if (inputLabel) {
      const layoutLabel = layoutGraph.getNode(v2.id);
      inputLabel.data.x = layoutLabel.data.x;
      inputLabel.data.y = layoutLabel.data.y;
      inputLabel.data._order = layoutLabel.data.order;
      inputLabel.data._rank = layoutLabel.data.rank;
      if ((_a3 = layoutGraph.getChildren(v2.id)) === null || _a3 === void 0 ? void 0 : _a3.length) {
        inputLabel.data.width = layoutLabel.data.width;
        inputLabel.data.height = layoutLabel.data.height;
      }
    }
  });
  inputGraph.getAllEdges().forEach((e3) => {
    const inputLabel = inputGraph.getEdge(e3.id);
    const layoutLabel = layoutGraph.getEdge(e3.id);
    inputLabel.data.points = layoutLabel ? layoutLabel.data.points : [];
    if (layoutLabel && layoutLabel.data.hasOwnProperty("x")) {
      inputLabel.data.x = layoutLabel.data.x;
      inputLabel.data.y = layoutLabel.data.y;
    }
  });
};
const nodeNumAttrs$1 = ["width", "height", "layer", "fixorder"];
const nodeDefaults$1 = { width: 0, height: 0 };
const edgeNumAttrs$1 = ["minlen", "weight", "width", "height", "labeloffset"];
const edgeDefaults$1 = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
const edgeAttrs$1 = ["labelpos"];
const buildLayoutGraph$1 = (inputGraph) => {
  const g2 = new Graph$9({ tree: [] });
  inputGraph.getAllNodes().forEach((v2) => {
    const node = canonicalize$1(inputGraph.getNode(v2.id).data);
    const defaultNode = Object.assign(Object.assign({}, nodeDefaults$1), node);
    const defaultAttrs = selectNumberAttrs$1(defaultNode, nodeNumAttrs$1);
    if (!g2.hasNode(v2.id)) {
      g2.addNode({
        id: v2.id,
        data: Object.assign({}, defaultAttrs)
      });
    }
    const parent = inputGraph.hasTreeStructure("combo") ? inputGraph.getParent(v2.id, "combo") : inputGraph.getParent(v2.id);
    if (!isNil(parent)) {
      if (!g2.hasNode(parent.id)) {
        g2.addNode(Object.assign({}, parent));
      }
      g2.setParent(v2.id, parent.id);
    }
  });
  inputGraph.getAllEdges().forEach((e3) => {
    const edge = canonicalize$1(inputGraph.getEdge(e3.id).data);
    const pickedProperties = {};
    edgeAttrs$1 === null || edgeAttrs$1 === void 0 ? void 0 : edgeAttrs$1.forEach((key) => {
      if (edge[key] !== void 0)
        pickedProperties[key] = edge[key];
    });
    g2.addEdge({
      id: e3.id,
      source: e3.source,
      target: e3.target,
      data: Object.assign({}, edgeDefaults$1, selectNumberAttrs$1(edge, edgeNumAttrs$1), pickedProperties)
    });
  });
  return g2;
};
const makeSpaceForEdgeLabels$1 = (g2, options) => {
  const { ranksep = 0, rankdir } = options;
  g2.getAllNodes().forEach((node) => {
    if (!isNaN(node.data.layer)) {
      if (!node.data.layer)
        node.data.layer = 0;
    }
  });
  g2.getAllEdges().forEach((edge) => {
    var _a3;
    edge.data.minlen *= 2;
    if (((_a3 = edge.data.labelpos) === null || _a3 === void 0 ? void 0 : _a3.toLowerCase()) !== "c") {
      if (rankdir === "TB" || rankdir === "BT") {
        edge.data.width += edge.data.labeloffset;
      } else {
        edge.data.height += edge.data.labeloffset;
      }
    }
  });
  return ranksep / 2;
};
const injectEdgeLabelProxies$1 = (g2) => {
  g2.getAllEdges().forEach((e3) => {
    if (e3.data.width && e3.data.height) {
      const v2 = g2.getNode(e3.source);
      const w2 = g2.getNode(e3.target);
      const label = {
        e: e3,
        rank: (w2.data.rank - v2.data.rank) / 2 + v2.data.rank
      };
      addDummyNode$1(g2, "edge-proxy", label, "_ep");
    }
  });
};
const assignRankMinMax$1 = (g2) => {
  let maxRank2 = 0;
  g2.getAllNodes().forEach((node) => {
    var _a3, _b;
    if (node.data.borderTop) {
      node.data.minRank = (_a3 = g2.getNode(node.data.borderTop)) === null || _a3 === void 0 ? void 0 : _a3.data.rank;
      node.data.maxRank = (_b = g2.getNode(node.data.borderBottom)) === null || _b === void 0 ? void 0 : _b.data.rank;
      maxRank2 = Math.max(maxRank2, node.data.maxRank || -Infinity);
    }
  });
  return maxRank2;
};
const removeEdgeLabelProxies$1 = (g2) => {
  g2.getAllNodes().forEach((node) => {
    if (node.data.dummy === "edge-proxy") {
      g2.getEdge(node.data.e.id).data.labelRank = node.data.rank;
      g2.removeNode(node.id);
    }
  });
};
const translateGraph$1 = (g2, options) => {
  let minX;
  let maxX = 0;
  let minY;
  let maxY = 0;
  const { marginx: marginX = 0, marginy: marginY = 0 } = {};
  const getExtremes = (attrs) => {
    if (!attrs.data)
      return;
    const x2 = attrs.data.x;
    const y2 = attrs.data.y;
    const w2 = attrs.data.width;
    const h2 = attrs.data.height;
    if (!isNaN(x2) && !isNaN(w2)) {
      if (minX === void 0) {
        minX = x2 - w2 / 2;
      }
      minX = Math.min(minX, x2 - w2 / 2);
      maxX = Math.max(maxX, x2 + w2 / 2);
    }
    if (!isNaN(y2) && !isNaN(h2)) {
      if (minY === void 0) {
        minY = y2 - h2 / 2;
      }
      minY = Math.min(minY, y2 - h2 / 2);
      maxY = Math.max(maxY, y2 + h2 / 2);
    }
  };
  g2.getAllNodes().forEach((v2) => {
    getExtremes(v2);
  });
  g2.getAllEdges().forEach((e3) => {
    if (e3 === null || e3 === void 0 ? void 0 : e3.data.hasOwnProperty("x")) {
      getExtremes(e3);
    }
  });
  minX -= marginX;
  minY -= marginY;
  g2.getAllNodes().forEach((node) => {
    node.data.x -= minX;
    node.data.y -= minY;
  });
  g2.getAllEdges().forEach((edge) => {
    var _a3;
    (_a3 = edge.data.points) === null || _a3 === void 0 ? void 0 : _a3.forEach((p2) => {
      p2.x -= minX;
      p2.y -= minY;
    });
    if (edge.data.hasOwnProperty("x")) {
      edge.data.x -= minX;
    }
    if (edge.data.hasOwnProperty("y")) {
      edge.data.y -= minY;
    }
  });
  return {
    width: maxX - minX + marginX,
    height: maxY - minY + marginY
  };
};
const assignNodeIntersects$1 = (g2) => {
  g2.getAllEdges().forEach((e3) => {
    const nodeV = g2.getNode(e3.source);
    const nodeW = g2.getNode(e3.target);
    let p1;
    let p2;
    if (!e3.data.points) {
      e3.data.points = [];
      p1 = { x: nodeW.data.x, y: nodeW.data.y };
      p2 = { x: nodeV.data.x, y: nodeV.data.y };
    } else {
      p1 = e3.data.points[0];
      p2 = e3.data.points[e3.data.points.length - 1];
    }
    e3.data.points.unshift(intersectRect$1(nodeV.data, p1));
    e3.data.points.push(intersectRect$1(nodeW.data, p2));
  });
};
const fixupEdgeLabelCoords$1 = (g2) => {
  g2.getAllEdges().forEach((edge) => {
    if (edge.data.hasOwnProperty("x")) {
      if (edge.data.labelpos === "l" || edge.data.labelpos === "r") {
        edge.data.width -= edge.data.labeloffset;
      }
      switch (edge.data.labelpos) {
        case "l":
          edge.data.x -= edge.data.width / 2 + edge.data.labeloffset;
          break;
        case "r":
          edge.data.x += edge.data.width / 2 + edge.data.labeloffset;
          break;
      }
    }
  });
};
const reversePointsForReversedEdges$1 = (g2) => {
  g2.getAllEdges().forEach((edge) => {
    var _a3;
    if (edge.data.reversed) {
      (_a3 = edge.data.points) === null || _a3 === void 0 ? void 0 : _a3.reverse();
    }
  });
};
const removeBorderNodes$1 = (g2) => {
  g2.getAllNodes().forEach((v2) => {
    var _a3, _b, _c;
    if ((_a3 = g2.getChildren(v2.id)) === null || _a3 === void 0 ? void 0 : _a3.length) {
      const node = g2.getNode(v2.id);
      const t3 = g2.getNode(node.data.borderTop);
      const b2 = g2.getNode(node.data.borderBottom);
      const l2 = g2.getNode(node.data.borderLeft[((_b = node.data.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
      const r2 = g2.getNode(node.data.borderRight[((_c = node.data.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
      node.data.width = Math.abs((r2 === null || r2 === void 0 ? void 0 : r2.data.x) - (l2 === null || l2 === void 0 ? void 0 : l2.data.x)) || 10;
      node.data.height = Math.abs((b2 === null || b2 === void 0 ? void 0 : b2.data.y) - (t3 === null || t3 === void 0 ? void 0 : t3.data.y)) || 10;
      node.data.x = ((l2 === null || l2 === void 0 ? void 0 : l2.data.x) || 0) + node.data.width / 2;
      node.data.y = ((t3 === null || t3 === void 0 ? void 0 : t3.data.y) || 0) + node.data.height / 2;
    }
  });
  g2.getAllNodes().forEach((n2) => {
    if (n2.data.dummy === "border") {
      g2.removeNode(n2.id);
    }
  });
};
const removeSelfEdges$1 = (g2) => {
  g2.getAllEdges().forEach((e3) => {
    if (e3.source === e3.target) {
      const node = g2.getNode(e3.source);
      if (!node.data.selfEdges) {
        node.data.selfEdges = [];
      }
      node.data.selfEdges.push(e3);
      g2.removeEdge(e3.id);
    }
  });
};
const insertSelfEdges$1 = (g2) => {
  const layers = buildLayerMatrix$1(g2);
  layers === null || layers === void 0 ? void 0 : layers.forEach((layer) => {
    let orderShift = 0;
    layer === null || layer === void 0 ? void 0 : layer.forEach((v2, i2) => {
      var _a3;
      const node = g2.getNode(v2);
      node.data.order = i2 + orderShift;
      (_a3 = node.data.selfEdges) === null || _a3 === void 0 ? void 0 : _a3.forEach((selfEdge) => {
        addDummyNode$1(g2, "selfedge", {
          width: selfEdge.data.width,
          height: selfEdge.data.height,
          rank: node.data.rank,
          order: i2 + ++orderShift,
          e: selfEdge
        }, "_se");
      });
      delete node.data.selfEdges;
    });
  });
};
const positionSelfEdges$1 = (g2) => {
  g2.getAllNodes().forEach((v2) => {
    const node = g2.getNode(v2.id);
    if (node.data.dummy === "selfedge") {
      const selfNode = g2.getNode(node.data.e.source);
      const x2 = selfNode.data.x + selfNode.data.width / 2;
      const y2 = selfNode.data.y;
      const dx = node.data.x - x2;
      const dy = selfNode.data.height / 2;
      if (g2.hasEdge(node.data.e.id)) {
        g2.updateEdgeData(node.data.e.id, node.data.e.data);
      } else {
        g2.addEdge({
          id: node.data.e.id,
          source: node.data.e.source,
          target: node.data.e.target,
          data: node.data.e.data
        });
      }
      g2.removeNode(v2.id);
      node.data.e.data.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { y: y2, x: x2 + dx },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ];
      node.data.e.data.x = node.data.x;
      node.data.e.data.y = node.data.y;
    }
  });
};
const selectNumberAttrs$1 = (obj, attrs) => {
  const pickedProperties = {};
  attrs === null || attrs === void 0 ? void 0 : attrs.forEach((key) => {
    if (obj[key] === void 0)
      return;
    pickedProperties[key] = +obj[key];
  });
  return pickedProperties;
};
const canonicalize$1 = (attrs = {}) => {
  const newAttrs = {};
  Object.keys(attrs).forEach((k) => {
    newAttrs[k.toLowerCase()] = attrs[k];
  });
  return newAttrs;
};
const isArray = Array.isArray;
const floydWarshall = (adjMatrix) => {
  const dist2 = [];
  const size = adjMatrix.length;
  for (let i2 = 0; i2 < size; i2 += 1) {
    dist2[i2] = [];
    for (let j = 0; j < size; j += 1) {
      if (i2 === j) {
        dist2[i2][j] = 0;
      } else if (adjMatrix[i2][j] === 0 || !adjMatrix[i2][j]) {
        dist2[i2][j] = Infinity;
      } else {
        dist2[i2][j] = adjMatrix[i2][j];
      }
    }
  }
  for (let k = 0; k < size; k += 1) {
    for (let i2 = 0; i2 < size; i2 += 1) {
      for (let j = 0; j < size; j += 1) {
        if (dist2[i2][j] > dist2[i2][k] + dist2[k][j]) {
          dist2[i2][j] = dist2[i2][k] + dist2[k][j];
        }
      }
    }
  }
  return dist2;
};
const getAdjMatrix = (data2, directed) => {
  const { nodes, edges } = data2;
  const matrix3 = [];
  const nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach((node, i2) => {
      nodeMap[node.id] = i2;
      const row2 = [];
      matrix3.push(row2);
    });
  }
  edges === null || edges === void 0 ? void 0 : edges.forEach((e3) => {
    const { source, target } = e3;
    const sIndex = nodeMap[source];
    const tIndex = nodeMap[target];
    if (sIndex === void 0 || tIndex === void 0)
      return;
    matrix3[sIndex][tIndex] = 1;
    {
      matrix3[tIndex][sIndex] = 1;
    }
  });
  return matrix3;
};
const scaleMatrix = (matrix3, ratio) => {
  const result = [];
  matrix3.forEach((row2) => {
    const newRow = [];
    row2.forEach((v2) => {
      newRow.push(v2 * ratio);
    });
    result.push(newRow);
  });
  return result;
};
const getLayoutBBox = (nodes) => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  nodes.forEach((node) => {
    let size = node.data.size;
    if (isArray(size)) {
      if (size.length === 1)
        size = [size[0], size[0]];
    } else if (isNumber(size)) {
      size = [size, size];
    } else if (size === void 0 || isNaN(size)) {
      size = [30, 30];
    }
    const halfSize = [size[0] / 2, size[1] / 2];
    const left = node.data.x - halfSize[0];
    const right = node.data.x + halfSize[0];
    const top = node.data.y - halfSize[1];
    const bottom = node.data.y + halfSize[1];
    if (minX > left)
      minX = left;
    if (minY > top)
      minY = top;
    if (maxX < right)
      maxX = right;
    if (maxY < bottom)
      maxY = bottom;
  });
  return { minX, minY, maxX, maxY };
};
const getEuclideanDistance = (p1, p2) => Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
const graphTreeDfs = (graph2, nodes, fn, mode = "TB", treeKey, stopFns = {}) => {
  if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
    return;
  const { stopBranchFn, stopAllFn } = stopFns;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (!graph2.hasNode(node.id))
      continue;
    if (stopBranchFn === null || stopBranchFn === void 0 ? void 0 : stopBranchFn(node))
      continue;
    if (stopAllFn === null || stopAllFn === void 0 ? void 0 : stopAllFn(node))
      return;
    if (mode === "TB")
      fn(node);
    graphTreeDfs(graph2, graph2.getChildren(node.id, treeKey), fn, mode, treeKey, stopFns);
    if (mode !== "TB")
      fn(node);
  }
};
const clone = (target) => {
  if (target === null) {
    return target;
  }
  if (target instanceof Date) {
    return new Date(target.getTime());
  }
  if (target instanceof Array) {
    const cp = [];
    target.forEach((v2) => {
      cp.push(v2);
    });
    return cp.map((n2) => clone(n2));
  }
  if (typeof target === "object") {
    const cp = {};
    Object.keys(target).forEach((k) => {
      cp[k] = clone(target[k]);
    });
    return cp;
  }
  return target;
};
const cloneFormatData = (target, initRange) => {
  const cloned = clone(target);
  cloned.data = cloned.data || {};
  if (initRange) {
    if (!isNumber(cloned.data.x))
      cloned.data.x = Math.random() * initRange[0];
    if (!isNumber(cloned.data.y))
      cloned.data.y = Math.random() * initRange[1];
  }
  return cloned;
};
function parseSize(size) {
  if (!size)
    return [0, 0, 0];
  if (isNumber(size))
    return [size, size, size];
  else if (size.length === 0)
    return [0, 0, 0];
  const [x2, y2 = x2, z2 = x2] = size;
  return [x2, y2, z2];
}
function formatNumberFn(defaultValue, value) {
  let resultFunc;
  if (isFunction$1(value)) {
    resultFunc = value;
  } else if (isNumber(value)) {
    resultFunc = () => value;
  } else {
    resultFunc = () => defaultValue;
  }
  return resultFunc;
}
function formatSizeFn(defaultValue, value, resultIsNumber = true) {
  if (!value && value !== 0) {
    return (d3) => {
      const { size } = d3.data || {};
      if (size) {
        if (Array.isArray(size))
          return resultIsNumber ? Math.max(...size) || defaultValue : size;
        if (isObject$2(size) && size.width && size.height) {
          return resultIsNumber ? Math.max(size.width, size.height) || defaultValue : [size.width, size.height];
        }
        return size;
      }
      return defaultValue;
    };
  }
  if (isFunction$1(value))
    return value;
  if (isNumber(value))
    return () => value;
  if (Array.isArray(value)) {
    return () => {
      if (resultIsNumber)
        return Math.max(...value) || defaultValue;
      return value;
    };
  }
  if (isObject$2(value) && value.width && value.height) {
    return () => {
      if (resultIsNumber)
        return Math.max(value.width, value.height) || defaultValue;
      return [value.width, value.height];
    };
  }
  return () => defaultValue;
}
const formatNodeSizeToNumber = (nodeSize, nodeSpacing, defaultNodeSize = 10) => {
  let nodeSizeFunc;
  const nodeSpacingFunc = typeof nodeSpacing === "function" ? nodeSpacing : () => nodeSpacing || 0;
  if (!nodeSize) {
    nodeSizeFunc = (d3) => {
      var _a3, _b, _c;
      if ((_a3 = d3.data) === null || _a3 === void 0 ? void 0 : _a3.bboxSize)
        return (_b = d3.data) === null || _b === void 0 ? void 0 : _b.bboxSize;
      if ((_c = d3.data) === null || _c === void 0 ? void 0 : _c.size) {
        const dataSize = d3.data.size;
        if (Array.isArray(dataSize))
          return dataSize;
        if (isObject$2(dataSize))
          return [dataSize.width, dataSize.height];
        return dataSize;
      }
      return defaultNodeSize;
    };
  } else if (Array.isArray(nodeSize)) {
    nodeSizeFunc = (d3) => nodeSize;
  } else if (isFunction$1(nodeSize)) {
    nodeSizeFunc = nodeSize;
  } else {
    nodeSizeFunc = (d3) => nodeSize;
  }
  const func = (d3) => {
    const nodeSize2 = nodeSizeFunc(d3);
    const nodeSpacing2 = nodeSpacingFunc(d3);
    return Math.max(...parseSize(nodeSize2)) + nodeSpacing2;
  };
  return func;
};
const DEFAULTS_LAYOUT_OPTIONS$b = {
  rankdir: "TB",
  nodesep: 50,
  ranksep: 50,
  edgeLabelSpace: true,
  ranker: "tight-tree",
  controlPoints: false,
  radial: false,
  focusNode: null
  // radial  true 
};
class AntVDagreLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "antv-dagre";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$b), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericDagreLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericDagreLayout(true, graph2, options);
    });
  }
  genericDagreLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const {
        nodeSize,
        align,
        rankdir = "TB",
        ranksep,
        nodesep,
        ranksepFunc,
        nodesepFunc,
        edgeLabelSpace,
        ranker,
        nodeOrder,
        begin,
        controlPoints,
        radial,
        sortByCombo,
        // focusNode,
        preset
      } = mergedOptions;
      const g2 = new Graph$9({
        tree: []
      });
      const ranksepfunc = formatNumberFn(ranksep || 50, ranksepFunc);
      const nodesepfunc = formatNumberFn(nodesep || 50, nodesepFunc);
      let horisep = nodesepfunc;
      let vertisep = ranksepfunc;
      if (rankdir === "LR" || rankdir === "RL") {
        horisep = ranksepfunc;
        vertisep = nodesepfunc;
      }
      const nodeSizeFunc = formatSizeFn(10, nodeSize, false);
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      nodes.forEach((node) => {
        const size = parseSize(nodeSizeFunc(node));
        const verti = vertisep(node);
        const hori = horisep(node);
        const width2 = size[0] + 2 * hori;
        const height = size[1] + 2 * verti;
        const layer = node.data.layer;
        if (isNumber(layer)) {
          g2.addNode({
            id: node.id,
            data: { width: width2, height, layer }
          });
        } else {
          g2.addNode({
            id: node.id,
            data: { width: width2, height }
          });
        }
      });
      if (sortByCombo) {
        g2.attachTreeStructure("combo");
        nodes.forEach((node) => {
          const { parentId } = node.data;
          if (parentId === void 0)
            return;
          if (g2.hasNode(parentId)) {
            g2.setParent(node.id, parentId, "combo");
          }
        });
      }
      edges.forEach((edge) => {
        g2.addEdge({
          id: edge.id,
          source: edge.source,
          target: edge.target,
          data: {
            weight: edge.data.weight || 1
          }
        });
      });
      let prevGraph = void 0;
      if (preset === null || preset === void 0 ? void 0 : preset.length) {
        prevGraph = new Graph$9({
          nodes: preset
        });
      }
      layout$1(g2, {
        prevGraph,
        edgeLabelSpace,
        keepNodeOrder: !!nodeOrder,
        nodeOrder: nodeOrder || [],
        acyclicer: "greedy",
        ranker,
        rankdir,
        nodesep,
        align
      });
      const layoutTopLeft = [0, 0];
      if (begin) {
        let minX = Infinity;
        let minY = Infinity;
        g2.getAllNodes().forEach((node) => {
          if (minX > node.data.x)
            minX = node.data.x;
          if (minY > node.data.y)
            minY = node.data.y;
        });
        g2.getAllEdges().forEach((edge) => {
          var _a3;
          (_a3 = edge.data.points) === null || _a3 === void 0 ? void 0 : _a3.forEach((point2) => {
            if (minX > point2.x)
              minX = point2.x;
            if (minY > point2.y)
              minY = point2.y;
          });
        });
        layoutTopLeft[0] = begin[0] - minX;
        layoutTopLeft[1] = begin[1] - minY;
      }
      const isHorizontal2 = rankdir === "LR" || rankdir === "RL";
      if (radial) ;
      else {
        const layerCoords = /* @__PURE__ */ new Set();
        const isInvert = rankdir === "BT" || rankdir === "RL";
        const layerCoordSort = isInvert ? (a2, b2) => b2 - a2 : (a2, b2) => a2 - b2;
        g2.getAllNodes().forEach((node) => {
          node.data.x = node.data.x + layoutTopLeft[0];
          node.data.y = node.data.y + layoutTopLeft[1];
          layerCoords.add(isHorizontal2 ? node.data.x : node.data.y);
        });
        const layerCoordsArr = Array.from(layerCoords).sort(layerCoordSort);
        const isDifferentLayer = isHorizontal2 ? (point1, point2) => point1.x !== point2.x : (point1, point2) => point1.y !== point2.y;
        const filterControlPointsOutOfBoundary = isHorizontal2 ? (ps, point1, point2) => {
          const max2 = Math.max(point1.y, point2.y);
          const min2 = Math.min(point1.y, point2.y);
          return ps.filter((point3) => point3.y <= max2 && point3.y >= min2);
        } : (ps, point1, point2) => {
          const max2 = Math.max(point1.x, point2.x);
          const min2 = Math.min(point1.x, point2.x);
          return ps.filter((point3) => point3.x <= max2 && point3.x >= min2);
        };
        g2.getAllEdges().forEach((edge, i2) => {
          var _a3;
          if (edgeLabelSpace && controlPoints && edge.data.type !== "loop") {
            edge.data.controlPoints = getControlPoints((_a3 = edge.data.points) === null || _a3 === void 0 ? void 0 : _a3.map(({ x: x2, y: y2 }) => ({
              x: x2 + layoutTopLeft[0],
              y: y2 + layoutTopLeft[1]
            })), g2.getNode(edge.source), g2.getNode(edge.target), layerCoordsArr, isHorizontal2, isDifferentLayer, filterControlPointsOutOfBoundary);
          }
        });
      }
      let layoutNodes = [];
      layoutNodes = g2.getAllNodes().map((node) => cloneFormatData(node));
      const layoutEdges = g2.getAllEdges();
      if (assign) {
        layoutNodes.forEach((node) => {
          graph2.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
        layoutEdges.forEach((edge) => {
          graph2.mergeEdgeData(edge.id, {
            controlPoints: edge.data.controlPoints
          });
        });
      }
      const result = {
        nodes: layoutNodes,
        edges: layoutEdges
      };
      return result;
    });
  }
}
const getControlPoints = (points, sourceNode, targetNode, layerCoordsArr, isHorizontal2, isDifferentLayer, filterControlPointsOutOfBoundary) => {
  let controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || [];
  if (sourceNode && targetNode) {
    let { x: sourceX, y: sourceY } = sourceNode.data;
    let { x: targetX, y: targetY } = targetNode.data;
    if (isHorizontal2) {
      sourceX = sourceNode.data.y;
      sourceY = sourceNode.data.x;
      targetX = targetNode.data.y;
      targetY = targetNode.data.x;
    }
    if (targetY !== sourceY && sourceX !== targetX) {
      const sourceLayer = layerCoordsArr.indexOf(sourceY);
      const sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
      if (sourceNextLayerCoord) {
        const firstControlPoint = controlPoints[0];
        const insertStartControlPoint = isHorizontal2 ? {
          x: (sourceY + sourceNextLayerCoord) / 2,
          y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX
        } : {
          x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
          y: (sourceY + sourceNextLayerCoord) / 2
        };
        if (!firstControlPoint || isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
          controlPoints.unshift(insertStartControlPoint);
        }
      }
      const targetLayer = layerCoordsArr.indexOf(targetY);
      const layerDiff = Math.abs(targetLayer - sourceLayer);
      if (layerDiff === 1) {
        controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode.data, targetNode.data);
        if (!controlPoints.length) {
          controlPoints.push(isHorizontal2 ? {
            x: (sourceY + targetY) / 2,
            y: sourceX
          } : {
            x: sourceX,
            y: (sourceY + targetY) / 2
          });
        }
      } else if (layerDiff > 1) {
        const targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
        if (targetLastLayerCoord) {
          const lastControlPoints = controlPoints[controlPoints.length - 1];
          const insertEndControlPoint = isHorizontal2 ? {
            x: (targetY + targetLastLayerCoord) / 2,
            y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX
          } : {
            x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
            y: (targetY + targetLastLayerCoord) / 2
          };
          if (!lastControlPoints || isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
            controlPoints.push(insertEndControlPoint);
          }
        }
      }
    }
  }
  return controlPoints;
};
const handleSingleNodeGraph = (graph2, assign, center) => {
  const nodes = graph2.getAllNodes();
  const edges = graph2.getAllEdges();
  if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
    const result = { nodes: [], edges };
    return result;
  }
  if (nodes.length === 1) {
    if (assign) {
      graph2.mergeNodeData(nodes[0].id, {
        x: center[0],
        y: center[1]
      });
    }
    const result = {
      nodes: [
        Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1] }) })
      ],
      edges
    };
    return result;
  }
};
const DEFAULTS_LAYOUT_OPTIONS$a = {
  radius: null,
  startRadius: null,
  endRadius: null,
  startAngle: 0,
  endAngle: 2 * Math.PI,
  clockwise: true,
  divisions: 1,
  ordering: null,
  angleRatio: 1
};
class CircularLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "circular";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$a), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericCircularLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericCircularLayout(true, graph2, options);
    });
  }
  genericCircularLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { width: width2, height, center, divisions, startAngle = 0, endAngle = 2 * Math.PI, angleRatio, ordering, clockwise, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize } = mergedOptions;
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      const [calculatedWidth, calculatedHeight, calculatedCenter] = calculateCenter(width2, height, center);
      const n2 = nodes === null || nodes === void 0 ? void 0 : nodes.length;
      if (!n2 || n2 === 1) {
        return handleSingleNodeGraph(graph2, assign, calculatedCenter);
      }
      const angleStep = (endAngle - startAngle) / n2;
      let { radius, startRadius, endRadius } = mergedOptions;
      if (paramNodeSpacing) {
        const nodeSpacing = formatNumberFn(10, paramNodeSpacing);
        const nodeSize = formatSizeFn(10, paramNodeSize);
        let maxNodeSize = -Infinity;
        nodes.forEach((node) => {
          const nSize = nodeSize(node);
          if (maxNodeSize < nSize)
            maxNodeSize = nSize;
        });
        let perimeter = 0;
        nodes.forEach((node, i2) => {
          if (i2 === 0)
            perimeter += maxNodeSize || 10;
          else
            perimeter += (nodeSpacing(node) || 0) + (maxNodeSize || 10);
        });
        radius = perimeter / (2 * Math.PI);
      } else if (!radius && !startRadius && !endRadius) {
        radius = Math.min(calculatedHeight, calculatedWidth) / 2;
      } else if (!startRadius && endRadius) {
        startRadius = endRadius;
      } else if (startRadius && !endRadius) {
        endRadius = startRadius;
      }
      const astep = angleStep * angleRatio;
      let layoutNodes = [];
      if (ordering === "topology") {
        layoutNodes = topologyOrdering(graph2, nodes);
      } else if (ordering === "topology-directed") {
        layoutNodes = topologyOrdering(graph2, nodes, true);
      } else if (ordering === "degree") {
        layoutNodes = degreeOrdering(graph2, nodes);
      } else {
        layoutNodes = nodes.map((node) => cloneFormatData(node));
      }
      const divN = Math.ceil(n2 / divisions);
      for (let i2 = 0; i2 < n2; ++i2) {
        let r2 = radius;
        if (!r2 && startRadius !== null && endRadius !== null) {
          r2 = startRadius + i2 * (endRadius - startRadius) / (n2 - 1);
        }
        if (!r2) {
          r2 = 10 + i2 * 100 / (n2 - 1);
        }
        let angle2 = startAngle + i2 % divN * astep + 2 * Math.PI / divisions * Math.floor(i2 / divN);
        if (!clockwise) {
          angle2 = endAngle - i2 % divN * astep - 2 * Math.PI / divisions * Math.floor(i2 / divN);
        }
        layoutNodes[i2].data.x = calculatedCenter[0] + Math.cos(angle2) * r2;
        layoutNodes[i2].data.y = calculatedCenter[1] + Math.sin(angle2) * r2;
      }
      if (assign) {
        layoutNodes.forEach((node) => {
          graph2.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
}
const topologyOrdering = (graph2, nodes, directed = false) => {
  const orderedCNodes = [cloneFormatData(nodes[0])];
  const pickFlags = {};
  const n2 = nodes.length;
  pickFlags[nodes[0].id] = true;
  let k = 0;
  nodes.forEach((node, i2) => {
    if (i2 !== 0) {
      if ((i2 === n2 - 1 || graph2.getDegree(node.id, "both") !== graph2.getDegree(nodes[i2 + 1].id, "both") || graph2.areNeighbors(orderedCNodes[k].id, node.id)) && !pickFlags[node.id]) {
        orderedCNodes.push(cloneFormatData(node));
        pickFlags[node.id] = true;
        k++;
      } else {
        const children = directed ? graph2.getSuccessors(orderedCNodes[k].id) : graph2.getNeighbors(orderedCNodes[k].id);
        let foundChild = false;
        for (let j = 0; j < children.length; j++) {
          const child = children[j];
          if (graph2.getDegree(child.id) === graph2.getDegree(node.id) && !pickFlags[child.id]) {
            orderedCNodes.push(cloneFormatData(child));
            pickFlags[child.id] = true;
            foundChild = true;
            break;
          }
        }
        let ii = 0;
        while (!foundChild) {
          if (!pickFlags[nodes[ii].id]) {
            orderedCNodes.push(cloneFormatData(nodes[ii]));
            pickFlags[nodes[ii].id] = true;
            foundChild = true;
          }
          ii++;
          if (ii === n2) {
            break;
          }
        }
      }
    }
  });
  return orderedCNodes;
};
function degreeOrdering(graph2, nodes) {
  const orderedNodes = [];
  nodes.forEach((node, i2) => {
    orderedNodes.push(cloneFormatData(node));
  });
  orderedNodes.sort((nodeA, nodeB) => graph2.getDegree(nodeA.id, "both") - graph2.getDegree(nodeB.id, "both"));
  return orderedNodes;
}
const calculateCenter = (width2, height, center) => {
  let calculatedWidth = width2;
  let calculatedHeight = height;
  let calculatedCenter = center;
  if (!calculatedWidth && typeof window !== "undefined") {
    calculatedWidth = window.innerWidth;
  }
  if (!calculatedHeight && typeof window !== "undefined") {
    calculatedHeight = window.innerHeight;
  }
  if (!calculatedCenter) {
    calculatedCenter = [calculatedWidth / 2, calculatedHeight / 2];
  }
  return [calculatedWidth, calculatedHeight, calculatedCenter];
};
const DEFAULTS_LAYOUT_OPTIONS$9 = {
  nodeSize: 30,
  nodeSpacing: 10,
  preventOverlap: false,
  sweep: void 0,
  equidistant: false,
  startAngle: 3 / 2 * Math.PI,
  clockwise: true,
  maxLevelDiff: void 0,
  sortBy: "degree"
};
class ConcentricLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "concentric";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$9), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericConcentricLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericConcentricLayout(true, graph2, options);
    });
  }
  genericConcentricLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center: propsCenter, width: propsWidth, height: propsHeight, sortBy: propsSortBy, maxLevelDiff: propsMaxLevelDiff, sweep: propsSweep, clockwise, equidistant, preventOverlap, startAngle = 3 / 2 * Math.PI, nodeSize, nodeSpacing } = mergedOptions;
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph2, assign, center);
      }
      const layoutNodes = [];
      let maxNodeSize;
      let maxNodeSpacing = 0;
      if (isArray(nodeSize)) {
        maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
      } else if (isFunction$1(nodeSize)) {
        maxNodeSize = -Infinity;
        nodes.forEach((node) => {
          const currentSize = Math.max(...parseSize(nodeSize(node)));
          if (currentSize > maxNodeSize)
            maxNodeSize = currentSize;
        });
      } else {
        maxNodeSize = nodeSize;
      }
      if (isArray(nodeSpacing)) {
        maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
      } else if (isNumber(nodeSpacing)) {
        maxNodeSpacing = nodeSpacing;
      }
      nodes.forEach((node) => {
        const cnode = cloneFormatData(node);
        layoutNodes.push(cnode);
        let nodeSize2 = maxNodeSize;
        const { data: data2 } = cnode;
        if (isArray(data2.size)) {
          nodeSize2 = Math.max(data2.size[0], data2.size[1]);
        } else if (isNumber(data2.size)) {
          nodeSize2 = data2.size;
        } else if (isObject$2(data2.size)) {
          nodeSize2 = Math.max(data2.size.width, data2.size.height);
        }
        maxNodeSize = Math.max(maxNodeSize, nodeSize2);
        if (isFunction$1(nodeSpacing)) {
          maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
        }
      });
      const nodeIdxMap = {};
      layoutNodes.forEach((node, i2) => {
        nodeIdxMap[node.id] = i2;
      });
      let sortBy = propsSortBy;
      if (!isString$1(sortBy) || layoutNodes[0].data[sortBy] === void 0) {
        sortBy = "degree";
      }
      if (sortBy === "degree") {
        layoutNodes.sort((n1, n2) => graph2.getDegree(n2.id, "both") - graph2.getDegree(n1.id, "both"));
      } else {
        layoutNodes.sort((n1, n2) => n2.data[sortBy] - n1.data[sortBy]);
      }
      const maxValueNode = layoutNodes[0];
      const maxLevelDiff = (propsMaxLevelDiff || (sortBy === "degree" ? graph2.getDegree(maxValueNode.id, "both") : maxValueNode.data[sortBy])) / 4;
      const levels = [{ nodes: [] }];
      let currentLevel = levels[0];
      layoutNodes.forEach((node) => {
        if (currentLevel.nodes.length > 0) {
          const diff = sortBy === "degree" ? Math.abs(graph2.getDegree(currentLevel.nodes[0].id, "both") - graph2.getDegree(node.id, "both")) : Math.abs(currentLevel.nodes[0].data[sortBy] - node.data[sortBy]);
          if (maxLevelDiff && diff >= maxLevelDiff) {
            currentLevel = { nodes: [] };
            levels.push(currentLevel);
          }
        }
        currentLevel.nodes.push(node);
      });
      let minDist = maxNodeSize + maxNodeSpacing;
      if (!preventOverlap) {
        const firstLvlHasMulti = levels.length > 0 && levels[0].nodes.length > 1;
        const maxR = Math.min(width2, height) / 2 - minDist;
        const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
        minDist = Math.min(minDist, rStep);
      }
      let r2 = 0;
      levels.forEach((level) => {
        const sweep = propsSweep === void 0 ? 2 * Math.PI - 2 * Math.PI / level.nodes.length : propsSweep;
        level.dTheta = sweep / Math.max(1, level.nodes.length - 1);
        if (level.nodes.length > 1 && preventOverlap) {
          const dcos = Math.cos(level.dTheta) - Math.cos(0);
          const dsin = Math.sin(level.dTheta) - Math.sin(0);
          const rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
          r2 = Math.max(rMin, r2);
        }
        level.r = r2;
        r2 += minDist;
      });
      if (equidistant) {
        let rDeltaMax = 0;
        let rr = 0;
        for (let i2 = 0; i2 < levels.length; i2++) {
          const level = levels[i2];
          const rDelta = (level.r || 0) - rr;
          rDeltaMax = Math.max(rDeltaMax, rDelta);
        }
        rr = 0;
        levels.forEach((level, i2) => {
          if (i2 === 0) {
            rr = level.r || 0;
          }
          level.r = rr;
          rr += rDeltaMax;
        });
      }
      levels.forEach((level) => {
        const dTheta = level.dTheta || 0;
        const rr = level.r || 0;
        level.nodes.forEach((node, j) => {
          const theta = startAngle + (clockwise ? 1 : -1) * dTheta * j;
          node.data.x = center[0] + rr * Math.cos(theta);
          node.data.y = center[1] + rr * Math.sin(theta);
        });
      });
      if (assign) {
        layoutNodes.forEach((node) => graph2.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
}
function tree_add$2(d3) {
  const x2 = +this._x.call(null, d3), y2 = +this._y.call(null, d3);
  return add$3(this.cover(x2, y2), x2, y2, d3);
}
function add$3(tree, x2, y2, d3) {
  if (isNaN(x2) || isNaN(y2)) return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent = node, !(node = node[i2 = bottom << 1 | right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x2 === xp && y2 === yp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i2] = leaf, tree;
}
function addAll$2(data2) {
  var d3, i2, n2 = data2.length, x2, y2, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, d3 = data2[i2])) || isNaN(y2 = +this._y.call(null, d3))) continue;
    xz[i2] = x2;
    yz[i2] = y2;
    if (x2 < x0) x0 = x2;
    if (x2 > x1) x1 = x2;
    if (y2 < y0) y0 = y2;
    if (y2 > y1) y1 = y2;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add$3(this, xz[i2], yz[i2], data2[i2]);
  }
  return this;
}
function tree_cover$2(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
    y1 = (y0 = Math.floor(y2)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {
      i2 = (y2 < y0) << 1 | x2 < x0;
      parent = new Array(4), parent[i2] = node, node = parent, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}
function tree_data$2() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length) do
      data2.push(node.data);
    while (node = node.next);
  });
  return data2;
}
function tree_extent$2(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Quad$1(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}
function tree_find$2(x2, y2, radius) {
  var data2, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i2;
  if (node) quads.push(new Quad$1(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x2 - radius, y0 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new Quad$1(node[3], xm, ym, x22, y22),
        new Quad$1(node[2], x1, ym, xm, y22),
        new Quad$1(node[1], xm, y1, x22, ym),
        new Quad$1(node[0], x1, y1, xm, ym)
      );
      if (i2 = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d22 = dx * dx + dy * dy;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x2 - d3, y0 = y2 - d3;
        x3 = x2 + d3, y3 = y2 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}
function tree_remove$2(d3) {
  if (isNaN(x2 = +this._x.call(null, d3)) || isNaN(y2 = +this._y.call(null, d3))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, right, bottom, i2, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent = node, node = node[i2 = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3]) retainer = parent, j = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll$2(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2) this.remove(data2[i2]);
  return this;
}
function tree_root$2() {
  return this._root;
}
function tree_size$2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}
function tree_visit$2(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad$1(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad$1(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad$1(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad$1(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad$1(child, x0, y0, xm, ym));
    }
  }
  return this;
}
function tree_visitAfter$2(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad$1(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad$1(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad$1(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad$1(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad$1(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}
function defaultX$2(d3) {
  return d3[0];
}
function tree_x$2(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function defaultY$1(d3) {
  return d3[1];
}
function tree_y$1(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
function quadtree(nodes, x2, y2) {
  var tree = new Quadtree(x2 == null ? defaultX$2 : x2, y2 == null ? defaultY$1 : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x2, y2, x0, y0, x1, y1) {
  this._x = x2;
  this._y = y2;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy$2(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto$2 = quadtree.prototype = Quadtree.prototype;
treeProto$2.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy2;
  if (!node.length) return copy2._root = leaf_copy$2(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(4) });
        else node.target[i2] = leaf_copy$2(child);
      }
    }
  }
  return copy2;
};
treeProto$2.add = tree_add$2;
treeProto$2.addAll = addAll$2;
treeProto$2.cover = tree_cover$2;
treeProto$2.data = tree_data$2;
treeProto$2.extent = tree_extent$2;
treeProto$2.find = tree_find$2;
treeProto$2.remove = tree_remove$2;
treeProto$2.removeAll = removeAll$2;
treeProto$2.root = tree_root$2;
treeProto$2.size = tree_size$2;
treeProto$2.visit = tree_visit$2;
treeProto$2.visitAfter = tree_visitAfter$2;
treeProto$2.x = tree_x$2;
treeProto$2.y = tree_y$1;
function tree_add$1(d3) {
  const x2 = +this._x.call(null, d3), y2 = +this._y.call(null, d3), z2 = +this._z.call(null, d3);
  return add$2(this.cover(x2, y2, z2), x2, y2, z2, d3);
}
function add$2(tree, x2, y2, z2, d3) {
  if (isNaN(x2) || isNaN(y2) || isNaN(z2)) return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep2, i2, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep2 = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
    if (parent = node, !(node = node[i2 = deep2 << 2 | bottom << 1 | right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  zp = +tree._z.call(null, node.data);
  if (x2 === xp && y2 === yp && z2 === zp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(8) : tree._root = new Array(8);
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep2 = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
  } while ((i2 = deep2 << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i2] = leaf, tree;
}
function addAll$1(data2) {
  if (!Array.isArray(data2)) data2 = Array.from(data2);
  const n2 = data2.length;
  const xz = new Float64Array(n2);
  const yz = new Float64Array(n2);
  const zz = new Float64Array(n2);
  let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
  for (let i2 = 0, d3, x2, y2, z2; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, d3 = data2[i2])) || isNaN(y2 = +this._y.call(null, d3)) || isNaN(z2 = +this._z.call(null, d3))) continue;
    xz[i2] = x2;
    yz[i2] = y2;
    zz[i2] = z2;
    if (x2 < x0) x0 = x2;
    if (x2 > x1) x1 = x2;
    if (y2 < y0) y0 = y2;
    if (y2 > y1) y1 = y2;
    if (z2 < z0) z0 = z2;
    if (z2 > z1) z1 = z2;
  }
  if (x0 > x1 || y0 > y1 || z0 > z1) return this;
  this.cover(x0, y0, z0).cover(x1, y1, z1);
  for (let i2 = 0; i2 < n2; ++i2) {
    add$2(this, xz[i2], yz[i2], zz[i2], data2[i2]);
  }
  return this;
}
function tree_cover$1(x2, y2, z2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2) || isNaN(z2 = +z2)) return this;
  var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
    y1 = (y0 = Math.floor(y2)) + 1;
    z1 = (z0 = Math.floor(z2)) + 1;
  } else {
    var t3 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1 || z0 > z2 || z2 >= z1) {
      i2 = (z2 < z0) << 2 | (y2 < y0) << 1 | x2 < x0;
      parent = new Array(8), parent[i2] = node, node = parent, t3 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + t3, y1 = y0 + t3, z1 = z0 + t3;
          break;
        case 1:
          x0 = x1 - t3, y1 = y0 + t3, z1 = z0 + t3;
          break;
        case 2:
          x1 = x0 + t3, y0 = y1 - t3, z1 = z0 + t3;
          break;
        case 3:
          x0 = x1 - t3, y0 = y1 - t3, z1 = z0 + t3;
          break;
        case 4:
          x1 = x0 + t3, y1 = y0 + t3, z0 = z1 - t3;
          break;
        case 5:
          x0 = x1 - t3, y1 = y0 + t3, z0 = z1 - t3;
          break;
        case 6:
          x1 = x0 + t3, y0 = y1 - t3, z0 = z1 - t3;
          break;
        case 7:
          x0 = x1 - t3, y0 = y1 - t3, z0 = z1 - t3;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  return this;
}
function tree_data$1() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length) do
      data2.push(node.data);
    while (node = node.next);
  });
  return data2;
}
function tree_extent$1(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1], +_2[0][2]).cover(+_2[1][0], +_2[1][1], +_2[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function Octant(node, x0, y0, z0, x1, y1, z1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.z0 = z0;
  this.x1 = x1;
  this.y1 = y1;
  this.z1 = z1;
}
function tree_find$1(x2, y2, z2, radius) {
  var data2, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x22, y22, z22, x3 = this._x1, y3 = this._y1, z3 = this._z1, octs = [], node = this._root, q, i2;
  if (node) octs.push(new Octant(node, x0, y0, z0, x3, y3, z3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x2 - radius, y0 = y2 - radius, z0 = z2 - radius;
    x3 = x2 + radius, y3 = y2 + radius, z3 = z2 + radius;
    radius *= radius;
  }
  while (q = octs.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (z1 = q.z0) > z3 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0 || (z22 = q.z1) < z0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2, zm = (z1 + z22) / 2;
      octs.push(
        new Octant(node[7], xm, ym, zm, x22, y22, z22),
        new Octant(node[6], x1, ym, zm, xm, y22, z22),
        new Octant(node[5], xm, y1, zm, x22, ym, z22),
        new Octant(node[4], x1, y1, zm, xm, ym, z22),
        new Octant(node[3], xm, ym, z1, x22, y22, zm),
        new Octant(node[2], x1, ym, z1, xm, y22, zm),
        new Octant(node[1], xm, y1, z1, x22, ym, zm),
        new Octant(node[0], x1, y1, z1, xm, ym, zm)
      );
      if (i2 = (z2 >= zm) << 2 | (y2 >= ym) << 1 | x2 >= xm) {
        q = octs[octs.length - 1];
        octs[octs.length - 1] = octs[octs.length - 1 - i2];
        octs[octs.length - 1 - i2] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), dz = z2 - +this._z.call(null, node.data), d22 = dx * dx + dy * dy + dz * dz;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x2 - d3, y0 = y2 - d3, z0 = z2 - d3;
        x3 = x2 + d3, y3 = y2 + d3, z3 = z2 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}
const distance$2 = (x1, y1, z1, x2, y2, z2) => Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
function findAllWithinRadius(x2, y2, z2, radius) {
  const result = [];
  const xMin = x2 - radius;
  const yMin = y2 - radius;
  const zMin = z2 - radius;
  const xMax = x2 + radius;
  const yMax = y2 + radius;
  const zMax = z2 + radius;
  this.visit((node, x1, y1, z1, x22, y22, z22) => {
    if (!node.length) {
      do {
        const d3 = node.data;
        if (distance$2(x2, y2, z2, this._x(d3), this._y(d3), this._z(d3)) <= radius) {
          result.push(d3);
        }
      } while (node = node.next);
    }
    return x1 > xMax || y1 > yMax || z1 > zMax || x22 < xMin || y22 < yMin || z22 < zMin;
  });
  return result;
}
function tree_remove$1(d3) {
  if (isNaN(x2 = +this._x.call(null, d3)) || isNaN(y2 = +this._y.call(null, d3)) || isNaN(z2 = +this._z.call(null, d3))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x2, y2, z2, xm, ym, zm, right, bottom, deep2, i2, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep2 = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
    if (!(parent = node, node = node[i2 = deep2 << 2 | bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 7] || parent[i2 + 2 & 7] || parent[i2 + 3 & 7] || parent[i2 + 4 & 7] || parent[i2 + 5 & 7] || parent[i2 + 6 & 7] || parent[i2 + 7 & 7]) retainer = parent, j = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll$1(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2) this.remove(data2[i2]);
  return this;
}
function tree_root$1() {
  return this._root;
}
function tree_size$1() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}
function tree_visit$1(callback) {
  var octs = [], q, node = this._root, child, x0, y0, z0, x1, y1, z1;
  if (node) octs.push(new Octant(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q = octs.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[7]) octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
      if (child = node[6]) octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
      if (child = node[5]) octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
      if (child = node[4]) octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
      if (child = node[3]) octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
      if (child = node[2]) octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
      if (child = node[1]) octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
      if (child = node[0]) octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
    }
  }
  return this;
}
function tree_visitAfter$1(callback) {
  var octs = [], next = [], q;
  if (this._root) octs.push(new Octant(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q = octs.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[0]) octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
      if (child = node[1]) octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
      if (child = node[2]) octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
      if (child = node[3]) octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
      if (child = node[4]) octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
      if (child = node[5]) octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
      if (child = node[6]) octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
      if (child = node[7]) octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.z0, q.x1, q.y1, q.z1);
  }
  return this;
}
function defaultX$1(d3) {
  return d3[0];
}
function tree_x$1(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function defaultY(d3) {
  return d3[1];
}
function tree_y(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
function defaultZ(d3) {
  return d3[2];
}
function tree_z(_2) {
  return arguments.length ? (this._z = _2, this) : this._z;
}
function octree(nodes, x2, y2, z2) {
  var tree = new Octree(x2 == null ? defaultX$1 : x2, y2 == null ? defaultY : y2, z2 == null ? defaultZ : z2, NaN, NaN, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Octree(x2, y2, z2, x0, y0, z0, x1, y1, z1) {
  this._x = x2;
  this._y = y2;
  this._z = z2;
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  this._root = void 0;
}
function leaf_copy$1(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto$1 = octree.prototype = Octree.prototype;
treeProto$1.copy = function() {
  var copy2 = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
  if (!node) return copy2;
  if (!node.length) return copy2._root = leaf_copy$1(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(8) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 8; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(8) });
        else node.target[i2] = leaf_copy$1(child);
      }
    }
  }
  return copy2;
};
treeProto$1.add = tree_add$1;
treeProto$1.addAll = addAll$1;
treeProto$1.cover = tree_cover$1;
treeProto$1.data = tree_data$1;
treeProto$1.extent = tree_extent$1;
treeProto$1.find = tree_find$1;
treeProto$1.findAllWithinRadius = findAllWithinRadius;
treeProto$1.remove = tree_remove$1;
treeProto$1.removeAll = removeAll$1;
treeProto$1.root = tree_root$1;
treeProto$1.size = tree_size$1;
treeProto$1.visit = tree_visit$1;
treeProto$1.visitAfter = tree_visitAfter$1;
treeProto$1.x = tree_x$1;
treeProto$1.y = tree_y;
treeProto$1.z = tree_z;
const theta2 = 0.81;
const epsilon = 0.1;
function forceNBody(calcGraph, factor, coulombDisScale2, accMap, dimensions = 2) {
  const weightParam = factor / coulombDisScale2;
  const calcNodes = calcGraph.getAllNodes();
  const data2 = calcNodes.map((calcNode, i2) => {
    const { nodeStrength, x: x2, y: y2, z: z2, size } = calcNode.data;
    return {
      x: x2,
      y: y2,
      z: z2,
      size,
      index: i2,
      id: calcNode.id,
      vx: 0,
      vy: 0,
      vz: 0,
      weight: weightParam * nodeStrength
    };
  });
  const tree = (dimensions === 2 ? quadtree(data2, (d3) => d3.x, (d3) => d3.y) : octree(data2, (d3) => d3.x, (d3) => d3.y, (d3) => d3.z)).visitAfter(accumulate);
  const nodeMap = /* @__PURE__ */ new Map();
  data2.forEach((n2) => {
    nodeMap.set(n2.id, n2);
    computeForce(n2, tree, dimensions);
  });
  data2.map((n2, i2) => {
    const { id: id2, data: data3 } = calcNodes[i2];
    const { mass = 1 } = data3;
    accMap[id2] = {
      x: n2.vx / mass,
      y: n2.vy / mass,
      z: n2.vz / mass
    };
  });
  return accMap;
}
function accumulate(treeNode) {
  let accWeight = 0;
  let accX = 0;
  let accY = 0;
  let accZ = 0;
  let accSize = 0;
  const numChildren = treeNode.length;
  if (numChildren) {
    for (let i2 = 0; i2 < numChildren; i2++) {
      const q = treeNode[i2];
      if (q && q.weight) {
        accWeight += q.weight;
        accX += q.x * q.weight;
        accY += q.y * q.weight;
        accZ += q.z * q.weight;
        accSize += q.size * q.weight;
      }
    }
    treeNode.x = accX / accWeight;
    treeNode.y = accY / accWeight;
    treeNode.z = accZ / accWeight;
    treeNode.size = accSize / accWeight;
    treeNode.weight = accWeight;
  } else {
    const q = treeNode;
    treeNode.x = q.data.x;
    treeNode.y = q.data.y;
    treeNode.z = q.data.z;
    treeNode.size = q.data.size;
    treeNode.weight = q.data.weight;
  }
}
const apply$1 = (treeNode, x1, arg1, arg2, arg3, node, dimensions) => {
  var _a3;
  if (((_a3 = treeNode.data) === null || _a3 === void 0 ? void 0 : _a3.id) === node.id)
    return;
  const x2 = [arg1, arg2, arg3][dimensions - 1];
  const dx = node.x - treeNode.x || epsilon;
  const dy = node.y - treeNode.y || epsilon;
  const dz = node.z - treeNode.z || epsilon;
  const pos = [dx, dy, dz];
  const width2 = x2 - x1;
  let len2 = 0;
  for (let i2 = 0; i2 < dimensions; i2++) {
    len2 += pos[i2] * pos[i2];
  }
  const len1 = Math.sqrt(len2);
  const len3 = len1 * len2;
  if (width2 * width2 * theta2 < len2) {
    const param = treeNode.weight / len3;
    node.vx += dx * param;
    node.vy += dy * param;
    node.vz += dz * param;
    return true;
  }
  if (treeNode.length)
    return false;
  if (treeNode.data !== node) {
    const param = treeNode.data.weight / len3;
    node.vx += dx * param;
    node.vy += dy * param;
    node.vz += dz * param;
  }
};
function computeForce(node, tree, dimensions) {
  tree.visit((treeNode, x1, y1, x2, y2) => apply$1(treeNode, x1, y1, x2, y2, node, dimensions));
}
const DEFAULTS_LAYOUT_OPTIONS$8 = {
  dimensions: 2,
  maxIteration: 500,
  gravity: 10,
  factor: 1,
  edgeStrength: 50,
  nodeStrength: 1e3,
  coulombDisScale: 5e-3,
  damping: 0.9,
  maxSpeed: 200,
  minMovement: 0.4,
  interval: 0.02,
  linkDistance: 200,
  clusterNodeStrength: 20,
  preventOverlap: true,
  distanceThresholdMode: "mean"
};
class ForceLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "force";
    this.timeInterval = 0;
    this.judgingDistance = 0;
    this.running = false;
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$8), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericForceLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericForceLayout(true, graph2, options);
    });
  }
  /**
   * Stop simulation immediately.
   */
  stop() {
    if (this.timeInterval && typeof window !== "undefined") {
      window.clearInterval(this.timeInterval);
    }
    this.running = false;
  }
  /**
   * Manually steps the simulation by the specified number of iterations.
   * @see https://github.com/d3/d3-force#simulation_tick
   */
  tick(iterations = this.options.maxIteration || 1) {
    if (this.lastResult) {
      return this.lastResult;
    }
    for (let i2 = 0; (this.judgingDistance > this.lastOptions.minMovement || i2 < 1) && i2 < iterations; i2++) {
      this.runOneStep(this.lastCalcGraph, this.lastGraph, i2, this.lastVelMap, this.lastOptions);
      this.updatePosition(this.lastGraph, this.lastCalcGraph, this.lastVelMap, this.lastOptions);
    }
    const result = {
      nodes: this.lastLayoutNodes,
      edges: this.lastLayoutEdges
    };
    if (this.lastAssign) {
      result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
        x: node.data.x,
        y: node.data.y,
        z: this.options.dimensions === 3 ? node.data.z : void 0
      }));
    }
    return result;
  }
  genericForceLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      const formattedOptions = this.formatOptions(mergedOptions, graph2);
      const { dimensions, width: width2, height, nodeSize, getMass, nodeStrength, edgeStrength, linkDistance } = formattedOptions;
      const layoutNodes = nodes.map((node, i2) => {
        return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), {
          // ...randomDistribution(node, dimensions, 30, i),
          x: isNumber(node.data.x) ? node.data.x : Math.random() * width2,
          y: isNumber(node.data.y) ? node.data.y : Math.random() * height,
          z: isNumber(node.data.z) ? node.data.z : Math.random() * Math.sqrt(width2 * height),
          size: nodeSize(node) || 30,
          mass: getMass(node),
          nodeStrength: nodeStrength(node)
        }) });
      });
      const layoutEdges = edges.map((edge) => Object.assign(Object.assign({}, edge), { data: Object.assign(Object.assign({}, edge.data), { edgeStrength: edgeStrength(edge), linkDistance: linkDistance(edge, graph2.getNode(edge.source), graph2.getNode(edge.target)) }) }));
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
        this.lastResult = { nodes: [], edges };
        return { nodes: [], edges };
      }
      const velMap = {};
      nodes.forEach((node, i2) => {
        velMap[node.id] = {
          x: 0,
          y: 0,
          z: 0
        };
      });
      const calcGraph = new Graph$9({
        nodes: layoutNodes,
        edges: layoutEdges
      });
      this.formatCentripetal(formattedOptions, calcGraph);
      const { maxIteration, minMovement, onTick } = formattedOptions;
      this.lastLayoutNodes = layoutNodes;
      this.lastLayoutEdges = layoutEdges;
      this.lastAssign = assign;
      this.lastGraph = graph2;
      this.lastCalcGraph = calcGraph;
      this.lastOptions = formattedOptions;
      this.lastVelMap = velMap;
      if (typeof window === "undefined")
        return;
      let iter = 0;
      return new Promise((resolve) => {
        this.timeInterval = window.setInterval(() => {
          if (!nodes || !this.running) {
            resolve({
              nodes: formatOutNodes(graph2, layoutNodes),
              edges
            });
          }
          this.runOneStep(calcGraph, graph2, iter, velMap, formattedOptions);
          this.updatePosition(graph2, calcGraph, velMap, formattedOptions);
          if (assign) {
            layoutNodes.forEach((node) => graph2.mergeNodeData(node.id, {
              x: node.data.x,
              y: node.data.y,
              z: dimensions === 3 ? node.data.z : void 0
            }));
          }
          onTick === null || onTick === void 0 ? void 0 : onTick({
            nodes: formatOutNodes(graph2, layoutNodes),
            edges
          });
          iter++;
          if (iter >= maxIteration || this.judgingDistance < minMovement) {
            window.clearInterval(this.timeInterval);
            resolve({
              nodes: formatOutNodes(graph2, layoutNodes),
              edges
            });
          }
        }, 0);
        this.running = true;
      });
    });
  }
  /**
   * Format merged layout options.
   * @param options merged layout options
   * @param graph original graph
   * @returns
   */
  formatOptions(options, graph2) {
    const formattedOptions = Object.assign({}, options);
    const { width: propsWidth, height: propsHeight, getMass } = options;
    formattedOptions.width = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
    formattedOptions.height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
    if (!options.center) {
      formattedOptions.center = [
        formattedOptions.width / 2,
        formattedOptions.height / 2
      ];
    }
    if (!getMass) {
      formattedOptions.getMass = (d3) => {
        let massWeight = 1;
        if (isNumber(d3 === null || d3 === void 0 ? void 0 : d3.data.mass))
          massWeight = d3 === null || d3 === void 0 ? void 0 : d3.data.mass;
        const degree3 = graph2.getDegree(d3.id, "both");
        return !degree3 || degree3 < 5 ? massWeight : degree3 * 5 * massWeight;
      };
    }
    formattedOptions.nodeSize = formatNodeSizeToNumber(options.nodeSize, options.nodeSpacing);
    const linkDistanceFn = options.linkDistance ? formatNumberFn(1, options.linkDistance) : (edge) => {
      return 1 + formattedOptions.nodeSize(graph2.getNode(edge.source)) + formattedOptions.nodeSize(graph2.getNode(edge.target));
    };
    formattedOptions.linkDistance = linkDistanceFn;
    formattedOptions.nodeStrength = formatNumberFn(1, options.nodeStrength);
    formattedOptions.edgeStrength = formatNumberFn(1, options.edgeStrength);
    return formattedOptions;
  }
  /**
   * Format centripetalOption in the option.
   * @param options merged layout options
   * @param calcGraph calculation graph
   */
  formatCentripetal(options, calcGraph) {
    const { dimensions, centripetalOptions, center, clusterNodeStrength, leafCluster, clustering, nodeClusterBy } = options;
    const calcNodes = calcGraph.getAllNodes();
    const basicCentripetal = centripetalOptions || {
      leaf: 2,
      single: 2,
      others: 1,
      // eslint-disable-next-line
      center: (n2) => {
        return {
          x: center[0],
          y: center[1],
          z: dimensions === 3 ? center[2] : void 0
        };
      }
    };
    if (typeof clusterNodeStrength !== "function") {
      options.clusterNodeStrength = (node) => clusterNodeStrength;
    }
    let sameTypeLeafMap;
    let clusters;
    if (leafCluster && nodeClusterBy) {
      sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
      clusters = Array.from(new Set(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.map((node) => node.data[nodeClusterBy]))) || [];
      options.centripetalOptions = Object.assign(basicCentripetal, {
        single: 100,
        leaf: (node) => {
          const { siblingLeaves, sameTypeLeaves } = sameTypeLeafMap[node.id] || {};
          if ((sameTypeLeaves === null || sameTypeLeaves === void 0 ? void 0 : sameTypeLeaves.length) === (siblingLeaves === null || siblingLeaves === void 0 ? void 0 : siblingLeaves.length) || (clusters === null || clusters === void 0 ? void 0 : clusters.length) === 1) {
            return 1;
          }
          return options.clusterNodeStrength(node);
        },
        others: 1,
        center: (node) => {
          const degree3 = calcGraph.getDegree(node.id, "both");
          if (!degree3) {
            return {
              x: 100,
              y: 100,
              z: 0
            };
          }
          let centerPos;
          if (degree3 === 1) {
            const { sameTypeLeaves = [] } = sameTypeLeafMap[node.id] || {};
            if (sameTypeLeaves.length === 1) {
              centerPos = void 0;
            } else if (sameTypeLeaves.length > 1) {
              centerPos = getAvgNodePosition(sameTypeLeaves);
            }
          } else {
            centerPos = void 0;
          }
          return {
            x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
            y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
            z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z
          };
        }
      });
    }
    if (clustering && nodeClusterBy) {
      if (!sameTypeLeafMap) {
        sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
      }
      if (!clusters) {
        clusters = Array.from(new Set(calcNodes.map((node) => node.data[nodeClusterBy])));
      }
      clusters = clusters.filter((item) => item !== void 0);
      const centerInfo = {};
      clusters.forEach((cluster) => {
        const sameTypeNodes = calcNodes.filter((node) => node.data[nodeClusterBy] === cluster).map((node) => calcGraph.getNode(node.id));
        centerInfo[cluster] = getAvgNodePosition(sameTypeNodes);
      });
      options.centripetalOptions = Object.assign(basicCentripetal, {
        single: (node) => options.clusterNodeStrength(node),
        leaf: (node) => options.clusterNodeStrength(node),
        others: (node) => options.clusterNodeStrength(node),
        center: (node) => {
          const centerPos = centerInfo[node.data[nodeClusterBy]];
          return {
            x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
            y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
            z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z
          };
        }
      });
    }
    const { leaf, single, others } = options.centripetalOptions || {};
    if (leaf && typeof leaf !== "function") {
      options.centripetalOptions.leaf = () => leaf;
    }
    if (single && typeof single !== "function") {
      options.centripetalOptions.single = () => single;
    }
    if (others && typeof others !== "function") {
      options.centripetalOptions.others = () => others;
    }
  }
  /**
   * One iteration.
   * @param calcGraph calculation graph
   * @param graph origin graph
   * @param iter current iteration index
   * @param velMap nodes' velocity map
   * @param options formatted layout options
   * @returns
   */
  runOneStep(calcGraph, graph2, iter, velMap, options) {
    const accMap = {};
    const calcNodes = calcGraph.getAllNodes();
    const calcEdges = calcGraph.getAllEdges();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
      return;
    const { monitor } = options;
    this.calRepulsive(calcGraph, accMap, options);
    if (calcEdges)
      this.calAttractive(calcGraph, accMap, options);
    this.calGravity(calcGraph, graph2, accMap, options);
    this.updateVelocity(calcGraph, accMap, velMap, options);
    if (monitor) {
      const energy = this.calTotalEnergy(accMap, calcNodes);
      monitor({
        energy,
        nodes: graph2.getAllNodes(),
        edges: graph2.getAllEdges(),
        iterations: iter
      });
    }
  }
  /**
   * Calculate graph energy for monitoring convergence.
   * @param accMap acceleration map
   * @param nodes calculation nodes
   * @returns energy
   */
  calTotalEnergy(accMap, nodes) {
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
      return 0;
    let energy = 0;
    nodes.forEach((node, i2) => {
      const vx = accMap[node.id].x;
      const vy = accMap[node.id].y;
      const vz = this.options.dimensions === 3 ? accMap[node.id].z : 0;
      const speed2 = vx * vx + vy * vy + vz * vz;
      const { mass = 1 } = node.data;
      energy += mass * speed2 * 0.5;
    });
    return energy;
  }
  /**
   * Calculate the repulsive forces according to coulombs law.
   * @param calcGraph calculation graph
   * @param accMap acceleration map
   * @param options formatted layout options
   */
  calRepulsive(calcGraph, accMap, options) {
    const { dimensions, factor, coulombDisScale } = options;
    forceNBody(calcGraph, factor, coulombDisScale * coulombDisScale, accMap, dimensions);
  }
  /**
   * Calculate the attractive forces according to hooks law.
   * @param calcGraph calculation graph
   * @param accMap acceleration map
   */
  calAttractive(calcGraph, accMap, options) {
    const { dimensions, nodeSize } = options;
    calcGraph.getAllEdges().forEach((edge, i2) => {
      const { source, target } = edge;
      const sourceNode = calcGraph.getNode(source);
      const targetNode = calcGraph.getNode(target);
      if (!sourceNode || !targetNode)
        return;
      let vecX = targetNode.data.x - sourceNode.data.x;
      let vecY = targetNode.data.y - sourceNode.data.y;
      let vecZ = dimensions === 3 ? targetNode.data.z - sourceNode.data.z : 0;
      if (!vecX && !vecY) {
        vecX = Math.random() * 0.01;
        vecY = Math.random() * 0.01;
        if (dimensions === 3 && !vecZ) {
          vecZ = Math.random() * 0.01;
        }
      }
      const vecLength = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ);
      if (vecLength < nodeSize(sourceNode) + nodeSize(targetNode))
        return;
      const direX = vecX / vecLength;
      const direY = vecY / vecLength;
      const direZ = vecZ / vecLength;
      const { linkDistance = 200, edgeStrength = 200 } = edge.data || {};
      const diff = linkDistance - vecLength;
      const param = diff * edgeStrength;
      const massSource = sourceNode.data.mass || 1;
      const massTarget = targetNode.data.mass || 1;
      const sourceMassRatio = 1 / massSource;
      const targetMassRatio = 1 / massTarget;
      const disX = direX * param;
      const disY = direY * param;
      const disZ = direZ * param;
      accMap[source].x -= disX * sourceMassRatio;
      accMap[source].y -= disY * sourceMassRatio;
      accMap[source].z -= disZ * sourceMassRatio;
      accMap[target].x += disX * targetMassRatio;
      accMap[target].y += disY * targetMassRatio;
      accMap[target].z += disZ * targetMassRatio;
    });
  }
  /**
   * Calculate the gravity forces toward center.
   * @param calcGraph calculation graph
   * @param graph origin graph
   * @param accMap acceleration map
   * @param options formatted layout options
   */
  calGravity(calcGraph, graph2, accMap, options) {
    const { getCenter } = options;
    const calcNodes = calcGraph.getAllNodes();
    const nodes = graph2.getAllNodes();
    const edges = graph2.getAllEdges();
    const { width: width2, height, center, gravity: defaultGravity, centripetalOptions } = options;
    if (!calcNodes)
      return;
    calcNodes.forEach((calcNode) => {
      const { id: id2, data: data2 } = calcNode;
      const { mass, x: x2, y: y2, z: z2 } = data2;
      const node = graph2.getNode(id2);
      let vecX = 0;
      let vecY = 0;
      let vecZ = 0;
      let gravity = defaultGravity;
      const inDegree = calcGraph.getDegree(id2, "in");
      const outDegree = calcGraph.getDegree(id2, "out");
      const degree3 = calcGraph.getDegree(id2, "both");
      const forceCenter2 = getCenter === null || getCenter === void 0 ? void 0 : getCenter(node, degree3);
      if (forceCenter2) {
        const [centerX, centerY, strength] = forceCenter2;
        vecX = x2 - centerX;
        vecY = y2 - centerY;
        gravity = strength;
      } else {
        vecX = x2 - center[0];
        vecY = y2 - center[1];
        vecZ = z2 - center[2];
      }
      if (gravity) {
        accMap[id2].x -= gravity * vecX / mass;
        accMap[id2].y -= gravity * vecY / mass;
        accMap[id2].z -= gravity * vecZ / mass;
      }
      if (centripetalOptions) {
        const { leaf, single, others, center: centriCenter } = centripetalOptions;
        const { x: centriX, y: centriY, z: centriZ, centerStrength } = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width2, height)) || {
          x: 0,
          y: 0,
          z: 0,
          centerStrength: 0
        };
        if (!isNumber(centriX) || !isNumber(centriY))
          return;
        const vx = (x2 - centriX) / mass;
        const vy = (y2 - centriY) / mass;
        const vz = (z2 - centriZ) / mass;
        if (centerStrength) {
          accMap[id2].x -= centerStrength * vx;
          accMap[id2].y -= centerStrength * vy;
          accMap[id2].z -= centerStrength * vz;
        }
        if (degree3 === 0) {
          const singleStrength = single(node);
          if (!singleStrength)
            return;
          accMap[id2].x -= singleStrength * vx;
          accMap[id2].y -= singleStrength * vy;
          accMap[id2].z -= singleStrength * vz;
          return;
        }
        if (inDegree === 0 || outDegree === 0) {
          const leafStrength = leaf(node, nodes, edges);
          if (!leafStrength)
            return;
          accMap[id2].x -= leafStrength * vx;
          accMap[id2].y -= leafStrength * vy;
          accMap[id2].z -= leafStrength * vz;
          return;
        }
        const othersStrength = others(node);
        if (!othersStrength)
          return;
        accMap[id2].x -= othersStrength * vx;
        accMap[id2].y -= othersStrength * vy;
        accMap[id2].z -= othersStrength * vz;
      }
    });
  }
  /**
   * Update the velocities for nodes.
   * @param calcGraph calculation graph
   * @param accMap acceleration map
   * @param velMap velocity map
   * @param options formatted layout options
   * @returns
   */
  updateVelocity(calcGraph, accMap, velMap, options) {
    const { damping, maxSpeed, interval: interval2, dimensions } = options;
    const calcNodes = calcGraph.getAllNodes();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
      return;
    calcNodes.forEach((calcNode) => {
      const { id: id2 } = calcNode;
      let vx = (velMap[id2].x + accMap[id2].x * interval2) * damping || 0.01;
      let vy = (velMap[id2].y + accMap[id2].y * interval2) * damping || 0.01;
      let vz = dimensions === 3 ? (velMap[id2].z + accMap[id2].z * interval2) * damping || 0.01 : 0;
      const vLength = Math.sqrt(vx * vx + vy * vy + vz * vz);
      if (vLength > maxSpeed) {
        const param2 = maxSpeed / vLength;
        vx = param2 * vx;
        vy = param2 * vy;
        vz = param2 * vz;
      }
      velMap[id2] = {
        x: vx,
        y: vy,
        z: vz
      };
    });
  }
  /**
   * Update nodes' positions.
   * @param graph origin graph
   * @param calcGraph calculatition graph
   * @param velMap velocity map
   * @param options formatted layou options
   * @returns
   */
  updatePosition(graph2, calcGraph, velMap, options) {
    const { distanceThresholdMode, interval: interval2, dimensions } = options;
    const calcNodes = calcGraph.getAllNodes();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length)) {
      this.judgingDistance = 0;
      return;
    }
    let sum = 0;
    if (distanceThresholdMode === "max")
      this.judgingDistance = -Infinity;
    else if (distanceThresholdMode === "min")
      this.judgingDistance = Infinity;
    calcNodes.forEach((calcNode) => {
      const { id: id2 } = calcNode;
      const node = graph2.getNode(id2);
      if (isNumber(node.data.fx) && isNumber(node.data.fy)) {
        calcGraph.mergeNodeData(id2, {
          x: node.data.fx,
          y: node.data.fy,
          z: dimensions === 3 ? node.data.fz : void 0
        });
        return;
      }
      const distX = velMap[id2].x * interval2;
      const distY = velMap[id2].y * interval2;
      const distZ = dimensions === 3 ? velMap[id2].z * interval2 : 0;
      calcGraph.mergeNodeData(id2, {
        x: calcNode.data.x + distX,
        y: calcNode.data.y + distY,
        z: calcNode.data.z + distZ
      });
      const distanceMagnitude = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
      switch (distanceThresholdMode) {
        case "max":
          if (this.judgingDistance < distanceMagnitude) {
            this.judgingDistance = distanceMagnitude;
          }
          break;
        case "min":
          if (this.judgingDistance > distanceMagnitude) {
            this.judgingDistance = distanceMagnitude;
          }
          break;
        default:
          sum = sum + distanceMagnitude;
          break;
      }
    });
    if (!distanceThresholdMode || distanceThresholdMode === "mean") {
      this.judgingDistance = sum / calcNodes.length;
    }
  }
}
const getSameTypeLeafMap = (calcGraph, nodeClusterBy) => {
  const calcNodes = calcGraph.getAllNodes();
  if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
    return {};
  const sameTypeLeafMap = {};
  calcNodes.forEach((node, i2) => {
    const degree3 = calcGraph.getDegree(node.id, "both");
    if (degree3 === 1) {
      sameTypeLeafMap[node.id] = getCoreNodeAndSiblingLeaves(calcGraph, "leaf", node, nodeClusterBy);
    }
  });
  return sameTypeLeafMap;
};
const getCoreNodeAndSiblingLeaves = (calcGraph, type, node, nodeClusterBy) => {
  const inDegree = calcGraph.getDegree(node.id, "in");
  const outDegree = calcGraph.getDegree(node.id, "out");
  let coreNode = node;
  let siblingLeaves = [];
  if (inDegree === 0) {
    coreNode = calcGraph.getSuccessors(node.id)[0];
    siblingLeaves = calcGraph.getNeighbors(coreNode.id);
  } else if (outDegree === 0) {
    coreNode = calcGraph.getPredecessors(node.id)[0];
    siblingLeaves = calcGraph.getNeighbors(coreNode.id);
  }
  siblingLeaves = siblingLeaves.filter((node2) => calcGraph.getDegree(node2.id, "in") === 0 || calcGraph.getDegree(node2.id, "out") === 0);
  const sameTypeLeaves = getSameTypeNodes(calcGraph, type, nodeClusterBy, node, siblingLeaves);
  return { coreNode, siblingLeaves, sameTypeLeaves };
};
const getSameTypeNodes = (calcGraph, type, nodeClusterBy, node, relativeNodes) => {
  const typeName = node.data[nodeClusterBy] || "";
  let sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter((item) => item.data[nodeClusterBy] === typeName)) || [];
  {
    sameTypeNodes = sameTypeNodes.filter((item) => calcGraph.getDegree(item.id, "in") === 0 || calcGraph.getDegree(item.id, "out") === 0);
  }
  return sameTypeNodes;
};
const getAvgNodePosition = (nodes) => {
  const totalNodes = { x: 0, y: 0 };
  nodes.forEach((node) => {
    const { x: x2, y: y2 } = node.data;
    totalNodes.x += x2 || 0;
    totalNodes.y += y2 || 0;
  });
  const length2 = nodes.length || 1;
  return {
    x: totalNodes.x / length2,
    y: totalNodes.y / length2
  };
};
const formatOutNodes = (graph2, layoutNodes) => layoutNodes.map((calcNode) => {
  const { id: id2, data: data2 } = calcNode;
  const node = graph2.getNode(id2);
  return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { x: data2.x, y: data2.y, z: data2.z }) });
});
var matrix2 = {};
const toString = Object.prototype.toString;
function isAnyArray$1(value) {
  const tag = toString.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}
const libEsm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isAnyArray: isAnyArray$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(libEsm);
function max$1(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray$1(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var maxValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] > maxValue) maxValue = input[i2];
  }
  return maxValue;
}
function min$1(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray$1(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var minValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] < minValue) minValue = input[i2];
  }
  return minValue;
}
function rescale$1(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray$1(input)) {
    throw new TypeError("input must be an array");
  } else if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var output;
  if (options.output !== void 0) {
    if (!isAnyArray$1(options.output)) {
      throw new TypeError("output option must be an array if specified");
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }
  var currentMin = min$1(input);
  var currentMax = max$1(input);
  if (currentMin === currentMax) {
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  }
  var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
  if (minValue >= maxValue) {
    throw new RangeError("min option must be smaller than max option");
  }
  var factor = (maxValue - minValue) / (currentMax - currentMin);
  for (var i2 = 0; i2 < input.length; i2++) {
    output[i2] = (input[i2] - currentMin) * factor + minValue;
  }
  return output;
}
const libEs6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: rescale$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(libEs6);
Object.defineProperty(matrix2, "__esModule", { value: true });
var isAnyArray = require$$0;
var rescale = require$$1;
const indent = " ".repeat(2);
const indentData = " ".repeat(4);
function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}
function inspectMatrixWithOptions(matrix3, options = {}) {
  const {
    maxRows = 15,
    maxColumns = 10,
    maxNumSize = 8,
    padMinus = "auto"
  } = options;
  return `${matrix3.constructor.name} {
${indent}[
${indentData}${inspectData(matrix3, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix3.rows}
${indent}columns: ${matrix3.columns}
}`;
}
function inspectData(matrix3, maxRows, maxColumns, maxNumSize, padMinus) {
  const { rows, columns } = matrix3;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];
  if (padMinus === "auto") {
    padMinus = false;
    loop: for (let i2 = 0; i2 < maxI; i2++) {
      for (let j = 0; j < maxJ; j++) {
        if (matrix3.get(i2, j) < 0) {
          padMinus = true;
          break loop;
        }
      }
    }
  }
  for (let i2 = 0; i2 < maxI; i2++) {
    let line2 = [];
    for (let j = 0; j < maxJ; j++) {
      line2.push(formatNumber(matrix3.get(i2, j), maxNumSize, padMinus));
    }
    result.push(`${line2.join(" ")}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`
${indentData}`);
}
function formatNumber(num, maxNumSize, padMinus) {
  return (num >= 0 && padMinus ? ` ${formatNumber2(num, maxNumSize - 1)}` : formatNumber2(num, maxNumSize)).padEnd(maxNumSize);
}
function formatNumber2(num, len2) {
  let str2 = num.toString();
  if (str2.length <= len2) return str2;
  let fix = num.toFixed(len2);
  if (fix.length > len2) {
    fix = num.toFixed(Math.max(0, len2 - (fix.length - len2)));
  }
  if (fix.length <= len2 && !fix.startsWith("0.000") && !fix.startsWith("-0.000")) {
    return fix;
  }
  let exp = num.toExponential(len2);
  if (exp.length > len2) {
    exp = num.toExponential(Math.max(0, len2 - (exp.length - len2)));
  }
  return exp.slice(0);
}
function installMathOperations(AbstractMatrix2, Matrix2) {
  AbstractMatrix2.prototype.add = function add2(value) {
    if (typeof value === "number") return this.addS(value);
    return this.addM(value);
  };
  AbstractMatrix2.prototype.addS = function addS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) + value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.addM = function addM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) + matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.add = function add2(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.add(value);
  };
  AbstractMatrix2.prototype.sub = function sub2(value) {
    if (typeof value === "number") return this.subS(value);
    return this.subM(value);
  };
  AbstractMatrix2.prototype.subS = function subS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) - value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.subM = function subM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) - matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.sub = function sub2(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.sub(value);
  };
  AbstractMatrix2.prototype.subtract = AbstractMatrix2.prototype.sub;
  AbstractMatrix2.prototype.subtractS = AbstractMatrix2.prototype.subS;
  AbstractMatrix2.prototype.subtractM = AbstractMatrix2.prototype.subM;
  AbstractMatrix2.subtract = AbstractMatrix2.sub;
  AbstractMatrix2.prototype.mul = function mul2(value) {
    if (typeof value === "number") return this.mulS(value);
    return this.mulM(value);
  };
  AbstractMatrix2.prototype.mulS = function mulS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) * value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.mulM = function mulM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) * matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.mul = function mul2(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.mul(value);
  };
  AbstractMatrix2.prototype.multiply = AbstractMatrix2.prototype.mul;
  AbstractMatrix2.prototype.multiplyS = AbstractMatrix2.prototype.mulS;
  AbstractMatrix2.prototype.multiplyM = AbstractMatrix2.prototype.mulM;
  AbstractMatrix2.multiply = AbstractMatrix2.mul;
  AbstractMatrix2.prototype.div = function div(value) {
    if (typeof value === "number") return this.divS(value);
    return this.divM(value);
  };
  AbstractMatrix2.prototype.divS = function divS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) / value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.divM = function divM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) / matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.div = function div(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.div(value);
  };
  AbstractMatrix2.prototype.divide = AbstractMatrix2.prototype.div;
  AbstractMatrix2.prototype.divideS = AbstractMatrix2.prototype.divS;
  AbstractMatrix2.prototype.divideM = AbstractMatrix2.prototype.divM;
  AbstractMatrix2.divide = AbstractMatrix2.div;
  AbstractMatrix2.prototype.mod = function mod2(value) {
    if (typeof value === "number") return this.modS(value);
    return this.modM(value);
  };
  AbstractMatrix2.prototype.modS = function modS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) % value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.modM = function modM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) % matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.mod = function mod2(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.mod(value);
  };
  AbstractMatrix2.prototype.modulus = AbstractMatrix2.prototype.mod;
  AbstractMatrix2.prototype.modulusS = AbstractMatrix2.prototype.modS;
  AbstractMatrix2.prototype.modulusM = AbstractMatrix2.prototype.modM;
  AbstractMatrix2.modulus = AbstractMatrix2.mod;
  AbstractMatrix2.prototype.and = function and(value) {
    if (typeof value === "number") return this.andS(value);
    return this.andM(value);
  };
  AbstractMatrix2.prototype.andS = function andS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) & value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.andM = function andM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) & matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.and = function and(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.and(value);
  };
  AbstractMatrix2.prototype.or = function or(value) {
    if (typeof value === "number") return this.orS(value);
    return this.orM(value);
  };
  AbstractMatrix2.prototype.orS = function orS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) | value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.orM = function orM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) | matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.or = function or(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.or(value);
  };
  AbstractMatrix2.prototype.xor = function xor(value) {
    if (typeof value === "number") return this.xorS(value);
    return this.xorM(value);
  };
  AbstractMatrix2.prototype.xorS = function xorS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) ^ value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.xorM = function xorM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) ^ matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.xor = function xor(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.xor(value);
  };
  AbstractMatrix2.prototype.leftShift = function leftShift(value) {
    if (typeof value === "number") return this.leftShiftS(value);
    return this.leftShiftM(value);
  };
  AbstractMatrix2.prototype.leftShiftS = function leftShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) << value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.leftShiftM = function leftShiftM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) << matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.leftShift = function leftShift(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.leftShift(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === "number") return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) >> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) >> matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.signPropagatingRightShift = function signPropagatingRightShift(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.signPropagatingRightShift(value);
  };
  AbstractMatrix2.prototype.rightShift = function rightShift(value) {
    if (typeof value === "number") return this.rightShiftS(value);
    return this.rightShiftM(value);
  };
  AbstractMatrix2.prototype.rightShiftS = function rightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) >>> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.rightShiftM = function rightShiftM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) >>> matrix3.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.rightShift = function rightShift(matrix3, value) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix2.prototype.zeroFillRightShift = AbstractMatrix2.prototype.rightShift;
  AbstractMatrix2.prototype.zeroFillRightShiftS = AbstractMatrix2.prototype.rightShiftS;
  AbstractMatrix2.prototype.zeroFillRightShiftM = AbstractMatrix2.prototype.rightShiftM;
  AbstractMatrix2.zeroFillRightShift = AbstractMatrix2.rightShift;
  AbstractMatrix2.prototype.not = function not() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, ~this.get(i2, j));
      }
    }
    return this;
  };
  AbstractMatrix2.not = function not(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.not();
  };
  AbstractMatrix2.prototype.abs = function abs() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.abs(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.abs = function abs(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.abs();
  };
  AbstractMatrix2.prototype.acos = function acos() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.acos(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.acos = function acos(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.acos();
  };
  AbstractMatrix2.prototype.acosh = function acosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.acosh(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.acosh = function acosh(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.acosh();
  };
  AbstractMatrix2.prototype.asin = function asin() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.asin(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.asin = function asin(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.asin();
  };
  AbstractMatrix2.prototype.asinh = function asinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.asinh(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.asinh = function asinh(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.asinh();
  };
  AbstractMatrix2.prototype.atan = function atan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.atan(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.atan = function atan(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.atan();
  };
  AbstractMatrix2.prototype.atanh = function atanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.atanh(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.atanh = function atanh(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.atanh();
  };
  AbstractMatrix2.prototype.cbrt = function cbrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.cbrt(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.cbrt = function cbrt(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.cbrt();
  };
  AbstractMatrix2.prototype.ceil = function ceil() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.ceil(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.ceil = function ceil(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.ceil();
  };
  AbstractMatrix2.prototype.clz32 = function clz32() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.clz32(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.clz32 = function clz32(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.clz32();
  };
  AbstractMatrix2.prototype.cos = function cos() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.cos(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.cos = function cos(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.cos();
  };
  AbstractMatrix2.prototype.cosh = function cosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.cosh(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.cosh = function cosh(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.cosh();
  };
  AbstractMatrix2.prototype.exp = function exp() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.exp(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.exp = function exp(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.exp();
  };
  AbstractMatrix2.prototype.expm1 = function expm1() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.expm1(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.expm1 = function expm1(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.expm1();
  };
  AbstractMatrix2.prototype.floor = function floor() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.floor(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.floor = function floor(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.floor();
  };
  AbstractMatrix2.prototype.fround = function fround() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.fround(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.fround = function fround(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.fround();
  };
  AbstractMatrix2.prototype.log = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.log(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.log = function log2(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.log();
  };
  AbstractMatrix2.prototype.log1p = function log1p() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.log1p(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.log1p = function log1p(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.log1p();
  };
  AbstractMatrix2.prototype.log10 = function log10() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.log10(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.log10 = function log10(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.log10();
  };
  AbstractMatrix2.prototype.log2 = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.log2(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.log2 = function log2(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.log2();
  };
  AbstractMatrix2.prototype.round = function round2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.round(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.round = function round2(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.round();
  };
  AbstractMatrix2.prototype.sign = function sign() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.sign(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.sign = function sign(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.sign();
  };
  AbstractMatrix2.prototype.sin = function sin() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.sin(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.sin = function sin(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.sin();
  };
  AbstractMatrix2.prototype.sinh = function sinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.sinh(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.sinh = function sinh(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.sinh();
  };
  AbstractMatrix2.prototype.sqrt = function sqrt2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.sqrt(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.sqrt = function sqrt2(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.sqrt();
  };
  AbstractMatrix2.prototype.tan = function tan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.tan(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.tan = function tan(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.tan();
  };
  AbstractMatrix2.prototype.tanh = function tanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.tanh(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.tanh = function tanh(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.tanh();
  };
  AbstractMatrix2.prototype.trunc = function trunc() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, Math.trunc(this.get(i2, j)));
      }
    }
    return this;
  };
  AbstractMatrix2.trunc = function trunc(matrix3) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.trunc();
  };
  AbstractMatrix2.pow = function pow2(matrix3, arg0) {
    const newMatrix = new Matrix2(matrix3);
    return newMatrix.pow(arg0);
  };
  AbstractMatrix2.prototype.pow = function pow2(value) {
    if (typeof value === "number") return this.powS(value);
    return this.powM(value);
  };
  AbstractMatrix2.prototype.powS = function powS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) ** value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.powM = function powM(matrix3) {
    matrix3 = Matrix2.checkMatrix(matrix3);
    if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) ** matrix3.get(i2, j));
      }
    }
    return this;
  };
}
function checkRowIndex(matrix3, index2, outer) {
  let max2 = outer ? matrix3.rows : matrix3.rows - 1;
  if (index2 < 0 || index2 > max2) {
    throw new RangeError("Row index out of range");
  }
}
function checkColumnIndex(matrix3, index2, outer) {
  let max2 = outer ? matrix3.columns : matrix3.columns - 1;
  if (index2 < 0 || index2 > max2) {
    throw new RangeError("Column index out of range");
  }
}
function checkRowVector(matrix3, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix3.columns) {
    throw new RangeError(
      "vector size must be the same as the number of columns"
    );
  }
  return vector;
}
function checkColumnVector(matrix3, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix3.rows) {
    throw new RangeError("vector size must be the same as the number of rows");
  }
  return vector;
}
function checkRowIndices(matrix3, rowIndices) {
  if (!isAnyArray.isAnyArray(rowIndices)) {
    throw new TypeError("row indices must be an array");
  }
  for (let i2 = 0; i2 < rowIndices.length; i2++) {
    if (rowIndices[i2] < 0 || rowIndices[i2] >= matrix3.rows) {
      throw new RangeError("row indices are out of range");
    }
  }
}
function checkColumnIndices(matrix3, columnIndices) {
  if (!isAnyArray.isAnyArray(columnIndices)) {
    throw new TypeError("column indices must be an array");
  }
  for (let i2 = 0; i2 < columnIndices.length; i2++) {
    if (columnIndices[i2] < 0 || columnIndices[i2] >= matrix3.columns) {
      throw new RangeError("column indices are out of range");
    }
  }
}
function checkRange(matrix3, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError("expected 4 arguments");
  }
  checkNumber("startRow", startRow);
  checkNumber("endRow", endRow);
  checkNumber("startColumn", startColumn);
  checkNumber("endColumn", endColumn);
  if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix3.rows || endRow < 0 || endRow >= matrix3.rows || startColumn < 0 || startColumn >= matrix3.columns || endColumn < 0 || endColumn >= matrix3.columns) {
    throw new RangeError("Submatrix indices are out of range");
  }
}
function newArray(length2, value = 0) {
  let array = [];
  for (let i2 = 0; i2 < length2; i2++) {
    array.push(value);
  }
  return array;
}
function checkNumber(name, value) {
  if (typeof value !== "number") {
    throw new TypeError(`${name} must be a number`);
  }
}
function checkNonEmpty(matrix3) {
  if (matrix3.isEmpty()) {
    throw new Error("Empty matrix has no elements to index");
  }
}
function sumByRow(matrix3) {
  let sum = newArray(matrix3.rows);
  for (let i2 = 0; i2 < matrix3.rows; ++i2) {
    for (let j = 0; j < matrix3.columns; ++j) {
      sum[i2] += matrix3.get(i2, j);
    }
  }
  return sum;
}
function sumByColumn(matrix3) {
  let sum = newArray(matrix3.columns);
  for (let i2 = 0; i2 < matrix3.rows; ++i2) {
    for (let j = 0; j < matrix3.columns; ++j) {
      sum[j] += matrix3.get(i2, j);
    }
  }
  return sum;
}
function sumAll(matrix3) {
  let v2 = 0;
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      v2 += matrix3.get(i2, j);
    }
  }
  return v2;
}
function productByRow(matrix3) {
  let sum = newArray(matrix3.rows, 1);
  for (let i2 = 0; i2 < matrix3.rows; ++i2) {
    for (let j = 0; j < matrix3.columns; ++j) {
      sum[i2] *= matrix3.get(i2, j);
    }
  }
  return sum;
}
function productByColumn(matrix3) {
  let sum = newArray(matrix3.columns, 1);
  for (let i2 = 0; i2 < matrix3.rows; ++i2) {
    for (let j = 0; j < matrix3.columns; ++j) {
      sum[j] *= matrix3.get(i2, j);
    }
  }
  return sum;
}
function productAll(matrix3) {
  let v2 = 1;
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      v2 *= matrix3.get(i2, j);
    }
  }
  return v2;
}
function varianceByRow(matrix3, unbiased, mean) {
  const rows = matrix3.rows;
  const cols = matrix3.columns;
  const variance = [];
  for (let i2 = 0; i2 < rows; i2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x2 = 0;
    for (let j = 0; j < cols; j++) {
      x2 = matrix3.get(i2, j) - mean[i2];
      sum1 += x2;
      sum2 += x2 * x2;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / cols) / cols);
    }
  }
  return variance;
}
function varianceByColumn(matrix3, unbiased, mean) {
  const rows = matrix3.rows;
  const cols = matrix3.columns;
  const variance = [];
  for (let j = 0; j < cols; j++) {
    let sum1 = 0;
    let sum2 = 0;
    let x2 = 0;
    for (let i2 = 0; i2 < rows; i2++) {
      x2 = matrix3.get(i2, j) - mean[j];
      sum1 += x2;
      sum2 += x2 * x2;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / rows) / rows);
    }
  }
  return variance;
}
function varianceAll(matrix3, unbiased, mean) {
  const rows = matrix3.rows;
  const cols = matrix3.columns;
  const size = rows * cols;
  let sum1 = 0;
  let sum2 = 0;
  let x2 = 0;
  for (let i2 = 0; i2 < rows; i2++) {
    for (let j = 0; j < cols; j++) {
      x2 = matrix3.get(i2, j) - mean;
      sum1 += x2;
      sum2 += x2 * x2;
    }
  }
  if (unbiased) {
    return (sum2 - sum1 * sum1 / size) / (size - 1);
  } else {
    return (sum2 - sum1 * sum1 / size) / size;
  }
}
function centerByRow(matrix3, mean) {
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      matrix3.set(i2, j, matrix3.get(i2, j) - mean[i2]);
    }
  }
}
function centerByColumn(matrix3, mean) {
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      matrix3.set(i2, j, matrix3.get(i2, j) - mean[j]);
    }
  }
}
function centerAll(matrix3, mean) {
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      matrix3.set(i2, j, matrix3.get(i2, j) - mean);
    }
  }
}
function getScaleByRow(matrix3) {
  const scale3 = [];
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    let sum = 0;
    for (let j = 0; j < matrix3.columns; j++) {
      sum += matrix3.get(i2, j) ** 2 / (matrix3.columns - 1);
    }
    scale3.push(Math.sqrt(sum));
  }
  return scale3;
}
function scaleByRow(matrix3, scale3) {
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      matrix3.set(i2, j, matrix3.get(i2, j) / scale3[i2]);
    }
  }
}
function getScaleByColumn(matrix3) {
  const scale3 = [];
  for (let j = 0; j < matrix3.columns; j++) {
    let sum = 0;
    for (let i2 = 0; i2 < matrix3.rows; i2++) {
      sum += matrix3.get(i2, j) ** 2 / (matrix3.rows - 1);
    }
    scale3.push(Math.sqrt(sum));
  }
  return scale3;
}
function scaleByColumn(matrix3, scale3) {
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      matrix3.set(i2, j, matrix3.get(i2, j) / scale3[j]);
    }
  }
}
function getScaleAll(matrix3) {
  const divider = matrix3.size - 1;
  let sum = 0;
  for (let j = 0; j < matrix3.columns; j++) {
    for (let i2 = 0; i2 < matrix3.rows; i2++) {
      sum += matrix3.get(i2, j) ** 2 / divider;
    }
  }
  return Math.sqrt(sum);
}
function scaleAll(matrix3, scale3) {
  for (let i2 = 0; i2 < matrix3.rows; i2++) {
    for (let j = 0; j < matrix3.columns; j++) {
      matrix3.set(i2, j, matrix3.get(i2, j) / scale3);
    }
  }
}
class AbstractMatrix {
  static from1DArray(newRows, newColumns, newData) {
    let length2 = newRows * newColumns;
    if (length2 !== newData.length) {
      throw new RangeError("data length does not match given dimensions");
    }
    let newMatrix = new Matrix$1(newRows, newColumns);
    for (let row2 = 0; row2 < newRows; row2++) {
      for (let column = 0; column < newColumns; column++) {
        newMatrix.set(row2, column, newData[row2 * newColumns + column]);
      }
    }
    return newMatrix;
  }
  static rowVector(newData) {
    let vector = new Matrix$1(1, newData.length);
    for (let i2 = 0; i2 < newData.length; i2++) {
      vector.set(0, i2, newData[i2]);
    }
    return vector;
  }
  static columnVector(newData) {
    let vector = new Matrix$1(newData.length, 1);
    for (let i2 = 0; i2 < newData.length; i2++) {
      vector.set(i2, 0, newData[i2]);
    }
    return vector;
  }
  static zeros(rows, columns) {
    return new Matrix$1(rows, columns);
  }
  static ones(rows, columns) {
    return new Matrix$1(rows, columns).fill(1);
  }
  static rand(rows, columns, options = {}) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { random = Math.random } = options;
    let matrix3 = new Matrix$1(rows, columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        matrix3.set(i2, j, random());
      }
    }
    return matrix3;
  }
  static randInt(rows, columns, options = {}) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { min: min2 = 0, max: max2 = 1e3, random = Math.random } = options;
    if (!Number.isInteger(min2)) throw new TypeError("min must be an integer");
    if (!Number.isInteger(max2)) throw new TypeError("max must be an integer");
    if (min2 >= max2) throw new RangeError("min must be smaller than max");
    let interval2 = max2 - min2;
    let matrix3 = new Matrix$1(rows, columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        let value = min2 + Math.round(random() * interval2);
        matrix3.set(i2, j, value);
      }
    }
    return matrix3;
  }
  static eye(rows, columns, value) {
    if (columns === void 0) columns = rows;
    if (value === void 0) value = 1;
    let min2 = Math.min(rows, columns);
    let matrix3 = this.zeros(rows, columns);
    for (let i2 = 0; i2 < min2; i2++) {
      matrix3.set(i2, i2, value);
    }
    return matrix3;
  }
  static diag(data2, rows, columns) {
    let l2 = data2.length;
    if (rows === void 0) rows = l2;
    if (columns === void 0) columns = rows;
    let min2 = Math.min(l2, rows, columns);
    let matrix3 = this.zeros(rows, columns);
    for (let i2 = 0; i2 < min2; i2++) {
      matrix3.set(i2, i2, data2[i2]);
    }
    return matrix3;
  }
  static min(matrix1, matrix22) {
    matrix1 = this.checkMatrix(matrix1);
    matrix22 = this.checkMatrix(matrix22);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new Matrix$1(rows, columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        result.set(i2, j, Math.min(matrix1.get(i2, j), matrix22.get(i2, j)));
      }
    }
    return result;
  }
  static max(matrix1, matrix22) {
    matrix1 = this.checkMatrix(matrix1);
    matrix22 = this.checkMatrix(matrix22);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new this(rows, columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        result.set(i2, j, Math.max(matrix1.get(i2, j), matrix22.get(i2, j)));
      }
    }
    return result;
  }
  static checkMatrix(value) {
    return AbstractMatrix.isMatrix(value) ? value : new Matrix$1(value);
  }
  static isMatrix(value) {
    return value != null && value.klass === "Matrix";
  }
  get size() {
    return this.rows * this.columns;
  }
  apply(callback) {
    if (typeof callback !== "function") {
      throw new TypeError("callback must be a function");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        callback.call(this, i2, j);
      }
    }
    return this;
  }
  to1DArray() {
    let array = [];
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        array.push(this.get(i2, j));
      }
    }
    return array;
  }
  to2DArray() {
    let copy2 = [];
    for (let i2 = 0; i2 < this.rows; i2++) {
      copy2.push([]);
      for (let j = 0; j < this.columns; j++) {
        copy2[i2].push(this.get(i2, j));
      }
    }
    return copy2;
  }
  toJSON() {
    return this.to2DArray();
  }
  isRowVector() {
    return this.rows === 1;
  }
  isColumnVector() {
    return this.columns === 1;
  }
  isVector() {
    return this.rows === 1 || this.columns === 1;
  }
  isSquare() {
    return this.rows === this.columns;
  }
  isEmpty() {
    return this.rows === 0 || this.columns === 0;
  }
  isSymmetric() {
    if (this.isSquare()) {
      for (let i2 = 0; i2 < this.rows; i2++) {
        for (let j = 0; j <= i2; j++) {
          if (this.get(i2, j) !== this.get(j, i2)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }
  isDistance() {
    if (!this.isSymmetric()) return false;
    for (let i2 = 0; i2 < this.rows; i2++) {
      if (this.get(i2, i2) !== 0) return false;
    }
    return true;
  }
  isEchelonForm() {
    let i2 = 0;
    let j = 0;
    let previousColumn = -1;
    let isEchelonForm = true;
    let checked = false;
    while (i2 < this.rows && isEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i2, j) === 0) {
          j++;
        } else if (this.get(i2, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isEchelonForm = false;
          checked = true;
        }
      }
      i2++;
    }
    return isEchelonForm;
  }
  isReducedEchelonForm() {
    let i2 = 0;
    let j = 0;
    let previousColumn = -1;
    let isReducedEchelonForm = true;
    let checked = false;
    while (i2 < this.rows && isReducedEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i2, j) === 0) {
          j++;
        } else if (this.get(i2, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isReducedEchelonForm = false;
          checked = true;
        }
      }
      for (let k = j + 1; k < this.rows; k++) {
        if (this.get(i2, k) !== 0) {
          isReducedEchelonForm = false;
        }
      }
      i2++;
    }
    return isReducedEchelonForm;
  }
  echelonForm() {
    let result = this.clone();
    let h2 = 0;
    let k = 0;
    while (h2 < result.rows && k < result.columns) {
      let iMax = h2;
      for (let i2 = h2; i2 < result.rows; i2++) {
        if (result.get(i2, k) > result.get(iMax, k)) {
          iMax = i2;
        }
      }
      if (result.get(iMax, k) === 0) {
        k++;
      } else {
        result.swapRows(h2, iMax);
        let tmp2 = result.get(h2, k);
        for (let j = k; j < result.columns; j++) {
          result.set(h2, j, result.get(h2, j) / tmp2);
        }
        for (let i2 = h2 + 1; i2 < result.rows; i2++) {
          let factor = result.get(i2, k) / result.get(h2, k);
          result.set(i2, k, 0);
          for (let j = k + 1; j < result.columns; j++) {
            result.set(i2, j, result.get(i2, j) - result.get(h2, j) * factor);
          }
        }
        h2++;
        k++;
      }
    }
    return result;
  }
  reducedEchelonForm() {
    let result = this.echelonForm();
    let m3 = result.columns;
    let n2 = result.rows;
    let h2 = n2 - 1;
    while (h2 >= 0) {
      if (result.maxRow(h2) === 0) {
        h2--;
      } else {
        let p2 = 0;
        let pivot = false;
        while (p2 < n2 && pivot === false) {
          if (result.get(h2, p2) === 1) {
            pivot = true;
          } else {
            p2++;
          }
        }
        for (let i2 = 0; i2 < h2; i2++) {
          let factor = result.get(i2, p2);
          for (let j = p2; j < m3; j++) {
            let tmp2 = result.get(i2, j) - factor * result.get(h2, j);
            result.set(i2, j, tmp2);
          }
        }
        h2--;
      }
    }
    return result;
  }
  set() {
    throw new Error("set method is unimplemented");
  }
  get() {
    throw new Error("get method is unimplemented");
  }
  repeat(options = {}) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { rows = 1, columns = 1 } = options;
    if (!Number.isInteger(rows) || rows <= 0) {
      throw new TypeError("rows must be a positive integer");
    }
    if (!Number.isInteger(columns) || columns <= 0) {
      throw new TypeError("columns must be a positive integer");
    }
    let matrix3 = new Matrix$1(this.rows * rows, this.columns * columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        matrix3.setSubMatrix(this, this.rows * i2, this.columns * j);
      }
    }
    return matrix3;
  }
  fill(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, value);
      }
    }
    return this;
  }
  neg() {
    return this.mulS(-1);
  }
  getRow(index2) {
    checkRowIndex(this, index2);
    let row2 = [];
    for (let i2 = 0; i2 < this.columns; i2++) {
      row2.push(this.get(index2, i2));
    }
    return row2;
  }
  getRowVector(index2) {
    return Matrix$1.rowVector(this.getRow(index2));
  }
  setRow(index2, array) {
    checkRowIndex(this, index2);
    array = checkRowVector(this, array);
    for (let i2 = 0; i2 < this.columns; i2++) {
      this.set(index2, i2, array[i2]);
    }
    return this;
  }
  swapRows(row1, row2) {
    checkRowIndex(this, row1);
    checkRowIndex(this, row2);
    for (let i2 = 0; i2 < this.columns; i2++) {
      let temp = this.get(row1, i2);
      this.set(row1, i2, this.get(row2, i2));
      this.set(row2, i2, temp);
    }
    return this;
  }
  getColumn(index2) {
    checkColumnIndex(this, index2);
    let column = [];
    for (let i2 = 0; i2 < this.rows; i2++) {
      column.push(this.get(i2, index2));
    }
    return column;
  }
  getColumnVector(index2) {
    return Matrix$1.columnVector(this.getColumn(index2));
  }
  setColumn(index2, array) {
    checkColumnIndex(this, index2);
    array = checkColumnVector(this, array);
    for (let i2 = 0; i2 < this.rows; i2++) {
      this.set(i2, index2, array[i2]);
    }
    return this;
  }
  swapColumns(column1, column2) {
    checkColumnIndex(this, column1);
    checkColumnIndex(this, column2);
    for (let i2 = 0; i2 < this.rows; i2++) {
      let temp = this.get(i2, column1);
      this.set(i2, column1, this.get(i2, column2));
      this.set(i2, column2, temp);
    }
    return this;
  }
  addRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) + vector[j]);
      }
    }
    return this;
  }
  subRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) - vector[j]);
      }
    }
    return this;
  }
  mulRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) * vector[j]);
      }
    }
    return this;
  }
  divRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) / vector[j]);
      }
    }
    return this;
  }
  addColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) + vector[i2]);
      }
    }
    return this;
  }
  subColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) - vector[i2]);
      }
    }
    return this;
  }
  mulColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) * vector[i2]);
      }
    }
    return this;
  }
  divColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i2, j, this.get(i2, j) / vector[i2]);
      }
    }
    return this;
  }
  mulRow(index2, value) {
    checkRowIndex(this, index2);
    for (let i2 = 0; i2 < this.columns; i2++) {
      this.set(index2, i2, this.get(index2, i2) * value);
    }
    return this;
  }
  mulColumn(index2, value) {
    checkColumnIndex(this, index2);
    for (let i2 = 0; i2 < this.rows; i2++) {
      this.set(i2, index2, this.get(i2, index2) * value);
    }
    return this;
  }
  max(by) {
    if (this.isEmpty()) {
      return NaN;
    }
    switch (by) {
      case "row": {
        const max2 = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
        for (let row2 = 0; row2 < this.rows; row2++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row2, column) > max2[row2]) {
              max2[row2] = this.get(row2, column);
            }
          }
        }
        return max2;
      }
      case "column": {
        const max2 = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
        for (let row2 = 0; row2 < this.rows; row2++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row2, column) > max2[column]) {
              max2[column] = this.get(row2, column);
            }
          }
        }
        return max2;
      }
      case void 0: {
        let max2 = this.get(0, 0);
        for (let row2 = 0; row2 < this.rows; row2++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row2, column) > max2) {
              max2 = this.get(row2, column);
            }
          }
        }
        return max2;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  maxIndex() {
    checkNonEmpty(this);
    let v2 = this.get(0, 0);
    let idx = [0, 0];
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i2, j) > v2) {
          v2 = this.get(i2, j);
          idx[0] = i2;
          idx[1] = j;
        }
      }
    }
    return idx;
  }
  min(by) {
    if (this.isEmpty()) {
      return NaN;
    }
    switch (by) {
      case "row": {
        const min2 = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
        for (let row2 = 0; row2 < this.rows; row2++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row2, column) < min2[row2]) {
              min2[row2] = this.get(row2, column);
            }
          }
        }
        return min2;
      }
      case "column": {
        const min2 = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
        for (let row2 = 0; row2 < this.rows; row2++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row2, column) < min2[column]) {
              min2[column] = this.get(row2, column);
            }
          }
        }
        return min2;
      }
      case void 0: {
        let min2 = this.get(0, 0);
        for (let row2 = 0; row2 < this.rows; row2++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row2, column) < min2) {
              min2 = this.get(row2, column);
            }
          }
        }
        return min2;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  minIndex() {
    checkNonEmpty(this);
    let v2 = this.get(0, 0);
    let idx = [0, 0];
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i2, j) < v2) {
          v2 = this.get(i2, j);
          idx[0] = i2;
          idx[1] = j;
        }
      }
    }
    return idx;
  }
  maxRow(row2) {
    checkRowIndex(this, row2);
    if (this.isEmpty()) {
      return NaN;
    }
    let v2 = this.get(row2, 0);
    for (let i2 = 1; i2 < this.columns; i2++) {
      if (this.get(row2, i2) > v2) {
        v2 = this.get(row2, i2);
      }
    }
    return v2;
  }
  maxRowIndex(row2) {
    checkRowIndex(this, row2);
    checkNonEmpty(this);
    let v2 = this.get(row2, 0);
    let idx = [row2, 0];
    for (let i2 = 1; i2 < this.columns; i2++) {
      if (this.get(row2, i2) > v2) {
        v2 = this.get(row2, i2);
        idx[1] = i2;
      }
    }
    return idx;
  }
  minRow(row2) {
    checkRowIndex(this, row2);
    if (this.isEmpty()) {
      return NaN;
    }
    let v2 = this.get(row2, 0);
    for (let i2 = 1; i2 < this.columns; i2++) {
      if (this.get(row2, i2) < v2) {
        v2 = this.get(row2, i2);
      }
    }
    return v2;
  }
  minRowIndex(row2) {
    checkRowIndex(this, row2);
    checkNonEmpty(this);
    let v2 = this.get(row2, 0);
    let idx = [row2, 0];
    for (let i2 = 1; i2 < this.columns; i2++) {
      if (this.get(row2, i2) < v2) {
        v2 = this.get(row2, i2);
        idx[1] = i2;
      }
    }
    return idx;
  }
  maxColumn(column) {
    checkColumnIndex(this, column);
    if (this.isEmpty()) {
      return NaN;
    }
    let v2 = this.get(0, column);
    for (let i2 = 1; i2 < this.rows; i2++) {
      if (this.get(i2, column) > v2) {
        v2 = this.get(i2, column);
      }
    }
    return v2;
  }
  maxColumnIndex(column) {
    checkColumnIndex(this, column);
    checkNonEmpty(this);
    let v2 = this.get(0, column);
    let idx = [0, column];
    for (let i2 = 1; i2 < this.rows; i2++) {
      if (this.get(i2, column) > v2) {
        v2 = this.get(i2, column);
        idx[0] = i2;
      }
    }
    return idx;
  }
  minColumn(column) {
    checkColumnIndex(this, column);
    if (this.isEmpty()) {
      return NaN;
    }
    let v2 = this.get(0, column);
    for (let i2 = 1; i2 < this.rows; i2++) {
      if (this.get(i2, column) < v2) {
        v2 = this.get(i2, column);
      }
    }
    return v2;
  }
  minColumnIndex(column) {
    checkColumnIndex(this, column);
    checkNonEmpty(this);
    let v2 = this.get(0, column);
    let idx = [0, column];
    for (let i2 = 1; i2 < this.rows; i2++) {
      if (this.get(i2, column) < v2) {
        v2 = this.get(i2, column);
        idx[0] = i2;
      }
    }
    return idx;
  }
  diag() {
    let min2 = Math.min(this.rows, this.columns);
    let diag = [];
    for (let i2 = 0; i2 < min2; i2++) {
      diag.push(this.get(i2, i2));
    }
    return diag;
  }
  norm(type = "frobenius") {
    switch (type) {
      case "max":
        return this.max();
      case "frobenius":
        return Math.sqrt(this.dot(this));
      default:
        throw new RangeError(`unknown norm type: ${type}`);
    }
  }
  cumulativeSum() {
    let sum = 0;
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        sum += this.get(i2, j);
        this.set(i2, j, sum);
      }
    }
    return this;
  }
  dot(vector2) {
    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
    let vector1 = this.to1DArray();
    if (vector1.length !== vector2.length) {
      throw new RangeError("vectors do not have the same size");
    }
    let dot2 = 0;
    for (let i2 = 0; i2 < vector1.length; i2++) {
      dot2 += vector1[i2] * vector2[i2];
    }
    return dot2;
  }
  mmul(other) {
    other = Matrix$1.checkMatrix(other);
    let m3 = this.rows;
    let n2 = this.columns;
    let p2 = other.columns;
    let result = new Matrix$1(m3, p2);
    let Bcolj = new Float64Array(n2);
    for (let j = 0; j < p2; j++) {
      for (let k = 0; k < n2; k++) {
        Bcolj[k] = other.get(k, j);
      }
      for (let i2 = 0; i2 < m3; i2++) {
        let s3 = 0;
        for (let k = 0; k < n2; k++) {
          s3 += this.get(i2, k) * Bcolj[k];
        }
        result.set(i2, j, s3);
      }
    }
    return result;
  }
  mpow(scalar) {
    if (!this.isSquare()) {
      throw new RangeError("Matrix must be square");
    }
    if (!Number.isInteger(scalar) || scalar < 0) {
      throw new RangeError("Exponent must be a non-negative integer");
    }
    let result = Matrix$1.eye(this.rows);
    let bb = this;
    for (let e3 = scalar; e3 >= 1; e3 /= 2) {
      if ((e3 & 1) !== 0) {
        result = result.mmul(bb);
      }
      bb = bb.mmul(bb);
    }
    return result;
  }
  strassen2x2(other) {
    other = Matrix$1.checkMatrix(other);
    let result = new Matrix$1(2, 2);
    const a11 = this.get(0, 0);
    const b11 = other.get(0, 0);
    const a12 = this.get(0, 1);
    const b12 = other.get(0, 1);
    const a21 = this.get(1, 0);
    const b21 = other.get(1, 0);
    const a22 = this.get(1, 1);
    const b22 = other.get(1, 1);
    const m1 = (a11 + a22) * (b11 + b22);
    const m22 = (a21 + a22) * b11;
    const m3 = a11 * (b12 - b22);
    const m4 = a22 * (b21 - b11);
    const m5 = (a11 + a12) * b22;
    const m6 = (a21 - a11) * (b11 + b12);
    const m7 = (a12 - a22) * (b21 + b22);
    const c00 = m1 + m4 - m5 + m7;
    const c01 = m3 + m5;
    const c10 = m22 + m4;
    const c11 = m1 - m22 + m3 + m6;
    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    return result;
  }
  strassen3x3(other) {
    other = Matrix$1.checkMatrix(other);
    let result = new Matrix$1(3, 3);
    const a00 = this.get(0, 0);
    const a01 = this.get(0, 1);
    const a02 = this.get(0, 2);
    const a10 = this.get(1, 0);
    const a11 = this.get(1, 1);
    const a12 = this.get(1, 2);
    const a20 = this.get(2, 0);
    const a21 = this.get(2, 1);
    const a22 = this.get(2, 2);
    const b00 = other.get(0, 0);
    const b01 = other.get(0, 1);
    const b02 = other.get(0, 2);
    const b10 = other.get(1, 0);
    const b11 = other.get(1, 1);
    const b12 = other.get(1, 2);
    const b20 = other.get(2, 0);
    const b21 = other.get(2, 1);
    const b22 = other.get(2, 2);
    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
    const m22 = (a00 - a10) * (-b01 + b11);
    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
    const m5 = (a10 + a11) * (-b00 + b01);
    const m6 = a00 * b00;
    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
    const m8 = (-a00 + a20) * (b02 - b12);
    const m9 = (a20 + a21) * (-b00 + b02);
    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
    const m13 = (a02 - a22) * (b11 - b21);
    const m14 = a02 * b20;
    const m15 = (a21 + a22) * (-b20 + b21);
    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
    const m17 = (a02 - a12) * (b12 - b22);
    const m18 = (a11 + a12) * (-b20 + b22);
    const m19 = a01 * b10;
    const m20 = a12 * b21;
    const m21 = a10 * b02;
    const m222 = a20 * b01;
    const m23 = a22 * b22;
    const c00 = m6 + m14 + m19;
    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
    const c10 = m22 + m3 + m4 + m6 + m14 + m16 + m17;
    const c11 = m22 + m4 + m5 + m6 + m20;
    const c12 = m14 + m16 + m17 + m18 + m21;
    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
    const c21 = m12 + m13 + m14 + m15 + m222;
    const c22 = m6 + m7 + m8 + m9 + m23;
    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(0, 2, c02);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    result.set(1, 2, c12);
    result.set(2, 0, c20);
    result.set(2, 1, c21);
    result.set(2, 2, c22);
    return result;
  }
  mmulStrassen(y2) {
    y2 = Matrix$1.checkMatrix(y2);
    let x2 = this.clone();
    let r1 = x2.rows;
    let c1 = x2.columns;
    let r2 = y2.rows;
    let c2 = y2.columns;
    if (c1 !== r2) {
      console.warn(
        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`
      );
    }
    function embed(mat, rows, cols) {
      let r4 = mat.rows;
      let c4 = mat.columns;
      if (r4 === rows && c4 === cols) {
        return mat;
      } else {
        let resultat = AbstractMatrix.zeros(rows, cols);
        resultat = resultat.setSubMatrix(mat, 0, 0);
        return resultat;
      }
    }
    let r3 = Math.max(r1, r2);
    let c3 = Math.max(c1, c2);
    x2 = embed(x2, r3, c3);
    y2 = embed(y2, r3, c3);
    function blockMult(a2, b2, rows, cols) {
      if (rows <= 512 || cols <= 512) {
        return a2.mmul(b2);
      }
      if (rows % 2 === 1 && cols % 2 === 1) {
        a2 = embed(a2, rows + 1, cols + 1);
        b2 = embed(b2, rows + 1, cols + 1);
      } else if (rows % 2 === 1) {
        a2 = embed(a2, rows + 1, cols);
        b2 = embed(b2, rows + 1, cols);
      } else if (cols % 2 === 1) {
        a2 = embed(a2, rows, cols + 1);
        b2 = embed(b2, rows, cols + 1);
      }
      let halfRows = parseInt(a2.rows / 2, 10);
      let halfCols = parseInt(a2.columns / 2, 10);
      let a11 = a2.subMatrix(0, halfRows - 1, 0, halfCols - 1);
      let b11 = b2.subMatrix(0, halfRows - 1, 0, halfCols - 1);
      let a12 = a2.subMatrix(0, halfRows - 1, halfCols, a2.columns - 1);
      let b12 = b2.subMatrix(0, halfRows - 1, halfCols, b2.columns - 1);
      let a21 = a2.subMatrix(halfRows, a2.rows - 1, 0, halfCols - 1);
      let b21 = b2.subMatrix(halfRows, b2.rows - 1, 0, halfCols - 1);
      let a22 = a2.subMatrix(halfRows, a2.rows - 1, halfCols, a2.columns - 1);
      let b22 = b2.subMatrix(halfRows, b2.rows - 1, halfCols, b2.columns - 1);
      let m1 = blockMult(
        AbstractMatrix.add(a11, a22),
        AbstractMatrix.add(b11, b22),
        halfRows,
        halfCols
      );
      let m22 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
      let m6 = blockMult(
        AbstractMatrix.sub(a21, a11),
        AbstractMatrix.add(b11, b12),
        halfRows,
        halfCols
      );
      let m7 = blockMult(
        AbstractMatrix.sub(a12, a22),
        AbstractMatrix.add(b21, b22),
        halfRows,
        halfCols
      );
      let c11 = AbstractMatrix.add(m1, m4);
      c11.sub(m5);
      c11.add(m7);
      let c12 = AbstractMatrix.add(m3, m5);
      let c21 = AbstractMatrix.add(m22, m4);
      let c22 = AbstractMatrix.sub(m1, m22);
      c22.add(m3);
      c22.add(m6);
      let result = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
      result = result.setSubMatrix(c11, 0, 0);
      result = result.setSubMatrix(c12, c11.rows, 0);
      result = result.setSubMatrix(c21, 0, c11.columns);
      result = result.setSubMatrix(c22, c11.rows, c11.columns);
      return result.subMatrix(0, rows - 1, 0, cols - 1);
    }
    return blockMult(x2, y2, r3, c3);
  }
  scaleRows(options = {}) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { min: min2 = 0, max: max2 = 1 } = options;
    if (!Number.isFinite(min2)) throw new TypeError("min must be a number");
    if (!Number.isFinite(max2)) throw new TypeError("max must be a number");
    if (min2 >= max2) throw new RangeError("min must be smaller than max");
    let newMatrix = new Matrix$1(this.rows, this.columns);
    for (let i2 = 0; i2 < this.rows; i2++) {
      const row2 = this.getRow(i2);
      if (row2.length > 0) {
        rescale(row2, { min: min2, max: max2, output: row2 });
      }
      newMatrix.setRow(i2, row2);
    }
    return newMatrix;
  }
  scaleColumns(options = {}) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { min: min2 = 0, max: max2 = 1 } = options;
    if (!Number.isFinite(min2)) throw new TypeError("min must be a number");
    if (!Number.isFinite(max2)) throw new TypeError("max must be a number");
    if (min2 >= max2) throw new RangeError("min must be smaller than max");
    let newMatrix = new Matrix$1(this.rows, this.columns);
    for (let i2 = 0; i2 < this.columns; i2++) {
      const column = this.getColumn(i2);
      if (column.length) {
        rescale(column, {
          min: min2,
          max: max2,
          output: column
        });
      }
      newMatrix.setColumn(i2, column);
    }
    return newMatrix;
  }
  flipRows() {
    const middle = Math.ceil(this.columns / 2);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < middle; j++) {
        let first = this.get(i2, j);
        let last = this.get(i2, this.columns - 1 - j);
        this.set(i2, j, last);
        this.set(i2, this.columns - 1 - j, first);
      }
    }
    return this;
  }
  flipColumns() {
    const middle = Math.ceil(this.rows / 2);
    for (let j = 0; j < this.columns; j++) {
      for (let i2 = 0; i2 < middle; i2++) {
        let first = this.get(i2, j);
        let last = this.get(this.rows - 1 - i2, j);
        this.set(i2, j, last);
        this.set(this.rows - 1 - i2, j, first);
      }
    }
    return this;
  }
  kroneckerProduct(other) {
    other = Matrix$1.checkMatrix(other);
    let m3 = this.rows;
    let n2 = this.columns;
    let p2 = other.rows;
    let q = other.columns;
    let result = new Matrix$1(m3 * p2, n2 * q);
    for (let i2 = 0; i2 < m3; i2++) {
      for (let j = 0; j < n2; j++) {
        for (let k = 0; k < p2; k++) {
          for (let l2 = 0; l2 < q; l2++) {
            result.set(p2 * i2 + k, q * j + l2, this.get(i2, j) * other.get(k, l2));
          }
        }
      }
    }
    return result;
  }
  kroneckerSum(other) {
    other = Matrix$1.checkMatrix(other);
    if (!this.isSquare() || !other.isSquare()) {
      throw new Error("Kronecker Sum needs two Square Matrices");
    }
    let m3 = this.rows;
    let n2 = other.rows;
    let AxI = this.kroneckerProduct(Matrix$1.eye(n2, n2));
    let IxB = Matrix$1.eye(m3, m3).kroneckerProduct(other);
    return AxI.add(IxB);
  }
  transpose() {
    let result = new Matrix$1(this.columns, this.rows);
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j = 0; j < this.columns; j++) {
        result.set(j, i2, this.get(i2, j));
      }
    }
    return result;
  }
  sortRows(compareFunction = compareNumbers) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      this.setRow(i2, this.getRow(i2).sort(compareFunction));
    }
    return this;
  }
  sortColumns(compareFunction = compareNumbers) {
    for (let i2 = 0; i2 < this.columns; i2++) {
      this.setColumn(i2, this.getColumn(i2).sort(compareFunction));
    }
    return this;
  }
  subMatrix(startRow, endRow, startColumn, endColumn) {
    checkRange(this, startRow, endRow, startColumn, endColumn);
    let newMatrix = new Matrix$1(
      endRow - startRow + 1,
      endColumn - startColumn + 1
    );
    for (let i2 = startRow; i2 <= endRow; i2++) {
      for (let j = startColumn; j <= endColumn; j++) {
        newMatrix.set(i2 - startRow, j - startColumn, this.get(i2, j));
      }
    }
    return newMatrix;
  }
  subMatrixRow(indices, startColumn, endColumn) {
    if (startColumn === void 0) startColumn = 0;
    if (endColumn === void 0) endColumn = this.columns - 1;
    if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
      throw new RangeError("Argument out of range");
    }
    let newMatrix = new Matrix$1(indices.length, endColumn - startColumn + 1);
    for (let i2 = 0; i2 < indices.length; i2++) {
      for (let j = startColumn; j <= endColumn; j++) {
        if (indices[i2] < 0 || indices[i2] >= this.rows) {
          throw new RangeError(`Row index out of range: ${indices[i2]}`);
        }
        newMatrix.set(i2, j - startColumn, this.get(indices[i2], j));
      }
    }
    return newMatrix;
  }
  subMatrixColumn(indices, startRow, endRow) {
    if (startRow === void 0) startRow = 0;
    if (endRow === void 0) endRow = this.rows - 1;
    if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
      throw new RangeError("Argument out of range");
    }
    let newMatrix = new Matrix$1(endRow - startRow + 1, indices.length);
    for (let i2 = 0; i2 < indices.length; i2++) {
      for (let j = startRow; j <= endRow; j++) {
        if (indices[i2] < 0 || indices[i2] >= this.columns) {
          throw new RangeError(`Column index out of range: ${indices[i2]}`);
        }
        newMatrix.set(j - startRow, i2, this.get(j, indices[i2]));
      }
    }
    return newMatrix;
  }
  setSubMatrix(matrix3, startRow, startColumn) {
    matrix3 = Matrix$1.checkMatrix(matrix3);
    if (matrix3.isEmpty()) {
      return this;
    }
    let endRow = startRow + matrix3.rows - 1;
    let endColumn = startColumn + matrix3.columns - 1;
    checkRange(this, startRow, endRow, startColumn, endColumn);
    for (let i2 = 0; i2 < matrix3.rows; i2++) {
      for (let j = 0; j < matrix3.columns; j++) {
        this.set(startRow + i2, startColumn + j, matrix3.get(i2, j));
      }
    }
    return this;
  }
  selection(rowIndices, columnIndices) {
    checkRowIndices(this, rowIndices);
    checkColumnIndices(this, columnIndices);
    let newMatrix = new Matrix$1(rowIndices.length, columnIndices.length);
    for (let i2 = 0; i2 < rowIndices.length; i2++) {
      let rowIndex = rowIndices[i2];
      for (let j = 0; j < columnIndices.length; j++) {
        let columnIndex = columnIndices[j];
        newMatrix.set(i2, j, this.get(rowIndex, columnIndex));
      }
    }
    return newMatrix;
  }
  trace() {
    let min2 = Math.min(this.rows, this.columns);
    let trace = 0;
    for (let i2 = 0; i2 < min2; i2++) {
      trace += this.get(i2, i2);
    }
    return trace;
  }
  clone() {
    return this.constructor.copy(this, new Matrix$1(this.rows, this.columns));
  }
  /**
   * @template {AbstractMatrix} M
   * @param {AbstractMatrix} from
   * @param {M} to
   * @return {M}
   */
  static copy(from, to) {
    for (const [row2, column, value] of from.entries()) {
      to.set(row2, column, value);
    }
    return to;
  }
  sum(by) {
    switch (by) {
      case "row":
        return sumByRow(this);
      case "column":
        return sumByColumn(this);
      case void 0:
        return sumAll(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  product(by) {
    switch (by) {
      case "row":
        return productByRow(this);
      case "column":
        return productByColumn(this);
      case void 0:
        return productAll(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  mean(by) {
    const sum = this.sum(by);
    switch (by) {
      case "row": {
        for (let i2 = 0; i2 < this.rows; i2++) {
          sum[i2] /= this.columns;
        }
        return sum;
      }
      case "column": {
        for (let i2 = 0; i2 < this.columns; i2++) {
          sum[i2] /= this.rows;
        }
        return sum;
      }
      case void 0:
        return sum / this.size;
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  variance(by, options = {}) {
    if (typeof by === "object") {
      options = by;
      by = void 0;
    }
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { unbiased = true, mean = this.mean(by) } = options;
    if (typeof unbiased !== "boolean") {
      throw new TypeError("unbiased must be a boolean");
    }
    switch (by) {
      case "row": {
        if (!isAnyArray.isAnyArray(mean)) {
          throw new TypeError("mean must be an array");
        }
        return varianceByRow(this, unbiased, mean);
      }
      case "column": {
        if (!isAnyArray.isAnyArray(mean)) {
          throw new TypeError("mean must be an array");
        }
        return varianceByColumn(this, unbiased, mean);
      }
      case void 0: {
        if (typeof mean !== "number") {
          throw new TypeError("mean must be a number");
        }
        return varianceAll(this, unbiased, mean);
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  standardDeviation(by, options) {
    if (typeof by === "object") {
      options = by;
      by = void 0;
    }
    const variance = this.variance(by, options);
    if (by === void 0) {
      return Math.sqrt(variance);
    } else {
      for (let i2 = 0; i2 < variance.length; i2++) {
        variance[i2] = Math.sqrt(variance[i2]);
      }
      return variance;
    }
  }
  center(by, options = {}) {
    if (typeof by === "object") {
      options = by;
      by = void 0;
    }
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    const { center = this.mean(by) } = options;
    switch (by) {
      case "row": {
        if (!isAnyArray.isAnyArray(center)) {
          throw new TypeError("center must be an array");
        }
        centerByRow(this, center);
        return this;
      }
      case "column": {
        if (!isAnyArray.isAnyArray(center)) {
          throw new TypeError("center must be an array");
        }
        centerByColumn(this, center);
        return this;
      }
      case void 0: {
        if (typeof center !== "number") {
          throw new TypeError("center must be a number");
        }
        centerAll(this, center);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  scale(by, options = {}) {
    if (typeof by === "object") {
      options = by;
      by = void 0;
    }
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    let scale3 = options.scale;
    switch (by) {
      case "row": {
        if (scale3 === void 0) {
          scale3 = getScaleByRow(this);
        } else if (!isAnyArray.isAnyArray(scale3)) {
          throw new TypeError("scale must be an array");
        }
        scaleByRow(this, scale3);
        return this;
      }
      case "column": {
        if (scale3 === void 0) {
          scale3 = getScaleByColumn(this);
        } else if (!isAnyArray.isAnyArray(scale3)) {
          throw new TypeError("scale must be an array");
        }
        scaleByColumn(this, scale3);
        return this;
      }
      case void 0: {
        if (scale3 === void 0) {
          scale3 = getScaleAll(this);
        } else if (typeof scale3 !== "number") {
          throw new TypeError("scale must be a number");
        }
        scaleAll(this, scale3);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }
  toString(options) {
    return inspectMatrixWithOptions(this, options);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * iterator from left to right, from top to bottom
   * yield [row, column, value]
   * @returns {Generator<[number, number, number], void, void>}
   */
  *entries() {
    for (let row2 = 0; row2 < this.rows; row2++) {
      for (let col = 0; col < this.columns; col++) {
        yield [row2, col, this.get(row2, col)];
      }
    }
  }
  /**
   * iterator from left to right, from top to bottom
   * yield value
   * @returns {Generator<number, void, void>}
   */
  *values() {
    for (let row2 = 0; row2 < this.rows; row2++) {
      for (let col = 0; col < this.columns; col++) {
        yield this.get(row2, col);
      }
    }
  }
}
AbstractMatrix.prototype.klass = "Matrix";
if (typeof Symbol !== "undefined") {
  AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
}
function compareNumbers(a2, b2) {
  return a2 - b2;
}
function isArrayOfNumbers(array) {
  return array.every((element) => {
    return typeof element === "number";
  });
}
AbstractMatrix.random = AbstractMatrix.rand;
AbstractMatrix.randomInt = AbstractMatrix.randInt;
AbstractMatrix.diagonal = AbstractMatrix.diag;
AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
AbstractMatrix.identity = AbstractMatrix.eye;
AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
AbstractMatrix.prototype.tensorProduct = AbstractMatrix.prototype.kroneckerProduct;
let Matrix$1 = (_a = class extends AbstractMatrix {
  constructor(nRows, nColumns) {
    super();
    __privateAdd(this, _Matrix_instances);
    /**
     * @type {Float64Array[]}
     */
    __publicField(this, "data");
    if (_a.isMatrix(nRows)) {
      __privateMethod(this, _Matrix_instances, initData_fn).call(this, nRows.rows, nRows.columns);
      _a.copy(nRows, this);
    } else if (Number.isInteger(nRows) && nRows >= 0) {
      __privateMethod(this, _Matrix_instances, initData_fn).call(this, nRows, nColumns);
    } else if (isAnyArray.isAnyArray(nRows)) {
      const arrayData = nRows;
      nRows = arrayData.length;
      nColumns = nRows ? arrayData[0].length : 0;
      if (typeof nColumns !== "number") {
        throw new TypeError(
          "Data must be a 2D array with at least one element"
        );
      }
      this.data = [];
      for (let i2 = 0; i2 < nRows; i2++) {
        if (arrayData[i2].length !== nColumns) {
          throw new RangeError("Inconsistent array dimensions");
        }
        if (!isArrayOfNumbers(arrayData[i2])) {
          throw new TypeError("Input data contains non-numeric values");
        }
        this.data.push(Float64Array.from(arrayData[i2]));
      }
      this.rows = nRows;
      this.columns = nColumns;
    } else {
      throw new TypeError(
        "First argument must be a positive number or an array"
      );
    }
  }
  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }
  removeRow(index2) {
    checkRowIndex(this, index2);
    this.data.splice(index2, 1);
    this.rows -= 1;
    return this;
  }
  addRow(index2, array) {
    if (array === void 0) {
      array = index2;
      index2 = this.rows;
    }
    checkRowIndex(this, index2, true);
    array = Float64Array.from(checkRowVector(this, array));
    this.data.splice(index2, 0, array);
    this.rows += 1;
    return this;
  }
  removeColumn(index2) {
    checkColumnIndex(this, index2);
    for (let i2 = 0; i2 < this.rows; i2++) {
      const newRow = new Float64Array(this.columns - 1);
      for (let j = 0; j < index2; j++) {
        newRow[j] = this.data[i2][j];
      }
      for (let j = index2 + 1; j < this.columns; j++) {
        newRow[j - 1] = this.data[i2][j];
      }
      this.data[i2] = newRow;
    }
    this.columns -= 1;
    return this;
  }
  addColumn(index2, array) {
    if (typeof array === "undefined") {
      array = index2;
      index2 = this.columns;
    }
    checkColumnIndex(this, index2, true);
    array = checkColumnVector(this, array);
    for (let i2 = 0; i2 < this.rows; i2++) {
      const newRow = new Float64Array(this.columns + 1);
      let j = 0;
      for (; j < index2; j++) {
        newRow[j] = this.data[i2][j];
      }
      newRow[j++] = array[i2];
      for (; j < this.columns + 1; j++) {
        newRow[j] = this.data[i2][j - 1];
      }
      this.data[i2] = newRow;
    }
    this.columns += 1;
    return this;
  }
}, _Matrix_instances = new WeakSet(), /**
 * Init an empty matrix
 * @param {number} nRows
 * @param {number} nColumns
 */
initData_fn = function(nRows, nColumns) {
  this.data = [];
  if (Number.isInteger(nColumns) && nColumns >= 0) {
    for (let i2 = 0; i2 < nRows; i2++) {
      this.data.push(new Float64Array(nColumns));
    }
  } else {
    throw new TypeError("nColumns must be a positive integer");
  }
  this.rows = nRows;
  this.columns = nColumns;
}, _a);
installMathOperations(AbstractMatrix, Matrix$1);
const _SymmetricMatrix = class _SymmetricMatrix extends AbstractMatrix {
  /**
   * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
   * @return {this}
   */
  constructor(diagonalSize) {
    super();
    /** @type {Matrix} */
    __privateAdd(this, _matrix);
    if (Matrix$1.isMatrix(diagonalSize)) {
      if (!diagonalSize.isSymmetric()) {
        throw new TypeError("not symmetric data");
      }
      __privateSet(this, _matrix, Matrix$1.copy(
        diagonalSize,
        new Matrix$1(diagonalSize.rows, diagonalSize.rows)
      ));
    } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
      __privateSet(this, _matrix, new Matrix$1(diagonalSize, diagonalSize));
    } else {
      __privateSet(this, _matrix, new Matrix$1(diagonalSize));
      if (!this.isSymmetric()) {
        throw new TypeError("not symmetric data");
      }
    }
  }
  get size() {
    return __privateGet(this, _matrix).size;
  }
  get rows() {
    return __privateGet(this, _matrix).rows;
  }
  get columns() {
    return __privateGet(this, _matrix).columns;
  }
  get diagonalSize() {
    return this.rows;
  }
  /**
   * not the same as matrix.isSymmetric()
   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
   *
   * @param value
   * @returns {boolean}
   */
  static isSymmetricMatrix(value) {
    return Matrix$1.isMatrix(value) && value.klassType === "SymmetricMatrix";
  }
  /**
   * @param diagonalSize
   * @return {SymmetricMatrix}
   */
  static zeros(diagonalSize) {
    return new this(diagonalSize);
  }
  /**
   * @param diagonalSize
   * @return {SymmetricMatrix}
   */
  static ones(diagonalSize) {
    return new this(diagonalSize).fill(1);
  }
  clone() {
    const matrix3 = new _SymmetricMatrix(this.diagonalSize);
    for (const [row2, col, value] of this.upperRightEntries()) {
      matrix3.set(row2, col, value);
    }
    return matrix3;
  }
  toMatrix() {
    return new Matrix$1(this);
  }
  get(rowIndex, columnIndex) {
    return __privateGet(this, _matrix).get(rowIndex, columnIndex);
  }
  set(rowIndex, columnIndex, value) {
    __privateGet(this, _matrix).set(rowIndex, columnIndex, value);
    __privateGet(this, _matrix).set(columnIndex, rowIndex, value);
    return this;
  }
  removeCross(index2) {
    __privateGet(this, _matrix).removeRow(index2);
    __privateGet(this, _matrix).removeColumn(index2);
    return this;
  }
  addCross(index2, array) {
    if (array === void 0) {
      array = index2;
      index2 = this.diagonalSize;
    }
    const row2 = array.slice();
    row2.splice(index2, 1);
    __privateGet(this, _matrix).addRow(index2, row2);
    __privateGet(this, _matrix).addColumn(index2, array);
    return this;
  }
  /**
   * @param {Mask[]} mask
   */
  applyMask(mask) {
    if (mask.length !== this.diagonalSize) {
      throw new RangeError("Mask size do not match with matrix size");
    }
    const sidesToRemove = [];
    for (const [index2, passthroughs] of mask.entries()) {
      if (passthroughs) continue;
      sidesToRemove.push(index2);
    }
    sidesToRemove.reverse();
    for (const sideIndex of sidesToRemove) {
      this.removeCross(sideIndex);
    }
    return this;
  }
  /**
   * Compact format upper-right corner of matrix
   * iterate from left to right, from top to bottom.
   *
   * ```
   *   A B C D
   * A 1 2 3 4
   * B 2 5 6 7
   * C 3 6 8 9
   * D 4 7 9 10
   * ```
   *
   * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
   *
   * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
   *
   * @returns {number[]}
   */
  toCompact() {
    const { diagonalSize } = this;
    const compact = new Array(diagonalSize * (diagonalSize + 1) / 2);
    for (let col = 0, row2 = 0, index2 = 0; index2 < compact.length; index2++) {
      compact[index2] = this.get(row2, col);
      if (++col >= diagonalSize) col = ++row2;
    }
    return compact;
  }
  /**
   * @param {number[]} compact
   * @return {SymmetricMatrix}
   */
  static fromCompact(compact) {
    const compactSize = compact.length;
    const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;
    if (!Number.isInteger(diagonalSize)) {
      throw new TypeError(
        `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
          compact
        )}`
      );
    }
    const matrix3 = new _SymmetricMatrix(diagonalSize);
    for (let col = 0, row2 = 0, index2 = 0; index2 < compactSize; index2++) {
      matrix3.set(col, row2, compact[index2]);
      if (++col >= diagonalSize) col = ++row2;
    }
    return matrix3;
  }
  /**
   * half iterator upper-right-corner from left to right, from top to bottom
   * yield [row, column, value]
   *
   * @returns {Generator<[number, number, number], void, void>}
   */
  *upperRightEntries() {
    for (let row2 = 0, col = 0; row2 < this.diagonalSize; void 0) {
      const value = this.get(row2, col);
      yield [row2, col, value];
      if (++col >= this.diagonalSize) col = ++row2;
    }
  }
  /**
   * half iterator upper-right-corner from left to right, from top to bottom
   * yield value
   *
   * @returns {Generator<[number, number, number], void, void>}
   */
  *upperRightValues() {
    for (let row2 = 0, col = 0; row2 < this.diagonalSize; void 0) {
      const value = this.get(row2, col);
      yield value;
      if (++col >= this.diagonalSize) col = ++row2;
    }
  }
};
_matrix = new WeakMap();
let SymmetricMatrix = _SymmetricMatrix;
SymmetricMatrix.prototype.klassType = "SymmetricMatrix";
class DistanceMatrix extends SymmetricMatrix {
  /**
   * not the same as matrix.isSymmetric()
   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
   *
   * @param value
   * @returns {boolean}
   */
  static isDistanceMatrix(value) {
    return SymmetricMatrix.isSymmetricMatrix(value) && value.klassSubType === "DistanceMatrix";
  }
  constructor(sideSize) {
    super(sideSize);
    if (!this.isDistance()) {
      throw new TypeError("Provided arguments do no produce a distance matrix");
    }
  }
  set(rowIndex, columnIndex, value) {
    if (rowIndex === columnIndex) value = 0;
    return super.set(rowIndex, columnIndex, value);
  }
  addCross(index2, array) {
    if (array === void 0) {
      array = index2;
      index2 = this.diagonalSize;
    }
    array = array.slice();
    array[index2] = 0;
    return super.addCross(index2, array);
  }
  toSymmetricMatrix() {
    return new SymmetricMatrix(this);
  }
  clone() {
    const matrix3 = new DistanceMatrix(this.diagonalSize);
    for (const [row2, col, value] of this.upperRightEntries()) {
      if (row2 === col) continue;
      matrix3.set(row2, col, value);
    }
    return matrix3;
  }
  /**
   * Compact format upper-right corner of matrix
   * no diagonal (only zeros)
   * iterable from left to right, from top to bottom.
   *
   * ```
   *   A B C D
   * A 0 1 2 3
   * B 1 0 4 5
   * C 2 4 0 6
   * D 3 5 6 0
   * ```
   *
   * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
   *
   * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
   *
   * @returns {number[]}
   */
  toCompact() {
    const { diagonalSize } = this;
    const compactLength = (diagonalSize - 1) * diagonalSize / 2;
    const compact = new Array(compactLength);
    for (let col = 1, row2 = 0, index2 = 0; index2 < compact.length; index2++) {
      compact[index2] = this.get(row2, col);
      if (++col >= diagonalSize) col = ++row2 + 1;
    }
    return compact;
  }
  /**
   * @param {number[]} compact
   */
  static fromCompact(compact) {
    const compactSize = compact.length;
    if (compactSize === 0) {
      return new this(0);
    }
    const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;
    if (!Number.isInteger(diagonalSize)) {
      throw new TypeError(
        `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
          compact
        )}`
      );
    }
    const matrix3 = new this(diagonalSize);
    for (let col = 1, row2 = 0, index2 = 0; index2 < compactSize; index2++) {
      matrix3.set(col, row2, compact[index2]);
      if (++col >= diagonalSize) col = ++row2 + 1;
    }
    return matrix3;
  }
}
DistanceMatrix.prototype.klassSubType = "DistanceMatrix";
class BaseView extends AbstractMatrix {
  constructor(matrix3, rows, columns) {
    super();
    this.matrix = matrix3;
    this.rows = rows;
    this.columns = columns;
  }
}
class MatrixColumnView extends BaseView {
  constructor(matrix3, column) {
    checkColumnIndex(matrix3, column);
    super(matrix3, matrix3.rows, 1);
    this.column = column;
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.column, value);
    return this;
  }
  get(rowIndex) {
    return this.matrix.get(rowIndex, this.column);
  }
}
class MatrixColumnSelectionView extends BaseView {
  constructor(matrix3, columnIndices) {
    checkColumnIndices(matrix3, columnIndices);
    super(matrix3, matrix3.rows, columnIndices.length);
    this.columnIndices = columnIndices;
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
  }
}
class MatrixFlipColumnView extends BaseView {
  constructor(matrix3) {
    super(matrix3, matrix3.rows, matrix3.columns);
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
  }
}
class MatrixFlipRowView extends BaseView {
  constructor(matrix3) {
    super(matrix3, matrix3.rows, matrix3.columns);
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
  }
}
class MatrixRowView extends BaseView {
  constructor(matrix3, row2) {
    checkRowIndex(matrix3, row2);
    super(matrix3, 1, matrix3.columns);
    this.row = row2;
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.row, columnIndex, value);
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(this.row, columnIndex);
  }
}
class MatrixRowSelectionView extends BaseView {
  constructor(matrix3, rowIndices) {
    checkRowIndices(matrix3, rowIndices);
    super(matrix3, rowIndices.length, matrix3.columns);
    this.rowIndices = rowIndices;
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
  }
}
class MatrixSelectionView extends BaseView {
  constructor(matrix3, rowIndices, columnIndices) {
    checkRowIndices(matrix3, rowIndices);
    checkColumnIndices(matrix3, columnIndices);
    super(matrix3, rowIndices.length, columnIndices.length);
    this.rowIndices = rowIndices;
    this.columnIndices = columnIndices;
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
      value
    );
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex]
    );
  }
}
class MatrixSubView extends BaseView {
  constructor(matrix3, startRow, endRow, startColumn, endColumn) {
    checkRange(matrix3, startRow, endRow, startColumn, endColumn);
    super(matrix3, endRow - startRow + 1, endColumn - startColumn + 1);
    this.startRow = startRow;
    this.startColumn = startColumn;
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
      value
    );
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.startRow + rowIndex,
      this.startColumn + columnIndex
    );
  }
}
class MatrixTransposeView extends BaseView {
  constructor(matrix3) {
    super(matrix3, matrix3.columns, matrix3.rows);
  }
  set(rowIndex, columnIndex, value) {
    this.matrix.set(columnIndex, rowIndex, value);
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.matrix.get(columnIndex, rowIndex);
  }
}
class WrapperMatrix1D extends AbstractMatrix {
  constructor(data2, options = {}) {
    const { rows = 1 } = options;
    if (data2.length % rows !== 0) {
      throw new Error("the data length is not divisible by the number of rows");
    }
    super();
    this.rows = rows;
    this.columns = data2.length / rows;
    this.data = data2;
  }
  set(rowIndex, columnIndex, value) {
    let index2 = this._calculateIndex(rowIndex, columnIndex);
    this.data[index2] = value;
    return this;
  }
  get(rowIndex, columnIndex) {
    let index2 = this._calculateIndex(rowIndex, columnIndex);
    return this.data[index2];
  }
  _calculateIndex(row2, column) {
    return row2 * this.columns + column;
  }
}
class WrapperMatrix2D extends AbstractMatrix {
  constructor(data2) {
    super();
    this.data = data2;
    this.rows = data2.length;
    this.columns = data2[0].length;
  }
  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }
  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }
}
function wrap$1(array, options) {
  if (isAnyArray.isAnyArray(array)) {
    if (array[0] && isAnyArray.isAnyArray(array[0])) {
      return new WrapperMatrix2D(array);
    } else {
      return new WrapperMatrix1D(array, options);
    }
  } else {
    throw new Error("the argument is not an array");
  }
}
class LuDecomposition {
  constructor(matrix3) {
    matrix3 = WrapperMatrix2D.checkMatrix(matrix3);
    let lu = matrix3.clone();
    let rows = lu.rows;
    let columns = lu.columns;
    let pivotVector = new Float64Array(rows);
    let pivotSign = 1;
    let i2, j, k, p2, s3, t3, v2;
    let LUcolj, kmax;
    for (i2 = 0; i2 < rows; i2++) {
      pivotVector[i2] = i2;
    }
    LUcolj = new Float64Array(rows);
    for (j = 0; j < columns; j++) {
      for (i2 = 0; i2 < rows; i2++) {
        LUcolj[i2] = lu.get(i2, j);
      }
      for (i2 = 0; i2 < rows; i2++) {
        kmax = Math.min(i2, j);
        s3 = 0;
        for (k = 0; k < kmax; k++) {
          s3 += lu.get(i2, k) * LUcolj[k];
        }
        LUcolj[i2] -= s3;
        lu.set(i2, j, LUcolj[i2]);
      }
      p2 = j;
      for (i2 = j + 1; i2 < rows; i2++) {
        if (Math.abs(LUcolj[i2]) > Math.abs(LUcolj[p2])) {
          p2 = i2;
        }
      }
      if (p2 !== j) {
        for (k = 0; k < columns; k++) {
          t3 = lu.get(p2, k);
          lu.set(p2, k, lu.get(j, k));
          lu.set(j, k, t3);
        }
        v2 = pivotVector[p2];
        pivotVector[p2] = pivotVector[j];
        pivotVector[j] = v2;
        pivotSign = -pivotSign;
      }
      if (j < rows && lu.get(j, j) !== 0) {
        for (i2 = j + 1; i2 < rows; i2++) {
          lu.set(i2, j, lu.get(i2, j) / lu.get(j, j));
        }
      }
    }
    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
  }
  isSingular() {
    let data2 = this.LU;
    let col = data2.columns;
    for (let j = 0; j < col; j++) {
      if (data2.get(j, j) === 0) {
        return true;
      }
    }
    return false;
  }
  solve(value) {
    value = Matrix$1.checkMatrix(value);
    let lu = this.LU;
    let rows = lu.rows;
    if (rows !== value.rows) {
      throw new Error("Invalid matrix dimensions");
    }
    if (this.isSingular()) {
      throw new Error("LU matrix is singular");
    }
    let count = value.columns;
    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
    let columns = lu.columns;
    let i2, j, k;
    for (k = 0; k < columns; k++) {
      for (i2 = k + 1; i2 < columns; i2++) {
        for (j = 0; j < count; j++) {
          X.set(i2, j, X.get(i2, j) - X.get(k, j) * lu.get(i2, k));
        }
      }
    }
    for (k = columns - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / lu.get(k, k));
      }
      for (i2 = 0; i2 < k; i2++) {
        for (j = 0; j < count; j++) {
          X.set(i2, j, X.get(i2, j) - X.get(k, j) * lu.get(i2, k));
        }
      }
    }
    return X;
  }
  get determinant() {
    let data2 = this.LU;
    if (!data2.isSquare()) {
      throw new Error("Matrix must be square");
    }
    let determinant2 = this.pivotSign;
    let col = data2.columns;
    for (let j = 0; j < col; j++) {
      determinant2 *= data2.get(j, j);
    }
    return determinant2;
  }
  get lowerTriangularMatrix() {
    let data2 = this.LU;
    let rows = data2.rows;
    let columns = data2.columns;
    let X = new Matrix$1(rows, columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        if (i2 > j) {
          X.set(i2, j, data2.get(i2, j));
        } else if (i2 === j) {
          X.set(i2, j, 1);
        } else {
          X.set(i2, j, 0);
        }
      }
    }
    return X;
  }
  get upperTriangularMatrix() {
    let data2 = this.LU;
    let rows = data2.rows;
    let columns = data2.columns;
    let X = new Matrix$1(rows, columns);
    for (let i2 = 0; i2 < rows; i2++) {
      for (let j = 0; j < columns; j++) {
        if (i2 <= j) {
          X.set(i2, j, data2.get(i2, j));
        } else {
          X.set(i2, j, 0);
        }
      }
    }
    return X;
  }
  get pivotPermutationVector() {
    return Array.from(this.pivotVector);
  }
}
function hypotenuse(a2, b2) {
  let r2 = 0;
  if (Math.abs(a2) > Math.abs(b2)) {
    r2 = b2 / a2;
    return Math.abs(a2) * Math.sqrt(1 + r2 * r2);
  }
  if (b2 !== 0) {
    r2 = a2 / b2;
    return Math.abs(b2) * Math.sqrt(1 + r2 * r2);
  }
  return 0;
}
class QrDecomposition {
  constructor(value) {
    value = WrapperMatrix2D.checkMatrix(value);
    let qr = value.clone();
    let m3 = value.rows;
    let n2 = value.columns;
    let rdiag = new Float64Array(n2);
    let i2, j, k, s3;
    for (k = 0; k < n2; k++) {
      let nrm = 0;
      for (i2 = k; i2 < m3; i2++) {
        nrm = hypotenuse(nrm, qr.get(i2, k));
      }
      if (nrm !== 0) {
        if (qr.get(k, k) < 0) {
          nrm = -nrm;
        }
        for (i2 = k; i2 < m3; i2++) {
          qr.set(i2, k, qr.get(i2, k) / nrm);
        }
        qr.set(k, k, qr.get(k, k) + 1);
        for (j = k + 1; j < n2; j++) {
          s3 = 0;
          for (i2 = k; i2 < m3; i2++) {
            s3 += qr.get(i2, k) * qr.get(i2, j);
          }
          s3 = -s3 / qr.get(k, k);
          for (i2 = k; i2 < m3; i2++) {
            qr.set(i2, j, qr.get(i2, j) + s3 * qr.get(i2, k));
          }
        }
      }
      rdiag[k] = -nrm;
    }
    this.QR = qr;
    this.Rdiag = rdiag;
  }
  solve(value) {
    value = Matrix$1.checkMatrix(value);
    let qr = this.QR;
    let m3 = qr.rows;
    if (value.rows !== m3) {
      throw new Error("Matrix row dimensions must agree");
    }
    if (!this.isFullRank()) {
      throw new Error("Matrix is rank deficient");
    }
    let count = value.columns;
    let X = value.clone();
    let n2 = qr.columns;
    let i2, j, k, s3;
    for (k = 0; k < n2; k++) {
      for (j = 0; j < count; j++) {
        s3 = 0;
        for (i2 = k; i2 < m3; i2++) {
          s3 += qr.get(i2, k) * X.get(i2, j);
        }
        s3 = -s3 / qr.get(k, k);
        for (i2 = k; i2 < m3; i2++) {
          X.set(i2, j, X.get(i2, j) + s3 * qr.get(i2, k));
        }
      }
    }
    for (k = n2 - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / this.Rdiag[k]);
      }
      for (i2 = 0; i2 < k; i2++) {
        for (j = 0; j < count; j++) {
          X.set(i2, j, X.get(i2, j) - X.get(k, j) * qr.get(i2, k));
        }
      }
    }
    return X.subMatrix(0, n2 - 1, 0, count - 1);
  }
  isFullRank() {
    let columns = this.QR.columns;
    for (let i2 = 0; i2 < columns; i2++) {
      if (this.Rdiag[i2] === 0) {
        return false;
      }
    }
    return true;
  }
  get upperTriangularMatrix() {
    let qr = this.QR;
    let n2 = qr.columns;
    let X = new Matrix$1(n2, n2);
    let i2, j;
    for (i2 = 0; i2 < n2; i2++) {
      for (j = 0; j < n2; j++) {
        if (i2 < j) {
          X.set(i2, j, qr.get(i2, j));
        } else if (i2 === j) {
          X.set(i2, j, this.Rdiag[i2]);
        } else {
          X.set(i2, j, 0);
        }
      }
    }
    return X;
  }
  get orthogonalMatrix() {
    let qr = this.QR;
    let rows = qr.rows;
    let columns = qr.columns;
    let X = new Matrix$1(rows, columns);
    let i2, j, k, s3;
    for (k = columns - 1; k >= 0; k--) {
      for (i2 = 0; i2 < rows; i2++) {
        X.set(i2, k, 0);
      }
      X.set(k, k, 1);
      for (j = k; j < columns; j++) {
        if (qr.get(k, k) !== 0) {
          s3 = 0;
          for (i2 = k; i2 < rows; i2++) {
            s3 += qr.get(i2, k) * X.get(i2, j);
          }
          s3 = -s3 / qr.get(k, k);
          for (i2 = k; i2 < rows; i2++) {
            X.set(i2, j, X.get(i2, j) + s3 * qr.get(i2, k));
          }
        }
      }
    }
    return X;
  }
}
let SingularValueDecomposition$1 = class SingularValueDecomposition {
  constructor(value, options = {}) {
    value = WrapperMatrix2D.checkMatrix(value);
    if (value.isEmpty()) {
      throw new Error("Matrix must be non-empty");
    }
    let m3 = value.rows;
    let n2 = value.columns;
    const {
      computeLeftSingularVectors = true,
      computeRightSingularVectors = true,
      autoTranspose = false
    } = options;
    let wantu = Boolean(computeLeftSingularVectors);
    let wantv = Boolean(computeRightSingularVectors);
    let swapped = false;
    let a2;
    if (m3 < n2) {
      if (!autoTranspose) {
        a2 = value.clone();
        console.warn(
          "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
        );
      } else {
        a2 = value.transpose();
        m3 = a2.rows;
        n2 = a2.columns;
        swapped = true;
        let aux = wantu;
        wantu = wantv;
        wantv = aux;
      }
    } else {
      a2 = value.clone();
    }
    let nu = Math.min(m3, n2);
    let ni = Math.min(m3 + 1, n2);
    let s3 = new Float64Array(ni);
    let U2 = new Matrix$1(m3, nu);
    let V2 = new Matrix$1(n2, n2);
    let e3 = new Float64Array(n2);
    let work = new Float64Array(m3);
    let si = new Float64Array(ni);
    for (let i2 = 0; i2 < ni; i2++) si[i2] = i2;
    let nct = Math.min(m3 - 1, n2);
    let nrt = Math.max(0, Math.min(n2 - 2, m3));
    let mrc = Math.max(nct, nrt);
    for (let k = 0; k < mrc; k++) {
      if (k < nct) {
        s3[k] = 0;
        for (let i2 = k; i2 < m3; i2++) {
          s3[k] = hypotenuse(s3[k], a2.get(i2, k));
        }
        if (s3[k] !== 0) {
          if (a2.get(k, k) < 0) {
            s3[k] = -s3[k];
          }
          for (let i2 = k; i2 < m3; i2++) {
            a2.set(i2, k, a2.get(i2, k) / s3[k]);
          }
          a2.set(k, k, a2.get(k, k) + 1);
        }
        s3[k] = -s3[k];
      }
      for (let j = k + 1; j < n2; j++) {
        if (k < nct && s3[k] !== 0) {
          let t3 = 0;
          for (let i2 = k; i2 < m3; i2++) {
            t3 += a2.get(i2, k) * a2.get(i2, j);
          }
          t3 = -t3 / a2.get(k, k);
          for (let i2 = k; i2 < m3; i2++) {
            a2.set(i2, j, a2.get(i2, j) + t3 * a2.get(i2, k));
          }
        }
        e3[j] = a2.get(k, j);
      }
      if (wantu && k < nct) {
        for (let i2 = k; i2 < m3; i2++) {
          U2.set(i2, k, a2.get(i2, k));
        }
      }
      if (k < nrt) {
        e3[k] = 0;
        for (let i2 = k + 1; i2 < n2; i2++) {
          e3[k] = hypotenuse(e3[k], e3[i2]);
        }
        if (e3[k] !== 0) {
          if (e3[k + 1] < 0) {
            e3[k] = 0 - e3[k];
          }
          for (let i2 = k + 1; i2 < n2; i2++) {
            e3[i2] /= e3[k];
          }
          e3[k + 1] += 1;
        }
        e3[k] = -e3[k];
        if (k + 1 < m3 && e3[k] !== 0) {
          for (let i2 = k + 1; i2 < m3; i2++) {
            work[i2] = 0;
          }
          for (let i2 = k + 1; i2 < m3; i2++) {
            for (let j = k + 1; j < n2; j++) {
              work[i2] += e3[j] * a2.get(i2, j);
            }
          }
          for (let j = k + 1; j < n2; j++) {
            let t3 = -e3[j] / e3[k + 1];
            for (let i2 = k + 1; i2 < m3; i2++) {
              a2.set(i2, j, a2.get(i2, j) + t3 * work[i2]);
            }
          }
        }
        if (wantv) {
          for (let i2 = k + 1; i2 < n2; i2++) {
            V2.set(i2, k, e3[i2]);
          }
        }
      }
    }
    let p2 = Math.min(n2, m3 + 1);
    if (nct < n2) {
      s3[nct] = a2.get(nct, nct);
    }
    if (m3 < p2) {
      s3[p2 - 1] = 0;
    }
    if (nrt + 1 < p2) {
      e3[nrt] = a2.get(nrt, p2 - 1);
    }
    e3[p2 - 1] = 0;
    if (wantu) {
      for (let j = nct; j < nu; j++) {
        for (let i2 = 0; i2 < m3; i2++) {
          U2.set(i2, j, 0);
        }
        U2.set(j, j, 1);
      }
      for (let k = nct - 1; k >= 0; k--) {
        if (s3[k] !== 0) {
          for (let j = k + 1; j < nu; j++) {
            let t3 = 0;
            for (let i2 = k; i2 < m3; i2++) {
              t3 += U2.get(i2, k) * U2.get(i2, j);
            }
            t3 = -t3 / U2.get(k, k);
            for (let i2 = k; i2 < m3; i2++) {
              U2.set(i2, j, U2.get(i2, j) + t3 * U2.get(i2, k));
            }
          }
          for (let i2 = k; i2 < m3; i2++) {
            U2.set(i2, k, -U2.get(i2, k));
          }
          U2.set(k, k, 1 + U2.get(k, k));
          for (let i2 = 0; i2 < k - 1; i2++) {
            U2.set(i2, k, 0);
          }
        } else {
          for (let i2 = 0; i2 < m3; i2++) {
            U2.set(i2, k, 0);
          }
          U2.set(k, k, 1);
        }
      }
    }
    if (wantv) {
      for (let k = n2 - 1; k >= 0; k--) {
        if (k < nrt && e3[k] !== 0) {
          for (let j = k + 1; j < n2; j++) {
            let t3 = 0;
            for (let i2 = k + 1; i2 < n2; i2++) {
              t3 += V2.get(i2, k) * V2.get(i2, j);
            }
            t3 = -t3 / V2.get(k + 1, k);
            for (let i2 = k + 1; i2 < n2; i2++) {
              V2.set(i2, j, V2.get(i2, j) + t3 * V2.get(i2, k));
            }
          }
        }
        for (let i2 = 0; i2 < n2; i2++) {
          V2.set(i2, k, 0);
        }
        V2.set(k, k, 1);
      }
    }
    let pp = p2 - 1;
    let eps = Number.EPSILON;
    while (p2 > 0) {
      let k, kase;
      for (k = p2 - 2; k >= -1; k--) {
        if (k === -1) {
          break;
        }
        const alpha = Number.MIN_VALUE + eps * Math.abs(s3[k] + Math.abs(s3[k + 1]));
        if (Math.abs(e3[k]) <= alpha || Number.isNaN(e3[k])) {
          e3[k] = 0;
          break;
        }
      }
      if (k === p2 - 2) {
        kase = 4;
      } else {
        let ks;
        for (ks = p2 - 1; ks >= k; ks--) {
          if (ks === k) {
            break;
          }
          let t3 = (ks !== p2 ? Math.abs(e3[ks]) : 0) + (ks !== k + 1 ? Math.abs(e3[ks - 1]) : 0);
          if (Math.abs(s3[ks]) <= eps * t3) {
            s3[ks] = 0;
            break;
          }
        }
        if (ks === k) {
          kase = 3;
        } else if (ks === p2 - 1) {
          kase = 1;
        } else {
          kase = 2;
          k = ks;
        }
      }
      k++;
      switch (kase) {
        case 1: {
          let f2 = e3[p2 - 2];
          e3[p2 - 2] = 0;
          for (let j = p2 - 2; j >= k; j--) {
            let t3 = hypotenuse(s3[j], f2);
            let cs2 = s3[j] / t3;
            let sn = f2 / t3;
            s3[j] = t3;
            if (j !== k) {
              f2 = -sn * e3[j - 1];
              e3[j - 1] = cs2 * e3[j - 1];
            }
            if (wantv) {
              for (let i2 = 0; i2 < n2; i2++) {
                t3 = cs2 * V2.get(i2, j) + sn * V2.get(i2, p2 - 1);
                V2.set(i2, p2 - 1, -sn * V2.get(i2, j) + cs2 * V2.get(i2, p2 - 1));
                V2.set(i2, j, t3);
              }
            }
          }
          break;
        }
        case 2: {
          let f2 = e3[k - 1];
          e3[k - 1] = 0;
          for (let j = k; j < p2; j++) {
            let t3 = hypotenuse(s3[j], f2);
            let cs2 = s3[j] / t3;
            let sn = f2 / t3;
            s3[j] = t3;
            f2 = -sn * e3[j];
            e3[j] = cs2 * e3[j];
            if (wantu) {
              for (let i2 = 0; i2 < m3; i2++) {
                t3 = cs2 * U2.get(i2, j) + sn * U2.get(i2, k - 1);
                U2.set(i2, k - 1, -sn * U2.get(i2, j) + cs2 * U2.get(i2, k - 1));
                U2.set(i2, j, t3);
              }
            }
          }
          break;
        }
        case 3: {
          const scale3 = Math.max(
            Math.abs(s3[p2 - 1]),
            Math.abs(s3[p2 - 2]),
            Math.abs(e3[p2 - 2]),
            Math.abs(s3[k]),
            Math.abs(e3[k])
          );
          const sp = s3[p2 - 1] / scale3;
          const spm1 = s3[p2 - 2] / scale3;
          const epm1 = e3[p2 - 2] / scale3;
          const sk = s3[k] / scale3;
          const ek = e3[k] / scale3;
          const b2 = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
          const c2 = sp * epm1 * (sp * epm1);
          let shift = 0;
          if (b2 !== 0 || c2 !== 0) {
            if (b2 < 0) {
              shift = 0 - Math.sqrt(b2 * b2 + c2);
            } else {
              shift = Math.sqrt(b2 * b2 + c2);
            }
            shift = c2 / (b2 + shift);
          }
          let f2 = (sk + sp) * (sk - sp) + shift;
          let g2 = sk * ek;
          for (let j = k; j < p2 - 1; j++) {
            let t3 = hypotenuse(f2, g2);
            if (t3 === 0) t3 = Number.MIN_VALUE;
            let cs2 = f2 / t3;
            let sn = g2 / t3;
            if (j !== k) {
              e3[j - 1] = t3;
            }
            f2 = cs2 * s3[j] + sn * e3[j];
            e3[j] = cs2 * e3[j] - sn * s3[j];
            g2 = sn * s3[j + 1];
            s3[j + 1] = cs2 * s3[j + 1];
            if (wantv) {
              for (let i2 = 0; i2 < n2; i2++) {
                t3 = cs2 * V2.get(i2, j) + sn * V2.get(i2, j + 1);
                V2.set(i2, j + 1, -sn * V2.get(i2, j) + cs2 * V2.get(i2, j + 1));
                V2.set(i2, j, t3);
              }
            }
            t3 = hypotenuse(f2, g2);
            if (t3 === 0) t3 = Number.MIN_VALUE;
            cs2 = f2 / t3;
            sn = g2 / t3;
            s3[j] = t3;
            f2 = cs2 * e3[j] + sn * s3[j + 1];
            s3[j + 1] = -sn * e3[j] + cs2 * s3[j + 1];
            g2 = sn * e3[j + 1];
            e3[j + 1] = cs2 * e3[j + 1];
            if (wantu && j < m3 - 1) {
              for (let i2 = 0; i2 < m3; i2++) {
                t3 = cs2 * U2.get(i2, j) + sn * U2.get(i2, j + 1);
                U2.set(i2, j + 1, -sn * U2.get(i2, j) + cs2 * U2.get(i2, j + 1));
                U2.set(i2, j, t3);
              }
            }
          }
          e3[p2 - 2] = f2;
          break;
        }
        case 4: {
          if (s3[k] <= 0) {
            s3[k] = s3[k] < 0 ? -s3[k] : 0;
            if (wantv) {
              for (let i2 = 0; i2 <= pp; i2++) {
                V2.set(i2, k, -V2.get(i2, k));
              }
            }
          }
          while (k < pp) {
            if (s3[k] >= s3[k + 1]) {
              break;
            }
            let t3 = s3[k];
            s3[k] = s3[k + 1];
            s3[k + 1] = t3;
            if (wantv && k < n2 - 1) {
              for (let i2 = 0; i2 < n2; i2++) {
                t3 = V2.get(i2, k + 1);
                V2.set(i2, k + 1, V2.get(i2, k));
                V2.set(i2, k, t3);
              }
            }
            if (wantu && k < m3 - 1) {
              for (let i2 = 0; i2 < m3; i2++) {
                t3 = U2.get(i2, k + 1);
                U2.set(i2, k + 1, U2.get(i2, k));
                U2.set(i2, k, t3);
              }
            }
            k++;
          }
          p2--;
          break;
        }
      }
    }
    if (swapped) {
      let tmp2 = V2;
      V2 = U2;
      U2 = tmp2;
    }
    this.m = m3;
    this.n = n2;
    this.s = s3;
    this.U = U2;
    this.V = V2;
  }
  solve(value) {
    let Y2 = value;
    let e3 = this.threshold;
    let scols = this.s.length;
    let Ls = Matrix$1.zeros(scols, scols);
    for (let i2 = 0; i2 < scols; i2++) {
      if (Math.abs(this.s[i2]) <= e3) {
        Ls.set(i2, i2, 0);
      } else {
        Ls.set(i2, i2, 1 / this.s[i2]);
      }
    }
    let U2 = this.U;
    let V2 = this.rightSingularVectors;
    let VL = V2.mmul(Ls);
    let vrows = V2.rows;
    let urows = U2.rows;
    let VLU = Matrix$1.zeros(vrows, urows);
    for (let i2 = 0; i2 < vrows; i2++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < scols; k++) {
          sum += VL.get(i2, k) * U2.get(j, k);
        }
        VLU.set(i2, j, sum);
      }
    }
    return VLU.mmul(Y2);
  }
  solveForDiagonal(value) {
    return this.solve(Matrix$1.diag(value));
  }
  inverse() {
    let V2 = this.V;
    let e3 = this.threshold;
    let vrows = V2.rows;
    let vcols = V2.columns;
    let X = new Matrix$1(vrows, this.s.length);
    for (let i2 = 0; i2 < vrows; i2++) {
      for (let j = 0; j < vcols; j++) {
        if (Math.abs(this.s[j]) > e3) {
          X.set(i2, j, V2.get(i2, j) / this.s[j]);
        }
      }
    }
    let U2 = this.U;
    let urows = U2.rows;
    let ucols = U2.columns;
    let Y2 = new Matrix$1(vrows, urows);
    for (let i2 = 0; i2 < vrows; i2++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < ucols; k++) {
          sum += X.get(i2, k) * U2.get(j, k);
        }
        Y2.set(i2, j, sum);
      }
    }
    return Y2;
  }
  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  }
  get norm2() {
    return this.s[0];
  }
  get rank() {
    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    let r2 = 0;
    let s3 = this.s;
    for (let i2 = 0, ii = s3.length; i2 < ii; i2++) {
      if (s3[i2] > tol) {
        r2++;
      }
    }
    return r2;
  }
  get diagonal() {
    return Array.from(this.s);
  }
  get threshold() {
    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
  }
  get leftSingularVectors() {
    return this.U;
  }
  get rightSingularVectors() {
    return this.V;
  }
  get diagonalMatrix() {
    return Matrix$1.diag(this.s);
  }
};
function inverse(matrix3, useSVD = false) {
  matrix3 = WrapperMatrix2D.checkMatrix(matrix3);
  if (useSVD) {
    return new SingularValueDecomposition$1(matrix3).inverse();
  } else {
    return solve(matrix3, Matrix$1.eye(matrix3.rows));
  }
}
function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
  if (useSVD) {
    return new SingularValueDecomposition$1(leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
}
function determinant(matrix3) {
  matrix3 = Matrix$1.checkMatrix(matrix3);
  if (matrix3.isSquare()) {
    if (matrix3.columns === 0) {
      return 1;
    }
    let a2, b2, c2, d3;
    if (matrix3.columns === 2) {
      a2 = matrix3.get(0, 0);
      b2 = matrix3.get(0, 1);
      c2 = matrix3.get(1, 0);
      d3 = matrix3.get(1, 1);
      return a2 * d3 - b2 * c2;
    } else if (matrix3.columns === 3) {
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new MatrixSelectionView(matrix3, [1, 2], [1, 2]);
      subMatrix1 = new MatrixSelectionView(matrix3, [1, 2], [0, 2]);
      subMatrix2 = new MatrixSelectionView(matrix3, [1, 2], [0, 1]);
      a2 = matrix3.get(0, 0);
      b2 = matrix3.get(0, 1);
      c2 = matrix3.get(0, 2);
      return a2 * determinant(subMatrix0) - b2 * determinant(subMatrix1) + c2 * determinant(subMatrix2);
    } else {
      return new LuDecomposition(matrix3).determinant;
    }
  } else {
    throw Error("determinant can only be calculated for a square matrix");
  }
}
function xrange(n2, exception) {
  let range = [];
  for (let i2 = 0; i2 < n2; i2++) {
    if (i2 !== exception) {
      range.push(i2);
    }
  }
  return range;
}
function dependenciesOneRow(error2, matrix3, index2, thresholdValue = 1e-9, thresholdError = 1e-9) {
  if (error2 > thresholdError) {
    return new Array(matrix3.rows + 1).fill(0);
  } else {
    let returnArray = matrix3.addRow(index2, [0]);
    for (let i2 = 0; i2 < returnArray.rows; i2++) {
      if (Math.abs(returnArray.get(i2, 0)) < thresholdValue) {
        returnArray.set(i2, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}
function linearDependencies(matrix3, options = {}) {
  const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
  matrix3 = Matrix$1.checkMatrix(matrix3);
  let n2 = matrix3.rows;
  let results = new Matrix$1(n2, n2);
  for (let i2 = 0; i2 < n2; i2++) {
    let b2 = Matrix$1.columnVector(matrix3.getRow(i2));
    let Abis = matrix3.subMatrixRow(xrange(n2, i2)).transpose();
    let svd = new SingularValueDecomposition$1(Abis);
    let x2 = svd.solve(b2);
    let error2 = Matrix$1.sub(b2, Abis.mmul(x2)).abs().max();
    results.setRow(
      i2,
      dependenciesOneRow(error2, x2, i2, thresholdValue, thresholdError)
    );
  }
  return results;
}
function pseudoInverse(matrix3, threshold = Number.EPSILON) {
  matrix3 = Matrix$1.checkMatrix(matrix3);
  if (matrix3.isEmpty()) {
    return matrix3.transpose();
  }
  let svdSolution = new SingularValueDecomposition$1(matrix3, { autoTranspose: true });
  let U2 = svdSolution.leftSingularVectors;
  let V2 = svdSolution.rightSingularVectors;
  let s3 = svdSolution.diagonal;
  for (let i2 = 0; i2 < s3.length; i2++) {
    if (Math.abs(s3[i2]) > threshold) {
      s3[i2] = 1 / s3[i2];
    } else {
      s3[i2] = 0;
    }
  }
  return V2.mmul(Matrix$1.diag(s3).mmul(U2.transpose()));
}
function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix$1(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix$1.isMatrix(yMatrix) && !isAnyArray.isAnyArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix$1(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center("column");
    if (!yIsSame) {
      yMatrix = yMatrix.center("column");
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < cov.rows; i2++) {
    for (let j = 0; j < cov.columns; j++) {
      cov.set(i2, j, cov.get(i2, j) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}
function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix$1(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix$1.isMatrix(yMatrix) && !isAnyArray.isAnyArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix$1(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true, scale: scale3 = true } = options;
  if (center) {
    xMatrix.center("column");
    if (!yIsSame) {
      yMatrix.center("column");
    }
  }
  if (scale3) {
    xMatrix.scale("column");
    if (!yIsSame) {
      yMatrix.scale("column");
    }
  }
  const sdx = xMatrix.standardDeviation("column", { unbiased: true });
  const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < corr.rows; i2++) {
    for (let j = 0; j < corr.columns; j++) {
      corr.set(
        i2,
        j,
        corr.get(i2, j) * (1 / (sdx[i2] * sdy[j])) * (1 / (xMatrix.rows - 1))
      );
    }
  }
  return corr;
}
class EigenvalueDecomposition {
  constructor(matrix3, options = {}) {
    const { assumeSymmetric = false } = options;
    matrix3 = WrapperMatrix2D.checkMatrix(matrix3);
    if (!matrix3.isSquare()) {
      throw new Error("Matrix is not a square matrix");
    }
    if (matrix3.isEmpty()) {
      throw new Error("Matrix must be non-empty");
    }
    let n2 = matrix3.columns;
    let V2 = new Matrix$1(n2, n2);
    let d3 = new Float64Array(n2);
    let e3 = new Float64Array(n2);
    let value = matrix3;
    let i2, j;
    let isSymmetric = false;
    if (assumeSymmetric) {
      isSymmetric = true;
    } else {
      isSymmetric = matrix3.isSymmetric();
    }
    if (isSymmetric) {
      for (i2 = 0; i2 < n2; i2++) {
        for (j = 0; j < n2; j++) {
          V2.set(i2, j, value.get(i2, j));
        }
      }
      tred2(n2, e3, d3, V2);
      tql2(n2, e3, d3, V2);
    } else {
      let H4 = new Matrix$1(n2, n2);
      let ort = new Float64Array(n2);
      for (j = 0; j < n2; j++) {
        for (i2 = 0; i2 < n2; i2++) {
          H4.set(i2, j, value.get(i2, j));
        }
      }
      orthes(n2, H4, ort, V2);
      hqr2(n2, e3, d3, V2, H4);
    }
    this.n = n2;
    this.e = e3;
    this.d = d3;
    this.V = V2;
  }
  get realEigenvalues() {
    return Array.from(this.d);
  }
  get imaginaryEigenvalues() {
    return Array.from(this.e);
  }
  get eigenvectorMatrix() {
    return this.V;
  }
  get diagonalMatrix() {
    let n2 = this.n;
    let e3 = this.e;
    let d3 = this.d;
    let X = new Matrix$1(n2, n2);
    let i2, j;
    for (i2 = 0; i2 < n2; i2++) {
      for (j = 0; j < n2; j++) {
        X.set(i2, j, 0);
      }
      X.set(i2, i2, d3[i2]);
      if (e3[i2] > 0) {
        X.set(i2, i2 + 1, e3[i2]);
      } else if (e3[i2] < 0) {
        X.set(i2, i2 - 1, e3[i2]);
      }
    }
    return X;
  }
}
function tred2(n2, e3, d3, V2) {
  let f2, g2, h2, i2, j, k, hh, scale3;
  for (j = 0; j < n2; j++) {
    d3[j] = V2.get(n2 - 1, j);
  }
  for (i2 = n2 - 1; i2 > 0; i2--) {
    scale3 = 0;
    h2 = 0;
    for (k = 0; k < i2; k++) {
      scale3 = scale3 + Math.abs(d3[k]);
    }
    if (scale3 === 0) {
      e3[i2] = d3[i2 - 1];
      for (j = 0; j < i2; j++) {
        d3[j] = V2.get(i2 - 1, j);
        V2.set(i2, j, 0);
        V2.set(j, i2, 0);
      }
    } else {
      for (k = 0; k < i2; k++) {
        d3[k] /= scale3;
        h2 += d3[k] * d3[k];
      }
      f2 = d3[i2 - 1];
      g2 = Math.sqrt(h2);
      if (f2 > 0) {
        g2 = -g2;
      }
      e3[i2] = scale3 * g2;
      h2 = h2 - f2 * g2;
      d3[i2 - 1] = f2 - g2;
      for (j = 0; j < i2; j++) {
        e3[j] = 0;
      }
      for (j = 0; j < i2; j++) {
        f2 = d3[j];
        V2.set(j, i2, f2);
        g2 = e3[j] + V2.get(j, j) * f2;
        for (k = j + 1; k <= i2 - 1; k++) {
          g2 += V2.get(k, j) * d3[k];
          e3[k] += V2.get(k, j) * f2;
        }
        e3[j] = g2;
      }
      f2 = 0;
      for (j = 0; j < i2; j++) {
        e3[j] /= h2;
        f2 += e3[j] * d3[j];
      }
      hh = f2 / (h2 + h2);
      for (j = 0; j < i2; j++) {
        e3[j] -= hh * d3[j];
      }
      for (j = 0; j < i2; j++) {
        f2 = d3[j];
        g2 = e3[j];
        for (k = j; k <= i2 - 1; k++) {
          V2.set(k, j, V2.get(k, j) - (f2 * e3[k] + g2 * d3[k]));
        }
        d3[j] = V2.get(i2 - 1, j);
        V2.set(i2, j, 0);
      }
    }
    d3[i2] = h2;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    V2.set(n2 - 1, i2, V2.get(i2, i2));
    V2.set(i2, i2, 1);
    h2 = d3[i2 + 1];
    if (h2 !== 0) {
      for (k = 0; k <= i2; k++) {
        d3[k] = V2.get(k, i2 + 1) / h2;
      }
      for (j = 0; j <= i2; j++) {
        g2 = 0;
        for (k = 0; k <= i2; k++) {
          g2 += V2.get(k, i2 + 1) * V2.get(k, j);
        }
        for (k = 0; k <= i2; k++) {
          V2.set(k, j, V2.get(k, j) - g2 * d3[k]);
        }
      }
    }
    for (k = 0; k <= i2; k++) {
      V2.set(k, i2 + 1, 0);
    }
  }
  for (j = 0; j < n2; j++) {
    d3[j] = V2.get(n2 - 1, j);
    V2.set(n2 - 1, j, 0);
  }
  V2.set(n2 - 1, n2 - 1, 1);
  e3[0] = 0;
}
function tql2(n2, e3, d3, V2) {
  let g2, h2, i2, j, k, l2, m3, p2, r2, dl1, c2, c22, c3, el1, s3, s22;
  for (i2 = 1; i2 < n2; i2++) {
    e3[i2 - 1] = e3[i2];
  }
  e3[n2 - 1] = 0;
  let f2 = 0;
  let tst1 = 0;
  let eps = Number.EPSILON;
  for (l2 = 0; l2 < n2; l2++) {
    tst1 = Math.max(tst1, Math.abs(d3[l2]) + Math.abs(e3[l2]));
    m3 = l2;
    while (m3 < n2) {
      if (Math.abs(e3[m3]) <= eps * tst1) {
        break;
      }
      m3++;
    }
    if (m3 > l2) {
      do {
        g2 = d3[l2];
        p2 = (d3[l2 + 1] - g2) / (2 * e3[l2]);
        r2 = hypotenuse(p2, 1);
        if (p2 < 0) {
          r2 = -r2;
        }
        d3[l2] = e3[l2] / (p2 + r2);
        d3[l2 + 1] = e3[l2] * (p2 + r2);
        dl1 = d3[l2 + 1];
        h2 = g2 - d3[l2];
        for (i2 = l2 + 2; i2 < n2; i2++) {
          d3[i2] -= h2;
        }
        f2 = f2 + h2;
        p2 = d3[m3];
        c2 = 1;
        c22 = c2;
        c3 = c2;
        el1 = e3[l2 + 1];
        s3 = 0;
        s22 = 0;
        for (i2 = m3 - 1; i2 >= l2; i2--) {
          c3 = c22;
          c22 = c2;
          s22 = s3;
          g2 = c2 * e3[i2];
          h2 = c2 * p2;
          r2 = hypotenuse(p2, e3[i2]);
          e3[i2 + 1] = s3 * r2;
          s3 = e3[i2] / r2;
          c2 = p2 / r2;
          p2 = c2 * d3[i2] - s3 * g2;
          d3[i2 + 1] = h2 + s3 * (c2 * g2 + s3 * d3[i2]);
          for (k = 0; k < n2; k++) {
            h2 = V2.get(k, i2 + 1);
            V2.set(k, i2 + 1, s3 * V2.get(k, i2) + c2 * h2);
            V2.set(k, i2, c2 * V2.get(k, i2) - s3 * h2);
          }
        }
        p2 = -s3 * s22 * c3 * el1 * e3[l2] / dl1;
        e3[l2] = s3 * p2;
        d3[l2] = c2 * p2;
      } while (Math.abs(e3[l2]) > eps * tst1);
    }
    d3[l2] = d3[l2] + f2;
    e3[l2] = 0;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    k = i2;
    p2 = d3[i2];
    for (j = i2 + 1; j < n2; j++) {
      if (d3[j] < p2) {
        k = j;
        p2 = d3[j];
      }
    }
    if (k !== i2) {
      d3[k] = d3[i2];
      d3[i2] = p2;
      for (j = 0; j < n2; j++) {
        p2 = V2.get(j, i2);
        V2.set(j, i2, V2.get(j, k));
        V2.set(j, k, p2);
      }
    }
  }
}
function orthes(n2, H4, ort, V2) {
  let low = 0;
  let high = n2 - 1;
  let f2, g2, h2, i2, j, m3;
  let scale3;
  for (m3 = low + 1; m3 <= high - 1; m3++) {
    scale3 = 0;
    for (i2 = m3; i2 <= high; i2++) {
      scale3 = scale3 + Math.abs(H4.get(i2, m3 - 1));
    }
    if (scale3 !== 0) {
      h2 = 0;
      for (i2 = high; i2 >= m3; i2--) {
        ort[i2] = H4.get(i2, m3 - 1) / scale3;
        h2 += ort[i2] * ort[i2];
      }
      g2 = Math.sqrt(h2);
      if (ort[m3] > 0) {
        g2 = -g2;
      }
      h2 = h2 - ort[m3] * g2;
      ort[m3] = ort[m3] - g2;
      for (j = m3; j < n2; j++) {
        f2 = 0;
        for (i2 = high; i2 >= m3; i2--) {
          f2 += ort[i2] * H4.get(i2, j);
        }
        f2 = f2 / h2;
        for (i2 = m3; i2 <= high; i2++) {
          H4.set(i2, j, H4.get(i2, j) - f2 * ort[i2]);
        }
      }
      for (i2 = 0; i2 <= high; i2++) {
        f2 = 0;
        for (j = high; j >= m3; j--) {
          f2 += ort[j] * H4.get(i2, j);
        }
        f2 = f2 / h2;
        for (j = m3; j <= high; j++) {
          H4.set(i2, j, H4.get(i2, j) - f2 * ort[j]);
        }
      }
      ort[m3] = scale3 * ort[m3];
      H4.set(m3, m3 - 1, scale3 * g2);
    }
  }
  for (i2 = 0; i2 < n2; i2++) {
    for (j = 0; j < n2; j++) {
      V2.set(i2, j, i2 === j ? 1 : 0);
    }
  }
  for (m3 = high - 1; m3 >= low + 1; m3--) {
    if (H4.get(m3, m3 - 1) !== 0) {
      for (i2 = m3 + 1; i2 <= high; i2++) {
        ort[i2] = H4.get(i2, m3 - 1);
      }
      for (j = m3; j <= high; j++) {
        g2 = 0;
        for (i2 = m3; i2 <= high; i2++) {
          g2 += ort[i2] * V2.get(i2, j);
        }
        g2 = g2 / ort[m3] / H4.get(m3, m3 - 1);
        for (i2 = m3; i2 <= high; i2++) {
          V2.set(i2, j, V2.get(i2, j) + g2 * ort[i2]);
        }
      }
    }
  }
}
function hqr2(nn, e3, d3, V2, H4) {
  let n2 = nn - 1;
  let low = 0;
  let high = nn - 1;
  let eps = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p2 = 0;
  let q = 0;
  let r2 = 0;
  let s3 = 0;
  let z2 = 0;
  let iter = 0;
  let i2, j, k, l2, m3, t3, w2, x2, y2;
  let ra, sa, vr, vi;
  let notlast, cdivres;
  for (i2 = 0; i2 < nn; i2++) {
    if (i2 < low || i2 > high) {
      d3[i2] = H4.get(i2, i2);
      e3[i2] = 0;
    }
    for (j = Math.max(i2 - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H4.get(i2, j));
    }
  }
  while (n2 >= low) {
    l2 = n2;
    while (l2 > low) {
      s3 = Math.abs(H4.get(l2 - 1, l2 - 1)) + Math.abs(H4.get(l2, l2));
      if (s3 === 0) {
        s3 = norm;
      }
      if (Math.abs(H4.get(l2, l2 - 1)) < eps * s3) {
        break;
      }
      l2--;
    }
    if (l2 === n2) {
      H4.set(n2, n2, H4.get(n2, n2) + exshift);
      d3[n2] = H4.get(n2, n2);
      e3[n2] = 0;
      n2--;
      iter = 0;
    } else if (l2 === n2 - 1) {
      w2 = H4.get(n2, n2 - 1) * H4.get(n2 - 1, n2);
      p2 = (H4.get(n2 - 1, n2 - 1) - H4.get(n2, n2)) / 2;
      q = p2 * p2 + w2;
      z2 = Math.sqrt(Math.abs(q));
      H4.set(n2, n2, H4.get(n2, n2) + exshift);
      H4.set(n2 - 1, n2 - 1, H4.get(n2 - 1, n2 - 1) + exshift);
      x2 = H4.get(n2, n2);
      if (q >= 0) {
        z2 = p2 >= 0 ? p2 + z2 : p2 - z2;
        d3[n2 - 1] = x2 + z2;
        d3[n2] = d3[n2 - 1];
        if (z2 !== 0) {
          d3[n2] = x2 - w2 / z2;
        }
        e3[n2 - 1] = 0;
        e3[n2] = 0;
        x2 = H4.get(n2, n2 - 1);
        s3 = Math.abs(x2) + Math.abs(z2);
        p2 = x2 / s3;
        q = z2 / s3;
        r2 = Math.sqrt(p2 * p2 + q * q);
        p2 = p2 / r2;
        q = q / r2;
        for (j = n2 - 1; j < nn; j++) {
          z2 = H4.get(n2 - 1, j);
          H4.set(n2 - 1, j, q * z2 + p2 * H4.get(n2, j));
          H4.set(n2, j, q * H4.get(n2, j) - p2 * z2);
        }
        for (i2 = 0; i2 <= n2; i2++) {
          z2 = H4.get(i2, n2 - 1);
          H4.set(i2, n2 - 1, q * z2 + p2 * H4.get(i2, n2));
          H4.set(i2, n2, q * H4.get(i2, n2) - p2 * z2);
        }
        for (i2 = low; i2 <= high; i2++) {
          z2 = V2.get(i2, n2 - 1);
          V2.set(i2, n2 - 1, q * z2 + p2 * V2.get(i2, n2));
          V2.set(i2, n2, q * V2.get(i2, n2) - p2 * z2);
        }
      } else {
        d3[n2 - 1] = x2 + p2;
        d3[n2] = x2 + p2;
        e3[n2 - 1] = z2;
        e3[n2] = -z2;
      }
      n2 = n2 - 2;
      iter = 0;
    } else {
      x2 = H4.get(n2, n2);
      y2 = 0;
      w2 = 0;
      if (l2 < n2) {
        y2 = H4.get(n2 - 1, n2 - 1);
        w2 = H4.get(n2, n2 - 1) * H4.get(n2 - 1, n2);
      }
      if (iter === 10) {
        exshift += x2;
        for (i2 = low; i2 <= n2; i2++) {
          H4.set(i2, i2, H4.get(i2, i2) - x2);
        }
        s3 = Math.abs(H4.get(n2, n2 - 1)) + Math.abs(H4.get(n2 - 1, n2 - 2));
        x2 = y2 = 0.75 * s3;
        w2 = -0.4375 * s3 * s3;
      }
      if (iter === 30) {
        s3 = (y2 - x2) / 2;
        s3 = s3 * s3 + w2;
        if (s3 > 0) {
          s3 = Math.sqrt(s3);
          if (y2 < x2) {
            s3 = -s3;
          }
          s3 = x2 - w2 / ((y2 - x2) / 2 + s3);
          for (i2 = low; i2 <= n2; i2++) {
            H4.set(i2, i2, H4.get(i2, i2) - s3);
          }
          exshift += s3;
          x2 = y2 = w2 = 0.964;
        }
      }
      iter = iter + 1;
      m3 = n2 - 2;
      while (m3 >= l2) {
        z2 = H4.get(m3, m3);
        r2 = x2 - z2;
        s3 = y2 - z2;
        p2 = (r2 * s3 - w2) / H4.get(m3 + 1, m3) + H4.get(m3, m3 + 1);
        q = H4.get(m3 + 1, m3 + 1) - z2 - r2 - s3;
        r2 = H4.get(m3 + 2, m3 + 1);
        s3 = Math.abs(p2) + Math.abs(q) + Math.abs(r2);
        p2 = p2 / s3;
        q = q / s3;
        r2 = r2 / s3;
        if (m3 === l2) {
          break;
        }
        if (Math.abs(H4.get(m3, m3 - 1)) * (Math.abs(q) + Math.abs(r2)) < eps * (Math.abs(p2) * (Math.abs(H4.get(m3 - 1, m3 - 1)) + Math.abs(z2) + Math.abs(H4.get(m3 + 1, m3 + 1))))) {
          break;
        }
        m3--;
      }
      for (i2 = m3 + 2; i2 <= n2; i2++) {
        H4.set(i2, i2 - 2, 0);
        if (i2 > m3 + 2) {
          H4.set(i2, i2 - 3, 0);
        }
      }
      for (k = m3; k <= n2 - 1; k++) {
        notlast = k !== n2 - 1;
        if (k !== m3) {
          p2 = H4.get(k, k - 1);
          q = H4.get(k + 1, k - 1);
          r2 = notlast ? H4.get(k + 2, k - 1) : 0;
          x2 = Math.abs(p2) + Math.abs(q) + Math.abs(r2);
          if (x2 !== 0) {
            p2 = p2 / x2;
            q = q / x2;
            r2 = r2 / x2;
          }
        }
        if (x2 === 0) {
          break;
        }
        s3 = Math.sqrt(p2 * p2 + q * q + r2 * r2);
        if (p2 < 0) {
          s3 = -s3;
        }
        if (s3 !== 0) {
          if (k !== m3) {
            H4.set(k, k - 1, -s3 * x2);
          } else if (l2 !== m3) {
            H4.set(k, k - 1, -H4.get(k, k - 1));
          }
          p2 = p2 + s3;
          x2 = p2 / s3;
          y2 = q / s3;
          z2 = r2 / s3;
          q = q / p2;
          r2 = r2 / p2;
          for (j = k; j < nn; j++) {
            p2 = H4.get(k, j) + q * H4.get(k + 1, j);
            if (notlast) {
              p2 = p2 + r2 * H4.get(k + 2, j);
              H4.set(k + 2, j, H4.get(k + 2, j) - p2 * z2);
            }
            H4.set(k, j, H4.get(k, j) - p2 * x2);
            H4.set(k + 1, j, H4.get(k + 1, j) - p2 * y2);
          }
          for (i2 = 0; i2 <= Math.min(n2, k + 3); i2++) {
            p2 = x2 * H4.get(i2, k) + y2 * H4.get(i2, k + 1);
            if (notlast) {
              p2 = p2 + z2 * H4.get(i2, k + 2);
              H4.set(i2, k + 2, H4.get(i2, k + 2) - p2 * r2);
            }
            H4.set(i2, k, H4.get(i2, k) - p2);
            H4.set(i2, k + 1, H4.get(i2, k + 1) - p2 * q);
          }
          for (i2 = low; i2 <= high; i2++) {
            p2 = x2 * V2.get(i2, k) + y2 * V2.get(i2, k + 1);
            if (notlast) {
              p2 = p2 + z2 * V2.get(i2, k + 2);
              V2.set(i2, k + 2, V2.get(i2, k + 2) - p2 * r2);
            }
            V2.set(i2, k, V2.get(i2, k) - p2);
            V2.set(i2, k + 1, V2.get(i2, k + 1) - p2 * q);
          }
        }
      }
    }
  }
  if (norm === 0) {
    return;
  }
  for (n2 = nn - 1; n2 >= 0; n2--) {
    p2 = d3[n2];
    q = e3[n2];
    if (q === 0) {
      l2 = n2;
      H4.set(n2, n2, 1);
      for (i2 = n2 - 1; i2 >= 0; i2--) {
        w2 = H4.get(i2, i2) - p2;
        r2 = 0;
        for (j = l2; j <= n2; j++) {
          r2 = r2 + H4.get(i2, j) * H4.get(j, n2);
        }
        if (e3[i2] < 0) {
          z2 = w2;
          s3 = r2;
        } else {
          l2 = i2;
          if (e3[i2] === 0) {
            H4.set(i2, n2, w2 !== 0 ? -r2 / w2 : -r2 / (eps * norm));
          } else {
            x2 = H4.get(i2, i2 + 1);
            y2 = H4.get(i2 + 1, i2);
            q = (d3[i2] - p2) * (d3[i2] - p2) + e3[i2] * e3[i2];
            t3 = (x2 * s3 - z2 * r2) / q;
            H4.set(i2, n2, t3);
            H4.set(
              i2 + 1,
              n2,
              Math.abs(x2) > Math.abs(z2) ? (-r2 - w2 * t3) / x2 : (-s3 - y2 * t3) / z2
            );
          }
          t3 = Math.abs(H4.get(i2, n2));
          if (eps * t3 * t3 > 1) {
            for (j = i2; j <= n2; j++) {
              H4.set(j, n2, H4.get(j, n2) / t3);
            }
          }
        }
      }
    } else if (q < 0) {
      l2 = n2 - 1;
      if (Math.abs(H4.get(n2, n2 - 1)) > Math.abs(H4.get(n2 - 1, n2))) {
        H4.set(n2 - 1, n2 - 1, q / H4.get(n2, n2 - 1));
        H4.set(n2 - 1, n2, -(H4.get(n2, n2) - p2) / H4.get(n2, n2 - 1));
      } else {
        cdivres = cdiv(0, -H4.get(n2 - 1, n2), H4.get(n2 - 1, n2 - 1) - p2, q);
        H4.set(n2 - 1, n2 - 1, cdivres[0]);
        H4.set(n2 - 1, n2, cdivres[1]);
      }
      H4.set(n2, n2 - 1, 0);
      H4.set(n2, n2, 1);
      for (i2 = n2 - 2; i2 >= 0; i2--) {
        ra = 0;
        sa = 0;
        for (j = l2; j <= n2; j++) {
          ra = ra + H4.get(i2, j) * H4.get(j, n2 - 1);
          sa = sa + H4.get(i2, j) * H4.get(j, n2);
        }
        w2 = H4.get(i2, i2) - p2;
        if (e3[i2] < 0) {
          z2 = w2;
          r2 = ra;
          s3 = sa;
        } else {
          l2 = i2;
          if (e3[i2] === 0) {
            cdivres = cdiv(-ra, -sa, w2, q);
            H4.set(i2, n2 - 1, cdivres[0]);
            H4.set(i2, n2, cdivres[1]);
          } else {
            x2 = H4.get(i2, i2 + 1);
            y2 = H4.get(i2 + 1, i2);
            vr = (d3[i2] - p2) * (d3[i2] - p2) + e3[i2] * e3[i2] - q * q;
            vi = (d3[i2] - p2) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr = eps * norm * (Math.abs(w2) + Math.abs(q) + Math.abs(x2) + Math.abs(y2) + Math.abs(z2));
            }
            cdivres = cdiv(
              x2 * r2 - z2 * ra + q * sa,
              x2 * s3 - z2 * sa - q * ra,
              vr,
              vi
            );
            H4.set(i2, n2 - 1, cdivres[0]);
            H4.set(i2, n2, cdivres[1]);
            if (Math.abs(x2) > Math.abs(z2) + Math.abs(q)) {
              H4.set(
                i2 + 1,
                n2 - 1,
                (-ra - w2 * H4.get(i2, n2 - 1) + q * H4.get(i2, n2)) / x2
              );
              H4.set(
                i2 + 1,
                n2,
                (-sa - w2 * H4.get(i2, n2) - q * H4.get(i2, n2 - 1)) / x2
              );
            } else {
              cdivres = cdiv(
                -r2 - y2 * H4.get(i2, n2 - 1),
                -s3 - y2 * H4.get(i2, n2),
                z2,
                q
              );
              H4.set(i2 + 1, n2 - 1, cdivres[0]);
              H4.set(i2 + 1, n2, cdivres[1]);
            }
          }
          t3 = Math.max(Math.abs(H4.get(i2, n2 - 1)), Math.abs(H4.get(i2, n2)));
          if (eps * t3 * t3 > 1) {
            for (j = i2; j <= n2; j++) {
              H4.set(j, n2 - 1, H4.get(j, n2 - 1) / t3);
              H4.set(j, n2, H4.get(j, n2) / t3);
            }
          }
        }
      }
    }
  }
  for (i2 = 0; i2 < nn; i2++) {
    if (i2 < low || i2 > high) {
      for (j = i2; j < nn; j++) {
        V2.set(i2, j, H4.get(i2, j));
      }
    }
  }
  for (j = nn - 1; j >= low; j--) {
    for (i2 = low; i2 <= high; i2++) {
      z2 = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z2 = z2 + V2.get(i2, k) * H4.get(k, j);
      }
      V2.set(i2, j, z2);
    }
  }
}
function cdiv(xr, xi, yr, yi) {
  let r2, d3;
  if (Math.abs(yr) > Math.abs(yi)) {
    r2 = yi / yr;
    d3 = yr + r2 * yi;
    return [(xr + r2 * xi) / d3, (xi - r2 * xr) / d3];
  } else {
    r2 = yr / yi;
    d3 = yi + r2 * yr;
    return [(r2 * xr + xi) / d3, (r2 * xi - xr) / d3];
  }
}
class CholeskyDecomposition {
  constructor(value) {
    value = WrapperMatrix2D.checkMatrix(value);
    if (!value.isSymmetric()) {
      throw new Error("Matrix is not symmetric");
    }
    let a2 = value;
    let dimension = a2.rows;
    let l2 = new Matrix$1(dimension, dimension);
    let positiveDefinite = true;
    let i2, j, k;
    for (j = 0; j < dimension; j++) {
      let d3 = 0;
      for (k = 0; k < j; k++) {
        let s3 = 0;
        for (i2 = 0; i2 < k; i2++) {
          s3 += l2.get(k, i2) * l2.get(j, i2);
        }
        s3 = (a2.get(j, k) - s3) / l2.get(k, k);
        l2.set(j, k, s3);
        d3 = d3 + s3 * s3;
      }
      d3 = a2.get(j, j) - d3;
      positiveDefinite && (positiveDefinite = d3 > 0);
      l2.set(j, j, Math.sqrt(Math.max(d3, 0)));
      for (k = j + 1; k < dimension; k++) {
        l2.set(j, k, 0);
      }
    }
    this.L = l2;
    this.positiveDefinite = positiveDefinite;
  }
  isPositiveDefinite() {
    return this.positiveDefinite;
  }
  solve(value) {
    value = WrapperMatrix2D.checkMatrix(value);
    let l2 = this.L;
    let dimension = l2.rows;
    if (value.rows !== dimension) {
      throw new Error("Matrix dimensions do not match");
    }
    if (this.isPositiveDefinite() === false) {
      throw new Error("Matrix is not positive definite");
    }
    let count = value.columns;
    let B4 = value.clone();
    let i2, j, k;
    for (k = 0; k < dimension; k++) {
      for (j = 0; j < count; j++) {
        for (i2 = 0; i2 < k; i2++) {
          B4.set(k, j, B4.get(k, j) - B4.get(i2, j) * l2.get(k, i2));
        }
        B4.set(k, j, B4.get(k, j) / l2.get(k, k));
      }
    }
    for (k = dimension - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        for (i2 = k + 1; i2 < dimension; i2++) {
          B4.set(k, j, B4.get(k, j) - B4.get(i2, j) * l2.get(i2, k));
        }
        B4.set(k, j, B4.get(k, j) / l2.get(k, k));
      }
    }
    return B4;
  }
  get lowerTriangularMatrix() {
    return this.L;
  }
}
class nipals {
  constructor(X, options = {}) {
    X = WrapperMatrix2D.checkMatrix(X);
    let { Y: Y2 } = options;
    const {
      scaleScores = false,
      maxIterations = 1e3,
      terminationCriteria = 1e-10
    } = options;
    let u2;
    if (Y2) {
      if (isAnyArray.isAnyArray(Y2) && typeof Y2[0] === "number") {
        Y2 = Matrix$1.columnVector(Y2);
      } else {
        Y2 = WrapperMatrix2D.checkMatrix(Y2);
      }
      if (Y2.rows !== X.rows) {
        throw new Error("Y should have the same number of rows as X");
      }
      u2 = Y2.getColumnVector(0);
    } else {
      u2 = X.getColumnVector(0);
    }
    let diff = 1;
    let t3, q, w2, tOld;
    for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
      w2 = X.transpose().mmul(u2).div(u2.transpose().mmul(u2).get(0, 0));
      w2 = w2.div(w2.norm());
      t3 = X.mmul(w2).div(w2.transpose().mmul(w2).get(0, 0));
      if (counter > 0) {
        diff = t3.clone().sub(tOld).pow(2).sum();
      }
      tOld = t3.clone();
      if (Y2) {
        q = Y2.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
        q = q.div(q.norm());
        u2 = Y2.mmul(q).div(q.transpose().mmul(q).get(0, 0));
      } else {
        u2 = t3;
      }
    }
    if (Y2) {
      let p2 = X.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
      p2 = p2.div(p2.norm());
      let xResidual = X.clone().sub(t3.clone().mmul(p2.transpose()));
      let residual = u2.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
      let yResidual = Y2.clone().sub(
        t3.clone().mulS(residual.get(0, 0)).mmul(q.transpose())
      );
      this.t = t3;
      this.p = p2.transpose();
      this.w = w2.transpose();
      this.q = q;
      this.u = u2;
      this.s = t3.transpose().mmul(t3);
      this.xResidual = xResidual;
      this.yResidual = yResidual;
      this.betas = residual;
    } else {
      this.w = w2.transpose();
      this.s = t3.transpose().mmul(t3).sqrt();
      if (scaleScores) {
        this.t = t3.clone().div(this.s.get(0, 0));
      } else {
        this.t = t3;
      }
      this.xResidual = X.sub(t3.mmul(w2.transpose()));
    }
  }
}
matrix2.AbstractMatrix = AbstractMatrix;
matrix2.CHO = CholeskyDecomposition;
matrix2.CholeskyDecomposition = CholeskyDecomposition;
matrix2.DistanceMatrix = DistanceMatrix;
matrix2.EVD = EigenvalueDecomposition;
matrix2.EigenvalueDecomposition = EigenvalueDecomposition;
matrix2.LU = LuDecomposition;
matrix2.LuDecomposition = LuDecomposition;
var Matrix_1 = matrix2.Matrix = Matrix$1;
matrix2.MatrixColumnSelectionView = MatrixColumnSelectionView;
matrix2.MatrixColumnView = MatrixColumnView;
matrix2.MatrixFlipColumnView = MatrixFlipColumnView;
matrix2.MatrixFlipRowView = MatrixFlipRowView;
matrix2.MatrixRowSelectionView = MatrixRowSelectionView;
matrix2.MatrixRowView = MatrixRowView;
matrix2.MatrixSelectionView = MatrixSelectionView;
matrix2.MatrixSubView = MatrixSubView;
matrix2.MatrixTransposeView = MatrixTransposeView;
matrix2.NIPALS = nipals;
matrix2.Nipals = nipals;
matrix2.QR = QrDecomposition;
matrix2.QrDecomposition = QrDecomposition;
matrix2.SVD = SingularValueDecomposition$1;
var SingularValueDecomposition_1 = matrix2.SingularValueDecomposition = SingularValueDecomposition$1;
matrix2.SymmetricMatrix = SymmetricMatrix;
matrix2.WrapperMatrix1D = WrapperMatrix1D;
matrix2.WrapperMatrix2D = WrapperMatrix2D;
matrix2.correlation = correlation;
matrix2.covariance = covariance;
var _default = matrix2.default = Matrix$1;
matrix2.determinant = determinant;
matrix2.inverse = inverse;
matrix2.linearDependencies = linearDependencies;
matrix2.pseudoInverse = pseudoInverse;
matrix2.solve = solve;
matrix2.wrap = wrap$1;
const Matrix = Matrix_1;
const SingularValueDecomposition2 = SingularValueDecomposition_1;
_default.Matrix ? _default.Matrix : Matrix_1;
const DEFAULTS_LAYOUT_OPTIONS$7 = {
  center: [0, 0],
  linkDistance: 50
};
class MDSLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "mds";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$7), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericMDSLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericMDSLayout(true, graph2, options);
    });
  }
  genericMDSLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center = [0, 0], linkDistance = 50 } = mergedOptions;
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph2, assign, center);
      }
      const adjMatrix = getAdjMatrix({ nodes, edges });
      const distances = floydWarshall(adjMatrix);
      handleInfinity$1(distances);
      const scaledD = scaleMatrix(distances, linkDistance);
      const positions = runMDS(scaledD);
      const layoutNodes = [];
      positions.forEach((p2, i2) => {
        const cnode = cloneFormatData(nodes[i2]);
        cnode.data.x = p2[0] + center[0];
        cnode.data.y = p2[1] + center[1];
        layoutNodes.push(cnode);
      });
      if (assign) {
        layoutNodes.forEach((node) => graph2.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
}
const handleInfinity$1 = (distances) => {
  let maxDistance = -999999;
  distances.forEach((row2) => {
    row2.forEach((value) => {
      if (value === Infinity) {
        return;
      }
      if (maxDistance < value) {
        maxDistance = value;
      }
    });
  });
  distances.forEach((row2, i2) => {
    row2.forEach((value, j) => {
      if (value === Infinity) {
        distances[i2][j] = maxDistance;
      }
    });
  });
};
const runMDS = (distances) => {
  const dimension = 2;
  const M2 = Matrix.mul(Matrix.pow(distances, 2), -0.5);
  const rowMeans = M2.mean("row");
  const colMeans = M2.mean("column");
  const totalMean = M2.mean();
  M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
  const ret = new SingularValueDecomposition2(M2);
  const eigenValues = Matrix.sqrt(ret.diagonalMatrix).diagonal();
  return ret.leftSingularVectors.toJSON().map((row2) => {
    return Matrix.mul([row2], [eigenValues]).toJSON()[0].splice(0, dimension);
  });
};
function isLayoutWithIterations(layout2) {
  return !!layout2.tick && !!layout2.stop;
}
const FORCE_LAYOUT_TYPE_MAP = {
  gForce: true,
  force2: true,
  d3force: true,
  fruchterman: true,
  forceAtlas2: true,
  force: true,
  "graphin-force": true
};
const DEFAULTS_LAYOUT_OPTIONS$6 = {
  center: [0, 0],
  comboPadding: 10,
  treeKey: "combo"
};
class ComboCombinedLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "comboCombined";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$6), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericComboCombinedLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericComboCombinedLayout(true, graph2, options);
    });
  }
  genericComboCombinedLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = this.initVals(Object.assign(Object.assign({}, this.options), options));
      const { center, treeKey, outerLayout: propsOuterLayout } = mergedOptions;
      const nodes = graph2.getAllNodes().filter((node) => !node.data._isCombo);
      const combos = graph2.getAllNodes().filter((node) => node.data._isCombo);
      const edges = graph2.getAllEdges();
      const n2 = nodes === null || nodes === void 0 ? void 0 : nodes.length;
      if (!n2 || n2 === 1) {
        return handleSingleNodeGraph(graph2, assign, center);
      }
      const layoutNodes = [];
      const nodeMap = /* @__PURE__ */ new Map();
      nodes.forEach((node) => {
        nodeMap.set(node.id, node);
      });
      const comboMap = /* @__PURE__ */ new Map();
      combos.forEach((combo) => {
        comboMap.set(combo.id, combo);
      });
      const comboNodes = /* @__PURE__ */ new Map();
      const innerGraphLayoutPromises = this.getInnerGraphs(graph2, treeKey, nodeMap, comboMap, edges, mergedOptions, comboNodes);
      yield Promise.all(innerGraphLayoutPromises);
      const outerNodeIds = /* @__PURE__ */ new Map();
      const outerLayoutNodes = [];
      const nodeAncestorIdMap = /* @__PURE__ */ new Map();
      let allHaveNoPosition = true;
      graph2.getRoots(treeKey).forEach((root2) => {
        const combo = comboNodes.get(root2.id);
        const cacheCombo = comboMap.get(root2.id) || nodeMap.get(root2.id);
        const comboLayoutNode = {
          id: root2.id,
          data: Object.assign(Object.assign({}, root2.data), { x: combo.data.x || cacheCombo.data.x, y: combo.data.y || cacheCombo.data.y, fx: combo.data.fx || cacheCombo.data.fx, fy: combo.data.fy || cacheCombo.data.fy, mass: combo.data.mass || cacheCombo.data.mass, size: combo.data.size })
        };
        outerLayoutNodes.push(comboLayoutNode);
        outerNodeIds.set(root2.id, true);
        if (!isNaN(comboLayoutNode.data.x) && comboLayoutNode.data.x !== 0 && !isNaN(comboLayoutNode.data.y) && comboLayoutNode.data.y !== 0) {
          allHaveNoPosition = false;
        } else {
          comboLayoutNode.data.x = Math.random() * 100;
          comboLayoutNode.data.y = Math.random() * 100;
        }
        graphTreeDfs(graph2, [root2], (child) => {
          if (child.id !== root2.id)
            nodeAncestorIdMap.set(child.id, root2.id);
        }, "TB", treeKey);
      });
      const outerLayoutEdges = [];
      edges.forEach((edge) => {
        const sourceAncestorId = nodeAncestorIdMap.get(edge.source) || edge.source;
        const targetAncestorId = nodeAncestorIdMap.get(edge.target) || edge.target;
        if (sourceAncestorId !== targetAncestorId && outerNodeIds.has(sourceAncestorId) && outerNodeIds.has(targetAncestorId)) {
          outerLayoutEdges.push({
            id: edge.id,
            source: sourceAncestorId,
            target: targetAncestorId,
            data: {}
          });
        }
      });
      let outerPositions;
      if (outerLayoutNodes === null || outerLayoutNodes === void 0 ? void 0 : outerLayoutNodes.length) {
        if (outerLayoutNodes.length === 1) {
          outerLayoutNodes[0].data.x = center[0];
          outerLayoutNodes[0].data.y = center[1];
        } else {
          const outerLayoutGraph = new Graph$9({
            nodes: outerLayoutNodes,
            edges: outerLayoutEdges
          });
          const outerLayout = propsOuterLayout || new ForceLayout();
          if (allHaveNoPosition && FORCE_LAYOUT_TYPE_MAP[outerLayout.id]) {
            const outerLayoutPreset = outerLayoutNodes.length < 100 ? new MDSLayout() : new ConcentricLayout();
            yield outerLayoutPreset.assign(outerLayoutGraph);
          }
          const options2 = Object.assign({ center, kg: 5, preventOverlap: true, animate: false }, outerLayout.id === "force" ? {
            gravity: 1,
            factor: 4,
            linkDistance: (edge, source, target) => {
              const sourceSize = Math.max(...source.data.size) || 32;
              const targetSize = Math.max(...target.data.size) || 32;
              return sourceSize / 2 + targetSize / 2 + 200;
            }
          } : {});
          outerPositions = yield executeLayout(outerLayout, outerLayoutGraph, options2);
        }
        comboNodes.forEach((comboNode) => {
          var _a3;
          const outerPosition = outerPositions.nodes.find((pos) => pos.id === comboNode.id);
          if (outerPosition) {
            const { x: x3, y: y3 } = outerPosition.data;
            comboNode.data.visited = true;
            comboNode.data.x = x3;
            comboNode.data.y = y3;
            layoutNodes.push({
              id: comboNode.id,
              data: { x: x3, y: y3 }
            });
          }
          const { x: x2, y: y2 } = comboNode.data;
          (_a3 = comboNode.data.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((node) => {
            layoutNodes.push({
              id: node.id,
              data: { x: node.data.x + x2, y: node.data.y + y2 }
            });
          });
        });
        comboNodes.forEach(({ data: data2 }) => {
          const { x: x2, y: y2, visited, nodes: nodes2 } = data2;
          nodes2 === null || nodes2 === void 0 ? void 0 : nodes2.forEach((node) => {
            if (!visited) {
              const layoutNode = layoutNodes.find((n3) => n3.id === node.id);
              layoutNode.data.x += x2 || 0;
              layoutNode.data.y += y2 || 0;
            }
          });
        });
      }
      if (assign) {
        layoutNodes.forEach((node) => {
          graph2.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
  initVals(options) {
    const formattedOptions = Object.assign({}, options);
    const { nodeSize, spacing, comboPadding } = options;
    let nodeSizeFunc;
    let spacingFunc;
    if (isNumber(spacing)) {
      spacingFunc = () => spacing;
    } else if (isFunction$1(spacing)) {
      spacingFunc = spacing;
    } else {
      spacingFunc = () => 0;
    }
    formattedOptions.spacing = spacingFunc;
    if (!nodeSize) {
      nodeSizeFunc = (d3) => {
        const spacing2 = spacingFunc(d3);
        if (d3.size) {
          if (isArray(d3.size)) {
            const res = d3.size[0] > d3.size[1] ? d3.size[0] : d3.size[1];
            return (res + spacing2) / 2;
          }
          if (isObject$2(d3.size)) {
            const res = d3.size.width > d3.size.height ? d3.size.width : d3.size.height;
            return (res + spacing2) / 2;
          }
          return (d3.size + spacing2) / 2;
        }
        return 32 + spacing2 / 2;
      };
    } else if (isFunction$1(nodeSize)) {
      nodeSizeFunc = (d3) => {
        const size = nodeSize(d3);
        const spacing2 = spacingFunc(d3);
        if (isArray(d3.size)) {
          const res = d3.size[0] > d3.size[1] ? d3.size[0] : d3.size[1];
          return (res + spacing2) / 2;
        }
        return ((size || 32) + spacing2) / 2;
      };
    } else if (isArray(nodeSize)) {
      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
      const radius = larger / 2;
      nodeSizeFunc = (d3) => radius + spacingFunc(d3) / 2;
    } else {
      const radius = nodeSize / 2;
      nodeSizeFunc = (d3) => radius + spacingFunc(d3) / 2;
    }
    formattedOptions.nodeSize = nodeSizeFunc;
    let comboPaddingFunc;
    if (isNumber(comboPadding)) {
      comboPaddingFunc = () => comboPadding;
    } else if (isArray(comboPadding)) {
      comboPaddingFunc = () => Math.max.apply(null, comboPadding);
    } else if (isFunction$1(comboPadding)) {
      comboPaddingFunc = comboPadding;
    } else {
      comboPaddingFunc = () => 0;
    }
    formattedOptions.comboPadding = comboPaddingFunc;
    return formattedOptions;
  }
  getInnerGraphs(graph2, treeKey, nodeMap, comboMap, edges, options, comboNodes) {
    const { nodeSize, comboPadding, spacing, innerLayout } = options;
    const innerGraphLayout = innerLayout || new ConcentricLayout({});
    const innerLayoutOptions = {
      center: [0, 0],
      preventOverlap: true,
      nodeSpacing: spacing
    };
    const innerLayoutPromises = [];
    const getSize = (node) => {
      let padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(node)) || 10;
      if (isArray(padding))
        padding = Math.max(...padding);
      return {
        size: padding ? [padding * 2, padding * 2] : [30, 30],
        padding
      };
    };
    graph2.getRoots(treeKey).forEach((root2) => {
      comboNodes.set(root2.id, {
        id: root2.id,
        data: {
          nodes: [],
          size: getSize(root2).size
        }
      });
      let start = Promise.resolve();
      graphTreeDfs(graph2, [root2], (treeNode) => {
        var _a3;
        if (!treeNode.data._isCombo)
          return;
        const { size: nsize, padding } = getSize(treeNode);
        if (!((_a3 = graph2.getChildren(treeNode.id, treeKey)) === null || _a3 === void 0 ? void 0 : _a3.length)) {
          comboNodes.set(treeNode.id, {
            id: treeNode.id,
            data: Object.assign(Object.assign({}, treeNode.data), { size: nsize })
          });
        } else {
          const comboNode = comboNodes.get(treeNode.id);
          comboNodes.set(treeNode.id, {
            id: treeNode.id,
            data: Object.assign({ nodes: [] }, comboNode === null || comboNode === void 0 ? void 0 : comboNode.data)
          });
          const innerLayoutNodeIds = /* @__PURE__ */ new Map();
          const innerLayoutNodes = graph2.getChildren(treeNode.id, treeKey).map((child) => {
            if (child.data._isCombo) {
              if (!comboNodes.has(child.id)) {
                comboNodes.set(child.id, {
                  id: child.id,
                  data: Object.assign({}, child.data)
                });
              }
              innerLayoutNodeIds.set(child.id, true);
              return comboNodes.get(child.id);
            }
            const oriNode = nodeMap.get(child.id) || comboMap.get(child.id);
            innerLayoutNodeIds.set(child.id, true);
            return {
              id: child.id,
              data: Object.assign(Object.assign({}, oriNode.data), child.data)
            };
          });
          const innerGraphData = {
            nodes: innerLayoutNodes,
            edges: edges.filter((edge) => innerLayoutNodeIds.has(edge.source) && innerLayoutNodeIds.has(edge.target))
          };
          let minNodeSize = Infinity;
          innerLayoutNodes.forEach((node) => {
            var _a4;
            let { size } = node.data;
            if (!size) {
              size = ((_a4 = comboNodes.get(node.id)) === null || _a4 === void 0 ? void 0 : _a4.data.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
            }
            if (isNumber(size))
              size = [size, size];
            const [size0, size1] = size;
            if (minNodeSize > size0)
              minNodeSize = size0;
            if (minNodeSize > size1)
              minNodeSize = size1;
            node.data.size = size;
          });
          start = start.then(() => __awaiter$r(this, void 0, void 0, function* () {
            const innerGraphCore = new Graph$9(innerGraphData);
            yield executeLayout(innerGraphLayout, innerGraphCore, innerLayoutOptions, true);
            const { minX, minY, maxX, maxY } = getLayoutBBox(innerLayoutNodes);
            const center = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
            innerGraphData.nodes.forEach((node) => {
              node.data.x -= center.x;
              node.data.y -= center.y;
            });
            const size = [
              Math.max(maxX - minX, minNodeSize) + padding * 2,
              Math.max(maxY - minY, minNodeSize) + padding * 2
            ];
            comboNodes.get(treeNode.id).data.size = size;
            comboNodes.get(treeNode.id).data.nodes = innerLayoutNodes;
          }));
        }
        return true;
      }, "BT", treeKey);
      innerLayoutPromises.push(start);
    });
    return innerLayoutPromises;
  }
}
function executeLayout(layout2, graph2, options, assign) {
  var _a3;
  return __awaiter$r(this, void 0, void 0, function* () {
    if (isLayoutWithIterations(layout2)) {
      layout2.execute(graph2, options);
      layout2.stop();
      return layout2.tick((_a3 = options.iterations) !== null && _a3 !== void 0 ? _a3 : 300);
    }
    if (assign)
      return yield layout2.assign(graph2, options);
    return yield layout2.execute(graph2, options);
  });
}
function forceCenter$1(x2, y2) {
  var nodes, strength = 1;
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n2 - x2) * strength, sy = (sy / n2 - y2) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}
function constant$1(x2) {
  return function() {
    return x2;
  };
}
function jiggle$1(random) {
  return (random() - 0.5) * 1e-6;
}
function x$2(d3) {
  return d3.x + d3.vx;
}
function y$2(d3) {
  return d3.y + d3.vy;
}
function forceCollide(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function") radius = constant$1(radius == null ? 1 : +radius);
  function force() {
    var i2, n2 = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x$2, y$2).visitAfter(prepare);
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply2);
      }
    }
    function apply2(quad, x0, y0, x1, y1) {
      var data2 = quad.data, rj = quad.r, r2 = ri + rj;
      if (data2) {
        if (data2.index > node.index) {
          var x2 = xi - data2.x - data2.vx, y2 = yi - data2.y - data2.vy, l2 = x2 * x2 + y2 * y2;
          if (l2 < r2 * r2) {
            if (x2 === 0) x2 = jiggle$1(random), l2 += x2 * x2;
            if (y2 === 0) y2 = jiggle$1(random), l2 += y2 * y2;
            l2 = (r2 - (l2 = Math.sqrt(l2))) / l2 * strength;
            node.vx += (x2 *= l2) * (r2 = (rj *= rj) / (ri2 + rj));
            node.vy += (y2 *= l2) * r2;
            data2.vx -= x2 * (r2 = 1 - r2);
            data2.vy -= y2 * r2;
          }
        }
        return;
      }
      return x0 > xi + r2 || x1 < xi - r2 || y0 > yi + r2 || y1 < yi - r2;
    }
  }
  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i2 = quad.r = 0; i2 < 4; ++i2) {
      if (quad[i2] && quad[i2].r > quad.r) {
        quad.r = quad[i2].r;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node;
    radii = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node = nodes[i2], radii[node.index] = +radius(node, i2, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : radius;
  };
  return force;
}
function index$1(d3) {
  return d3.index;
}
function find$1(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function forceLink$1(links) {
  var id2 = index$1, strength = defaultStrength, strengths, distance2 = constant$1(30), distances, nodes, count, bias, random, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n2 = links.length; k < iterations; ++k) {
      for (var i2 = 0, link, source, target, x2, y2, l2, b2; i2 < n2; ++i2) {
        link = links[i2], source = link.source, target = link.target;
        x2 = target.x + target.vx - source.x - source.vx || jiggle$1(random);
        y2 = target.y + target.vy - source.y - source.vy || jiggle$1(random);
        l2 = Math.sqrt(x2 * x2 + y2 * y2);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x2 *= l2, y2 *= l2;
        target.vx -= x2 * (b2 = bias[i2]);
        target.vy -= y2 * b2;
        source.vx += x2 * (b2 = 1 - b2);
        source.vy += y2 * b2;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d3, i3) => [id2(d3, i3, nodes), d3])), link;
    for (i2 = 0, count = new Array(n2); i2 < m3; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object") link.source = find$1(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find$1(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link = links[i2], bias[i2] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance2(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$1(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance2 = typeof _2 === "function" ? _2 : constant$1(+_2), initializeDistance(), force) : distance2;
  };
  return force;
}
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t3; i2 < n2; ++i2) {
    if (!(t3 = arguments[i2] + "") || t3 in _2 || /[\s.]/.test(t3)) throw new Error("illegal type: " + t3);
    _2[t3] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t3) {
    var name = "", i2 = t3.indexOf(".");
    if (i2 >= 0) name = t3.slice(i2 + 1), t3 = t3.slice(0, i2);
    if (t3 && !types.hasOwnProperty(t3)) throw new Error("unknown type: " + t3);
    return { type: t3, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T2 = parseTypenames(typename + "", _2), t3, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      while (++i2 < n2) if ((t3 = (typename = T2[i2]).type) && (t3 = get(_2[t3], typename.name))) return t3;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t3 = (typename = T2[i2]).type) _2[t3] = set(_2[t3], typename.name, callback);
      else if (callback == null) for (t3 in _2) _2[t3] = set(_2[t3], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _2 = this._;
    for (var t3 in _2) copy2[t3] = _2[t3].slice();
    return new Dispatch(copy2);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t3; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t3 = this._[type], i2 = 0, n2 = t3.length; i2 < n2; ++i2) t3[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t3 = this._[type], i2 = 0, n2 = t3.length; i2 < n2; ++i2) t3[i2].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i2 = 0, n2 = type.length, c2; i2 < n2; ++i2) {
    if ((c2 = type[i2]).name === name) {
      return c2.value;
    }
  }
}
function set(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t3 = new Timer();
  t3.restart(callback, delay, time2);
  return t3;
}
function timerFlush() {
  now();
  ++frame;
  var t3 = taskHead, e3;
  while (t3) {
    if ((e3 = clockNow - t3._time) >= 0) t3._call.call(void 0, e3);
    t3 = t3._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t22, time2 = Infinity;
  while (t1) {
    if (t1._call) {
      if (time2 > t1._time) time2 = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t22 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t22 : taskHead = t22;
    }
  }
  taskTail = t0;
  sleep(time2);
}
function sleep(time2) {
  if (frame) return;
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity) timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time2) {
  var t3 = new Timer();
  delay = delay == null ? 0 : +delay;
  t3.restart((elapsed) => {
    t3.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t3;
}
const a$1 = 1664525;
const c$1 = 1013904223;
const m$1 = 4294967296;
function lcg$1() {
  let s3 = 1;
  return () => (s3 = (a$1 * s3 + c$1) % m$1) / m$1;
}
function x$1(d3) {
  return d3.x;
}
function y$1(d3) {
  return d3.y;
}
var initialRadius$1 = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
function forceSimulation$1(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch("tick", "end"), random = lcg$1();
  if (nodes == null) nodes = [];
  function step2() {
    tick2();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick2(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius$1 * Math.sqrt(0.5 + i2), angle2 = i2 * initialAngle;
        node.x = radius * Math.cos(angle2);
        node.y = radius * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x2, y2, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d22, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x2 - node.x;
        dy = y2 - node.y;
        d22 = dx * dx + dy * dy;
        if (d22 < radius) closest = node, radius = d22;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}
function forceManyBody$1() {
  var nodes, node, random, alpha, strength = constant$1(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta22 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate2);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2) node = nodes[i2], tree.visit(apply2);
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate2(quad) {
    var strength2 = 0, q, c2, weight = 0, x2, y2, i2;
    if (quad.length) {
      for (x2 = y2 = i2 = 0; i2 < 4; ++i2) {
        if ((q = quad[i2]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x2 += c2 * q.x, y2 += c2 * q.y;
        }
      }
      quad.x = x2 / weight;
      quad.y = y2 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply2(quad, x1, _2, x2) {
    if (!quad.value) return true;
    var x3 = quad.x - node.x, y2 = quad.y - node.y, w2 = x2 - x1, l2 = x3 * x3 + y2 * y2;
    if (w2 * w2 / theta22 < l2) {
      if (l2 < distanceMax2) {
        if (x3 === 0) x3 = jiggle$1(random), l2 += x3 * x3;
        if (y2 === 0) y2 = jiggle$1(random), l2 += y2 * y2;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x3 * quad.value * alpha / l2;
        node.vy += y2 * quad.value * alpha / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2) return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0) x3 = jiggle$1(random), l2 += x3 * x3;
      if (y2 === 0) y2 = jiggle$1(random), l2 += y2 * y2;
      if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node) {
        w2 = strengths[quad.data.index] * alpha / l2;
        node.vx += x3 * w2;
        node.vy += y2 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta22 = _2 * _2, force) : Math.sqrt(theta22);
  };
  return force;
}
function forceRadial$1(radius, x2, y2) {
  var nodes, strength = constant$1(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant$1(+radius);
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node = nodes[i2], dx = node.x - x2 || 1e-6, dy = node.y - y2 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2, initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  return force;
}
function forceX(x2) {
  var strength = constant$1(0.1), nodes, strengths, xz;
  if (typeof x2 !== "function") x2 = constant$1(x2 == null ? 0 : +x2);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    xz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x2(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : x2;
  };
  return force;
}
function forceY(y2) {
  var strength = constant$1(0.1), nodes, strengths, yz;
  if (typeof y2 !== "function") y2 = constant$1(y2 == null ? 0 : +y2);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    yz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y2(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$1(+_2), initialize(), force) : y2;
  };
  return force;
}
class D3ForceLayout {
  constructor(options) {
    this.id = "d3-force";
    this.config = {
      inputNodeAttrs: ["x", "y", "vx", "vy", "fx", "fy"],
      outputNodeAttrs: ["x", "y", "vx", "vy"],
      simulationAttrs: [
        "alpha",
        "alphaMin",
        "alphaDecay",
        "alphaTarget",
        "velocityDecay",
        "randomSource"
      ]
    };
    this.forceMap = {
      link: forceLink$1,
      manyBody: forceManyBody$1,
      center: forceCenter$1,
      collide: forceCollide,
      radial: forceRadial$1,
      x: forceX,
      y: forceY
    };
    this.options = {
      link: {
        id: (edge) => edge.id
      },
      manyBody: {},
      center: {
        x: 0,
        y: 0
      }
    };
    this.context = {
      options: {},
      assign: false,
      nodes: [],
      edges: []
    };
    deepMix(this.options, options);
    if (this.options.forceSimulation) {
      this.simulation = this.options.forceSimulation;
    }
  }
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericLayout(false, graph2, options);
    });
  }
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericLayout(true, graph2, options);
    });
  }
  stop() {
    this.simulation.stop();
  }
  tick(iterations) {
    this.simulation.tick(iterations);
    return this.getResult();
  }
  restart() {
    this.simulation.restart();
  }
  setFixedPosition(id2, position2) {
    const node = this.context.nodes.find((n2) => n2.id === id2);
    if (!node)
      return;
    position2.forEach((value, index2) => {
      if (typeof value === "number" || value === null) {
        const key = ["fx", "fy", "fz"][index2];
        node[key] = value;
      }
    });
  }
  getOptions(options) {
    var _a3, _b;
    const _2 = deepMix({}, this.options, options);
    if (_2.collide && ((_a3 = _2.collide) === null || _a3 === void 0 ? void 0 : _a3.radius) === void 0) {
      _2.collide = _2.collide || {};
      _2.collide.radius = (_b = _2.nodeSize) !== null && _b !== void 0 ? _b : 10;
    }
    if (_2.iterations === void 0) {
      if (_2.link && _2.link.iterations === void 0) {
        _2.iterations = _2.link.iterations;
      }
      if (_2.collide && _2.collide.iterations === void 0) {
        _2.iterations = _2.collide.iterations;
      }
    }
    this.context.options = _2;
    return _2;
  }
  genericLayout(assign, graph2, options) {
    var _a3;
    return __awaiter$r(this, void 0, void 0, function* () {
      const _options = this.getOptions(options);
      const nodes = graph2.getAllNodes().map(({ id: id2, data: data2 }) => Object.assign(Object.assign({ id: id2 }, data2), pick(data2.data, this.config.inputNodeAttrs)));
      const edges = graph2.getAllEdges().map((edge) => Object.assign({}, edge));
      Object.assign(this.context, { assign, nodes, edges, graph: graph2 });
      const promise = new Promise((resolver) => {
        this.resolver = resolver;
      });
      const simulation = this.setSimulation(_options);
      simulation.nodes(nodes);
      (_a3 = simulation.force("link")) === null || _a3 === void 0 ? void 0 : _a3.links(edges);
      return promise;
    });
  }
  getResult() {
    const { assign, nodes, edges, graph: graph2 } = this.context;
    const nodesResult = nodes.map((node) => ({
      id: node.id,
      data: Object.assign(Object.assign({}, node.data), pick(node, this.config.outputNodeAttrs))
    }));
    const edgeResult = edges.map(({ id: id2, source, target, data: data2 }) => ({
      id: id2,
      source: typeof source === "object" ? source.id : source,
      target: typeof target === "object" ? target.id : target,
      data: data2
    }));
    if (assign) {
      nodesResult.forEach((node) => graph2.mergeNodeData(node.id, node.data));
    }
    return { nodes: nodesResult, edges: edgeResult };
  }
  initSimulation() {
    return forceSimulation$1();
  }
  setSimulation(options) {
    const simulation = this.simulation || this.options.forceSimulation || this.initSimulation();
    if (!this.simulation) {
      this.simulation = simulation.on("tick", () => {
        var _a3;
        return (_a3 = options.onTick) === null || _a3 === void 0 ? void 0 : _a3.call(options, this.getResult());
      }).on("end", () => {
        var _a3;
        return (_a3 = this.resolver) === null || _a3 === void 0 ? void 0 : _a3.call(this, this.getResult());
      });
    }
    apply(simulation, this.config.simulationAttrs.map((name) => [
      name,
      options[name]
    ]));
    Object.entries(this.forceMap).forEach(([name, Ctor]) => {
      const forceName = name;
      if (options[name]) {
        let force = simulation.force(forceName);
        if (!force) {
          force = Ctor();
          simulation.force(forceName, force);
        }
        apply(force, Object.entries(options[forceName]));
      } else
        simulation.force(forceName, null);
    });
    return simulation;
  }
}
const apply = (target, params) => {
  return params.reduce((acc, [method, param]) => {
    if (!acc[method] || param === void 0)
      return acc;
    return acc[method].call(target, param);
  }, target);
};
function forceCenter(x2, y2, z2) {
  var nodes, strength = 1;
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  if (z2 == null) z2 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0, sz = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
    }
    for (sx = (sx / n2 - x2) * strength, sy = (sy / n2 - y2) * strength, sz = (sz / n2 - z2) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2];
      if (sx) {
        node.x -= sx;
      }
      if (sy) {
        node.y -= sy;
      }
      if (sz) {
        node.z -= sz;
      }
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  force.z = function(_2) {
    return arguments.length ? (z2 = +_2, force) : z2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}
function tree_add(d3) {
  const x2 = +this._x.call(null, d3);
  return add$1(this.cover(x2), x2, d3);
}
function add$1(tree, x2, d3) {
  if (isNaN(x2)) return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i2, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (parent = node, !(node = node[i2 = +right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  if (x2 === xp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(2) : tree._root = new Array(2);
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
  } while ((i2 = +right) === (j = +(xp >= xm)));
  return parent[j] = node, parent[i2] = leaf, tree;
}
function addAll(data2) {
  if (!Array.isArray(data2)) data2 = Array.from(data2);
  const n2 = data2.length;
  const xz = new Float64Array(n2);
  let x0 = Infinity, x1 = -Infinity;
  for (let i2 = 0, x2; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, data2[i2]))) continue;
    xz[i2] = x2;
    if (x2 < x0) x0 = x2;
    if (x2 > x1) x1 = x2;
  }
  if (x0 > x1) return this;
  this.cover(x0).cover(x1);
  for (let i2 = 0; i2 < n2; ++i2) {
    add$1(this, xz[i2], data2[i2]);
  }
  return this;
}
function tree_cover(x2) {
  if (isNaN(x2 = +x2)) return this;
  var x0 = this._x0, x1 = this._x1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1) {
      i2 = +(x2 < x0);
      parent = new Array(2), parent[i2] = node, node = parent, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2;
          break;
        case 1:
          x0 = x1 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._x1 = x1;
  return this;
}
function tree_data() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length) do
      data2.push(node.data);
    while (node = node.next);
  });
  return data2;
}
function tree_extent(_2) {
  return arguments.length ? this.cover(+_2[0][0]).cover(+_2[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}
function Half(node, x0, x1) {
  this.node = node;
  this.x0 = x0;
  this.x1 = x1;
}
function tree_find(x2, radius) {
  var data2, x0 = this._x0, x1, x22, x3 = this._x1, halves = [], node = this._root, q, i2;
  if (node) halves.push(new Half(node, x0, x3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x2 - radius;
    x3 = x2 + radius;
  }
  while (q = halves.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x3 || (x22 = q.x1) < x0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2;
      halves.push(
        new Half(node[1], xm, x22),
        new Half(node[0], x1, xm)
      );
      if (i2 = +(x2 >= xm)) {
        q = halves[halves.length - 1];
        halves[halves.length - 1] = halves[halves.length - 1 - i2];
        halves[halves.length - 1 - i2] = q;
      }
    } else {
      var d3 = Math.abs(x2 - +this._x.call(null, node.data));
      if (d3 < radius) {
        radius = d3;
        x0 = x2 - d3;
        x3 = x2 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}
function tree_remove(d3) {
  if (isNaN(x2 = +this._x.call(null, d3))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x2, xm, right, i2, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (!(parent = node, node = node[i2 = +right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 1]) retainer = parent, j = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2) this.remove(data2[i2]);
  return this;
}
function tree_root() {
  return this._root;
}
function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}
function tree_visit(callback) {
  var halves = [], q, node = this._root, child, x0, x1;
  if (node) halves.push(new Half(node, this._x0, this._x1));
  while (q = halves.pop()) {
    if (!callback(node = q.node, x0 = q.x0, x1 = q.x1) && node.length) {
      var xm = (x0 + x1) / 2;
      if (child = node[1]) halves.push(new Half(child, xm, x1));
      if (child = node[0]) halves.push(new Half(child, x0, xm));
    }
  }
  return this;
}
function tree_visitAfter(callback) {
  var halves = [], next = [], q;
  if (this._root) halves.push(new Half(this._root, this._x0, this._x1));
  while (q = halves.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, x1 = q.x1, xm = (x0 + x1) / 2;
      if (child = node[0]) halves.push(new Half(child, x0, xm));
      if (child = node[1]) halves.push(new Half(child, xm, x1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.x1);
  }
  return this;
}
function defaultX(d3) {
  return d3[0];
}
function tree_x(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function binarytree(nodes, x2) {
  var tree = new Binarytree(x2 == null ? defaultX : x2, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Binarytree(x2, x0, x1) {
  this._x = x2;
  this._x0 = x0;
  this._x1 = x1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto = binarytree.prototype = Binarytree.prototype;
treeProto.copy = function() {
  var copy2 = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
  if (!node) return copy2;
  if (!node.length) return copy2._root = leaf_copy(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(2) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 2; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(2) });
        else node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
function constant(x2) {
  return function() {
    return x2;
  };
}
function jiggle(random) {
  return (random() - 0.5) * 1e-6;
}
function index(d3) {
  return d3.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function forceLink(links) {
  var id2 = index, strength = defaultStrength, strengths, distance2 = constant(30), distances, nodes, nDim, count, bias, random, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n2 = links.length; k < iterations; ++k) {
      for (var i2 = 0, link, source, target, x2 = 0, y2 = 0, z2 = 0, l2, b2; i2 < n2; ++i2) {
        link = links[i2], source = link.source, target = link.target;
        x2 = target.x + target.vx - source.x - source.vx || jiggle(random);
        if (nDim > 1) {
          y2 = target.y + target.vy - source.y - source.vy || jiggle(random);
        }
        if (nDim > 2) {
          z2 = target.z + target.vz - source.z - source.vz || jiggle(random);
        }
        l2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x2 *= l2, y2 *= l2, z2 *= l2;
        target.vx -= x2 * (b2 = bias[i2]);
        if (nDim > 1) {
          target.vy -= y2 * b2;
        }
        if (nDim > 2) {
          target.vz -= z2 * b2;
        }
        source.vx += x2 * (b2 = 1 - b2);
        if (nDim > 1) {
          source.vy += y2 * b2;
        }
        if (nDim > 2) {
          source.vz += z2 * b2;
        }
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d3, i3) => [id2(d3, i3, nodes), d3])), link;
    for (i2 = 0, count = new Array(n2); i2 < m3; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object") link.source = find2(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find2(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link = links[i2], bias[i2] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance2(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance2 = typeof _2 === "function" ? _2 : constant(+_2), initializeDistance(), force) : distance2;
  };
  return force;
}
const a = 1664525;
const c = 1013904223;
const m2 = 4294967296;
function lcg() {
  let s3 = 1;
  return () => (s3 = (a * s3 + c) % m2) / m2;
}
var MAX_DIMENSIONS = 3;
function x(d3) {
  return d3.x;
}
function y(d3) {
  return d3.y;
}
function z(d3) {
  return d3.z;
}
var initialRadius = 10, initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));
function forceSimulation(nodes, numDimensions) {
  numDimensions = numDimensions || 2;
  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch("tick", "end"), random = lcg();
  if (nodes == null) nodes = [];
  function step2() {
    tick2();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick2(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (nDim > 1) {
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
        if (nDim > 2) {
          if (node.fz == null) node.z += node.vz *= velocityDecay;
          else node.z = node.fz, node.vz = 0;
        }
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (node.fz != null) node.z = node.fz;
      if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {
        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i2) : nDim > 1 ? Math.sqrt(0.5 + i2) : i2), rollAngle = i2 * initialAngleRoll, yawAngle = i2 * initialAngleYaw;
        if (nDim === 1) {
          node.x = radius;
        } else if (nDim === 2) {
          node.x = radius * Math.cos(rollAngle);
          node.y = radius * Math.sin(rollAngle);
        } else {
          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
          node.y = radius * Math.cos(rollAngle);
          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
        }
      }
      if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {
        node.vx = 0;
        if (nDim > 1) {
          node.vy = 0;
        }
        if (nDim > 2) {
          node.vz = 0;
        }
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random, nDim);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    numDimensions: function(_2) {
      return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_2))), forces.forEach(initializeForce), simulation) : nDim;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function() {
      var args = Array.prototype.slice.call(arguments);
      var x2 = args.shift() || 0, y2 = (nDim > 1 ? args.shift() : null) || 0, z2 = (nDim > 2 ? args.shift() : null) || 0, radius = args.shift() || Infinity;
      var i2 = 0, n2 = nodes.length, dx, dy, dz, d22, node, closest;
      radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x2 - node.x;
        dy = y2 - (node.y || 0);
        dz = z2 - (node.z || 0);
        d22 = dx * dx + dy * dy + dz * dz;
        if (d22 < radius) closest = node, radius = d22;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}
function forceManyBody() {
  var nodes, nDim, node, random, alpha, strength = constant(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta22 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = (nDim === 1 ? binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? octree(nodes, x, y, z) : null).visitAfter(accumulate2);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2) node = nodes[i2], tree.visit(apply2);
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate2(treeNode) {
    var strength2 = 0, q, c2, weight = 0, x2, y2, z2, i2;
    var numChildren = treeNode.length;
    if (numChildren) {
      for (x2 = y2 = z2 = i2 = 0; i2 < numChildren; ++i2) {
        if ((q = treeNode[i2]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x2 += c2 * (q.x || 0), y2 += c2 * (q.y || 0), z2 += c2 * (q.z || 0);
        }
      }
      strength2 *= Math.sqrt(4 / numChildren);
      treeNode.x = x2 / weight;
      if (nDim > 1) {
        treeNode.y = y2 / weight;
      }
      if (nDim > 2) {
        treeNode.z = z2 / weight;
      }
    } else {
      q = treeNode;
      q.x = q.data.x;
      if (nDim > 1) {
        q.y = q.data.y;
      }
      if (nDim > 2) {
        q.z = q.data.z;
      }
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    treeNode.value = strength2;
  }
  function apply2(treeNode, x1, arg1, arg2, arg3) {
    if (!treeNode.value) return true;
    var x2 = [arg1, arg2, arg3][nDim - 1];
    var x3 = treeNode.x - node.x, y2 = nDim > 1 ? treeNode.y - node.y : 0, z2 = nDim > 2 ? treeNode.z - node.z : 0, w2 = x2 - x1, l2 = x3 * x3 + y2 * y2 + z2 * z2;
    if (w2 * w2 / theta22 < l2) {
      if (l2 < distanceMax2) {
        if (x3 === 0) x3 = jiggle(random), l2 += x3 * x3;
        if (nDim > 1 && y2 === 0) y2 = jiggle(random), l2 += y2 * y2;
        if (nDim > 2 && z2 === 0) z2 = jiggle(random), l2 += z2 * z2;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x3 * treeNode.value * alpha / l2;
        if (nDim > 1) {
          node.vy += y2 * treeNode.value * alpha / l2;
        }
        if (nDim > 2) {
          node.vz += z2 * treeNode.value * alpha / l2;
        }
      }
      return true;
    } else if (treeNode.length || l2 >= distanceMax2) return;
    if (treeNode.data !== node || treeNode.next) {
      if (x3 === 0) x3 = jiggle(random), l2 += x3 * x3;
      if (nDim > 1 && y2 === 0) y2 = jiggle(random), l2 += y2 * y2;
      if (nDim > 2 && z2 === 0) z2 = jiggle(random), l2 += z2 * z2;
      if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (treeNode.data !== node) {
        w2 = strengths[treeNode.data.index] * alpha / l2;
        node.vx += x3 * w2;
        if (nDim > 1) {
          node.vy += y2 * w2;
        }
        if (nDim > 2) {
          node.vz += z2 * w2;
        }
      }
    while (treeNode = treeNode.next);
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta22 = _2 * _2, force) : Math.sqrt(theta22);
  };
  return force;
}
function forceRadial(radius, x2, y2, z2) {
  var nodes, nDim, strength = constant(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant(+radius);
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  if (z2 == null) z2 = 0;
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node = nodes[i2], dx = node.x - x2 || 1e-6, dy = (node.y || 0) - y2 || 1e-6, dz = (node.z || 0) - z2 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy + dz * dz), k = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node.vx += dx * k;
      if (nDim > 1) {
        node.vy += dy * k;
      }
      if (nDim > 2) {
        node.vz += dz * k;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(initNodes, ...args) {
    nodes = initNodes;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  force.z = function(_2) {
    return arguments.length ? (z2 = +_2, force) : z2;
  };
  return force;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq;
  return eq_1;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq = requireEq();
  function assocIndexOf(array, key) {
    var length2 = array.length;
    while (length2--) {
      if (eq(array[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice2 = arrayProto.splice;
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice2.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear) return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete) return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet) return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas) return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal || freeSelf || Function("return this")();
  _root = root2;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root2 = require_root();
  var Symbol2 = root2.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var nativeObjectToString = objectProto2.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto2 = Object.prototype;
  var nativeObjectToString = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject2;
  return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject2 = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction2;
  return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var root2 = require_root();
  var coreJsData = root2["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction2 = requireIsFunction(), isMasked = require_isMasked(), isObject2 = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  _getValue = getValue;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue = require_getValue();
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative;
  return _getNative;
}
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Map2 = getNative(root2, "Map");
  _Map = Map2;
  return _Map;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  _hashGet = hashGet;
  return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  _hashHas = hashHas;
  return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key, value) {
    var data2 = getMapData(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet) return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache) {
      var pairs = data2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache(pairs);
    }
    data2.set(key, value);
    this.size = data2.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack) return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach) return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach(array, iteratee) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  _arrayEach = arrayEach;
  return _arrayEach;
}
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e3) {
    }
  }();
  _defineProperty = defineProperty;
  return _defineProperty;
}
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue) return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject) return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue(), baseAssignValue = require_baseAssignValue();
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  _copyObject = copyObject;
  return _copyObject;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes) return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike2;
  return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments) return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike2 = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike2 = requireIsObjectLike();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray2 = Array.isArray;
  isArray_1 = isArray2;
  return isArray_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse) return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module, exports$1) {
    var root2 = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength2;
  return isLength_1;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength2 = requireIsLength(), isObjectLike2 = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary) return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil) return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module, exports$1) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype) return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto2 = Object.prototype;
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  _isPrototype = isPrototype2;
  return _isPrototype;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg) return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys) return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys) return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype2 = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype2(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction2 = requireIsFunction(), isLength2 = requireIsLength();
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  isArrayLike_1 = isArrayLike2;
  return isArrayLike_1;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike2 = requireIsArrayLike();
  function keys(object) {
    return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  keys_1 = keys;
  return keys_1;
}
var _baseAssign;
var hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign) return _baseAssign;
  hasRequired_baseAssign = 1;
  var copyObject = require_copyObject(), keys = requireKeys();
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  _baseAssign = baseAssign;
  return _baseAssign;
}
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn) return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn) return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject2 = requireIsObject(), isPrototype2 = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype2(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn) return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike2 = requireIsArrayLike();
  function keysIn(object) {
    return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}
var _baseAssignIn;
var hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn) return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  _baseAssignIn = baseAssignIn;
  return _baseAssignIn;
}
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module, exports$1) {
    var root2 = require_root();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray) return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array) {
    var index2 = -1, length2 = source.length;
    array || (array = Array(length2));
    while (++index2 < length2) {
      array[index2] = source[index2];
    }
    return array;
  }
  _copyArray = copyArray;
  return _copyArray;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter) return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray) return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols) return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto2 = Object.prototype;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _copySymbols;
var hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols) return _copySymbols;
  hasRequired_copySymbols = 1;
  var copyObject = require_copyObject(), getSymbols = require_getSymbols();
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  _copySymbols = copySymbols;
  return _copySymbols;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush) return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array, values2) {
    var index2 = -1, length2 = values2.length, offset = array.length;
    while (++index2 < length2) {
      array[offset + index2] = values2[index2];
    }
    return array;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype) return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var _getSymbolsIn;
var hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn) return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var arrayPush = require_arrayPush(), getPrototype = require_getPrototype(), getSymbols = require_getSymbols(), stubArray = requireStubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };
  _getSymbolsIn = getSymbolsIn;
  return _getSymbolsIn;
}
var _copySymbolsIn;
var hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn) return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var copyObject = require_copyObject(), getSymbolsIn = require_getSymbolsIn();
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  _copySymbolsIn = copySymbolsIn;
  return _copySymbolsIn;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray2 = requireIsArray();
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = requireKeys();
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _getAllKeysIn;
var hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn) return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbolsIn = require_getSymbolsIn(), keysIn = requireKeysIn();
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  _getAllKeysIn = getAllKeysIn;
  return _getAllKeysIn;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView) return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root2 = require_root();
  var DataView = getNative(root2, "DataView");
  _DataView = DataView;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise) return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Promise2 = getNative(root2, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Set2 = getNative(root2, "Set");
  _Set = Set2;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap) return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root2 = require_root();
  var WeakMap2 = getNative(root2, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag) return _getTag;
  hasRequired_getTag = 1;
  var DataView = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _initCloneArray;
var hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray) return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function initCloneArray(array) {
    var length2 = array.length, result = new array.constructor(length2);
    if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  _initCloneArray = initCloneArray;
  return _initCloneArray;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array) return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root2 = require_root();
  var Uint8Array2 = root2.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array2 = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}
var _cloneDataView;
var hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView) return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  _cloneDataView = cloneDataView;
  return _cloneDataView;
}
var _cloneRegExp;
var hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp) return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  _cloneRegExp = cloneRegExp;
  return _cloneRegExp;
}
var _cloneSymbol;
var hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol) return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var Symbol2 = require_Symbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  _cloneSymbol = cloneSymbol;
  return _cloneSymbol;
}
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray) return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}
var _initCloneByTag;
var hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag) return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer(), cloneDataView = require_cloneDataView(), cloneRegExp = require_cloneRegExp(), cloneSymbol = require_cloneSymbol(), cloneTypedArray = require_cloneTypedArray();
  var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return new Ctor();
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return new Ctor();
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  _initCloneByTag = initCloneByTag;
  return _initCloneByTag;
}
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate) return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject2 = requireIsObject();
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate;
  return _baseCreate;
}
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject) return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype(), isPrototype2 = require_isPrototype();
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}
var _baseIsMap;
var hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap) return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var getTag = require_getTag(), isObjectLike2 = requireIsObjectLike();
  var mapTag = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike2(value) && getTag(value) == mapTag;
  }
  _baseIsMap = baseIsMap;
  return _baseIsMap;
}
var isMap_1;
var hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap) return isMap_1;
  hasRequiredIsMap = 1;
  var baseIsMap = require_baseIsMap(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  isMap_1 = isMap;
  return isMap_1;
}
var _baseIsSet;
var hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet) return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var getTag = require_getTag(), isObjectLike2 = requireIsObjectLike();
  var setTag = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike2(value) && getTag(value) == setTag;
  }
  _baseIsSet = baseIsSet;
  return _baseIsSet;
}
var isSet_1;
var hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet) return isSet_1;
  hasRequiredIsSet = 1;
  var baseIsSet = require_baseIsSet(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  isSet_1 = isSet;
  return isSet_1;
}
var _baseClone;
var hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone) return _baseClone;
  hasRequired_baseClone = 1;
  var Stack = require_Stack(), arrayEach = require_arrayEach(), assignValue = require_assignValue(), baseAssign = require_baseAssign(), baseAssignIn = require_baseAssignIn(), cloneBuffer = require_cloneBuffer(), copyArray = require_copyArray(), copySymbols = require_copySymbols(), copySymbolsIn = require_copySymbolsIn(), getAllKeys = require_getAllKeys(), getAllKeysIn = require_getAllKeysIn(), getTag = require_getTag(), initCloneArray = require_initCloneArray(), initCloneByTag = require_initCloneByTag(), initCloneObject = require_initCloneObject(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isMap = requireIsMap(), isObject2 = requireIsObject(), isSet = requireIsSet(), keys = requireKeys(), keysIn = requireKeysIn();
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  _baseClone = baseClone;
  return _baseClone;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  var baseClone = require_baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  function clone2(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  clone_1 = clone2;
  return clone_1;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant) return constant_1;
  hasRequiredConstant = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant2;
  return constant_1;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor) return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor) return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn) return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys = requireKeys();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach) return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike2 = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike2(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach) return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity_1;
  hasRequiredIdentity = 1;
  function identity2(value) {
    return value;
  }
  identity_1 = identity2;
  return identity_1;
}
var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction) return _castFunction;
  hasRequired_castFunction = 1;
  var identity2 = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity2;
  }
  _castFunction = castFunction;
  return _castFunction;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray2 = requireIsArray();
  function forEach(collection, iteratee) {
    var func = isArray2(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach;
  return forEach_1;
}
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each;
  hasRequiredEach = 1;
  each = requireForEach();
  return each;
}
var _baseFilter;
var hasRequired_baseFilter;
function require_baseFilter() {
  if (hasRequired_baseFilter) return _baseFilter;
  hasRequired_baseFilter = 1;
  var baseEach = require_baseEach();
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index2, collection2) {
      if (predicate(value, index2, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  _baseFilter = baseFilter;
  return _baseFilter;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd) return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas) return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache) return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values2) {
    var index2 = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index2 < length2) {
      this.add(values2[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome) return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas) return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays) return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray) return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray) return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag) return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects) return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray = requireIsTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual) return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike2 = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch) return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
    if (object == null) {
      return !length2;
    }
    object = Object(object);
    while (index2--) {
      var data2 = matchData[index2];
      if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
        return false;
      }
    }
    while (++index2 < length2) {
      data2 = matchData[index2];
      var key = data2[0], objValue = object[key], srcValue = data2[1];
      if (noCustomizer && data2[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable) return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject2 = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject2(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData) return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys = requireKeys();
  function getMatchData(object) {
    var result = keys(object), length2 = result.length;
    while (length2--) {
      var key = result[length2], value = object[key];
      result[length2] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches) return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike2 = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey) return _isKey;
  hasRequired_isKey = 1;
  var isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray2(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  _isKey = isKey;
  return _isKey;
}
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize) return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache)();
    return memoized;
  }
  memoize2.Cache = MapCache;
  memoize_1 = memoize2;
  return memoize_1;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped) return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize2 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath) return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match2, number2, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array, iteratee) {
    var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array[index2], index2, array);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray2(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString2;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath) return _castPath;
  hasRequired_castPath = 1;
  var isArray2 = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString2 = requireToString();
  function castPath(value, object) {
    if (isArray2(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString2(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey) return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet) return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object, path) {
    path = castPath(path, object);
    var index2 = 0, length2 = path.length;
    while (object != null && index2 < length2) {
      object = object[toKey(path[index2++])];
    }
    return index2 && index2 == length2 ? object : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet();
  function get2(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get2;
  return get_1;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn) return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath) return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isIndex = require_isIndex(), isLength2 = requireIsLength(), toKey = require_toKey();
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index2 = -1, length2 = path.length, result = false;
    while (++index2 < length2) {
      var key = toKey(path[index2]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object == null ? 0 : object.length;
    return !!length2 && isLength2(length2) && isIndex(key, length2) && (isArray2(object) || isArguments(object));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn) return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get2(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty) return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep) return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet();
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee) return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity2 = requireIdentity(), isArray2 = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity2;
    }
    if (typeof value == "object") {
      return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var filter_1;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter_1;
  hasRequiredFilter = 1;
  var arrayFilter = require_arrayFilter(), baseFilter = require_baseFilter(), baseIteratee = require_baseIteratee(), isArray2 = requireIsArray();
  function filter2(collection, predicate) {
    var func = isArray2(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  filter_1 = filter2;
  return filter_1;
}
var _baseHas;
var hasRequired_baseHas;
function require_baseHas() {
  if (hasRequired_baseHas) return _baseHas;
  hasRequired_baseHas = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseHas(object, key) {
    return object != null && hasOwnProperty2.call(object, key);
  }
  _baseHas = baseHas;
  return _baseHas;
}
var has_1;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas) return has_1;
  hasRequiredHas = 1;
  var baseHas = require_baseHas(), hasPath = require_hasPath();
  function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
  }
  has_1 = has;
  return has_1;
}
var isEmpty_1;
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty) return isEmpty_1;
  hasRequiredIsEmpty = 1;
  var baseKeys = require_baseKeys(), getTag = require_getTag(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isArrayLike2 = requireIsArrayLike(), isBuffer2 = requireIsBuffer(), isPrototype2 = require_isPrototype(), isTypedArray = requireIsTypedArray();
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function isEmpty2(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype2(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty2.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  isEmpty_1 = isEmpty2;
  return isEmpty_1;
}
var isUndefined_1;
var hasRequiredIsUndefined;
function requireIsUndefined() {
  if (hasRequiredIsUndefined) return isUndefined_1;
  hasRequiredIsUndefined = 1;
  function isUndefined2(value) {
    return value === void 0;
  }
  isUndefined_1 = isUndefined2;
  return isUndefined_1;
}
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap) return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach(), isArrayLike2 = requireIsArrayLike();
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var map_1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map_1;
  hasRequiredMap = 1;
  var arrayMap = require_arrayMap(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray2 = requireIsArray();
  function map2(collection, iteratee) {
    var func = isArray2(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  map_1 = map2;
  return map_1;
}
var _arrayReduce;
var hasRequired_arrayReduce;
function require_arrayReduce() {
  if (hasRequired_arrayReduce) return _arrayReduce;
  hasRequired_arrayReduce = 1;
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    if (initAccum && length2) {
      accumulator = array[++index2];
    }
    while (++index2 < length2) {
      accumulator = iteratee(accumulator, array[index2], index2, array);
    }
    return accumulator;
  }
  _arrayReduce = arrayReduce;
  return _arrayReduce;
}
var _baseReduce;
var hasRequired_baseReduce;
function require_baseReduce() {
  if (hasRequired_baseReduce) return _baseReduce;
  hasRequired_baseReduce = 1;
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index2, collection2) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
    });
    return accumulator;
  }
  _baseReduce = baseReduce;
  return _baseReduce;
}
var reduce_1;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce_1;
  hasRequiredReduce = 1;
  var arrayReduce = require_arrayReduce(), baseEach = require_baseEach(), baseIteratee = require_baseIteratee(), baseReduce = require_baseReduce(), isArray2 = requireIsArray();
  function reduce2(collection, iteratee, accumulator) {
    var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }
  reduce_1 = reduce2;
  return reduce_1;
}
var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString) return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag = require_baseGetTag(), isArray2 = requireIsArray(), isObjectLike2 = requireIsObjectLike();
  var stringTag = "[object String]";
  function isString2(value) {
    return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
  }
  isString_1 = isString2;
  return isString_1;
}
var _asciiSize;
var hasRequired_asciiSize;
function require_asciiSize() {
  if (hasRequired_asciiSize) return _asciiSize;
  hasRequired_asciiSize = 1;
  var baseProperty = require_baseProperty();
  var asciiSize = baseProperty("length");
  _asciiSize = asciiSize;
  return _asciiSize;
}
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode) return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsZWJ = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  _hasUnicode = hasUnicode;
  return _hasUnicode;
}
var _unicodeSize;
var hasRequired_unicodeSize;
function require_unicodeSize() {
  if (hasRequired_unicodeSize) return _unicodeSize;
  hasRequired_unicodeSize = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }
  _unicodeSize = unicodeSize;
  return _unicodeSize;
}
var _stringSize;
var hasRequired_stringSize;
function require_stringSize() {
  if (hasRequired_stringSize) return _stringSize;
  hasRequired_stringSize = 1;
  var asciiSize = require_asciiSize(), hasUnicode = require_hasUnicode(), unicodeSize = require_unicodeSize();
  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  _stringSize = stringSize;
  return _stringSize;
}
var size_1;
var hasRequiredSize;
function requireSize() {
  if (hasRequiredSize) return size_1;
  hasRequiredSize = 1;
  var baseKeys = require_baseKeys(), getTag = require_getTag(), isArrayLike2 = requireIsArrayLike(), isString2 = requireIsString(), stringSize = require_stringSize();
  var mapTag = "[object Map]", setTag = "[object Set]";
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    if (isArrayLike2(collection)) {
      return isString2(collection) ? stringSize(collection) : collection.length;
    }
    var tag = getTag(collection);
    if (tag == mapTag || tag == setTag) {
      return collection.size;
    }
    return baseKeys(collection).length;
  }
  size_1 = size;
  return size_1;
}
var transform_1;
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform) return transform_1;
  hasRequiredTransform = 1;
  var arrayEach = require_arrayEach(), baseCreate = require_baseCreate(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee(), getPrototype = require_getPrototype(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isFunction2 = requireIsFunction(), isObject2 = requireIsObject(), isTypedArray = requireIsTypedArray();
  function transform2(object, iteratee, accumulator) {
    var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray(object);
    iteratee = baseIteratee(iteratee, 4);
    if (accumulator == null) {
      var Ctor = object && object.constructor;
      if (isArrLike) {
        accumulator = isArr ? new Ctor() : [];
      } else if (isObject2(object)) {
        accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
      } else {
        accumulator = {};
      }
    }
    (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
      return iteratee(accumulator, value, index2, object2);
    });
    return accumulator;
  }
  transform_1 = transform2;
  return transform_1;
}
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable) return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments = requireIsArguments(), isArray2 = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten) return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply) return _apply;
  hasRequired_apply = 1;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply2;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest) return _overRest;
  hasRequired_overRest = 1;
  var apply2 = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform2) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
      while (++index2 < length2) {
        array[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform2(array);
      return apply2(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString) return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant2 = requireConstant(), defineProperty = require_defineProperty(), identity2 = requireIdentity();
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut) return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString) return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest) return _baseRest;
  hasRequired_baseRest = 1;
  var identity2 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity2), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex) return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN) return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf) return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array, value, fromIndex) {
    var index2 = fromIndex - 1, length2 = array.length;
    while (++index2 < length2) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf) return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes) return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array, value) {
    var length2 = array == null ? 0 : array.length;
    return !!length2 && baseIndexOf(array, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith) return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array, value, comparator) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (comparator(value, array[index2])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop) return noop_1;
  hasRequiredNoop = 1;
  function noop2() {
  }
  noop_1 = noop2;
  return noop_1;
}
var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet) return _createSet;
  hasRequired_createSet = 1;
  var Set2 = require_Set(), noop2 = requireNoop(), setToArray = require_setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
    return new Set2(values2);
  };
  _createSet = createSet;
  return _createSet;
}
var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq) return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length2 >= LARGE_ARRAY_SIZE) {
      var set2 = iteratee ? null : createSet(array);
      if (set2) {
        return setToArray(set2);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length2) {
        var value = array[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject) return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike2 = requireIsArrayLike(), isObjectLike2 = requireIsObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var union_1;
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion) return union_1;
  hasRequiredUnion = 1;
  var baseFlatten = require_baseFlatten(), baseRest = require_baseRest(), baseUniq = require_baseUniq(), isArrayLikeObject = requireIsArrayLikeObject();
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  union_1 = union;
  return union_1;
}
var _baseValues;
var hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues) return _baseValues;
  hasRequired_baseValues = 1;
  var arrayMap = require_arrayMap();
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }
  _baseValues = baseValues;
  return _baseValues;
}
var values_1;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values_1;
  hasRequiredValues = 1;
  var baseValues = require_baseValues(), keys = requireKeys();
  function values2(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }
  values_1 = values2;
  return values_1;
}
var lodash_1$1;
var hasRequiredLodash;
function requireLodash() {
  if (hasRequiredLodash) return lodash_1$1;
  hasRequiredLodash = 1;
  var lodash2;
  if (typeof commonjsRequire === "function") {
    try {
      lodash2 = {
        clone: requireClone(),
        constant: requireConstant(),
        each: requireEach(),
        filter: requireFilter(),
        has: requireHas(),
        isArray: requireIsArray(),
        isEmpty: requireIsEmpty(),
        isFunction: requireIsFunction(),
        isUndefined: requireIsUndefined(),
        keys: requireKeys(),
        map: requireMap(),
        reduce: requireReduce(),
        size: requireSize(),
        transform: requireTransform(),
        union: requireUnion(),
        values: requireValues()
      };
    } catch (e3) {
    }
  }
  if (!lodash2) {
    lodash2 = window._;
  }
  lodash_1$1 = lodash2;
  return lodash_1$1;
}
var graph;
var hasRequiredGraph;
function requireGraph() {
  if (hasRequiredGraph) return graph;
  hasRequiredGraph = 1;
  var _2 = requireLodash();
  graph = Graph3;
  var DEFAULT_EDGE_NAME = "\0";
  var GRAPH_NODE = "\0";
  var EDGE_KEY_DELIM = "";
  function Graph3(opts) {
    this._isDirected = _2.has(opts, "directed") ? opts.directed : true;
    this._isMultigraph = _2.has(opts, "multigraph") ? opts.multigraph : false;
    this._isCompound = _2.has(opts, "compound") ? opts.compound : false;
    this._label = void 0;
    this._defaultNodeLabelFn = _2.constant(void 0);
    this._defaultEdgeLabelFn = _2.constant(void 0);
    this._nodes = {};
    if (this._isCompound) {
      this._parent = {};
      this._children = {};
      this._children[GRAPH_NODE] = {};
    }
    this._in = {};
    this._preds = {};
    this._out = {};
    this._sucs = {};
    this._edgeObjs = {};
    this._edgeLabels = {};
  }
  Graph3.prototype._nodeCount = 0;
  Graph3.prototype._edgeCount = 0;
  Graph3.prototype.isDirected = function() {
    return this._isDirected;
  };
  Graph3.prototype.isMultigraph = function() {
    return this._isMultigraph;
  };
  Graph3.prototype.isCompound = function() {
    return this._isCompound;
  };
  Graph3.prototype.setGraph = function(label) {
    this._label = label;
    return this;
  };
  Graph3.prototype.graph = function() {
    return this._label;
  };
  Graph3.prototype.setDefaultNodeLabel = function(newDefault) {
    if (!_2.isFunction(newDefault)) {
      newDefault = _2.constant(newDefault);
    }
    this._defaultNodeLabelFn = newDefault;
    return this;
  };
  Graph3.prototype.nodeCount = function() {
    return this._nodeCount;
  };
  Graph3.prototype.nodes = function() {
    return _2.keys(this._nodes);
  };
  Graph3.prototype.sources = function() {
    var self2 = this;
    return _2.filter(this.nodes(), function(v2) {
      return _2.isEmpty(self2._in[v2]);
    });
  };
  Graph3.prototype.sinks = function() {
    var self2 = this;
    return _2.filter(this.nodes(), function(v2) {
      return _2.isEmpty(self2._out[v2]);
    });
  };
  Graph3.prototype.setNodes = function(vs, value) {
    var args = arguments;
    var self2 = this;
    _2.each(vs, function(v2) {
      if (args.length > 1) {
        self2.setNode(v2, value);
      } else {
        self2.setNode(v2);
      }
    });
    return this;
  };
  Graph3.prototype.setNode = function(v2, value) {
    if (_2.has(this._nodes, v2)) {
      if (arguments.length > 1) {
        this._nodes[v2] = value;
      }
      return this;
    }
    this._nodes[v2] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v2);
    if (this._isCompound) {
      this._parent[v2] = GRAPH_NODE;
      this._children[v2] = {};
      this._children[GRAPH_NODE][v2] = true;
    }
    this._in[v2] = {};
    this._preds[v2] = {};
    this._out[v2] = {};
    this._sucs[v2] = {};
    ++this._nodeCount;
    return this;
  };
  Graph3.prototype.node = function(v2) {
    return this._nodes[v2];
  };
  Graph3.prototype.hasNode = function(v2) {
    return _2.has(this._nodes, v2);
  };
  Graph3.prototype.removeNode = function(v2) {
    var self2 = this;
    if (_2.has(this._nodes, v2)) {
      var removeEdge = function(e3) {
        self2.removeEdge(self2._edgeObjs[e3]);
      };
      delete this._nodes[v2];
      if (this._isCompound) {
        this._removeFromParentsChildList(v2);
        delete this._parent[v2];
        _2.each(this.children(v2), function(child) {
          self2.setParent(child);
        });
        delete this._children[v2];
      }
      _2.each(_2.keys(this._in[v2]), removeEdge);
      delete this._in[v2];
      delete this._preds[v2];
      _2.each(_2.keys(this._out[v2]), removeEdge);
      delete this._out[v2];
      delete this._sucs[v2];
      --this._nodeCount;
    }
    return this;
  };
  Graph3.prototype.setParent = function(v2, parent) {
    if (!this._isCompound) {
      throw new Error("Cannot set parent in a non-compound graph");
    }
    if (_2.isUndefined(parent)) {
      parent = GRAPH_NODE;
    } else {
      parent += "";
      for (var ancestor = parent; !_2.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
        if (ancestor === v2) {
          throw new Error("Setting " + parent + " as parent of " + v2 + " would create a cycle");
        }
      }
      this.setNode(parent);
    }
    this.setNode(v2);
    this._removeFromParentsChildList(v2);
    this._parent[v2] = parent;
    this._children[parent][v2] = true;
    return this;
  };
  Graph3.prototype._removeFromParentsChildList = function(v2) {
    delete this._children[this._parent[v2]][v2];
  };
  Graph3.prototype.parent = function(v2) {
    if (this._isCompound) {
      var parent = this._parent[v2];
      if (parent !== GRAPH_NODE) {
        return parent;
      }
    }
  };
  Graph3.prototype.children = function(v2) {
    if (_2.isUndefined(v2)) {
      v2 = GRAPH_NODE;
    }
    if (this._isCompound) {
      var children = this._children[v2];
      if (children) {
        return _2.keys(children);
      }
    } else if (v2 === GRAPH_NODE) {
      return this.nodes();
    } else if (this.hasNode(v2)) {
      return [];
    }
  };
  Graph3.prototype.predecessors = function(v2) {
    var predsV = this._preds[v2];
    if (predsV) {
      return _2.keys(predsV);
    }
  };
  Graph3.prototype.successors = function(v2) {
    var sucsV = this._sucs[v2];
    if (sucsV) {
      return _2.keys(sucsV);
    }
  };
  Graph3.prototype.neighbors = function(v2) {
    var preds = this.predecessors(v2);
    if (preds) {
      return _2.union(preds, this.successors(v2));
    }
  };
  Graph3.prototype.isLeaf = function(v2) {
    var neighbors;
    if (this.isDirected()) {
      neighbors = this.successors(v2);
    } else {
      neighbors = this.neighbors(v2);
    }
    return neighbors.length === 0;
  };
  Graph3.prototype.filterNodes = function(filter2) {
    var copy2 = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    copy2.setGraph(this.graph());
    var self2 = this;
    _2.each(this._nodes, function(value, v2) {
      if (filter2(v2)) {
        copy2.setNode(v2, value);
      }
    });
    _2.each(this._edgeObjs, function(e3) {
      if (copy2.hasNode(e3.v) && copy2.hasNode(e3.w)) {
        copy2.setEdge(e3, self2.edge(e3));
      }
    });
    var parents = {};
    function findParent(v2) {
      var parent = self2.parent(v2);
      if (parent === void 0 || copy2.hasNode(parent)) {
        parents[v2] = parent;
        return parent;
      } else if (parent in parents) {
        return parents[parent];
      } else {
        return findParent(parent);
      }
    }
    if (this._isCompound) {
      _2.each(copy2.nodes(), function(v2) {
        copy2.setParent(v2, findParent(v2));
      });
    }
    return copy2;
  };
  Graph3.prototype.setDefaultEdgeLabel = function(newDefault) {
    if (!_2.isFunction(newDefault)) {
      newDefault = _2.constant(newDefault);
    }
    this._defaultEdgeLabelFn = newDefault;
    return this;
  };
  Graph3.prototype.edgeCount = function() {
    return this._edgeCount;
  };
  Graph3.prototype.edges = function() {
    return _2.values(this._edgeObjs);
  };
  Graph3.prototype.setPath = function(vs, value) {
    var self2 = this;
    var args = arguments;
    _2.reduce(vs, function(v2, w2) {
      if (args.length > 1) {
        self2.setEdge(v2, w2, value);
      } else {
        self2.setEdge(v2, w2);
      }
      return w2;
    });
    return this;
  };
  Graph3.prototype.setEdge = function() {
    var v2, w2, name, value;
    var valueSpecified = false;
    var arg0 = arguments[0];
    if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
      v2 = arg0.v;
      w2 = arg0.w;
      name = arg0.name;
      if (arguments.length === 2) {
        value = arguments[1];
        valueSpecified = true;
      }
    } else {
      v2 = arg0;
      w2 = arguments[1];
      name = arguments[3];
      if (arguments.length > 2) {
        value = arguments[2];
        valueSpecified = true;
      }
    }
    v2 = "" + v2;
    w2 = "" + w2;
    if (!_2.isUndefined(name)) {
      name = "" + name;
    }
    var e3 = edgeArgsToId(this._isDirected, v2, w2, name);
    if (_2.has(this._edgeLabels, e3)) {
      if (valueSpecified) {
        this._edgeLabels[e3] = value;
      }
      return this;
    }
    if (!_2.isUndefined(name) && !this._isMultigraph) {
      throw new Error("Cannot set a named edge when isMultigraph = false");
    }
    this.setNode(v2);
    this.setNode(w2);
    this._edgeLabels[e3] = valueSpecified ? value : this._defaultEdgeLabelFn(v2, w2, name);
    var edgeObj = edgeArgsToObj(this._isDirected, v2, w2, name);
    v2 = edgeObj.v;
    w2 = edgeObj.w;
    Object.freeze(edgeObj);
    this._edgeObjs[e3] = edgeObj;
    incrementOrInitEntry(this._preds[w2], v2);
    incrementOrInitEntry(this._sucs[v2], w2);
    this._in[w2][e3] = edgeObj;
    this._out[v2][e3] = edgeObj;
    this._edgeCount++;
    return this;
  };
  Graph3.prototype.edge = function(v2, w2, name) {
    var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
    return this._edgeLabels[e3];
  };
  Graph3.prototype.hasEdge = function(v2, w2, name) {
    var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
    return _2.has(this._edgeLabels, e3);
  };
  Graph3.prototype.removeEdge = function(v2, w2, name) {
    var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
    var edge = this._edgeObjs[e3];
    if (edge) {
      v2 = edge.v;
      w2 = edge.w;
      delete this._edgeLabels[e3];
      delete this._edgeObjs[e3];
      decrementOrRemoveEntry(this._preds[w2], v2);
      decrementOrRemoveEntry(this._sucs[v2], w2);
      delete this._in[w2][e3];
      delete this._out[v2][e3];
      this._edgeCount--;
    }
    return this;
  };
  Graph3.prototype.inEdges = function(v2, u2) {
    var inV = this._in[v2];
    if (inV) {
      var edges = _2.values(inV);
      if (!u2) {
        return edges;
      }
      return _2.filter(edges, function(edge) {
        return edge.v === u2;
      });
    }
  };
  Graph3.prototype.outEdges = function(v2, w2) {
    var outV = this._out[v2];
    if (outV) {
      var edges = _2.values(outV);
      if (!w2) {
        return edges;
      }
      return _2.filter(edges, function(edge) {
        return edge.w === w2;
      });
    }
  };
  Graph3.prototype.nodeEdges = function(v2, w2) {
    var inEdges = this.inEdges(v2, w2);
    if (inEdges) {
      return inEdges.concat(this.outEdges(v2, w2));
    }
  };
  function incrementOrInitEntry(map2, k) {
    if (map2[k]) {
      map2[k]++;
    } else {
      map2[k] = 1;
    }
  }
  function decrementOrRemoveEntry(map2, k) {
    if (!--map2[k]) {
      delete map2[k];
    }
  }
  function edgeArgsToId(isDirected, v_, w_, name) {
    var v2 = "" + v_;
    var w2 = "" + w_;
    if (!isDirected && v2 > w2) {
      var tmp2 = v2;
      v2 = w2;
      w2 = tmp2;
    }
    return v2 + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (_2.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
  }
  function edgeArgsToObj(isDirected, v_, w_, name) {
    var v2 = "" + v_;
    var w2 = "" + w_;
    if (!isDirected && v2 > w2) {
      var tmp2 = v2;
      v2 = w2;
      w2 = tmp2;
    }
    var edgeObj = { v: v2, w: w2 };
    if (name) {
      edgeObj.name = name;
    }
    return edgeObj;
  }
  function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
  }
  return graph;
}
var version$1;
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version$1;
  hasRequiredVersion = 1;
  version$1 = "2.1.8";
  return version$1;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  lib = {
    Graph: requireGraph(),
    version: requireVersion()
  };
  return lib;
}
var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var _2 = requireLodash();
  var Graph3 = requireGraph();
  json = {
    write,
    read
  };
  function write(g2) {
    var json2 = {
      options: {
        directed: g2.isDirected(),
        multigraph: g2.isMultigraph(),
        compound: g2.isCompound()
      },
      nodes: writeNodes(g2),
      edges: writeEdges(g2)
    };
    if (!_2.isUndefined(g2.graph())) {
      json2.value = _2.clone(g2.graph());
    }
    return json2;
  }
  function writeNodes(g2) {
    return _2.map(g2.nodes(), function(v2) {
      var nodeValue = g2.node(v2);
      var parent = g2.parent(v2);
      var node = { v: v2 };
      if (!_2.isUndefined(nodeValue)) {
        node.value = nodeValue;
      }
      if (!_2.isUndefined(parent)) {
        node.parent = parent;
      }
      return node;
    });
  }
  function writeEdges(g2) {
    return _2.map(g2.edges(), function(e3) {
      var edgeValue = g2.edge(e3);
      var edge = { v: e3.v, w: e3.w };
      if (!_2.isUndefined(e3.name)) {
        edge.name = e3.name;
      }
      if (!_2.isUndefined(edgeValue)) {
        edge.value = edgeValue;
      }
      return edge;
    });
  }
  function read(json2) {
    var g2 = new Graph3(json2.options).setGraph(json2.value);
    _2.each(json2.nodes, function(entry) {
      g2.setNode(entry.v, entry.value);
      if (entry.parent) {
        g2.setParent(entry.v, entry.parent);
      }
    });
    _2.each(json2.edges, function(entry) {
      g2.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    });
    return g2;
  }
  return json;
}
var components_1;
var hasRequiredComponents;
function requireComponents() {
  if (hasRequiredComponents) return components_1;
  hasRequiredComponents = 1;
  var _2 = requireLodash();
  components_1 = components;
  function components(g2) {
    var visited = {};
    var cmpts = [];
    var cmpt;
    function dfs2(v2) {
      if (_2.has(visited, v2)) return;
      visited[v2] = true;
      cmpt.push(v2);
      _2.each(g2.successors(v2), dfs2);
      _2.each(g2.predecessors(v2), dfs2);
    }
    _2.each(g2.nodes(), function(v2) {
      cmpt = [];
      dfs2(v2);
      if (cmpt.length) {
        cmpts.push(cmpt);
      }
    });
    return cmpts;
  }
  return components_1;
}
var priorityQueue;
var hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue) return priorityQueue;
  hasRequiredPriorityQueue = 1;
  var _2 = requireLodash();
  priorityQueue = PriorityQueue;
  function PriorityQueue() {
    this._arr = [];
    this._keyIndices = {};
  }
  PriorityQueue.prototype.size = function() {
    return this._arr.length;
  };
  PriorityQueue.prototype.keys = function() {
    return this._arr.map(function(x2) {
      return x2.key;
    });
  };
  PriorityQueue.prototype.has = function(key) {
    return _2.has(this._keyIndices, key);
  };
  PriorityQueue.prototype.priority = function(key) {
    var index2 = this._keyIndices[key];
    if (index2 !== void 0) {
      return this._arr[index2].priority;
    }
  };
  PriorityQueue.prototype.min = function() {
    if (this.size() === 0) {
      throw new Error("Queue underflow");
    }
    return this._arr[0].key;
  };
  PriorityQueue.prototype.add = function(key, priority) {
    var keyIndices = this._keyIndices;
    key = String(key);
    if (!_2.has(keyIndices, key)) {
      var arr = this._arr;
      var index2 = arr.length;
      keyIndices[key] = index2;
      arr.push({ key, priority });
      this._decrease(index2);
      return true;
    }
    return false;
  };
  PriorityQueue.prototype.removeMin = function() {
    this._swap(0, this._arr.length - 1);
    var min2 = this._arr.pop();
    delete this._keyIndices[min2.key];
    this._heapify(0);
    return min2.key;
  };
  PriorityQueue.prototype.decrease = function(key, priority) {
    var index2 = this._keyIndices[key];
    if (priority > this._arr[index2].priority) {
      throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
    }
    this._arr[index2].priority = priority;
    this._decrease(index2);
  };
  PriorityQueue.prototype._heapify = function(i2) {
    var arr = this._arr;
    var l2 = 2 * i2;
    var r2 = l2 + 1;
    var largest = i2;
    if (l2 < arr.length) {
      largest = arr[l2].priority < arr[largest].priority ? l2 : largest;
      if (r2 < arr.length) {
        largest = arr[r2].priority < arr[largest].priority ? r2 : largest;
      }
      if (largest !== i2) {
        this._swap(i2, largest);
        this._heapify(largest);
      }
    }
  };
  PriorityQueue.prototype._decrease = function(index2) {
    var arr = this._arr;
    var priority = arr[index2].priority;
    var parent;
    while (index2 !== 0) {
      parent = index2 >> 1;
      if (arr[parent].priority < priority) {
        break;
      }
      this._swap(index2, parent);
      index2 = parent;
    }
  };
  PriorityQueue.prototype._swap = function(i2, j) {
    var arr = this._arr;
    var keyIndices = this._keyIndices;
    var origArrI = arr[i2];
    var origArrJ = arr[j];
    arr[i2] = origArrJ;
    arr[j] = origArrI;
    keyIndices[origArrJ.key] = i2;
    keyIndices[origArrI.key] = j;
  };
  return priorityQueue;
}
var dijkstra_1;
var hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra_1;
  hasRequiredDijkstra = 1;
  var _2 = requireLodash();
  var PriorityQueue = requirePriorityQueue();
  dijkstra_1 = dijkstra3;
  var DEFAULT_WEIGHT_FUNC = _2.constant(1);
  function dijkstra3(g2, source, weightFn, edgeFn) {
    return runDijkstra(
      g2,
      String(source),
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v2) {
        return g2.outEdges(v2);
      }
    );
  }
  function runDijkstra(g2, source, weightFn, edgeFn) {
    var results = {};
    var pq = new PriorityQueue();
    var v2, vEntry;
    var updateNeighbors = function(edge) {
      var w2 = edge.v !== v2 ? edge.v : edge.w;
      var wEntry = results[w2];
      var weight = weightFn(edge);
      var distance2 = vEntry.distance + weight;
      if (weight < 0) {
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
      }
      if (distance2 < wEntry.distance) {
        wEntry.distance = distance2;
        wEntry.predecessor = v2;
        pq.decrease(w2, distance2);
      }
    };
    g2.nodes().forEach(function(v3) {
      var distance2 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
      results[v3] = { distance: distance2 };
      pq.add(v3, distance2);
    });
    while (pq.size() > 0) {
      v2 = pq.removeMin();
      vEntry = results[v2];
      if (vEntry.distance === Number.POSITIVE_INFINITY) {
        break;
      }
      edgeFn(v2).forEach(updateNeighbors);
    }
    return results;
  }
  return dijkstra_1;
}
var dijkstraAll_1;
var hasRequiredDijkstraAll;
function requireDijkstraAll() {
  if (hasRequiredDijkstraAll) return dijkstraAll_1;
  hasRequiredDijkstraAll = 1;
  var dijkstra3 = requireDijkstra();
  var _2 = requireLodash();
  dijkstraAll_1 = dijkstraAll;
  function dijkstraAll(g2, weightFunc, edgeFunc) {
    return _2.transform(g2.nodes(), function(acc, v2) {
      acc[v2] = dijkstra3(g2, v2, weightFunc, edgeFunc);
    }, {});
  }
  return dijkstraAll_1;
}
var tarjan_1;
var hasRequiredTarjan;
function requireTarjan() {
  if (hasRequiredTarjan) return tarjan_1;
  hasRequiredTarjan = 1;
  var _2 = requireLodash();
  tarjan_1 = tarjan;
  function tarjan(g2) {
    var index2 = 0;
    var stack = [];
    var visited = {};
    var results = [];
    function dfs2(v2) {
      var entry = visited[v2] = {
        onStack: true,
        lowlink: index2,
        index: index2++
      };
      stack.push(v2);
      g2.successors(v2).forEach(function(w3) {
        if (!_2.has(visited, w3)) {
          dfs2(w3);
          entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink);
        } else if (visited[w3].onStack) {
          entry.lowlink = Math.min(entry.lowlink, visited[w3].index);
        }
      });
      if (entry.lowlink === entry.index) {
        var cmpt = [];
        var w2;
        do {
          w2 = stack.pop();
          visited[w2].onStack = false;
          cmpt.push(w2);
        } while (v2 !== w2);
        results.push(cmpt);
      }
    }
    g2.nodes().forEach(function(v2) {
      if (!_2.has(visited, v2)) {
        dfs2(v2);
      }
    });
    return results;
  }
  return tarjan_1;
}
var findCycles_1;
var hasRequiredFindCycles;
function requireFindCycles() {
  if (hasRequiredFindCycles) return findCycles_1;
  hasRequiredFindCycles = 1;
  var _2 = requireLodash();
  var tarjan = requireTarjan();
  findCycles_1 = findCycles;
  function findCycles(g2) {
    return _2.filter(tarjan(g2), function(cmpt) {
      return cmpt.length > 1 || cmpt.length === 1 && g2.hasEdge(cmpt[0], cmpt[0]);
    });
  }
  return findCycles_1;
}
var floydWarshall_1;
var hasRequiredFloydWarshall;
function requireFloydWarshall() {
  if (hasRequiredFloydWarshall) return floydWarshall_1;
  hasRequiredFloydWarshall = 1;
  var _2 = requireLodash();
  floydWarshall_1 = floydWarshall2;
  var DEFAULT_WEIGHT_FUNC = _2.constant(1);
  function floydWarshall2(g2, weightFn, edgeFn) {
    return runFloydWarshall(
      g2,
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v2) {
        return g2.outEdges(v2);
      }
    );
  }
  function runFloydWarshall(g2, weightFn, edgeFn) {
    var results = {};
    var nodes = g2.nodes();
    nodes.forEach(function(v2) {
      results[v2] = {};
      results[v2][v2] = { distance: 0 };
      nodes.forEach(function(w2) {
        if (v2 !== w2) {
          results[v2][w2] = { distance: Number.POSITIVE_INFINITY };
        }
      });
      edgeFn(v2).forEach(function(edge) {
        var w2 = edge.v === v2 ? edge.w : edge.v;
        var d3 = weightFn(edge);
        results[v2][w2] = { distance: d3, predecessor: v2 };
      });
    });
    nodes.forEach(function(k) {
      var rowK = results[k];
      nodes.forEach(function(i2) {
        var rowI = results[i2];
        nodes.forEach(function(j) {
          var ik = rowI[k];
          var kj = rowK[j];
          var ij = rowI[j];
          var altDistance = ik.distance + kj.distance;
          if (altDistance < ij.distance) {
            ij.distance = altDistance;
            ij.predecessor = kj.predecessor;
          }
        });
      });
    });
    return results;
  }
  return floydWarshall_1;
}
var topsort_1;
var hasRequiredTopsort;
function requireTopsort() {
  if (hasRequiredTopsort) return topsort_1;
  hasRequiredTopsort = 1;
  var _2 = requireLodash();
  topsort_1 = topsort;
  topsort.CycleException = CycleException;
  function topsort(g2) {
    var visited = {};
    var stack = {};
    var results = [];
    function visit(node) {
      if (_2.has(stack, node)) {
        throw new CycleException();
      }
      if (!_2.has(visited, node)) {
        stack[node] = true;
        visited[node] = true;
        _2.each(g2.predecessors(node), visit);
        delete stack[node];
        results.push(node);
      }
    }
    _2.each(g2.sinks(), visit);
    if (_2.size(visited) !== g2.nodeCount()) {
      throw new CycleException();
    }
    return results;
  }
  function CycleException() {
  }
  CycleException.prototype = new Error();
  return topsort_1;
}
var isAcyclic_1;
var hasRequiredIsAcyclic;
function requireIsAcyclic() {
  if (hasRequiredIsAcyclic) return isAcyclic_1;
  hasRequiredIsAcyclic = 1;
  var topsort = requireTopsort();
  isAcyclic_1 = isAcyclic;
  function isAcyclic(g2) {
    try {
      topsort(g2);
    } catch (e3) {
      if (e3 instanceof topsort.CycleException) {
        return false;
      }
      throw e3;
    }
    return true;
  }
  return isAcyclic_1;
}
var dfs_1;
var hasRequiredDfs;
function requireDfs() {
  if (hasRequiredDfs) return dfs_1;
  hasRequiredDfs = 1;
  var _2 = requireLodash();
  dfs_1 = dfs2;
  function dfs2(g2, vs, order2) {
    if (!_2.isArray(vs)) {
      vs = [vs];
    }
    var navigation = (g2.isDirected() ? g2.successors : g2.neighbors).bind(g2);
    var acc = [];
    var visited = {};
    _2.each(vs, function(v2) {
      if (!g2.hasNode(v2)) {
        throw new Error("Graph does not have node: " + v2);
      }
      doDfs(g2, v2, order2 === "post", visited, navigation, acc);
    });
    return acc;
  }
  function doDfs(g2, v2, postorder2, visited, navigation, acc) {
    if (!_2.has(visited, v2)) {
      visited[v2] = true;
      if (!postorder2) {
        acc.push(v2);
      }
      _2.each(navigation(v2), function(w2) {
        doDfs(g2, w2, postorder2, visited, navigation, acc);
      });
      if (postorder2) {
        acc.push(v2);
      }
    }
  }
  return dfs_1;
}
var postorder_1;
var hasRequiredPostorder;
function requirePostorder() {
  if (hasRequiredPostorder) return postorder_1;
  hasRequiredPostorder = 1;
  var dfs2 = requireDfs();
  postorder_1 = postorder2;
  function postorder2(g2, vs) {
    return dfs2(g2, vs, "post");
  }
  return postorder_1;
}
var preorder_1;
var hasRequiredPreorder;
function requirePreorder() {
  if (hasRequiredPreorder) return preorder_1;
  hasRequiredPreorder = 1;
  var dfs2 = requireDfs();
  preorder_1 = preorder2;
  function preorder2(g2, vs) {
    return dfs2(g2, vs, "pre");
  }
  return preorder_1;
}
var prim_1;
var hasRequiredPrim;
function requirePrim() {
  if (hasRequiredPrim) return prim_1;
  hasRequiredPrim = 1;
  var _2 = requireLodash();
  var Graph3 = requireGraph();
  var PriorityQueue = requirePriorityQueue();
  prim_1 = prim;
  function prim(g2, weightFunc) {
    var result = new Graph3();
    var parents = {};
    var pq = new PriorityQueue();
    var v2;
    function updateNeighbors(edge) {
      var w2 = edge.v === v2 ? edge.w : edge.v;
      var pri = pq.priority(w2);
      if (pri !== void 0) {
        var edgeWeight = weightFunc(edge);
        if (edgeWeight < pri) {
          parents[w2] = v2;
          pq.decrease(w2, edgeWeight);
        }
      }
    }
    if (g2.nodeCount() === 0) {
      return result;
    }
    _2.each(g2.nodes(), function(v3) {
      pq.add(v3, Number.POSITIVE_INFINITY);
      result.setNode(v3);
    });
    pq.decrease(g2.nodes()[0], 0);
    var init = false;
    while (pq.size() > 0) {
      v2 = pq.removeMin();
      if (_2.has(parents, v2)) {
        result.setEdge(v2, parents[v2]);
      } else if (init) {
        throw new Error("Input graph is not connected: " + g2);
      } else {
        init = true;
      }
      g2.nodeEdges(v2).forEach(updateNeighbors);
    }
    return result;
  }
  return prim_1;
}
var alg;
var hasRequiredAlg;
function requireAlg() {
  if (hasRequiredAlg) return alg;
  hasRequiredAlg = 1;
  alg = {
    components: requireComponents(),
    dijkstra: requireDijkstra(),
    dijkstraAll: requireDijkstraAll(),
    findCycles: requireFindCycles(),
    floydWarshall: requireFloydWarshall(),
    isAcyclic: requireIsAcyclic(),
    postorder: requirePostorder(),
    preorder: requirePreorder(),
    prim: requirePrim(),
    tarjan: requireTarjan(),
    topsort: requireTopsort()
  };
  return alg;
}
var graphlib$1;
var hasRequiredGraphlib;
function requireGraphlib() {
  if (hasRequiredGraphlib) return graphlib$1;
  hasRequiredGraphlib = 1;
  var lib2 = requireLib();
  graphlib$1 = {
    Graph: lib2.Graph,
    json: requireJson(),
    alg: requireAlg(),
    version: lib2.version
  };
  return graphlib$1;
}
var graphlib;
if (typeof commonjsRequire === "function") {
  try {
    graphlib = requireGraphlib();
  } catch (e3) {
  }
}
if (!graphlib) {
  graphlib = window.graphlib;
}
var graphlib_1 = graphlib;
var cloneDeep_1;
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep) return cloneDeep_1;
  hasRequiredCloneDeep = 1;
  var baseClone = require_baseClone();
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  cloneDeep_1 = cloneDeep;
  return cloneDeep_1;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(), isArrayLike2 = requireIsArrayLike(), isIndex = require_isIndex(), isObject2 = requireIsObject();
  function isIterateeCall(value, index2, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq(object[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults_1;
  hasRequiredDefaults = 1;
  var baseRest = require_baseRest(), eq = requireEq(), isIterateeCall = require_isIterateeCall(), keysIn = requireKeysIn();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var defaults = baseRest(function(object, sources) {
    object = Object(object);
    var index2 = -1;
    var length2 = sources.length;
    var guard = length2 > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length2 = 1;
    }
    while (++index2 < length2) {
      var source = sources[index2];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];
        if (value === void 0 || eq(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
          object[key] = source[key];
        }
      }
    }
    return object;
  });
  defaults_1 = defaults;
  return defaults_1;
}
var _createFind;
var hasRequired_createFind;
function require_createFind() {
  if (hasRequired_createFind) return _createFind;
  hasRequired_createFind = 1;
  var baseIteratee = require_baseIteratee(), isArrayLike2 = requireIsArrayLike(), keys = requireKeys();
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike2(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  _createFind = createFind;
  return _createFind;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger) return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var findIndex_1;
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex) return findIndex_1;
  hasRequiredFindIndex = 1;
  var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
  var nativeMax = Math.max;
  function findIndex(array, predicate, fromIndex) {
    var length2 = array == null ? 0 : array.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate, 3), index2);
  }
  findIndex_1 = findIndex;
  return findIndex_1;
}
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind) return find_1;
  hasRequiredFind = 1;
  var createFind = require_createFind(), findIndex = requireFindIndex();
  var find3 = createFind(findIndex);
  find_1 = find3;
  return find_1;
}
var flatten_1;
var hasRequiredFlatten;
function requireFlatten() {
  if (hasRequiredFlatten) return flatten_1;
  hasRequiredFlatten = 1;
  var baseFlatten = require_baseFlatten();
  function flatten2(array) {
    var length2 = array == null ? 0 : array.length;
    return length2 ? baseFlatten(array, 1) : [];
  }
  flatten_1 = flatten2;
  return flatten_1;
}
var forIn_1;
var hasRequiredForIn;
function requireForIn() {
  if (hasRequiredForIn) return forIn_1;
  hasRequiredForIn = 1;
  var baseFor = require_baseFor(), castFunction = require_castFunction(), keysIn = requireKeysIn();
  function forIn(object, iteratee) {
    return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
  }
  forIn_1 = forIn;
  return forIn_1;
}
var last_1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast) return last_1;
  hasRequiredLast = 1;
  function last(array) {
    var length2 = array == null ? 0 : array.length;
    return length2 ? array[length2 - 1] : void 0;
  }
  last_1 = last;
  return last_1;
}
var mapValues_1;
var hasRequiredMapValues;
function requireMapValues() {
  if (hasRequiredMapValues) return mapValues_1;
  hasRequiredMapValues = 1;
  var baseAssignValue = require_baseAssignValue(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee();
  function mapValues(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee, 3);
    baseForOwn(object, function(value, key, object2) {
      baseAssignValue(result, key, iteratee(value, key, object2));
    });
    return result;
  }
  mapValues_1 = mapValues;
  return mapValues_1;
}
var _baseExtremum;
var hasRequired_baseExtremum;
function require_baseExtremum() {
  if (hasRequired_baseExtremum) return _baseExtremum;
  hasRequired_baseExtremum = 1;
  var isSymbol = requireIsSymbol();
  function baseExtremum(array, iteratee, comparator) {
    var index2 = -1, length2 = array.length;
    while (++index2 < length2) {
      var value = array[index2], current2 = iteratee(value);
      if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
        var computed = current2, result = value;
      }
    }
    return result;
  }
  _baseExtremum = baseExtremum;
  return _baseExtremum;
}
var _baseGt;
var hasRequired_baseGt;
function require_baseGt() {
  if (hasRequired_baseGt) return _baseGt;
  hasRequired_baseGt = 1;
  function baseGt(value, other) {
    return value > other;
  }
  _baseGt = baseGt;
  return _baseGt;
}
var max_1;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max_1;
  hasRequiredMax = 1;
  var baseExtremum = require_baseExtremum(), baseGt = require_baseGt(), identity2 = requireIdentity();
  function max2(array) {
    return array && array.length ? baseExtremum(array, identity2, baseGt) : void 0;
  }
  max_1 = max2;
  return max_1;
}
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue) return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  _assignMergeValue = assignMergeValue;
  return _assignMergeValue;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike2 = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject2(value) {
    if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject2;
  return isPlainObject_1;
}
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet) return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  _safeGet = safeGet;
  return _safeGet;
}
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject) return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  toPlainObject_1 = toPlainObject;
  return toPlainObject_1;
}
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep) return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer(), isFunction2 = requireIsFunction(), isObject2 = requireIsObject(), isPlainObject2 = requireIsPlainObject(), isTypedArray = requireIsTypedArray(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  _baseMergeDeep = baseMergeDeep;
  return _baseMergeDeep;
}
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge) return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor(), baseMergeDeep = require_baseMergeDeep(), isObject2 = requireIsObject(), keysIn = requireKeysIn(), safeGet = require_safeGet();
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  _baseMerge = baseMerge;
  return _baseMerge;
}
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner) return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object = Object(object);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge_1;
  hasRequiredMerge = 1;
  var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
  var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  merge_1 = merge;
  return merge_1;
}
var _baseLt;
var hasRequired_baseLt;
function require_baseLt() {
  if (hasRequired_baseLt) return _baseLt;
  hasRequired_baseLt = 1;
  function baseLt(value, other) {
    return value < other;
  }
  _baseLt = baseLt;
  return _baseLt;
}
var min_1;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min_1;
  hasRequiredMin = 1;
  var baseExtremum = require_baseExtremum(), baseLt = require_baseLt(), identity2 = requireIdentity();
  function min2(array) {
    return array && array.length ? baseExtremum(array, identity2, baseLt) : void 0;
  }
  min_1 = min2;
  return min_1;
}
var minBy_1;
var hasRequiredMinBy;
function requireMinBy() {
  if (hasRequiredMinBy) return minBy_1;
  hasRequiredMinBy = 1;
  var baseExtremum = require_baseExtremum(), baseIteratee = require_baseIteratee(), baseLt = require_baseLt();
  function minBy2(array, iteratee) {
    return array && array.length ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt) : void 0;
  }
  minBy_1 = minBy2;
  return minBy_1;
}
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now_1;
  hasRequiredNow = 1;
  var root2 = require_root();
  var now2 = function() {
    return root2.Date.now();
  };
  now_1 = now2;
  return now_1;
}
var _baseSet;
var hasRequired_baseSet;
function require_baseSet() {
  if (hasRequired_baseSet) return _baseSet;
  hasRequired_baseSet = 1;
  var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject2 = requireIsObject(), toKey = require_toKey();
  function baseSet(object, path, value, customizer) {
    if (!isObject2(object)) {
      return object;
    }
    path = castPath(path, object);
    var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
    while (nested != null && ++index2 < length2) {
      var key = toKey(path[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }
  _baseSet = baseSet;
  return _baseSet;
}
var _basePickBy;
var hasRequired_basePickBy;
function require_basePickBy() {
  if (hasRequired_basePickBy) return _basePickBy;
  hasRequired_basePickBy = 1;
  var baseGet = require_baseGet(), baseSet = require_baseSet(), castPath = require_castPath();
  function basePickBy(object, paths, predicate) {
    var index2 = -1, length2 = paths.length, result = {};
    while (++index2 < length2) {
      var path = paths[index2], value = baseGet(object, path);
      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }
    return result;
  }
  _basePickBy = basePickBy;
  return _basePickBy;
}
var _basePick;
var hasRequired_basePick;
function require_basePick() {
  if (hasRequired_basePick) return _basePick;
  hasRequired_basePick = 1;
  var basePickBy = require_basePickBy(), hasIn = requireHasIn();
  function basePick(object, paths) {
    return basePickBy(object, paths, function(value, path) {
      return hasIn(object, path);
    });
  }
  _basePick = basePick;
  return _basePick;
}
var _flatRest;
var hasRequired_flatRest;
function require_flatRest() {
  if (hasRequired_flatRest) return _flatRest;
  hasRequired_flatRest = 1;
  var flatten2 = requireFlatten(), overRest = require_overRest(), setToString = require_setToString();
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten2), func + "");
  }
  _flatRest = flatRest;
  return _flatRest;
}
var pick_1;
var hasRequiredPick;
function requirePick() {
  if (hasRequiredPick) return pick_1;
  hasRequiredPick = 1;
  var basePick = require_basePick(), flatRest = require_flatRest();
  var pick2 = flatRest(function(object, paths) {
    return object == null ? {} : basePick(object, paths);
  });
  pick_1 = pick2;
  return pick_1;
}
var _baseRange;
var hasRequired_baseRange;
function require_baseRange() {
  if (hasRequired_baseRange) return _baseRange;
  hasRequired_baseRange = 1;
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function baseRange(start, end, step2, fromRight) {
    var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step2 || 1)), 0), result = Array(length2);
    while (length2--) {
      result[fromRight ? length2 : ++index2] = start;
      start += step2;
    }
    return result;
  }
  _baseRange = baseRange;
  return _baseRange;
}
var _createRange;
var hasRequired_createRange;
function require_createRange() {
  if (hasRequired_createRange) return _createRange;
  hasRequired_createRange = 1;
  var baseRange = require_baseRange(), isIterateeCall = require_isIterateeCall(), toFinite = requireToFinite();
  function createRange2(fromRight) {
    return function(start, end, step2) {
      if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
        end = step2 = void 0;
      }
      start = toFinite(start);
      if (end === void 0) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      step2 = step2 === void 0 ? start < end ? 1 : -1 : toFinite(step2);
      return baseRange(start, end, step2, fromRight);
    };
  }
  _createRange = createRange2;
  return _createRange;
}
var range_1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range_1;
  hasRequiredRange = 1;
  var createRange2 = require_createRange();
  var range = createRange2();
  range_1 = range;
  return range_1;
}
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy) return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array, comparer) {
    var length2 = array.length;
    array.sort(comparer);
    while (length2--) {
      array[length2] = array[length2].value;
    }
    return array;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending) return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol = requireIsSymbol();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple) return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object, other, orders) {
    var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length2) {
      var result = compareAscending(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order2 = orders[index2];
        return result * (order2 == "desc" ? -1 : 1);
      }
    }
    return object.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy) return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap = require_arrayMap(), baseGet = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary(), compareMultiple = require_compareMultiple(), identity2 = requireIdentity(), isArray2 = requireIsArray();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray2(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity2];
    }
    var index2 = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy) return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length2 = iteratees.length;
    if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy;
  return sortBy_1;
}
var uniqueId_1;
var hasRequiredUniqueId;
function requireUniqueId() {
  if (hasRequiredUniqueId) return uniqueId_1;
  hasRequiredUniqueId = 1;
  var toString2 = requireToString();
  var idCounter = 0;
  function uniqueId3(prefix) {
    var id2 = ++idCounter;
    return toString2(prefix) + id2;
  }
  uniqueId_1 = uniqueId3;
  return uniqueId_1;
}
var _baseZipObject;
var hasRequired_baseZipObject;
function require_baseZipObject() {
  if (hasRequired_baseZipObject) return _baseZipObject;
  hasRequired_baseZipObject = 1;
  function baseZipObject(props, values2, assignFunc) {
    var index2 = -1, length2 = props.length, valsLength = values2.length, result = {};
    while (++index2 < length2) {
      var value = index2 < valsLength ? values2[index2] : void 0;
      assignFunc(result, props[index2], value);
    }
    return result;
  }
  _baseZipObject = baseZipObject;
  return _baseZipObject;
}
var zipObject_1;
var hasRequiredZipObject;
function requireZipObject() {
  if (hasRequiredZipObject) return zipObject_1;
  hasRequiredZipObject = 1;
  var assignValue = require_assignValue(), baseZipObject = require_baseZipObject();
  function zipObject2(props, values2) {
    return baseZipObject(props || [], values2 || [], assignValue);
  }
  zipObject_1 = zipObject2;
  return zipObject_1;
}
var lodash;
if (typeof commonjsRequire === "function") {
  try {
    lodash = {
      cloneDeep: requireCloneDeep(),
      constant: requireConstant(),
      defaults: requireDefaults(),
      each: requireEach(),
      filter: requireFilter(),
      find: requireFind(),
      flatten: requireFlatten(),
      forEach: requireForEach(),
      forIn: requireForIn(),
      has: requireHas(),
      isUndefined: requireIsUndefined(),
      last: requireLast(),
      map: requireMap(),
      mapValues: requireMapValues(),
      max: requireMax(),
      merge: requireMerge(),
      min: requireMin(),
      minBy: requireMinBy(),
      now: requireNow(),
      pick: requirePick(),
      range: requireRange(),
      reduce: requireReduce(),
      sortBy: requireSortBy(),
      uniqueId: requireUniqueId(),
      values: requireValues(),
      zipObject: requireZipObject()
    };
  } catch (e3) {
  }
}
if (!lodash) {
  lodash = window._;
}
var lodash_1 = lodash;
var list = List$1;
function List$1() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}
List$1.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};
List$1.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};
List$1.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k, v2) {
  if (k !== "_next" && k !== "_prev") {
    return v2;
  }
}
var _$n = lodash_1;
var Graph$8 = graphlib_1.Graph;
var List3 = list;
var greedyFas = greedyFAS$1;
var DEFAULT_WEIGHT_FN = _$n.constant(1);
function greedyFAS$1(g2, weightFn) {
  if (g2.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return _$n.flatten(_$n.map(results, function(e3) {
    return g2.outEdges(e3.v, e3.w);
  }), true);
}
function doGreedyFAS(g2, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];
  var entry;
  while (g2.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g2, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g2, buckets, zeroIdx, entry);
    }
    if (g2.nodeCount()) {
      for (var i2 = buckets.length - 2; i2 > 0; --i2) {
        entry = buckets[i2].dequeue();
        if (entry) {
          results = results.concat(removeNode(g2, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g2, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : void 0;
  _$n.forEach(g2.inEdges(entry.v), function(edge) {
    var weight = g2.edge(edge);
    var uEntry = g2.node(edge.v);
    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  _$n.forEach(g2.outEdges(entry.v), function(edge) {
    var weight = g2.edge(edge);
    var w2 = edge.w;
    var wEntry = g2.node(w2);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g2.removeNode(entry.v);
  return results;
}
function buildState(g2, weightFn) {
  var fasGraph = new Graph$8();
  var maxIn = 0;
  var maxOut = 0;
  _$n.forEach(g2.nodes(), function(v2) {
    fasGraph.setNode(v2, { v: v2, "in": 0, out: 0 });
  });
  _$n.forEach(g2.edges(), function(e3) {
    var prevWeight = fasGraph.edge(e3.v, e3.w) || 0;
    var weight = weightFn(e3);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e3.v, e3.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e3.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e3.w)["in"] += weight);
  });
  var buckets = _$n.range(maxOut + maxIn + 3).map(function() {
    return new List3();
  });
  var zeroIdx = maxIn + 1;
  _$n.forEach(fasGraph.nodes(), function(v2) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v2));
  });
  return { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
var _$m = lodash_1;
var greedyFAS = greedyFas;
var acyclic$1 = {
  run: run$2,
  undo: undo$2
};
function run$2(g2) {
  var fas = g2.graph().acyclicer === "greedy" ? greedyFAS(g2, weightFn(g2)) : dfsFAS(g2);
  _$m.forEach(fas, function(e3) {
    var label = g2.edge(e3);
    g2.removeEdge(e3);
    label.forwardName = e3.name;
    label.reversed = true;
    g2.setEdge(e3.w, e3.v, label, _$m.uniqueId("rev"));
  });
  function weightFn(g3) {
    return function(e3) {
      return g3.edge(e3).weight;
    };
  }
}
function dfsFAS(g2) {
  var fas = [];
  var stack = {};
  var visited = {};
  function dfs2(v2) {
    if (_$m.has(visited, v2)) {
      return;
    }
    visited[v2] = true;
    stack[v2] = true;
    _$m.forEach(g2.outEdges(v2), function(e3) {
      if (_$m.has(stack, e3.w)) {
        fas.push(e3);
      } else {
        dfs2(e3.w);
      }
    });
    delete stack[v2];
  }
  _$m.forEach(g2.nodes(), dfs2);
  return fas;
}
function undo$2(g2) {
  _$m.forEach(g2.edges(), function(e3) {
    var label = g2.edge(e3);
    if (label.reversed) {
      g2.removeEdge(e3);
      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g2.setEdge(e3.w, e3.v, label, forwardName);
    }
  });
}
var _$l = lodash_1;
var Graph$7 = graphlib_1.Graph;
var util$a = {
  addDummyNode,
  simplify: simplify$1,
  asNonCompoundGraph,
  successorWeights,
  predecessorWeights,
  intersectRect,
  buildLayerMatrix,
  normalizeRanks: normalizeRanks$1,
  removeEmptyRanks: removeEmptyRanks$1,
  addBorderNode: addBorderNode$1,
  maxRank,
  partition,
  time,
  notime
};
function addDummyNode(g2, type, attrs, name) {
  var v2;
  do {
    v2 = _$l.uniqueId(name);
  } while (g2.hasNode(v2));
  attrs.dummy = type;
  g2.setNode(v2, attrs);
  return v2;
}
function simplify$1(g2) {
  var simplified = new Graph$7().setGraph(g2.graph());
  _$l.forEach(g2.nodes(), function(v2) {
    simplified.setNode(v2, g2.node(v2));
  });
  _$l.forEach(g2.edges(), function(e3) {
    var simpleLabel = simplified.edge(e3.v, e3.w) || { weight: 0, minlen: 1 };
    var label = g2.edge(e3);
    simplified.setEdge(e3.v, e3.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g2) {
  var simplified = new Graph$7({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
  _$l.forEach(g2.nodes(), function(v2) {
    if (!g2.children(v2).length) {
      simplified.setNode(v2, g2.node(v2));
    }
  });
  _$l.forEach(g2.edges(), function(e3) {
    simplified.setEdge(e3, g2.edge(e3));
  });
  return simplified;
}
function successorWeights(g2) {
  var weightMap = _$l.map(g2.nodes(), function(v2) {
    var sucs = {};
    _$l.forEach(g2.outEdges(v2), function(e3) {
      sucs[e3.w] = (sucs[e3.w] || 0) + g2.edge(e3).weight;
    });
    return sucs;
  });
  return _$l.zipObject(g2.nodes(), weightMap);
}
function predecessorWeights(g2) {
  var weightMap = _$l.map(g2.nodes(), function(v2) {
    var preds = {};
    _$l.forEach(g2.inEdges(v2), function(e3) {
      preds[e3.v] = (preds[e3.v] || 0) + g2.edge(e3).weight;
    });
    return preds;
  });
  return _$l.zipObject(g2.nodes(), weightMap);
}
function intersectRect(rect2, point2) {
  var x2 = rect2.x;
  var y2 = rect2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = rect2.width / 2;
  var h2 = rect2.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
    if (dy < 0) {
      h2 = -h2;
    }
    sx = h2 * dx / dy;
    sy = h2;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
}
function buildLayerMatrix(g2) {
  var layering = _$l.map(_$l.range(maxRank(g2) + 1), function() {
    return [];
  });
  _$l.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2);
    var rank2 = node.rank;
    if (!_$l.isUndefined(rank2)) {
      layering[rank2][node.order] = v2;
    }
  });
  return layering;
}
function normalizeRanks$1(g2) {
  var min2 = _$l.min(_$l.map(g2.nodes(), function(v2) {
    return g2.node(v2).rank;
  }));
  _$l.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2);
    if (_$l.has(node, "rank")) {
      node.rank -= min2;
    }
  });
}
function removeEmptyRanks$1(g2) {
  var offset = _$l.min(_$l.map(g2.nodes(), function(v2) {
    return g2.node(v2).rank;
  }));
  var layers = [];
  _$l.forEach(g2.nodes(), function(v2) {
    var rank2 = g2.node(v2).rank - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v2);
  });
  var delta = 0;
  var nodeRankFactor = g2.graph().nodeRankFactor;
  _$l.forEach(layers, function(vs, i2) {
    if (_$l.isUndefined(vs) && i2 % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _$l.forEach(vs, function(v2) {
        g2.node(v2).rank += delta;
      });
    }
  });
}
function addBorderNode$1(g2, prefix, rank2, order2) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank2;
    node.order = order2;
  }
  return addDummyNode(g2, "border", node, prefix);
}
function maxRank(g2) {
  return _$l.max(_$l.map(g2.nodes(), function(v2) {
    var rank2 = g2.node(v2).rank;
    if (!_$l.isUndefined(rank2)) {
      return rank2;
    }
  }));
}
function partition(collection, fn) {
  var result = { lhs: [], rhs: [] };
  _$l.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}
function time(name, fn) {
  var start = _$l.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (_$l.now() - start) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
var _$k = lodash_1;
var util$9 = util$a;
var normalize$3 = {
  run: run$1,
  undo: undo$1
};
function run$1(g2) {
  g2.graph().dummyChains = [];
  _$k.forEach(g2.edges(), function(edge) {
    normalizeEdge(g2, edge);
  });
}
function normalizeEdge(g2, e3) {
  var v2 = e3.v;
  var vRank = g2.node(v2).rank;
  var w2 = e3.w;
  var wRank = g2.node(w2).rank;
  var name = e3.name;
  var edgeLabel = g2.edge(e3);
  var labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1) return;
  g2.removeEdge(e3);
  var dummy, attrs, i2;
  for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel,
      edgeObj: e3,
      rank: vRank
    };
    dummy = util$9.addDummyNode(g2, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g2.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
    if (i2 === 0) {
      g2.graph().dummyChains.push(dummy);
    }
    v2 = dummy;
  }
  g2.setEdge(v2, w2, { weight: edgeLabel.weight }, name);
}
function undo$1(g2) {
  _$k.forEach(g2.graph().dummyChains, function(v2) {
    var node = g2.node(v2);
    var origLabel = node.edgeLabel;
    var w2;
    g2.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w2 = g2.successors(v2)[0];
      g2.removeNode(v2);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v2 = w2;
      node = g2.node(v2);
    }
  });
}
var _$j = lodash_1;
var util$8 = {
  longestPath: longestPath$1,
  slack: slack$2
};
function longestPath$1(g2) {
  var visited = {};
  function dfs2(v2) {
    var label = g2.node(v2);
    if (_$j.has(visited, v2)) {
      return label.rank;
    }
    visited[v2] = true;
    var rank2 = _$j.min(_$j.map(g2.outEdges(v2), function(e3) {
      return dfs2(e3.w) - g2.edge(e3).minlen;
    }));
    if (rank2 === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    rank2 === void 0 || // return value of _.map([]) for Lodash 4
    rank2 === null) {
      rank2 = 0;
    }
    return label.rank = rank2;
  }
  _$j.forEach(g2.sources(), dfs2);
}
function slack$2(g2, e3) {
  return g2.node(e3.w).rank - g2.node(e3.v).rank - g2.edge(e3).minlen;
}
var _$i = lodash_1;
var Graph$6 = graphlib_1.Graph;
var slack$1 = util$8.slack;
var feasibleTree_1 = feasibleTree$2;
function feasibleTree$2(g2) {
  var t3 = new Graph$6({ directed: false });
  var start = g2.nodes()[0];
  var size = g2.nodeCount();
  t3.setNode(start, {});
  var edge, delta;
  while (tightTree(t3, g2) < size) {
    edge = findMinSlackEdge(t3, g2);
    delta = t3.hasNode(edge.v) ? slack$1(g2, edge) : -slack$1(g2, edge);
    shiftRanks(t3, g2, delta);
  }
  return t3;
}
function tightTree(t3, g2) {
  function dfs2(v2) {
    _$i.forEach(g2.nodeEdges(v2), function(e3) {
      var edgeV = e3.v, w2 = v2 === edgeV ? e3.w : edgeV;
      if (!t3.hasNode(w2) && !slack$1(g2, e3)) {
        t3.setNode(w2, {});
        t3.setEdge(v2, w2, {});
        dfs2(w2);
      }
    });
  }
  _$i.forEach(t3.nodes(), dfs2);
  return t3.nodeCount();
}
function findMinSlackEdge(t3, g2) {
  return _$i.minBy(g2.edges(), function(e3) {
    if (t3.hasNode(e3.v) !== t3.hasNode(e3.w)) {
      return slack$1(g2, e3);
    }
  });
}
function shiftRanks(t3, g2, delta) {
  _$i.forEach(t3.nodes(), function(v2) {
    g2.node(v2).rank += delta;
  });
}
var _$h = lodash_1;
var feasibleTree$1 = feasibleTree_1;
var slack = util$8.slack;
var initRank = util$8.longestPath;
var preorder = graphlib_1.alg.preorder;
var postorder$1 = graphlib_1.alg.postorder;
var simplify = util$a.simplify;
var networkSimplex_1 = networkSimplex$1;
networkSimplex$1.initLowLimValues = initLowLimValues;
networkSimplex$1.initCutValues = initCutValues;
networkSimplex$1.calcCutValue = calcCutValue;
networkSimplex$1.leaveEdge = leaveEdge;
networkSimplex$1.enterEdge = enterEdge;
networkSimplex$1.exchangeEdges = exchangeEdges;
function networkSimplex$1(g2) {
  g2 = simplify(g2);
  initRank(g2);
  var t3 = feasibleTree$1(g2);
  initLowLimValues(t3);
  initCutValues(t3, g2);
  var e3, f2;
  while (e3 = leaveEdge(t3)) {
    f2 = enterEdge(t3, g2, e3);
    exchangeEdges(t3, g2, e3, f2);
  }
}
function initCutValues(t3, g2) {
  var vs = postorder$1(t3, t3.nodes());
  vs = vs.slice(0, vs.length - 1);
  _$h.forEach(vs, function(v2) {
    assignCutValue(t3, g2, v2);
  });
}
function assignCutValue(t3, g2, child) {
  var childLab = t3.node(child);
  var parent = childLab.parent;
  t3.edge(child, parent).cutvalue = calcCutValue(t3, g2, child);
}
function calcCutValue(t3, g2, child) {
  var childLab = t3.node(child);
  var parent = childLab.parent;
  var childIsTail = true;
  var graphEdge = g2.edge(child, parent);
  var cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g2.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  _$h.forEach(g2.nodeEdges(child), function(e3) {
    var isOutEdge = e3.v === child, other = isOutEdge ? e3.w : e3.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g2.edge(e3).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t3, child, other)) {
        var otherCutValue = t3.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree, root2) {
  if (arguments.length < 2) {
    root2 = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root2);
}
function dfsAssignLowLim(tree, visited, nextLim, v2, parent) {
  var low = nextLim;
  var label = tree.node(v2);
  visited[v2] = true;
  _$h.forEach(tree.neighbors(v2), function(w2) {
    if (!_$h.has(visited, w2)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w2, v2);
    }
  });
  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    delete label.parent;
  }
  return nextLim;
}
function leaveEdge(tree) {
  return _$h.find(tree.edges(), function(e3) {
    return tree.edge(e3).cutvalue < 0;
  });
}
function enterEdge(t3, g2, edge) {
  var v2 = edge.v;
  var w2 = edge.w;
  if (!g2.hasEdge(v2, w2)) {
    v2 = edge.w;
    w2 = edge.v;
  }
  var vLabel = t3.node(v2);
  var wLabel = t3.node(w2);
  var tailLabel = vLabel;
  var flip = false;
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  var candidates = _$h.filter(g2.edges(), function(edge2) {
    return flip === isDescendant(t3, t3.node(edge2.v), tailLabel) && flip !== isDescendant(t3, t3.node(edge2.w), tailLabel);
  });
  return _$h.minBy(candidates, function(edge2) {
    return slack(g2, edge2);
  });
}
function exchangeEdges(t3, g2, e3, f2) {
  var v2 = e3.v;
  var w2 = e3.w;
  t3.removeEdge(v2, w2);
  t3.setEdge(f2.v, f2.w, {});
  initLowLimValues(t3);
  initCutValues(t3, g2);
  updateRanks(t3, g2);
}
function updateRanks(t3, g2) {
  var root2 = _$h.find(t3.nodes(), function(v2) {
    return !g2.node(v2).parent;
  });
  var vs = preorder(t3, root2);
  vs = vs.slice(1);
  _$h.forEach(vs, function(v2) {
    var parent = t3.node(v2).parent, edge = g2.edge(v2, parent), flipped = false;
    if (!edge) {
      edge = g2.edge(parent, v2);
      flipped = true;
    }
    g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree, u2, v2) {
  return tree.hasEdge(u2, v2);
}
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
var rankUtil = util$8;
var longestPath = rankUtil.longestPath;
var feasibleTree = feasibleTree_1;
var networkSimplex = networkSimplex_1;
var rank_1 = rank$1;
function rank$1(g2) {
  switch (g2.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g2);
      break;
    case "tight-tree":
      tightTreeRanker(g2);
      break;
    case "longest-path":
      longestPathRanker(g2);
      break;
    default:
      networkSimplexRanker(g2);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g2) {
  longestPath(g2);
  feasibleTree(g2);
}
function networkSimplexRanker(g2) {
  networkSimplex(g2);
}
var _$g = lodash_1;
var parentDummyChains_1 = parentDummyChains$1;
function parentDummyChains$1(g2) {
  var postorderNums = postorder(g2);
  _$g.forEach(g2.graph().dummyChains, function(v2) {
    var node = g2.node(v2);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;
    while (v2 !== edgeObj.w) {
      node = g2.node(v2);
      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca && g2.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending = false;
        }
      }
      if (!ascending) {
        while (pathIdx < path.length - 1 && g2.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }
      g2.setParent(v2, pathV);
      v2 = g2.successors(v2)[0];
    }
  });
}
function findPath(g2, postorderNums, v2, w2) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v2].low, postorderNums[w2].low);
  var lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim);
  var parent;
  var lca;
  parent = v2;
  do {
    parent = g2.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w2;
  while ((parent = g2.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder(g2) {
  var result = {};
  var lim = 0;
  function dfs2(v2) {
    var low = lim;
    _$g.forEach(g2.children(v2), dfs2);
    result[v2] = { low, lim: lim++ };
  }
  _$g.forEach(g2.children(), dfs2);
  return result;
}
var _$f = lodash_1;
var util$7 = util$a;
var nestingGraph$1 = {
  run,
  cleanup
};
function run(g2) {
  var root2 = util$7.addDummyNode(g2, "root", {}, "_root");
  var depths = treeDepths(g2);
  var height = _$f.max(_$f.values(depths)) - 1;
  var nodeSep = 2 * height + 1;
  g2.graph().nestingRoot = root2;
  _$f.forEach(g2.edges(), function(e3) {
    g2.edge(e3).minlen *= nodeSep;
  });
  var weight = sumWeights(g2) + 1;
  _$f.forEach(g2.children(), function(child) {
    dfs(g2, root2, nodeSep, weight, height, depths, child);
  });
  g2.graph().nodeRankFactor = nodeSep;
}
function dfs(g2, root2, nodeSep, weight, height, depths, v2) {
  var children = g2.children(v2);
  if (!children.length) {
    if (v2 !== root2) {
      g2.setEdge(root2, v2, { weight: 0, minlen: nodeSep });
    }
    return;
  }
  var top = util$7.addBorderNode(g2, "_bt");
  var bottom = util$7.addBorderNode(g2, "_bb");
  var label = g2.node(v2);
  g2.setParent(top, v2);
  label.borderTop = top;
  g2.setParent(bottom, v2);
  label.borderBottom = bottom;
  _$f.forEach(children, function(child) {
    dfs(g2, root2, nodeSep, weight, height, depths, child);
    var childNode = g2.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
    g2.setEdge(top, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
    g2.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
  });
  if (!g2.parent(v2)) {
    g2.setEdge(root2, top, { weight: 0, minlen: height + depths[v2] });
  }
}
function treeDepths(g2) {
  var depths = {};
  function dfs2(v2, depth) {
    var children = g2.children(v2);
    if (children && children.length) {
      _$f.forEach(children, function(child) {
        dfs2(child, depth + 1);
      });
    }
    depths[v2] = depth;
  }
  _$f.forEach(g2.children(), function(v2) {
    dfs2(v2, 1);
  });
  return depths;
}
function sumWeights(g2) {
  return _$f.reduce(g2.edges(), function(acc, e3) {
    return acc + g2.edge(e3).weight;
  }, 0);
}
function cleanup(g2) {
  var graphLabel = g2.graph();
  g2.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _$f.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    if (edge.nestingEdge) {
      g2.removeEdge(e3);
    }
  });
}
var _$e = lodash_1;
var util$6 = util$a;
var addBorderSegments_1 = addBorderSegments$1;
function addBorderSegments$1(g2) {
  function dfs2(v2) {
    var children = g2.children(v2);
    var node = g2.node(v2);
    if (children.length) {
      _$e.forEach(children, dfs2);
    }
    if (_$e.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank2 = node.minRank, maxRank2 = node.maxRank + 1; rank2 < maxRank2; ++rank2) {
        addBorderNode(g2, "borderLeft", "_bl", v2, node, rank2);
        addBorderNode(g2, "borderRight", "_br", v2, node, rank2);
      }
    }
  }
  _$e.forEach(g2.children(), dfs2);
}
function addBorderNode(g2, prop, prefix, sg, sgNode, rank2) {
  var label = { width: 0, height: 0, rank: rank2, borderType: prop };
  var prev = sgNode[prop][rank2 - 1];
  var curr = util$6.addDummyNode(g2, "border", label, prefix);
  sgNode[prop][rank2] = curr;
  g2.setParent(curr, sg);
  if (prev) {
    g2.setEdge(prev, curr, { weight: 1 });
  }
}
var _$d = lodash_1;
var coordinateSystem$1 = {
  adjust,
  undo
};
function adjust(g2) {
  var rankDir = g2.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g2);
  }
}
function undo(g2) {
  var rankDir = g2.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g2);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g2);
    swapWidthHeight(g2);
  }
}
function swapWidthHeight(g2) {
  _$d.forEach(g2.nodes(), function(v2) {
    swapWidthHeightOne(g2.node(v2));
  });
  _$d.forEach(g2.edges(), function(e3) {
    swapWidthHeightOne(g2.edge(e3));
  });
}
function swapWidthHeightOne(attrs) {
  var w2 = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w2;
}
function reverseY(g2) {
  _$d.forEach(g2.nodes(), function(v2) {
    reverseYOne(g2.node(v2));
  });
  _$d.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    _$d.forEach(edge.points, reverseYOne);
    if (_$d.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g2) {
  _$d.forEach(g2.nodes(), function(v2) {
    swapXYOne(g2.node(v2));
  });
  _$d.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    _$d.forEach(edge.points, swapXYOne);
    if (_$d.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  var x2 = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x2;
}
var _$c = lodash_1;
var initOrder_1 = initOrder$1;
function initOrder$1(g2) {
  var visited = {};
  var simpleNodes = _$c.filter(g2.nodes(), function(v2) {
    return !g2.children(v2).length;
  });
  var maxRank2 = _$c.max(_$c.map(simpleNodes, function(v2) {
    return g2.node(v2).rank;
  }));
  var layers = _$c.map(_$c.range(maxRank2 + 1), function() {
    return [];
  });
  function dfs2(v2) {
    if (_$c.has(visited, v2)) return;
    visited[v2] = true;
    var node = g2.node(v2);
    layers[node.rank].push(v2);
    _$c.forEach(g2.successors(v2), dfs2);
  }
  var orderedVs = _$c.sortBy(simpleNodes, function(v2) {
    return g2.node(v2).rank;
  });
  _$c.forEach(orderedVs, dfs2);
  return layers;
}
var _$b = lodash_1;
var crossCount_1 = crossCount$1;
function crossCount$1(g2, layering) {
  var cc = 0;
  for (var i2 = 1; i2 < layering.length; ++i2) {
    cc += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
  }
  return cc;
}
function twoLayerCrossCount(g2, northLayer, southLayer) {
  var southPos = _$b.zipObject(
    southLayer,
    _$b.map(southLayer, function(v2, i2) {
      return i2;
    })
  );
  var southEntries = _$b.flatten(_$b.map(northLayer, function(v2) {
    return _$b.sortBy(_$b.map(g2.outEdges(v2), function(e3) {
      return { pos: southPos[e3.w], weight: g2.edge(e3).weight };
    }), "pos");
  }), true);
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = _$b.map(new Array(treeSize), function() {
    return 0;
  });
  var cc = 0;
  _$b.forEach(southEntries.forEach(function(entry) {
    var index2 = entry.pos + firstIndex;
    tree[index2] += entry.weight;
    var weightSum = 0;
    while (index2 > 0) {
      if (index2 % 2) {
        weightSum += tree[index2 + 1];
      }
      index2 = index2 - 1 >> 1;
      tree[index2] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));
  return cc;
}
var _$a = lodash_1;
var barycenter_1 = barycenter$1;
function barycenter$1(g2, movable) {
  return _$a.map(movable, function(v2) {
    var inV = g2.inEdges(v2);
    if (!inV.length) {
      return { v: v2 };
    } else {
      var result = _$a.reduce(inV, function(acc, e3) {
        var edge = g2.edge(e3), nodeU = g2.node(e3.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v: v2,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}
var _$9 = lodash_1;
var resolveConflicts_1 = resolveConflicts$1;
function resolveConflicts$1(entries, cg) {
  var mappedEntries = {};
  _$9.forEach(entries, function(entry, i2) {
    var tmp2 = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i2
    };
    if (!_$9.isUndefined(entry.barycenter)) {
      tmp2.barycenter = entry.barycenter;
      tmp2.weight = entry.weight;
    }
  });
  _$9.forEach(cg.edges(), function(e3) {
    var entryV = mappedEntries[e3.v];
    var entryW = mappedEntries[e3.w];
    if (!_$9.isUndefined(entryV) && !_$9.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e3.w]);
    }
  });
  var sourceSet = _$9.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  var entries = [];
  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_$9.isUndefined(uEntry.barycenter) || _$9.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    _$9.forEach(entry["in"].reverse(), handleIn(entry));
    _$9.forEach(entry.out, handleOut(entry));
  }
  return _$9.map(
    _$9.filter(entries, function(entry2) {
      return !entry2.merged;
    }),
    function(entry2) {
      return _$9.pick(entry2, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}
var _$8 = lodash_1;
var util$5 = util$a;
var sort_1 = sort$1;
function sort$1(entries, biasRight) {
  var parts = util$5.partition(entries, function(entry) {
    return _$8.has(entry, "barycenter");
  });
  var sortable = parts.lhs, unsortable = _$8.sortBy(parts.rhs, function(entry) {
    return -entry.i;
  }), vs = [], sum = 0, weight = 0, vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  _$8.forEach(sortable, function(entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  var result = { vs: _$8.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index2) {
  var last;
  while (unsortable.length && (last = _$8.last(unsortable)).i <= index2) {
    unsortable.pop();
    vs.push(last.vs);
    index2++;
  }
  return index2;
}
function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}
var _$7 = lodash_1;
var barycenter = barycenter_1;
var resolveConflicts = resolveConflicts_1;
var sort = sort_1;
var sortSubgraph_1 = sortSubgraph$1;
function sortSubgraph$1(g2, v2, cg, biasRight) {
  var movable = g2.children(v2);
  var node = g2.node(v2);
  var bl = node ? node.borderLeft : void 0;
  var br = node ? node.borderRight : void 0;
  var subgraphs = {};
  if (bl) {
    movable = _$7.filter(movable, function(w2) {
      return w2 !== bl && w2 !== br;
    });
  }
  var barycenters = barycenter(g2, movable);
  _$7.forEach(barycenters, function(entry) {
    if (g2.children(entry.v).length) {
      var subgraphResult = sortSubgraph$1(g2, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_$7.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  var entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  var result = sort(entries, biasRight);
  if (bl) {
    result.vs = _$7.flatten([bl, result.vs, br], true);
    if (g2.predecessors(bl).length) {
      var blPred = g2.node(g2.predecessors(bl)[0]), brPred = g2.node(g2.predecessors(br)[0]);
      if (!_$7.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  _$7.forEach(entries, function(entry) {
    entry.vs = _$7.flatten(entry.vs.map(function(v2) {
      if (subgraphs[v2]) {
        return subgraphs[v2].vs;
      }
      return v2;
    }), true);
  });
}
function mergeBarycenters(target, other) {
  if (!_$7.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}
var _$6 = lodash_1;
var Graph$5 = graphlib_1.Graph;
var buildLayerGraph_1 = buildLayerGraph$1;
function buildLayerGraph$1(g2, rank2, relationship) {
  var root2 = createRootNode(g2), result = new Graph$5({ compound: true }).setGraph({ root: root2 }).setDefaultNodeLabel(function(v2) {
    return g2.node(v2);
  });
  _$6.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2), parent = g2.parent(v2);
    if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
      result.setNode(v2);
      result.setParent(v2, parent || root2);
      _$6.forEach(g2[relationship](v2), function(e3) {
        var u2 = e3.v === v2 ? e3.w : e3.v, edge = result.edge(u2, v2), weight = !_$6.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u2, v2, { weight: g2.edge(e3).weight + weight });
      });
      if (_$6.has(node, "minRank")) {
        result.setNode(v2, {
          borderLeft: node.borderLeft[rank2],
          borderRight: node.borderRight[rank2]
        });
      }
    }
  });
  return result;
}
function createRootNode(g2) {
  var v2;
  while (g2.hasNode(v2 = _$6.uniqueId("_root"))) ;
  return v2;
}
var _$5 = lodash_1;
var addSubgraphConstraints_1 = addSubgraphConstraints$1;
function addSubgraphConstraints$1(g2, cg, vs) {
  var prev = {}, rootPrev;
  _$5.forEach(vs, function(v2) {
    var child = g2.parent(v2), parent, prevChild;
    while (child) {
      parent = g2.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
var _$4 = lodash_1;
var initOrder = initOrder_1;
var crossCount = crossCount_1;
var sortSubgraph = sortSubgraph_1;
var buildLayerGraph = buildLayerGraph_1;
var addSubgraphConstraints = addSubgraphConstraints_1;
var Graph$4 = graphlib_1.Graph;
var util$4 = util$a;
var order_1 = order$1;
function order$1(g2) {
  var maxRank2 = util$4.maxRank(g2), downLayerGraphs = buildLayerGraphs(g2, _$4.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g2, _$4.range(maxRank2 - 1, -1, -1), "outEdges");
  var layering = initOrder(g2);
  assignOrder(g2, layering);
  var bestCC = Number.POSITIVE_INFINITY, best;
  for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2);
    layering = util$4.buildLayerMatrix(g2);
    var cc = crossCount(g2, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _$4.cloneDeep(layering);
      bestCC = cc;
    }
  }
  assignOrder(g2, best);
}
function buildLayerGraphs(g2, ranks, relationship) {
  return _$4.map(ranks, function(rank2) {
    return buildLayerGraph(g2, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph$4();
  _$4.forEach(layerGraphs, function(lg) {
    var root2 = lg.graph().root;
    var sorted = sortSubgraph(lg, root2, cg, biasRight);
    _$4.forEach(sorted.vs, function(v2, i2) {
      lg.node(v2).order = i2;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g2, layering) {
  _$4.forEach(layering, function(layer) {
    _$4.forEach(layer, function(v2, i2) {
      g2.node(v2).order = i2;
    });
  });
}
var _$3 = lodash_1;
var Graph$3 = graphlib_1.Graph;
var util$3 = util$a;
var bk = {
  positionX: positionX$1
};
function findType1Conflicts(g2, layering) {
  var conflicts = {};
  function visitLayer(prevLayer, layer) {
    var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _$3.last(layer);
    _$3.forEach(layer, function(v2, i2) {
      var w2 = findOtherInnerSegmentNode(g2, v2), k1 = w2 ? g2.node(w2).order : prevLayerLength;
      if (w2 || v2 === lastNode) {
        _$3.forEach(layer.slice(scanPos, i2 + 1), function(scanNode) {
          _$3.forEach(g2.predecessors(scanNode), function(u2) {
            var uLabel = g2.node(u2), uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g2.node(scanNode).dummy)) {
              addConflict(conflicts, u2, scanNode);
            }
          });
        });
        scanPos = i2 + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  _$3.reduce(layering, visitLayer);
  return conflicts;
}
function findType2Conflicts(g2, layering) {
  var conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v2;
    _$3.forEach(_$3.range(southPos, southEnd), function(i2) {
      v2 = south[i2];
      if (g2.node(v2).dummy) {
        _$3.forEach(g2.predecessors(v2), function(u2) {
          var uNode = g2.node(u2);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u2, v2);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    var prevNorthPos = -1, nextNorthPos, southPos = 0;
    _$3.forEach(south, function(v2, southLookahead) {
      if (g2.node(v2).dummy === "border") {
        var predecessors = g2.predecessors(v2);
        if (predecessors.length) {
          nextNorthPos = g2.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  _$3.reduce(layering, visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g2, v2) {
  if (g2.node(v2).dummy) {
    return _$3.find(g2.predecessors(v2), function(u2) {
      return g2.node(u2).dummy;
    });
  }
}
function addConflict(conflicts, v2, w2) {
  if (v2 > w2) {
    var tmp2 = v2;
    v2 = w2;
    w2 = tmp2;
  }
  var conflictsV = conflicts[v2];
  if (!conflictsV) {
    conflicts[v2] = conflictsV = {};
  }
  conflictsV[w2] = true;
}
function hasConflict(conflicts, v2, w2) {
  if (v2 > w2) {
    var tmp2 = v2;
    v2 = w2;
    w2 = tmp2;
  }
  return _$3.has(conflicts[v2], w2);
}
function verticalAlignment(g2, layering, conflicts, neighborFn) {
  var root2 = {}, align = {}, pos = {};
  _$3.forEach(layering, function(layer) {
    _$3.forEach(layer, function(v2, order2) {
      root2[v2] = v2;
      align[v2] = v2;
      pos[v2] = order2;
    });
  });
  _$3.forEach(layering, function(layer) {
    var prevIdx = -1;
    _$3.forEach(layer, function(v2) {
      var ws = neighborFn(v2);
      if (ws.length) {
        ws = _$3.sortBy(ws, function(w3) {
          return pos[w3];
        });
        var mp = (ws.length - 1) / 2;
        for (var i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
          var w2 = ws[i2];
          if (align[v2] === v2 && prevIdx < pos[w2] && !hasConflict(conflicts, v2, w2)) {
            align[w2] = v2;
            align[v2] = root2[v2] = root2[w2];
            prevIdx = pos[w2];
          }
        }
      }
    });
  });
  return { root: root2, align };
}
function horizontalCompaction(g2, layering, root2, align, reverseSep) {
  var xs = {}, blockG = buildBlockGraph(g2, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }
      elem = stack.pop();
    }
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e3) {
      return Math.max(acc, xs[e3.v] + blockG.edge(e3));
    }, 0);
  }
  function pass2(elem) {
    var min2 = blockG.outEdges(elem).reduce(function(acc, e3) {
      return Math.min(acc, xs[e3.w] - blockG.edge(e3));
    }, Number.POSITIVE_INFINITY);
    var node = g2.node(elem);
    if (min2 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min2);
    }
  }
  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));
  _$3.forEach(align, function(v2) {
    xs[v2] = xs[root2[v2]];
  });
  return xs;
}
function buildBlockGraph(g2, layering, root2, reverseSep) {
  var blockGraph = new Graph$3(), graphLabel = g2.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  _$3.forEach(layering, function(layer) {
    var u2;
    _$3.forEach(layer, function(v2) {
      var vRoot = root2[v2];
      blockGraph.setNode(vRoot);
      if (u2) {
        var uRoot = root2[u2], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u2), prevMax || 0));
      }
      u2 = v2;
    });
  });
  return blockGraph;
}
function findSmallestWidthAlignment(g2, xss) {
  return _$3.minBy(_$3.values(xss), function(xs) {
    var max2 = Number.NEGATIVE_INFINITY;
    var min2 = Number.POSITIVE_INFINITY;
    _$3.forIn(xs, function(x2, v2) {
      var halfWidth = width(g2, v2) / 2;
      max2 = Math.max(x2 + halfWidth, max2);
      min2 = Math.min(x2 - halfWidth, min2);
    });
    return max2 - min2;
  });
}
function alignCoordinates(xss, alignTo) {
  var alignToVals = _$3.values(alignTo), alignToMin = _$3.min(alignToVals), alignToMax = _$3.max(alignToVals);
  _$3.forEach(["u", "d"], function(vert) {
    _$3.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz, xs = xss[alignment], delta;
      if (xs === alignTo) return;
      var xsVals = _$3.values(xs);
      delta = horiz === "l" ? alignToMin - _$3.min(xsVals) : alignToMax - _$3.max(xsVals);
      if (delta) {
        xss[alignment] = _$3.mapValues(xs, function(x2) {
          return x2 + delta;
        });
      }
    });
  });
}
function balance(xss, align) {
  return _$3.mapValues(xss.ul, function(ignore, v2) {
    if (align) {
      return xss[align.toLowerCase()][v2];
    } else {
      var xs = _$3.sortBy(_$3.map(xss, v2));
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX$1(g2) {
  var layering = util$3.buildLayerMatrix(g2);
  var conflicts = _$3.merge(
    findType1Conflicts(g2, layering),
    findType2Conflicts(g2, layering)
  );
  var xss = {};
  var adjustedLayering;
  _$3.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _$3.values(layering).reverse();
    _$3.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _$3.map(adjustedLayering, function(inner) {
          return _$3.values(inner).reverse();
        });
      }
      var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
      var align = verticalAlignment(g2, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(
        g2,
        adjustedLayering,
        align.root,
        align.align,
        horiz === "r"
      );
      if (horiz === "r") {
        xs = _$3.mapValues(xs, function(x2) {
          return -x2;
        });
      }
      xss[vert + horiz] = xs;
    });
  });
  var smallestWidth = findSmallestWidthAlignment(g2, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g2.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return function(g2, v2, w2) {
    var vLabel = g2.node(v2);
    var wLabel = g2.node(w2);
    var sum = 0;
    var delta;
    sum += vLabel.width / 2;
    if (_$3.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.width / 2;
    if (_$3.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
}
function width(g2, v2) {
  return g2.node(v2).width;
}
var _$2 = lodash_1;
var util$2 = util$a;
var positionX = bk.positionX;
var position_1 = position$1;
function position$1(g2) {
  g2 = util$2.asNonCompoundGraph(g2);
  positionY(g2);
  _$2.forEach(positionX(g2), function(x2, v2) {
    g2.node(v2).x = x2;
  });
}
function positionY(g2) {
  var layering = util$2.buildLayerMatrix(g2);
  var rankSep = g2.graph().ranksep;
  var prevY = 0;
  _$2.forEach(layering, function(layer) {
    var maxHeight = _$2.max(_$2.map(layer, function(v2) {
      return g2.node(v2).height;
    }));
    _$2.forEach(layer, function(v2) {
      g2.node(v2).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}
var _$1 = lodash_1;
var acyclic = acyclic$1;
var normalize$2 = normalize$3;
var rank = rank_1;
var normalizeRanks = util$a.normalizeRanks;
var parentDummyChains = parentDummyChains_1;
var removeEmptyRanks = util$a.removeEmptyRanks;
var nestingGraph = nestingGraph$1;
var addBorderSegments = addBorderSegments_1;
var coordinateSystem = coordinateSystem$1;
var order = order_1;
var position = position_1;
var util$1 = util$a;
var Graph$2 = graphlib_1.Graph;
var layout_1 = layout;
function layout(g2, opts) {
  var time2 = opts && opts.debugTiming ? util$1.time : util$1.notime;
  time2("layout", function() {
    var layoutGraph = time2("  buildLayoutGraph", function() {
      return buildLayoutGraph(g2);
    });
    time2("  runLayout", function() {
      runLayout(layoutGraph, time2);
    });
    time2("  updateInputGraph", function() {
      updateInputGraph(g2, layoutGraph);
    });
  });
}
function runLayout(g2, time2) {
  time2("    makeSpaceForEdgeLabels", function() {
    makeSpaceForEdgeLabels(g2);
  });
  time2("    removeSelfEdges", function() {
    removeSelfEdges(g2);
  });
  time2("    acyclic", function() {
    acyclic.run(g2);
  });
  time2("    nestingGraph.run", function() {
    nestingGraph.run(g2);
  });
  time2("    rank", function() {
    rank(util$1.asNonCompoundGraph(g2));
  });
  time2("    injectEdgeLabelProxies", function() {
    injectEdgeLabelProxies(g2);
  });
  time2("    removeEmptyRanks", function() {
    removeEmptyRanks(g2);
  });
  time2("    nestingGraph.cleanup", function() {
    nestingGraph.cleanup(g2);
  });
  time2("    normalizeRanks", function() {
    normalizeRanks(g2);
  });
  time2("    assignRankMinMax", function() {
    assignRankMinMax(g2);
  });
  time2("    removeEdgeLabelProxies", function() {
    removeEdgeLabelProxies(g2);
  });
  time2("    normalize.run", function() {
    normalize$2.run(g2);
  });
  time2("    parentDummyChains", function() {
    parentDummyChains(g2);
  });
  time2("    addBorderSegments", function() {
    addBorderSegments(g2);
  });
  time2("    order", function() {
    order(g2);
  });
  time2("    insertSelfEdges", function() {
    insertSelfEdges(g2);
  });
  time2("    adjustCoordinateSystem", function() {
    coordinateSystem.adjust(g2);
  });
  time2("    position", function() {
    position(g2);
  });
  time2("    positionSelfEdges", function() {
    positionSelfEdges(g2);
  });
  time2("    removeBorderNodes", function() {
    removeBorderNodes(g2);
  });
  time2("    normalize.undo", function() {
    normalize$2.undo(g2);
  });
  time2("    fixupEdgeLabelCoords", function() {
    fixupEdgeLabelCoords(g2);
  });
  time2("    undoCoordinateSystem", function() {
    coordinateSystem.undo(g2);
  });
  time2("    translateGraph", function() {
    translateGraph(g2);
  });
  time2("    assignNodeIntersects", function() {
    assignNodeIntersects(g2);
  });
  time2("    reversePoints", function() {
    reversePointsForReversedEdges(g2);
  });
  time2("    acyclic.undo", function() {
    acyclic.undo(g2);
  });
}
function updateInputGraph(inputGraph, layoutGraph) {
  _$1.forEach(inputGraph.nodes(), function(v2) {
    var inputLabel = inputGraph.node(v2);
    var layoutLabel = layoutGraph.node(v2);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      if (layoutGraph.children(v2).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  _$1.forEach(inputGraph.edges(), function(e3) {
    var inputLabel = inputGraph.edge(e3);
    var layoutLabel = layoutGraph.edge(e3);
    inputLabel.points = layoutLabel.points;
    if (_$1.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  var g2 = new Graph$2({ multigraph: true, compound: true });
  var graph2 = canonicalize(inputGraph.graph());
  g2.setGraph(_$1.merge(
    {},
    graphDefaults,
    selectNumberAttrs(graph2, graphNumAttrs),
    _$1.pick(graph2, graphAttrs)
  ));
  _$1.forEach(inputGraph.nodes(), function(v2) {
    var node = canonicalize(inputGraph.node(v2));
    g2.setNode(v2, _$1.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g2.setParent(v2, inputGraph.parent(v2));
  });
  _$1.forEach(inputGraph.edges(), function(e3) {
    var edge = canonicalize(inputGraph.edge(e3));
    g2.setEdge(e3, _$1.merge(
      {},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _$1.pick(edge, edgeAttrs)
    ));
  });
  return g2;
}
function makeSpaceForEdgeLabels(g2) {
  var graph2 = g2.graph();
  graph2.ranksep /= 2;
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph2.rankdir === "TB" || graph2.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}
function injectEdgeLabelProxies(g2) {
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    if (edge.width && edge.height) {
      var v2 = g2.node(e3.v);
      var w2 = g2.node(e3.w);
      var label = { rank: (w2.rank - v2.rank) / 2 + v2.rank, e: e3 };
      util$1.addDummyNode(g2, "edge-proxy", label, "_ep");
    }
  });
}
function assignRankMinMax(g2) {
  var maxRank2 = 0;
  _$1.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2);
    if (node.borderTop) {
      node.minRank = g2.node(node.borderTop).rank;
      node.maxRank = g2.node(node.borderBottom).rank;
      maxRank2 = _$1.max(maxRank2, node.maxRank);
    }
  });
  g2.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g2) {
  _$1.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2);
    if (node.dummy === "edge-proxy") {
      g2.edge(node.e).labelRank = node.rank;
      g2.removeNode(v2);
    }
  });
}
function translateGraph(g2) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g2.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    var x2 = attrs.x;
    var y2 = attrs.y;
    var w2 = attrs.width;
    var h2 = attrs.height;
    minX = Math.min(minX, x2 - w2 / 2);
    maxX = Math.max(maxX, x2 + w2 / 2);
    minY = Math.min(minY, y2 - h2 / 2);
    maxY = Math.max(maxY, y2 + h2 / 2);
  }
  _$1.forEach(g2.nodes(), function(v2) {
    getExtremes(g2.node(v2));
  });
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    if (_$1.has(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  _$1.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2);
    node.x -= minX;
    node.y -= minY;
  });
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    _$1.forEach(edge.points, function(p2) {
      p2.x -= minX;
      p2.y -= minY;
    });
    if (_$1.has(edge, "x")) {
      edge.x -= minX;
    }
    if (_$1.has(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g2) {
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    var nodeV = g2.node(e3.v);
    var nodeW = g2.node(e3.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util$1.intersectRect(nodeV, p1));
    edge.points.push(util$1.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g2) {
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    if (_$1.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g2) {
  _$1.forEach(g2.edges(), function(e3) {
    var edge = g2.edge(e3);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g2) {
  _$1.forEach(g2.nodes(), function(v2) {
    if (g2.children(v2).length) {
      var node = g2.node(v2);
      var t3 = g2.node(node.borderTop);
      var b2 = g2.node(node.borderBottom);
      var l2 = g2.node(_$1.last(node.borderLeft));
      var r2 = g2.node(_$1.last(node.borderRight));
      node.width = Math.abs(r2.x - l2.x);
      node.height = Math.abs(b2.y - t3.y);
      node.x = l2.x + node.width / 2;
      node.y = t3.y + node.height / 2;
    }
  });
  _$1.forEach(g2.nodes(), function(v2) {
    if (g2.node(v2).dummy === "border") {
      g2.removeNode(v2);
    }
  });
}
function removeSelfEdges(g2) {
  _$1.forEach(g2.edges(), function(e3) {
    if (e3.v === e3.w) {
      var node = g2.node(e3.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e3, label: g2.edge(e3) });
      g2.removeEdge(e3);
    }
  });
}
function insertSelfEdges(g2) {
  var layers = util$1.buildLayerMatrix(g2);
  _$1.forEach(layers, function(layer) {
    var orderShift = 0;
    _$1.forEach(layer, function(v2, i2) {
      var node = g2.node(v2);
      node.order = i2 + orderShift;
      _$1.forEach(node.selfEdges, function(selfEdge) {
        util$1.addDummyNode(g2, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i2 + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}
function positionSelfEdges(g2) {
  _$1.forEach(g2.nodes(), function(v2) {
    var node = g2.node(v2);
    if (node.dummy === "selfedge") {
      var selfNode = g2.node(node.e.v);
      var x2 = selfNode.x + selfNode.width / 2;
      var y2 = selfNode.y;
      var dx = node.x - x2;
      var dy = selfNode.height / 2;
      g2.setEdge(node.e, node.label);
      g2.removeNode(v2);
      node.label.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { x: x2 + dx, y: y2 },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return _$1.mapValues(_$1.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  _$1.forEach(attrs, function(v2, k) {
    newAttrs[k.toLowerCase()] = v2;
  });
  return newAttrs;
}
var _ = lodash_1;
var util = util$a;
var Graph$1 = graphlib_1.Graph;
var debug = {
  debugOrdering
};
function debugOrdering(g2) {
  var layerMatrix = util.buildLayerMatrix(g2);
  var h2 = new Graph$1({ compound: true, multigraph: true }).setGraph({});
  _.forEach(g2.nodes(), function(v2) {
    h2.setNode(v2, { label: v2 });
    h2.setParent(v2, "layer" + g2.node(v2).rank);
  });
  _.forEach(g2.edges(), function(e3) {
    h2.setEdge(e3.v, e3.w, {}, e3.name);
  });
  _.forEach(layerMatrix, function(layer, i2) {
    var layerV = "layer" + i2;
    h2.setNode(layerV, { rank: "same" });
    _.reduce(layer, function(u2, v2) {
      h2.setEdge(u2, v2, { style: "invis" });
      return v2;
    });
  });
  return h2;
}
var version = "0.8.5";
var dagre = {
  graphlib: graphlib_1,
  layout: layout_1,
  debug,
  util: {
    time: util$a.time,
    notime: util$a.notime
  },
  version
};
const dagre$1 = /* @__PURE__ */ getDefaultExportFromCjs(dagre);
class DagreLayout {
  constructor(options) {
    this.id = "dagre";
    this.options = {};
    Object.assign(this.options, DagreLayout.defaultOptions, options);
  }
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericDagreLayout(false, graph2, Object.assign(Object.assign({}, this.options), options));
    });
  }
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericDagreLayout(true, graph2, Object.assign(Object.assign({}, this.options), options));
    });
  }
  genericDagreLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const { nodeSize } = options;
      const g2 = new dagre.graphlib.Graph();
      g2.setGraph(options);
      g2.setDefaultEdgeLabel(() => ({}));
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      if ([...nodes, ...edges].some(({ id: id2 }) => isNumber(id2))) {
        console.error("Dagre layout only support string id, it will convert number to string.");
      }
      graph2.getAllNodes().forEach((node) => {
        const { id: id2 } = node;
        const data2 = Object.assign({}, node.data);
        if (nodeSize !== void 0) {
          const [width2, height] = parseSize(isFunction$1(nodeSize) ? nodeSize(node) : nodeSize);
          Object.assign(data2, { width: width2, height });
        }
        g2.setNode(id2.toString(), data2);
      });
      graph2.getAllEdges().forEach(({ id: id2, source, target }) => {
        g2.setEdge(source.toString(), target.toString(), { id: id2 });
      });
      dagre$1.layout(g2);
      const mapping = { nodes: [], edges: [] };
      g2.nodes().forEach((id2) => {
        const data2 = g2.node(id2);
        mapping.nodes.push({ id: id2, data: data2 });
        if (assign)
          graph2.mergeNodeData(id2, data2);
      });
      g2.edges().forEach((edge) => {
        const _a3 = g2.edge(edge), { id: id2 } = _a3, data2 = __rest$m(_a3, ["id"]);
        const { v: source, w: target } = edge;
        mapping.edges.push({ id: id2, source, target, data: data2 });
        if (assign)
          graph2.mergeEdgeData(id2, data2);
      });
      return mapping;
    });
  }
}
DagreLayout.defaultOptions = {};
class Body {
  constructor(params) {
    this.id = params.id || 0;
    this.rx = params.rx;
    this.ry = params.ry;
    this.fx = 0;
    this.fy = 0;
    this.mass = params.mass;
    this.degree = params.degree;
    this.g = params.g || 0;
  }
  // returns the euclidean distance
  distanceTo(bo) {
    const dx = this.rx - bo.rx;
    const dy = this.ry - bo.ry;
    return Math.hypot(dx, dy);
  }
  setPos(x2, y2) {
    this.rx = x2;
    this.ry = y2;
  }
  // resets the forces
  resetForce() {
    this.fx = 0;
    this.fy = 0;
  }
  addForce(b2) {
    const dx = b2.rx - this.rx;
    const dy = b2.ry - this.ry;
    let dist2 = Math.hypot(dx, dy);
    dist2 = dist2 < 1e-4 ? 1e-4 : dist2;
    const F2 = this.g * (this.degree + 1) * (b2.degree + 1) / dist2;
    this.fx += F2 * dx / dist2;
    this.fy += F2 * dy / dist2;
  }
  // if quad contains this body
  in(quad) {
    return quad.contains(this.rx, this.ry);
  }
  // returns a new body
  add(bo) {
    const nenwMass = this.mass + bo.mass;
    const x2 = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;
    const y2 = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;
    const dg = this.degree + bo.degree;
    const params = {
      rx: x2,
      ry: y2,
      mass: nenwMass,
      degree: dg
    };
    return new Body(params);
  }
}
class Quad2 {
  constructor(params) {
    this.xmid = params.xmid;
    this.ymid = params.ymid;
    this.length = params.length;
    this.massCenter = params.massCenter || [0, 0];
    this.mass = params.mass || 1;
  }
  getLength() {
    return this.length;
  }
  contains(x2, y2) {
    const halfLen = this.length / 2;
    return x2 <= this.xmid + halfLen && x2 >= this.xmid - halfLen && y2 <= this.ymid + halfLen && y2 >= this.ymid - halfLen;
  }
  // northwest quadrant
  // tslint:disable-next-line
  NW() {
    const x2 = this.xmid - this.length / 4;
    const y2 = this.ymid + this.length / 4;
    const len2 = this.length / 2;
    const params = {
      xmid: x2,
      ymid: y2,
      length: len2
    };
    const NW = new Quad2(params);
    return NW;
  }
  // northeast
  // tslint:disable-next-line
  NE() {
    const x2 = this.xmid + this.length / 4;
    const y2 = this.ymid + this.length / 4;
    const len2 = this.length / 2;
    const params = {
      xmid: x2,
      ymid: y2,
      length: len2
    };
    const NE = new Quad2(params);
    return NE;
  }
  // southwest
  // tslint:disable-next-line
  SW() {
    const x2 = this.xmid - this.length / 4;
    const y2 = this.ymid - this.length / 4;
    const len2 = this.length / 2;
    const params = {
      xmid: x2,
      ymid: y2,
      length: len2
    };
    const SW = new Quad2(params);
    return SW;
  }
  // southeast
  // tslint:disable-next-line
  SE() {
    const x2 = this.xmid + this.length / 4;
    const y2 = this.ymid - this.length / 4;
    const len2 = this.length / 2;
    const params = {
      xmid: x2,
      ymid: y2,
      length: len2
    };
    const SE = new Quad2(params);
    return SE;
  }
}
class QuadTree {
  // each quadtree represents a quadrant and an aggregate body
  // that represents all bodies inside the quadrant
  constructor(param) {
    this.body = null;
    this.quad = null;
    this.NW = null;
    this.NE = null;
    this.SW = null;
    this.SE = null;
    this.theta = 0.5;
    if (param != null)
      this.quad = param;
  }
  // insert a body(node) into the tree
  insert(bo) {
    if (this.body == null) {
      this.body = bo;
      return;
    }
    if (!this._isExternal()) {
      this.body = this.body.add(bo);
      this._putBody(bo);
    } else {
      if (this.quad) {
        this.NW = new QuadTree(this.quad.NW());
        this.NE = new QuadTree(this.quad.NE());
        this.SW = new QuadTree(this.quad.SW());
        this.SE = new QuadTree(this.quad.SE());
      }
      this._putBody(this.body);
      this._putBody(bo);
      this.body = this.body.add(bo);
    }
  }
  // inserts bo into a quad
  // tslint:disable-next-line
  _putBody(bo) {
    if (!this.quad)
      return;
    if (bo.in(this.quad.NW()) && this.NW)
      this.NW.insert(bo);
    else if (bo.in(this.quad.NE()) && this.NE)
      this.NE.insert(bo);
    else if (bo.in(this.quad.SW()) && this.SW)
      this.SW.insert(bo);
    else if (bo.in(this.quad.SE()) && this.SE)
      this.SE.insert(bo);
  }
  // tslint:disable-next-line
  _isExternal() {
    return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
  }
  // update the forces
  updateForce(bo) {
    if (this.body == null || bo === this.body) {
      return;
    }
    if (this._isExternal())
      bo.addForce(this.body);
    else {
      const s3 = this.quad ? this.quad.getLength() : 0;
      const d3 = this.body.distanceTo(bo);
      if (s3 / d3 < this.theta)
        bo.addForce(this.body);
      else {
        this.NW && this.NW.updateForce(bo);
        this.NE && this.NE.updateForce(bo);
        this.SW && this.SW.updateForce(bo);
        this.SE && this.SE.updateForce(bo);
      }
    }
  }
}
const DEFAULTS_LAYOUT_OPTIONS$5 = {
  center: [0, 0],
  width: 300,
  height: 300,
  kr: 5,
  kg: 1,
  mode: "normal",
  preventOverlap: false,
  dissuadeHubs: false,
  maxIteration: 0,
  ks: 0.1,
  ksmax: 10,
  tao: 0.1
};
class ForceAtlas2Layout {
  constructor(options = {}) {
    this.options = options;
    this.id = "forceAtlas2";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$5), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericForceAtlas2Layout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericForceAtlas2Layout(true, graph2, options);
    });
  }
  genericForceAtlas2Layout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const edges = graph2.getAllEdges();
      const nodes = graph2.getAllNodes();
      const mergedOptions = this.formatOptions(options, nodes.length);
      const { width: width2, height, prune, maxIteration, nodeSize, center } = mergedOptions;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph2, assign, center);
      }
      const calcNodes = nodes.map((node) => cloneFormatData(node, [width2, height]));
      const calcEdges = edges.filter((edge) => {
        const { source, target } = edge;
        return source !== target;
      });
      const calcGraph = new Graph$9({
        nodes: calcNodes,
        edges: calcEdges
      });
      const sizes = this.getSizes(calcGraph, nodeSize);
      this.run(calcGraph, graph2, maxIteration, sizes, assign, mergedOptions);
      if (prune) {
        for (let j = 0; j < calcEdges.length; j += 1) {
          const { source, target } = calcEdges[j];
          const sourceDegree = calcGraph.getDegree(source);
          const targetDegree = calcGraph.getDegree(source);
          if (sourceDegree <= 1) {
            const targetNode = calcGraph.getNode(target);
            calcGraph.mergeNodeData(source, {
              x: targetNode.data.x,
              y: targetNode.data.y
            });
          } else if (targetDegree <= 1) {
            const sourceNode = calcGraph.getNode(source);
            calcGraph.mergeNodeData(target, {
              x: sourceNode.data.x,
              y: sourceNode.data.y
            });
          }
        }
        const postOptions = Object.assign(Object.assign({}, mergedOptions), { prune: false, barnesHut: false });
        this.run(calcGraph, graph2, 100, sizes, assign, postOptions);
      }
      return {
        nodes: calcNodes,
        edges
      };
    });
  }
  /**
   * Init the node positions if there is no initial positions.
   * And pre-calculate the size (max of width and height) for each node.
   * @param calcGraph graph for calculation
   * @param nodeSize node size config from layout options
   * @returns {SizeMap} node'id mapped to max of its width and height
   */
  getSizes(calcGraph, nodeSize) {
    const nodes = calcGraph.getAllNodes();
    const sizes = {};
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node = nodes[i2];
      sizes[node.id] = formatNodeSizeToNumber(nodeSize, void 0)(node);
    }
    return sizes;
  }
  /**
   * Format the options.
   * @param options input options
   * @param nodeNum number of nodes
   * @returns formatted options
   */
  formatOptions(options = {}, nodeNum) {
    const mergedOptions = Object.assign(Object.assign({}, this.options), options);
    const { center, width: width2, height, barnesHut, prune, maxIteration, kr, kg } = mergedOptions;
    mergedOptions.width = !width2 && typeof window !== "undefined" ? window.innerWidth : width2;
    mergedOptions.height = !height && typeof window !== "undefined" ? window.innerHeight : height;
    mergedOptions.center = !center ? [mergedOptions.width / 2, mergedOptions.height / 2] : center;
    if (barnesHut === void 0 && nodeNum > 250) {
      mergedOptions.barnesHut = true;
    }
    if (prune === void 0 && nodeNum > 100)
      mergedOptions.prune = true;
    if (maxIteration === 0 && !prune) {
      mergedOptions.maxIteration = 250;
      if (nodeNum <= 200 && nodeNum > 100)
        mergedOptions.maxIteration = 1e3;
      else if (nodeNum > 200)
        mergedOptions.maxIteration = 1200;
    } else if (maxIteration === 0 && prune) {
      mergedOptions.maxIteration = 100;
      if (nodeNum <= 200 && nodeNum > 100)
        mergedOptions.maxIteration = 500;
      else if (nodeNum > 200)
        mergedOptions.maxIteration = 950;
    }
    if (!kr) {
      mergedOptions.kr = 50;
      if (nodeNum > 100 && nodeNum <= 500)
        mergedOptions.kr = 20;
      else if (nodeNum > 500)
        mergedOptions.kr = 1;
    }
    if (!kg) {
      mergedOptions.kg = 20;
      if (nodeNum > 100 && nodeNum <= 500)
        mergedOptions.kg = 10;
      else if (nodeNum > 500)
        mergedOptions.kg = 1;
    }
    return mergedOptions;
  }
  /**
   * Loops for fa2.
   * @param calcGraph graph for calculation
   * @param graph original graph
   * @param iteration iteration number
   * @param sizes nodes' size
   * @param options formatted layout options
   * @returns
   */
  run(calcGraph, graph2, iteration, sizes, assign, options) {
    const { kr, barnesHut, onTick } = options;
    const calcNodes = calcGraph.getAllNodes();
    let sg = 0;
    let iter = iteration;
    const forces = {};
    const preForces = {};
    const bodies = {};
    for (let i2 = 0; i2 < calcNodes.length; i2 += 1) {
      const { data: data2, id: id2 } = calcNodes[i2];
      forces[id2] = [0, 0];
      if (barnesHut) {
        const params = {
          id: i2,
          rx: data2.x,
          ry: data2.y,
          mass: 1,
          g: kr,
          degree: calcGraph.getDegree(id2)
        };
        bodies[id2] = new Body(params);
      }
    }
    while (iter > 0) {
      sg = this.oneStep(calcGraph, {
        iter,
        preventOverlapIters: 50,
        krPrime: 100,
        sg,
        forces,
        preForces,
        bodies,
        sizes
      }, options);
      iter--;
      onTick === null || onTick === void 0 ? void 0 : onTick({
        nodes: calcNodes,
        edges: graph2.getAllEdges()
      });
    }
    return calcGraph;
  }
  /**
   * One step for a loop.
   * @param graph graph for calculation
   * @param params parameters for a loop
   * @param options formatted layout's input options
   * @returns
   */
  oneStep(graph2, params, options) {
    const { iter, preventOverlapIters, krPrime, sg, preForces, bodies, sizes } = params;
    let { forces } = params;
    const { preventOverlap, barnesHut } = options;
    const nodes = graph2.getAllNodes();
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const { id: id2 } = nodes[i2];
      preForces[id2] = [...forces[id2]];
      forces[id2] = [0, 0];
    }
    forces = this.getAttrForces(graph2, iter, preventOverlapIters, sizes, forces, options);
    if (barnesHut && (preventOverlap && iter > preventOverlapIters || !preventOverlap)) {
      forces = this.getOptRepGraForces(graph2, forces, bodies, options);
    } else {
      forces = this.getRepGraForces(graph2, iter, preventOverlapIters, forces, krPrime, sizes, options);
    }
    return this.updatePos(graph2, forces, preForces, sg, options);
  }
  /**
   * Calculate the attract forces for nodes.
   * @param graph graph for calculation
   * @param iter current iteration index
   * @param preventOverlapIters the iteration number for preventing overlappings
   * @param sizes nodes' sizes
   * @param forces forces for nodes, which will be modified
   * @param options formatted layout's input options
   * @returns
   */
  getAttrForces(graph2, iter, preventOverlapIters, sizes, forces, options) {
    const { preventOverlap, dissuadeHubs, mode, prune } = options;
    const edges = graph2.getAllEdges();
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const { source, target } = edges[i2];
      const sourceNode = graph2.getNode(source);
      const targetNode = graph2.getNode(target);
      const sourceDegree = graph2.getDegree(source);
      const targetDegree = graph2.getDegree(target);
      if (prune && (sourceDegree <= 1 || targetDegree <= 1))
        continue;
      const dir = [
        targetNode.data.x - sourceNode.data.x,
        targetNode.data.y - sourceNode.data.y
      ];
      let eucliDis = Math.hypot(dir[0], dir[1]);
      eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      if (preventOverlap && iter < preventOverlapIters) {
        eucliDis = eucliDis - sizes[source] - sizes[target];
      }
      let fa1 = eucliDis;
      let fa2 = fa1;
      if (mode === "linlog") {
        fa1 = Math.log(1 + eucliDis);
        fa2 = fa1;
      }
      if (dissuadeHubs) {
        fa1 = eucliDis / sourceDegree;
        fa2 = eucliDis / targetDegree;
      }
      if (preventOverlap && iter < preventOverlapIters && eucliDis <= 0) {
        fa1 = 0;
        fa2 = 0;
      } else if (preventOverlap && iter < preventOverlapIters && eucliDis > 0) {
        fa1 = eucliDis;
        fa2 = eucliDis;
      }
      forces[source][0] += fa1 * dir[0];
      forces[target][0] -= fa2 * dir[0];
      forces[source][1] += fa1 * dir[1];
      forces[target][1] -= fa2 * dir[1];
    }
    return forces;
  }
  /**
   * Calculate the repulsive forces for nodes under barnesHut mode.
   * @param graph graph for calculatiion
   * @param forces forces for nodes, which will be modified
   * @param bodies force body map
   * @param options formatted layout's input options
   * @returns
   */
  getOptRepGraForces(graph2, forces, bodies, options) {
    const { kg, center, prune } = options;
    const nodes = graph2.getAllNodes();
    const nodeNum = nodes.length;
    let minx = 9e10;
    let maxx = -9e10;
    let miny = 9e10;
    let maxy = -9e10;
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id: id2, data: data2 } = nodes[i2];
      if (prune && graph2.getDegree(id2) <= 1)
        continue;
      bodies[id2].setPos(data2.x, data2.y);
      if (data2.x >= maxx)
        maxx = data2.x;
      if (data2.x <= minx)
        minx = data2.x;
      if (data2.y >= maxy)
        maxy = data2.y;
      if (data2.y <= miny)
        miny = data2.y;
    }
    const width2 = Math.max(maxx - minx, maxy - miny);
    const quadParams = {
      xmid: (maxx + minx) / 2,
      ymid: (maxy + miny) / 2,
      length: width2,
      massCenter: center,
      mass: nodeNum
    };
    const quad = new Quad2(quadParams);
    const quadTree = new QuadTree(quad);
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id: id2 } = nodes[i2];
      if (prune && graph2.getDegree(id2) <= 1)
        continue;
      if (bodies[id2].in(quad))
        quadTree.insert(bodies[id2]);
    }
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id: id2, data: data2 } = nodes[i2];
      const degree3 = graph2.getDegree(id2);
      if (prune && degree3 <= 1)
        continue;
      bodies[id2].resetForce();
      quadTree.updateForce(bodies[id2]);
      forces[id2][0] -= bodies[id2].fx;
      forces[id2][1] -= bodies[id2].fy;
      const dir = [data2.x - center[0], data2.y - center[1]];
      let eucliDis = Math.hypot(dir[0], dir[1]);
      eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      const fg = kg * (degree3 + 1);
      forces[id2][0] -= fg * dir[0];
      forces[id2][1] -= fg * dir[1];
    }
    return forces;
  }
  /**
   * Calculate the repulsive forces for nodes.
   * @param graph graph for calculatiion
   * @param iter current iteration index
   * @param preventOverlapIters the iteration number for preventing overlappings
   * @param forces forces for nodes, which will be modified
   * @param krPrime larger the krPrime, larger the repulsive force
   * @param sizes nodes' sizes
   * @param options formatted layout's input options
   * @returns
   */
  getRepGraForces(graph2, iter, preventOverlapIters, forces, krPrime, sizes, options) {
    const { preventOverlap, kr, kg, center, prune } = options;
    const nodes = graph2.getAllNodes();
    const nodeNum = nodes.length;
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const nodei = nodes[i2];
      const degreei = graph2.getDegree(nodei.id);
      for (let j = i2 + 1; j < nodeNum; j += 1) {
        const nodej = nodes[j];
        const degreej = graph2.getDegree(nodej.id);
        if (prune && (degreei <= 1 || degreej <= 1))
          continue;
        const dir2 = [nodej.data.x - nodei.data.x, nodej.data.y - nodei.data.y];
        let eucliDis2 = Math.hypot(dir2[0], dir2[1]);
        eucliDis2 = eucliDis2 < 1e-4 ? 1e-4 : eucliDis2;
        dir2[0] = dir2[0] / eucliDis2;
        dir2[1] = dir2[1] / eucliDis2;
        if (preventOverlap && iter < preventOverlapIters) {
          eucliDis2 = eucliDis2 - sizes[nodei.id] - sizes[nodej.id];
        }
        let fr = kr * (degreei + 1) * (degreej + 1) / eucliDis2;
        if (preventOverlap && iter < preventOverlapIters && eucliDis2 < 0) {
          fr = krPrime * (degreei + 1) * (degreej + 1);
        } else if (preventOverlap && iter < preventOverlapIters && eucliDis2 === 0) {
          fr = 0;
        } else if (preventOverlap && iter < preventOverlapIters && eucliDis2 > 0) {
          fr = kr * (degreei + 1) * (degreej + 1) / eucliDis2;
        }
        forces[nodei.id][0] -= fr * dir2[0];
        forces[nodej.id][0] += fr * dir2[0];
        forces[nodei.id][1] -= fr * dir2[1];
        forces[nodej.id][1] += fr * dir2[1];
      }
      const dir = [nodei.data.x - center[0], nodei.data.y - center[1]];
      const eucliDis = Math.hypot(dir[0], dir[1]);
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      const fg = kg * (degreei + 1);
      forces[nodei.id][0] -= fg * dir[0];
      forces[nodei.id][1] -= fg * dir[1];
    }
    return forces;
  }
  /**
   * Update node positions.
   * @param graph graph for calculatiion
   * @param forces forces for nodes, which will be modified
   * @param preForces previous forces for nodes, which will be modified
   * @param sg constant for move distance of one step
   * @param options formatted layout's input options
   * @returns
   */
  updatePos(graph2, forces, preForces, sg, options) {
    const { ks, tao, prune, ksmax } = options;
    const nodes = graph2.getAllNodes();
    const nodeNum = nodes.length;
    const swgns = [];
    const trans = [];
    let swgG = 0;
    let traG = 0;
    let usingSg = sg;
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id: id2 } = nodes[i2];
      const degree3 = graph2.getDegree(id2);
      if (prune && degree3 <= 1)
        continue;
      const minus = [
        forces[id2][0] - preForces[id2][0],
        forces[id2][1] - preForces[id2][1]
      ];
      const minusNorm = Math.hypot(minus[0], minus[1]);
      const add2 = [
        forces[id2][0] + preForces[id2][0],
        forces[id2][1] + preForces[id2][1]
      ];
      const addNorm = Math.hypot(add2[0], add2[1]);
      swgns[i2] = minusNorm;
      trans[i2] = addNorm / 2;
      swgG += (degree3 + 1) * swgns[i2];
      traG += (degree3 + 1) * trans[i2];
    }
    const preSG = usingSg;
    usingSg = tao * traG / swgG;
    if (preSG !== 0) {
      usingSg = usingSg > 1.5 * preSG ? 1.5 * preSG : usingSg;
    }
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id: id2, data: data2 } = nodes[i2];
      const degree3 = graph2.getDegree(id2);
      if (prune && degree3 <= 1)
        continue;
      if (isNumber(data2.fx) && isNumber(data2.fy))
        continue;
      let sn = ks * usingSg / (1 + usingSg * Math.sqrt(swgns[i2]));
      let absForce = Math.hypot(forces[id2][0], forces[id2][1]);
      absForce = absForce < 1e-4 ? 1e-4 : absForce;
      const max2 = ksmax / absForce;
      sn = sn > max2 ? max2 : sn;
      const dnx = sn * forces[id2][0];
      const dny = sn * forces[id2][1];
      graph2.mergeNodeData(id2, {
        x: data2.x + dnx,
        y: data2.y + dny
      });
    }
    return usingSg;
  }
}
const DEFAULTS_LAYOUT_OPTIONS$4 = {
  maxIteration: 1e3,
  gravity: 10,
  speed: 5,
  clustering: false,
  clusterGravity: 10,
  width: 300,
  height: 300,
  nodeClusterBy: "cluster"
};
const SPEED_DIVISOR$1 = 800;
class FruchtermanLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "fruchterman";
    this.timeInterval = 0;
    this.running = false;
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$4), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericFruchtermanLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericFruchtermanLayout(true, graph2, options);
    });
  }
  /**
   * Stop simulation immediately.
   */
  stop() {
    if (this.timeInterval && typeof window !== "undefined") {
      window.clearInterval(this.timeInterval);
    }
    this.running = false;
  }
  /**
   * Manually steps the simulation by the specified number of iterations.
   * @see https://github.com/d3/d3-force#simulation_tick
   */
  tick(iterations = this.options.maxIteration || 1) {
    if (this.lastResult) {
      return this.lastResult;
    }
    for (let i2 = 0; i2 < iterations; i2++) {
      this.runOneStep(this.lastGraph, this.lastClusterMap, this.lastOptions);
    }
    const result = {
      nodes: this.lastLayoutNodes,
      edges: this.lastLayoutEdges
    };
    if (this.lastAssign) {
      result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
        x: node.data.x,
        y: node.data.y,
        z: this.options.dimensions === 3 ? node.data.z : void 0
      }));
    }
    return result;
  }
  genericFruchtermanLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      if (this.running)
        return;
      const formattedOptions = this.formatOptions(options);
      const { dimensions, width: width2, height, center, clustering, nodeClusterBy, maxIteration, onTick } = formattedOptions;
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
        const result = { nodes: [], edges };
        this.lastResult = result;
        return result;
      }
      if (nodes.length === 1) {
        if (assign) {
          graph2.mergeNodeData(nodes[0].id, {
            x: center[0],
            y: center[1],
            z: dimensions === 3 ? center[2] : void 0
          });
        }
        const result = {
          nodes: [
            Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1], z: dimensions === 3 ? center[2] : void 0 }) })
          ],
          edges
        };
        this.lastResult = result;
        return result;
      }
      const layoutNodes = nodes.map((node) => cloneFormatData(node, [width2, height]));
      const calcGraph = new Graph$9({
        nodes: layoutNodes,
        edges
      });
      const clusterMap = {};
      if (clustering) {
        layoutNodes.forEach((node) => {
          const clusterValue = node.data[nodeClusterBy];
          if (!clusterMap[clusterValue]) {
            clusterMap[clusterValue] = {
              name: clusterValue,
              cx: 0,
              cy: 0,
              count: 0
            };
          }
        });
      }
      this.lastLayoutNodes = layoutNodes;
      this.lastLayoutEdges = edges;
      this.lastAssign = assign;
      this.lastGraph = calcGraph;
      this.lastOptions = formattedOptions;
      this.lastClusterMap = clusterMap;
      if (typeof window === "undefined")
        return;
      let iter = 0;
      return new Promise((resolve) => {
        this.timeInterval = window.setInterval(() => {
          if (!this.running) {
            resolve({ nodes: layoutNodes, edges });
            return;
          }
          this.runOneStep(calcGraph, clusterMap, formattedOptions);
          if (assign) {
            layoutNodes.forEach(({ id: id2, data: data2 }) => graph2.mergeNodeData(id2, {
              x: data2.x,
              y: data2.y,
              z: dimensions === 3 ? data2.z : void 0
            }));
          }
          onTick === null || onTick === void 0 ? void 0 : onTick({
            nodes: layoutNodes,
            edges
          });
          iter++;
          if (iter >= maxIteration) {
            window.clearInterval(this.timeInterval);
            resolve({ nodes: layoutNodes, edges });
          }
        }, 0);
        this.running = true;
      });
    });
  }
  formatOptions(options = {}) {
    const mergedOptions = Object.assign(Object.assign({}, this.options), options);
    const { clustering, nodeClusterBy } = mergedOptions;
    const { center: propsCenter, width: propsWidth, height: propsHeight } = mergedOptions;
    mergedOptions.width = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
    mergedOptions.height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
    mergedOptions.center = !propsCenter ? [mergedOptions.width / 2, mergedOptions.height / 2] : propsCenter;
    mergedOptions.clustering = clustering && !!nodeClusterBy;
    return mergedOptions;
  }
  runOneStep(calcGraph, clusterMap, options) {
    const { dimensions, height, width: width2, gravity, center, speed, clustering, nodeClusterBy, clusterGravity: propsClusterGravity } = options;
    const area = height * width2;
    const maxDisplace = Math.sqrt(area) / 10;
    const nodes = calcGraph.getAllNodes();
    const k2 = area / (nodes.length + 1);
    const k = Math.sqrt(k2);
    const displacements = {};
    this.applyCalculate(calcGraph, displacements, k, k2);
    if (clustering) {
      for (const key in clusterMap) {
        clusterMap[key].cx = 0;
        clusterMap[key].cy = 0;
        clusterMap[key].count = 0;
      }
      nodes.forEach((node) => {
        const { data: data2 } = node;
        const c2 = clusterMap[data2[nodeClusterBy]];
        if (isNumber(data2.x)) {
          c2.cx += data2.x;
        }
        if (isNumber(data2.y)) {
          c2.cy += data2.y;
        }
        c2.count++;
      });
      for (const key in clusterMap) {
        clusterMap[key].cx /= clusterMap[key].count;
        clusterMap[key].cy /= clusterMap[key].count;
      }
      const clusterGravity = propsClusterGravity || gravity;
      nodes.forEach((node, j) => {
        const { id: id2, data: data2 } = node;
        if (!isNumber(data2.x) || !isNumber(data2.y))
          return;
        const c2 = clusterMap[data2[nodeClusterBy]];
        const distLength = Math.sqrt((data2.x - c2.cx) * (data2.x - c2.cx) + (data2.y - c2.cy) * (data2.y - c2.cy));
        const gravityForce = k * clusterGravity;
        displacements[id2].x -= gravityForce * (data2.x - c2.cx) / distLength;
        displacements[id2].y -= gravityForce * (data2.y - c2.cy) / distLength;
      });
    }
    nodes.forEach((node, j) => {
      const { id: id2, data: data2 } = node;
      if (!isNumber(data2.x) || !isNumber(data2.y))
        return;
      const gravityForce = 0.01 * k * gravity;
      displacements[id2].x -= gravityForce * (data2.x - center[0]);
      displacements[id2].y -= gravityForce * (data2.y - center[1]);
      if (dimensions === 3) {
        displacements[id2].z -= gravityForce * (data2.z - center[2]);
      }
    });
    nodes.forEach((node, j) => {
      const { id: id2, data: data2 } = node;
      if (isNumber(data2.fx) && isNumber(data2.fy)) {
        data2.x = data2.fx;
        data2.y = data2.fy;
        if (dimensions === 3) {
          data2.z = data2.fz;
        }
        return;
      }
      if (!isNumber(data2.x) || !isNumber(data2.y))
        return;
      const distLength = Math.sqrt(displacements[id2].x * displacements[id2].x + displacements[id2].y * displacements[id2].y + (dimensions === 3 ? displacements[id2].z * displacements[id2].z : 0));
      if (distLength > 0) {
        const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR$1), distLength);
        calcGraph.mergeNodeData(id2, {
          x: data2.x + displacements[id2].x / distLength * limitedDist,
          y: data2.y + displacements[id2].y / distLength * limitedDist,
          z: dimensions === 3 ? data2.z + displacements[id2].z / distLength * limitedDist : void 0
        });
      }
    });
  }
  applyCalculate(calcGraph, displacements, k, k2) {
    this.calRepulsive(calcGraph, displacements, k2);
    this.calAttractive(calcGraph, displacements, k);
  }
  calRepulsive(calcGraph, displacements, k2) {
    const nodes = calcGraph.getAllNodes();
    nodes.forEach(({ data: v2, id: vid }, i2) => {
      displacements[vid] = { x: 0, y: 0, z: 0 };
      nodes.forEach(({ data: u2, id: uid }, j) => {
        if (i2 <= j || !isNumber(v2.x) || !isNumber(u2.x) || !isNumber(v2.y) || !isNumber(u2.y)) {
          return;
        }
        let vecX = v2.x - u2.x;
        let vecY = v2.y - u2.y;
        let vecZ = this.options.dimensions === 3 ? v2.z - u2.z : 0;
        let lengthSqr = vecX * vecX + vecY * vecY + vecZ * vecZ;
        if (lengthSqr === 0) {
          lengthSqr = 1;
          vecX = 0.01;
          vecY = 0.01;
          vecZ = 0.01;
        }
        const common = k2 / lengthSqr;
        const dispX = vecX * common;
        const dispY = vecY * common;
        const dispZ = vecZ * common;
        displacements[vid].x += dispX;
        displacements[vid].y += dispY;
        displacements[uid].x -= dispX;
        displacements[uid].y -= dispY;
        if (this.options.dimensions === 3) {
          displacements[vid].z += dispZ;
          displacements[uid].z -= dispZ;
        }
      });
    });
  }
  calAttractive(calcGraph, displacements, k) {
    const edges = calcGraph.getAllEdges();
    edges.forEach((e3) => {
      const { source, target } = e3;
      if (!source || !target || source === target) {
        return;
      }
      const { data: u2 } = calcGraph.getNode(source);
      const { data: v2 } = calcGraph.getNode(target);
      if (!isNumber(v2.x) || !isNumber(u2.x) || !isNumber(v2.y) || !isNumber(u2.y)) {
        return;
      }
      const vecX = v2.x - u2.x;
      const vecY = v2.y - u2.y;
      const vecZ = this.options.dimensions === 3 ? v2.z - u2.z : 0;
      const common = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ) / k;
      const dispX = vecX * common;
      const dispY = vecY * common;
      const dispZ = vecZ * common;
      displacements[source].x += dispX;
      displacements[source].y += dispY;
      displacements[target].x -= dispX;
      displacements[target].y -= dispY;
      if (this.options.dimensions === 3) {
        displacements[source].z += dispZ;
        displacements[target].z -= dispZ;
      }
    });
  }
}
const DEFAULTS_LAYOUT_OPTIONS$3 = {
  begin: [0, 0],
  preventOverlap: true,
  preventOverlapPadding: 10,
  condense: false,
  rows: void 0,
  cols: void 0,
  position: void 0,
  sortBy: "degree",
  nodeSize: 30,
  width: 300,
  height: 300
};
class GridLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "grid";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$3), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericGridLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericGridLayout(true, graph2, options);
    });
  }
  genericGridLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { begin = [0, 0], condense, preventOverlapPadding, preventOverlap, rows: propsRows, cols: propsCols, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize, width: propsWidth, height: propsHeight, position: position2 } = mergedOptions;
      let { sortBy } = mergedOptions;
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      const n2 = nodes === null || nodes === void 0 ? void 0 : nodes.length;
      if (!n2 || n2 === 1) {
        return handleSingleNodeGraph(graph2, assign, begin);
      }
      const layoutNodes = nodes.map((node) => cloneFormatData(node));
      if (
        // `id` should be reserved keyword
        sortBy !== "id" && (!isString$1(sortBy) || layoutNodes[0].data[sortBy] === void 0)
      ) {
        sortBy = "degree";
      }
      if (sortBy === "degree") {
        layoutNodes.sort((n1, n22) => graph2.getDegree(n22.id, "both") - graph2.getDegree(n1.id, "both"));
      } else if (sortBy === "id") {
        layoutNodes.sort((n1, n22) => {
          if (isNumber(n22.id) && isNumber(n1.id)) {
            return n22.id - n1.id;
          }
          return `${n1.id}`.localeCompare(`${n22.id}`);
        });
      } else {
        layoutNodes.sort((n1, n22) => n22.data[sortBy] - n1.data[sortBy]);
      }
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const cells = n2;
      const rcs = { rows: propsRows, cols: propsCols };
      if (propsRows != null && propsCols != null) {
        rcs.rows = propsRows;
        rcs.cols = propsCols;
      } else if (propsRows != null && propsCols == null) {
        rcs.rows = propsRows;
        rcs.cols = Math.ceil(cells / rcs.rows);
      } else if (propsRows == null && propsCols != null) {
        rcs.cols = propsCols;
        rcs.rows = Math.ceil(cells / rcs.cols);
      } else {
        const splits = Math.sqrt(cells * height / width2);
        rcs.rows = Math.round(splits);
        rcs.cols = Math.round(width2 / height * splits);
      }
      rcs.rows = Math.max(rcs.rows, 1);
      rcs.cols = Math.max(rcs.cols, 1);
      if (rcs.cols * rcs.rows > cells) {
        const sm = small(rcs);
        const lg = large(rcs);
        if ((sm - 1) * lg >= cells) {
          small(rcs, sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(rcs, lg - 1);
        }
      } else {
        while (rcs.cols * rcs.rows < cells) {
          const sm = small(rcs);
          const lg = large(rcs);
          if ((lg + 1) * sm >= cells) {
            large(rcs, lg + 1);
          } else {
            small(rcs, sm + 1);
          }
        }
      }
      let cellWidth = condense ? 0 : width2 / rcs.cols;
      let cellHeight = condense ? 0 : height / rcs.rows;
      if (preventOverlap || paramNodeSpacing) {
        const nodeSpacing = formatNumberFn(10, paramNodeSpacing);
        const nodeSize = formatSizeFn(30, paramNodeSize, false);
        layoutNodes.forEach((node) => {
          if (!node.data.x || !node.data.y) {
            node.data.x = 0;
            node.data.y = 0;
          }
          const oNode = graph2.getNode(node.id);
          const [nodeW, nodeH] = parseSize(nodeSize(oNode) || 30);
          const p2 = nodeSpacing !== void 0 ? nodeSpacing(node) : preventOverlapPadding;
          const w2 = nodeW + p2;
          const h2 = nodeH + p2;
          cellWidth = Math.max(cellWidth, w2);
          cellHeight = Math.max(cellHeight, h2);
        });
      }
      const cellUsed = {};
      const rc = { row: 0, col: 0 };
      const id2manPos = {};
      for (let i2 = 0; i2 < layoutNodes.length; i2++) {
        const node = layoutNodes[i2];
        let rcPos;
        if (position2) {
          rcPos = position2(graph2.getNode(node.id));
        }
        if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
          const pos = {
            row: rcPos.row,
            col: rcPos.col
          };
          if (pos.col === void 0) {
            pos.col = 0;
            while (used(cellUsed, pos)) {
              pos.col++;
            }
          } else if (pos.row === void 0) {
            pos.row = 0;
            while (used(cellUsed, pos)) {
              pos.row++;
            }
          }
          id2manPos[node.id] = pos;
          use(cellUsed, pos);
        }
        getPos(node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed);
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      if (assign) {
        layoutNodes.forEach((node) => {
          graph2.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
      }
      return result;
    });
  }
}
const small = (rcs, val) => {
  let res;
  const rows = rcs.rows || 5;
  const cols = rcs.cols || 5;
  if (val == null) {
    res = Math.min(rows, cols);
  } else {
    const min2 = Math.min(rows, cols);
    if (min2 === rcs.rows) {
      rcs.rows = val;
    } else {
      rcs.cols = val;
    }
  }
  return res;
};
const large = (rcs, val) => {
  let result;
  const usedRows = rcs.rows || 5;
  const usedCols = rcs.cols || 5;
  if (val == null) {
    result = Math.max(usedRows, usedCols);
  } else {
    const max2 = Math.max(usedRows, usedCols);
    if (max2 === rcs.rows) {
      rcs.rows = val;
    } else {
      rcs.cols = val;
    }
  }
  return result;
};
const used = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] || false;
const use = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] = true;
const moveToNextCell = (rcs, rc) => {
  const cols = rcs.cols || 5;
  rc.col++;
  if (rc.col >= cols) {
    rc.col = 0;
    rc.row++;
  }
};
const getPos = (node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed) => {
  let x2;
  let y2;
  const rcPos = id2manPos[node.id];
  if (rcPos) {
    x2 = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
    y2 = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
  } else {
    while (used(cellUsed, rc)) {
      moveToNextCell(rcs, rc);
    }
    x2 = rc.col * cellWidth + cellWidth / 2 + begin[0];
    y2 = rc.row * cellHeight + cellHeight / 2 + begin[1];
    use(cellUsed, rc);
    moveToNextCell(rcs, rc);
  }
  node.data.x = x2;
  node.data.y = y2;
};
const mds = (dimension, distances, linkDistance) => {
  try {
    const M2 = Matrix.mul(Matrix.pow(distances, 2), -0.5);
    const rowMeans = M2.mean("row");
    const colMeans = M2.mean("column");
    const totalMean = M2.mean();
    M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
    const ret = new SingularValueDecomposition2(M2);
    const eigenValues = Matrix.sqrt(ret.diagonalMatrix).diagonal();
    return ret.leftSingularVectors.toJSON().map((row2) => {
      return Matrix.mul([row2], [eigenValues]).toJSON()[0].splice(0, dimension);
    });
  } catch (_a3) {
    const res = [];
    for (let i2 = 0; i2 < distances.length; i2++) {
      const x2 = Math.random() * linkDistance;
      const y2 = Math.random() * linkDistance;
      res.push([x2, y2]);
    }
    return res;
  }
};
const SPEED_DIVISOR = 800;
const DEFAULTS_LAYOUT_OPTIONS$2 = {
  iterations: 10,
  height: 10,
  width: 10,
  speed: 100,
  gravity: 10,
  k: 5
};
const radialNonoverlapForce = (graph2, options) => {
  const mergedOptions = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$2), options);
  const { positions, iterations, width: width2, k, speed = 100, strictRadial, focusIdx, radii = [], nodeSizeFunc } = mergedOptions;
  const nodes = graph2.getAllNodes();
  const disp = [];
  const maxDisplace = width2 / 10;
  for (let i2 = 0; i2 < iterations; i2++) {
    positions.forEach((_2, k2) => {
      disp[k2] = { x: 0, y: 0 };
    });
    getRepulsion(nodes, positions, disp, k, radii, nodeSizeFunc);
    updatePositions(positions, disp, speed, strictRadial, focusIdx, maxDisplace, width2, radii);
  }
  return positions;
};
const getRepulsion = (nodes, positions, disp, k, radii, nodeSizeFunc) => {
  positions.forEach((v2, i2) => {
    disp[i2] = { x: 0, y: 0 };
    positions.forEach((u2, j) => {
      if (i2 === j) {
        return;
      }
      if (radii[i2] !== radii[j]) {
        return;
      }
      let vecx = v2.x - u2.x;
      let vecy = v2.y - u2.y;
      let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
      if (vecLength === 0) {
        vecLength = 1;
        const sign = i2 > j ? 1 : -1;
        vecx = 0.01 * sign;
        vecy = 0.01 * sign;
      }
      if (vecLength < nodeSizeFunc(nodes[i2]) / 2 + nodeSizeFunc(nodes[j]) / 2) {
        const common = k * k / vecLength;
        disp[i2].x += vecx / vecLength * common;
        disp[i2].y += vecy / vecLength * common;
      }
    });
  });
};
const updatePositions = (positions, disp, speed, strictRadial, focusIdx, maxDisplace, width2, radii) => {
  const maxDisp = maxDisplace || width2 / 10;
  if (strictRadial) {
    disp.forEach((di, i2) => {
      const vx = positions[i2].x - positions[focusIdx].x;
      const vy = positions[i2].y - positions[focusIdx].y;
      const vLength = Math.sqrt(vx * vx + vy * vy);
      let vpx = vy / vLength;
      let vpy = -vx / vLength;
      const diLength = Math.sqrt(di.x * di.x + di.y * di.y);
      let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);
      if (alpha > Math.PI / 2) {
        alpha -= Math.PI / 2;
        vpx *= -1;
        vpy *= -1;
      }
      const tdispLength = Math.cos(alpha) * diLength;
      di.x = vpx * tdispLength;
      di.y = vpy * tdispLength;
    });
  }
  positions.forEach((n2, i2) => {
    if (i2 === focusIdx) {
      return;
    }
    const distLength = Math.sqrt(disp[i2].x * disp[i2].x + disp[i2].y * disp[i2].y);
    if (distLength > 0 && i2 !== focusIdx) {
      const limitedDist = Math.min(maxDisp * (speed / SPEED_DIVISOR), distLength);
      n2.x += disp[i2].x / distLength * limitedDist;
      n2.y += disp[i2].y / distLength * limitedDist;
      if (strictRadial) {
        let vx = n2.x - positions[focusIdx].x;
        let vy = n2.y - positions[focusIdx].y;
        const nfDis = Math.sqrt(vx * vx + vy * vy);
        vx = vx / nfDis * radii[i2];
        vy = vy / nfDis * radii[i2];
        n2.x = positions[focusIdx].x + vx;
        n2.y = positions[focusIdx].y + vy;
      }
    }
  });
  return positions;
};
const DEFAULTS_LAYOUT_OPTIONS$1 = {
  maxIteration: 1e3,
  focusNode: null,
  unitRadius: null,
  linkDistance: 50,
  preventOverlap: false,
  strictRadial: true,
  maxPreventOverlapIteration: 200,
  sortStrength: 10
};
class RadialLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "radial";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS$1), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericRadialLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericRadialLayout(true, graph2, options);
    });
  }
  genericRadialLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { width: propsWidth, height: propsHeight, center: propsCenter, focusNode: propsFocusNode, unitRadius: propsUnitRadius, nodeSize, nodeSpacing, strictRadial, preventOverlap, maxPreventOverlapIteration, sortBy, linkDistance = 50, sortStrength = 10, maxIteration = 1e3 } = mergedOptions;
      const nodes = graph2.getAllNodes();
      const edges = graph2.getAllEdges();
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph2, assign, center);
      }
      let focusNode = nodes[0];
      if (isString$1(propsFocusNode)) {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          if (nodes[i2].id === propsFocusNode) {
            focusNode = nodes[i2];
            break;
          }
        }
      } else {
        focusNode = propsFocusNode || nodes[0];
      }
      const focusIndex = getIndexById(nodes, focusNode.id);
      const adjMatrix = getAdjMatrix({ nodes, edges });
      const distances = floydWarshall(adjMatrix);
      const maxDistance = maxToFocus(distances, focusIndex);
      handleInfinity(distances, focusIndex, maxDistance + 1);
      const focusNodeD = distances[focusIndex];
      let semiWidth = width2 - center[0] > center[0] ? center[0] : width2 - center[0];
      let semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
      if (semiWidth === 0) {
        semiWidth = width2 / 2;
      }
      if (semiHeight === 0) {
        semiHeight = height / 2;
      }
      const maxRadius = Math.min(semiWidth, semiHeight);
      const maxD = Math.max(...focusNodeD);
      const radii = [];
      const unitRadius = !propsUnitRadius ? maxRadius / maxD : propsUnitRadius;
      focusNodeD.forEach((value, i2) => {
        radii[i2] = value * unitRadius;
      });
      const idealDistances = eIdealDisMatrix(nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength);
      const weights = getWeightMatrix(idealDistances);
      const mdsResult = mds(linkDistance, idealDistances, linkDistance);
      let positions = mdsResult.map(([x2, y2]) => ({
        x: (isNaN(x2) ? Math.random() * linkDistance : x2) - mdsResult[focusIndex][0],
        y: (isNaN(y2) ? Math.random() * linkDistance : y2) - mdsResult[focusIndex][1]
      }));
      this.run(maxIteration, positions, weights, idealDistances, radii, focusIndex);
      let nodeSizeFunc;
      if (preventOverlap) {
        nodeSizeFunc = formatNodeSizeToNumber(nodeSize, nodeSpacing);
        const nonoverlapForceParams = {
          nodes,
          nodeSizeFunc,
          positions,
          radii,
          height,
          width: width2,
          strictRadial: Boolean(strictRadial),
          focusIdx: focusIndex,
          iterations: maxPreventOverlapIteration || 200,
          k: positions.length / 4.5
        };
        positions = radialNonoverlapForce(graph2, nonoverlapForceParams);
      }
      const layoutNodes = [];
      positions.forEach((p2, i2) => {
        const cnode = cloneFormatData(nodes[i2]);
        cnode.data.x = p2.x + center[0];
        cnode.data.y = p2.y + center[1];
        layoutNodes.push(cnode);
      });
      if (assign) {
        layoutNodes.forEach((node) => graph2.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
  run(maxIteration, positions, weights, idealDistances, radii, focusIndex) {
    for (let i2 = 0; i2 <= maxIteration; i2++) {
      const param = i2 / maxIteration;
      this.oneIteration(param, positions, radii, idealDistances, weights, focusIndex);
    }
  }
  oneIteration(param, positions, radii, distances, weights, focusIndex) {
    const vparam = 1 - param;
    positions.forEach((v2, i2) => {
      const originDis = getEuclideanDistance(v2, { x: 0, y: 0 });
      const reciODis = originDis === 0 ? 0 : 1 / originDis;
      if (i2 === focusIndex) {
        return;
      }
      let xMolecule = 0;
      let yMolecule = 0;
      let denominator = 0;
      positions.forEach((u2, j) => {
        if (i2 === j) {
          return;
        }
        const edis = getEuclideanDistance(v2, u2);
        const reciEdis = edis === 0 ? 0 : 1 / edis;
        const idealDis = distances[j][i2];
        denominator += weights[i2][j];
        xMolecule += weights[i2][j] * (u2.x + idealDis * (v2.x - u2.x) * reciEdis);
        yMolecule += weights[i2][j] * (u2.y + idealDis * (v2.y - u2.y) * reciEdis);
      });
      const reciR = radii[i2] === 0 ? 0 : 1 / radii[i2];
      denominator *= vparam;
      denominator += param * reciR * reciR;
      xMolecule *= vparam;
      xMolecule += param * reciR * v2.x * reciODis;
      v2.x = xMolecule / denominator;
      yMolecule *= vparam;
      yMolecule += param * reciR * v2.y * reciODis;
      v2.y = yMolecule / denominator;
    });
  }
}
const eIdealDisMatrix = (nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength) => {
  if (!nodes)
    return [];
  const result = [];
  if (distances) {
    const sortValueCache = {};
    distances.forEach((row2, i2) => {
      const newRow = [];
      row2.forEach((v2, j) => {
        var _a3, _b;
        if (i2 === j) {
          newRow.push(0);
        } else if (radii[i2] === radii[j]) {
          if (sortBy === "data") {
            newRow.push(v2 * (Math.abs(i2 - j) * sortStrength) / (radii[i2] / unitRadius));
          } else if (sortBy) {
            let iValue;
            let jValue;
            if (sortValueCache[nodes[i2].id]) {
              iValue = sortValueCache[nodes[i2].id];
            } else {
              const value = (sortBy === "id" ? nodes[i2].id : (_a3 = nodes[i2].data) === null || _a3 === void 0 ? void 0 : _a3[sortBy]) || 0;
              if (isString$1(value)) {
                iValue = value.charCodeAt(0);
              } else {
                iValue = value;
              }
              sortValueCache[nodes[i2].id] = iValue;
            }
            if (sortValueCache[nodes[j].id]) {
              jValue = sortValueCache[nodes[j].id];
            } else {
              const value = (sortBy === "id" ? nodes[j].id : (_b = nodes[j].data) === null || _b === void 0 ? void 0 : _b[sortBy]) || 0;
              if (isString$1(value)) {
                jValue = value.charCodeAt(0);
              } else {
                jValue = value;
              }
              sortValueCache[nodes[j].id] = jValue;
            }
            newRow.push(v2 * (Math.abs(iValue - jValue) * sortStrength) / (radii[i2] / unitRadius));
          } else {
            newRow.push(v2 * linkDistance / (radii[i2] / unitRadius));
          }
        } else {
          const link = (linkDistance + unitRadius) / 2;
          newRow.push(v2 * link);
        }
      });
      result.push(newRow);
    });
  }
  return result;
};
const getWeightMatrix = (idealDistances) => {
  const rows = idealDistances.length;
  const cols = idealDistances[0].length;
  const result = [];
  for (let i2 = 0; i2 < rows; i2++) {
    const row2 = [];
    for (let j = 0; j < cols; j++) {
      if (idealDistances[i2][j] !== 0) {
        row2.push(1 / (idealDistances[i2][j] * idealDistances[i2][j]));
      } else {
        row2.push(0);
      }
    }
    result.push(row2);
  }
  return result;
};
const getIndexById = (array, id2) => {
  let index2 = -1;
  array.forEach((a2, i2) => {
    if (a2.id === id2) {
      index2 = i2;
    }
  });
  return Math.max(index2, 0);
};
const handleInfinity = (matrix3, focusIndex, step2) => {
  const length2 = matrix3.length;
  for (let i2 = 0; i2 < length2; i2++) {
    if (matrix3[focusIndex][i2] === Infinity) {
      matrix3[focusIndex][i2] = step2;
      matrix3[i2][focusIndex] = step2;
      for (let j = 0; j < length2; j++) {
        if (matrix3[i2][j] !== Infinity && matrix3[focusIndex][j] === Infinity) {
          matrix3[focusIndex][j] = step2 + matrix3[i2][j];
          matrix3[j][focusIndex] = step2 + matrix3[i2][j];
        }
      }
    }
  }
  for (let i2 = 0; i2 < length2; i2++) {
    if (i2 === focusIndex) {
      continue;
    }
    for (let j = 0; j < length2; j++) {
      if (matrix3[i2][j] === Infinity) {
        let minus = Math.abs(matrix3[focusIndex][i2] - matrix3[focusIndex][j]);
        minus = minus === 0 ? 1 : minus;
        matrix3[i2][j] = minus;
      }
    }
  }
};
const maxToFocus = (matrix3, focusIndex) => {
  let max2 = 0;
  for (let i2 = 0; i2 < matrix3[focusIndex].length; i2++) {
    if (matrix3[focusIndex][i2] === Infinity) {
      continue;
    }
    max2 = matrix3[focusIndex][i2] > max2 ? matrix3[focusIndex][i2] : max2;
  }
  return max2;
};
const DEFAULTS_LAYOUT_OPTIONS = {
  center: [0, 0],
  width: 300,
  height: 300
};
class RandomLayout {
  constructor(options = {}) {
    this.options = options;
    this.id = "random";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return this.genericRandomLayout(false, graph2, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      yield this.genericRandomLayout(true, graph2, options);
    });
  }
  genericRandomLayout(assign, graph2, options) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center: propsCenter, width: propsWidth, height: propsHeight } = mergedOptions;
      const nodes = graph2.getAllNodes();
      const layoutScale = 0.9;
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
      const layoutNodes = [];
      if (nodes) {
        nodes.forEach((node) => {
          layoutNodes.push({
            id: node.id,
            data: {
              x: (Math.random() - 0.5) * layoutScale * width2 + center[0],
              y: (Math.random() - 0.5) * layoutScale * height + center[1]
            }
          });
        });
      }
      if (assign) {
        layoutNodes.forEach((node) => graph2.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges: graph2.getAllEdges()
      };
      return result;
    });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
const proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
const throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
const transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id: id2, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error2) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep.addEventListener("message", function handleMessage(ev) {
    const { data: data2 } = ev;
    if (!data2 || !data2.id) {
      return;
    }
    const resolver = pendingListeners.get(data2.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data2);
    } finally {
      pendingListeners.delete(data2.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
const proxyCounter = /* @__PURE__ */ new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r2 = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path.map((p2) => p2.toString())
        }).then(fromWireValue);
        return r2.then.bind(r2);
      }
      return createProxy(ep, pendingListeners, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path, prop].map((p2) => p2.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, pendingListeners, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path.map((p2) => p2.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path.map((p2) => p2.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
const transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id2 = generateUUID();
    pendingListeners.set(id2, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
class Supervisor extends EventEmitter {
  constructor(graph2, layout2, options) {
    super();
    this.graph = graph2;
    this.layout = layout2;
    this.options = options;
    this.spawnWorker();
  }
  spawnWorker() {
    this.proxy = wrap(
      // @ts-ignore
      new Worker(new URL(
        /* @vite-ignore */
        "/assets/worker-DtAqWDqC.js",
        import.meta.url
      ), { type: "module" })
    );
    if (this.running) {
      this.running = false;
      this.execute();
    }
  }
  execute() {
    var _a3;
    return __awaiter$r(this, void 0, void 0, function* () {
      if (this.running)
        return this;
      this.running = true;
      const _b = this.layout.options, { onTick } = _b, rest = __rest$m(_b, ["onTick"]);
      const noFunctionOptions = {};
      Object.keys(rest).forEach((name) => {
        if (!isFunction$1(rest[name]))
          noFunctionOptions[name] = rest[name];
      });
      const payload = {
        layout: {
          id: this.layout.id,
          options: noFunctionOptions,
          iterations: (_a3 = this.options) === null || _a3 === void 0 ? void 0 : _a3.iterations
        },
        nodes: this.graph.getAllNodes(),
        edges: this.graph.getAllEdges()
      };
      const arraybufferWithNodesEdges = new Float32Array([0]);
      const [positions] = yield this.proxy.calculateLayout(payload, [
        arraybufferWithNodesEdges
      ]);
      return positions;
    });
  }
  stop() {
    this.running = false;
    this.proxy.stopLayout();
    return this;
  }
  kill() {
    this.proxy[releaseProxy]();
  }
  isRunning() {
    return this.running;
  }
}
var __awaiter$e = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class FishboneLayout extends BaseLayout {
  constructor() {
    super(...arguments);
    this.id = "fishbone";
  }
  getRoot() {
    const roots = this.context.model.getRootsData();
    if (isEmpty(roots) || roots.length > 2)
      return;
    return roots[0];
  }
  formatSize(nodeSize) {
    const nodeSizeFunc = typeof nodeSize === "function" ? nodeSize : () => nodeSize;
    return (node) => parseSize$1(nodeSizeFunc(node));
  }
  doLayout(root2, options) {
    const { hGap, getRibSep, vGap, nodeSize, height } = options;
    const { model } = this.context;
    const getSize = this.formatSize(nodeSize);
    let ribX = getSize(root2)[0] + getRibSep(root2);
    const getHorizontalOffset = (node, result2 = 0) => {
      var _a3;
      result2 += hGap * ((node.children || []).length + 1);
      (_a3 = node.children) === null || _a3 === void 0 ? void 0 : _a3.forEach((childId) => {
        var _a4;
        const child = model.getNodeLikeDatum(childId);
        (_a4 = child.children) === null || _a4 === void 0 ? void 0 : _a4.forEach((grandChildId) => {
          const grandChild = model.getNodeLikeDatum(grandChildId);
          result2 = getHorizontalOffset(grandChild, result2);
        });
      });
      return result2;
    };
    const getAuxiliaryPoint = (node) => {
      if (node.depth === 1)
        return ribX;
      const parent = model.getParentData(node.id, "tree");
      if (isAtEvenDepth(node)) {
        const ancestor = model.getParentData(parent.id, "tree");
        const deltaY = calculateY(node) - calculateY(ancestor);
        return getAuxiliaryPoint(parent) + deltaY * hGap / vGap;
      } else {
        const nodeIndex = (parent.children || []).indexOf(node.id);
        const followingSiblingsIncludeSelf = model.getNodeData((parent.children || []).slice(nodeIndex));
        return calculateX(parent) - followingSiblingsIncludeSelf.reduce((acc, sibling) => acc + getHorizontalOffset(sibling), 0) - getSize(parent)[0] / 2;
      }
    };
    const calculateX = memoize$2((node) => {
      if (isRoot(node))
        return getSize(node)[0] / 2;
      const parent = model.getParentData(node.id, "tree");
      if (isAtEvenDepth(node)) {
        return getAuxiliaryPoint(node) + getHorizontalOffset(node) + getSize(node)[0] / 2;
      } else {
        const deltaY = calculateY(node) - calculateY(parent);
        const ratio = hGap / vGap;
        return getAuxiliaryPoint(node) + deltaY * ratio;
      }
    }, (node) => node.id);
    const getParentY = (nodeId) => calculateY(model.getParentData(nodeId, "tree"));
    const calculateY = memoize$2((node) => {
      if (isRoot(node))
        return height / 2;
      if (!isAtEvenDepth(node)) {
        if (isEmpty(node.children))
          return getParentY(node.id) + vGap;
        const lastChild = model.getNodeLikeDatum(node.children.slice(-1)[0]);
        if (isEmpty(lastChild.children))
          return calculateY(lastChild) + vGap;
        const lastDescendant = model.getDescendantsData(node.id).slice(-1)[0];
        return (isAtEvenDepth(lastDescendant) ? getParentY(lastDescendant.id) : calculateY(lastDescendant)) + vGap;
      } else {
        const parent = model.getParentData(node.id, "tree");
        const nodeIndex = parent.children.indexOf(node.id);
        if (nodeIndex === 0)
          return getParentY(parent.id) + vGap;
        const prevSibling = model.getNodeLikeDatum(parent.children[nodeIndex - 1]);
        if (isEmpty(prevSibling.children))
          return calculateY(prevSibling) + vGap;
        const descendants = model.getDescendantsData(prevSibling.id);
        return Math.max(...descendants.map((descendant) => isAtEvenDepth(descendant) ? getParentY(descendant.id) : calculateY(descendant))) + vGap;
      }
    }, (node) => node.id);
    let tmpRibX = 0;
    const result = { nodes: [], edges: [] };
    const layout2 = (node) => {
      var _a3;
      (_a3 = node.children) === null || _a3 === void 0 ? void 0 : _a3.forEach((childId) => layout2(model.getNodeLikeDatum(childId)));
      const y2 = calculateY(node);
      const x2 = calculateX(node);
      result.nodes.push({ id: node.id, x: x2, y: y2 });
      if (isRoot(node))
        return;
      const edge = model.getRelatedEdgesData(node.id, "in")[0];
      const controlPoint = [getAuxiliaryPoint(node), isAtEvenDepth(node) ? y2 : getParentY(node.id)];
      result.edges.push({ id: idOf(edge), controlPoints: [controlPoint], relatedNodeId: node.id });
      tmpRibX = Math.max(tmpRibX, x2 + getRibSep(node));
      if (node.depth === 1)
        ribX = tmpRibX;
    };
    layout2(root2);
    return result;
  }
  placeAlterative(result, root2) {
    const oddIndexedRibs = (root2.children || []).filter((_2, index2) => index2 % 2 !== 0);
    if (oddIndexedRibs.length === 0)
      return result;
    const { model } = this.context;
    const rootY = result.nodes.find((node) => node.id === root2.id).y;
    const shouldFlip = (nodeId) => {
      const ancestors = model.getAncestorsData(nodeId, "tree");
      if (isEmpty(ancestors))
        return false;
      const ribId = ancestors.length === 1 ? nodeId : ancestors[ancestors.length - 2].id;
      return oddIndexedRibs.includes(ribId);
    };
    result.nodes.forEach((node) => {
      if (shouldFlip(node.id))
        node.y = 2 * rootY - node.y;
    });
    result.edges.forEach((edge) => {
      if (shouldFlip(edge.relatedNodeId)) {
        edge.controlPoints = edge.controlPoints.map((point2) => [point2[0], 2 * rootY - point2[1]]);
      }
    });
  }
  rightToLeft(result, options) {
    result.nodes.forEach((node) => node.x = options.width - node.x);
    result.edges.forEach((edge) => {
      edge.controlPoints = edge.controlPoints.map((point2) => [options.width - point2[0], point2[1]]);
    });
    return result;
  }
  execute(data2, propOptions) {
    return __awaiter$e(this, void 0, void 0, function* () {
      const options = Object.assign(Object.assign(Object.assign({}, FishboneLayout.defaultOptions), this.options), propOptions);
      const { direction: direction2, nodeSize } = options;
      const root2 = this.getRoot();
      if (!root2)
        return data2;
      const getSize = this.formatSize(nodeSize);
      options.vGap || (options.vGap = Math.max(...(data2.nodes || []).map((node) => getSize(node)[1])));
      options.hGap || (options.hGap = Math.max(...(data2.nodes || []).map((node) => getSize(node)[0])));
      let result = this.doLayout(root2, options);
      this.placeAlterative(result, root2);
      if (direction2 === "RL") {
        result = this.rightToLeft(result, options);
      }
      const { model } = this.context;
      const nodes = [];
      const edges = [];
      result.nodes.forEach((node) => {
        const { id: id2, x: x2, y: y2 } = node;
        const nodeData = model.getNodeLikeDatum(id2);
        nodes.push(assignElementStyle(nodeData, { x: x2, y: y2 }));
      });
      result.edges.forEach((edge) => {
        const { id: id2, controlPoints } = edge;
        const edgeData = model.getEdgeDatum(id2);
        edges.push(assignElementStyle(edgeData, { controlPoints }));
      });
      return { nodes, edges };
    });
  }
}
FishboneLayout.defaultOptions = {
  direction: "RL",
  getRibSep: () => 60
};
const assignElementStyle = (element, style) => {
  return Object.assign(Object.assign({}, element), { style: Object.assign(Object.assign({}, element.style || {}), style) });
};
const isRoot = (node) => node.depth === 0;
const isAtEvenDepth = (node) => (node.depth || (node.depth = 0)) % 2 === 0;
var __awaiter$d = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SnakeLayout extends BaseLayout {
  constructor() {
    super(...arguments);
    this.id = "snake";
  }
  formatSize(nodes, size) {
    const sizeFn = typeof size === "function" ? size : () => size;
    return nodes.reduce((acc, node) => {
      const [w2, h2] = parseSize$1(sizeFn(node)) || [0, 0];
      return [Math.max(acc[0], w2), Math.max(acc[1], h2)];
    }, [0, 0]);
  }
  /**
   * Validates the graph data to ensure it meets the requirements for linear arrangement.
   * @param data - Graph data
   * @returns false if the graph is not connected, has more than one source or sink node, or contains cycles.
   */
  validate(data2) {
    const { nodes = [], edges = [] } = data2;
    const inDegree = {};
    const outDegree = {};
    const adjList = {};
    nodes.forEach((node) => {
      inDegree[node.id] = 0;
      outDegree[node.id] = 0;
      adjList[node.id] = [];
    });
    edges.forEach((edge) => {
      inDegree[edge.target]++;
      outDegree[edge.source]++;
      adjList[edge.source].push(edge.target);
    });
    const visited = /* @__PURE__ */ new Set();
    const dfs2 = (nodeId) => {
      if (visited.has(nodeId))
        return;
      visited.add(nodeId);
      adjList[nodeId].forEach(dfs2);
    };
    dfs2(nodes[0].id);
    if (visited.size !== nodes.length)
      return false;
    const sourceNodes = nodes.filter((node) => inDegree[node.id] === 0);
    const sinkNodes = nodes.filter((node) => outDegree[node.id] === 0);
    if (sourceNodes.length !== 1 || sinkNodes.length !== 1)
      return false;
    const middleNodes = nodes.filter((node) => inDegree[node.id] === 1 && outDegree[node.id] === 1);
    if (middleNodes.length !== nodes.length - 2)
      return false;
    return true;
  }
  execute(model, options) {
    return __awaiter$d(this, void 0, void 0, function* () {
      var _a3;
      if (!this.validate(model))
        return model;
      const { nodeSize: propNodeSize, padding: propPadding, sortBy, cols, colGap: propColSep, rowGap: propRowSep, clockwise, width: width2, height } = Object.assign({}, SnakeLayout.defaultOptions, this.options, options);
      const [top, right, bottom, left] = parsePadding(propPadding);
      const nodeSize = this.formatSize(model.nodes || [], propNodeSize);
      const rows = Math.ceil((model.nodes || []).length / cols);
      let colSep = propColSep ? propColSep : (width2 - left - right - cols * nodeSize[0]) / (cols - 1);
      let rowSep = propRowSep ? propRowSep : (height - top - bottom - rows * nodeSize[1]) / (rows - 1);
      if (rowSep === Infinity || rowSep < 0)
        rowSep = 0;
      if (colSep === Infinity || colSep < 0)
        colSep = 0;
      const sortedNodes = sortBy ? (_a3 = model.nodes) === null || _a3 === void 0 ? void 0 : _a3.sort(sortBy) : topologicalSort(model);
      const nodes = (sortedNodes || []).map((node, index2) => {
        const rowIndex = Math.floor(index2 / cols);
        const colIndex = index2 % cols;
        const actualColIndex = clockwise ? rowIndex % 2 === 0 ? colIndex : cols - 1 - colIndex : rowIndex % 2 === 0 ? cols - 1 - colIndex : colIndex;
        const x2 = left + actualColIndex * (nodeSize[0] + colSep) + nodeSize[0] / 2;
        const y2 = top + rowIndex * (nodeSize[1] + rowSep) + nodeSize[1] / 2;
        return {
          id: node.id,
          style: { x: x2, y: y2 }
        };
      });
      return { nodes };
    });
  }
}
SnakeLayout.defaultOptions = {
  padding: 0,
  cols: 5,
  clockwise: true
};
function topologicalSort(data2) {
  const { nodes = [], edges = [] } = data2;
  const inDegree = {};
  const adjList = {};
  nodes.forEach((node) => {
    inDegree[node.id] = 0;
    adjList[node.id] = [];
  });
  edges.forEach((edge) => {
    inDegree[edge.target]++;
    adjList[edge.source].push(edge.target);
  });
  const queue = [];
  const sortedNodes = [];
  nodes.forEach((node) => {
    if (inDegree[node.id] === 0) {
      queue.push(node.id);
    }
  });
  while (queue.length > 0) {
    const nodeId = queue.shift();
    const node = nodes.find((n2) => n2.id === nodeId);
    sortedNodes.push(node);
    adjList[nodeId].forEach((neighbor) => {
      inDegree[neighbor]--;
      if (inDegree[neighbor] === 0) {
        queue.push(neighbor);
      }
    });
  }
  return sortedNodes;
}
const spectral = [
  "rgb(158, 1, 66)",
  "rgb(213, 62, 79)",
  "rgb(244, 109, 67)",
  "rgb(253, 174, 97)",
  "rgb(254, 224, 139)",
  "rgb(255, 255, 191)",
  "rgb(230, 245, 152)",
  "rgb(171, 221, 164)",
  "rgb(102, 194, 165)",
  "rgb(50, 136, 189)",
  "rgb(94, 79, 162)"
];
const tableau = [
  "rgb(78, 121, 167)",
  "rgb(242, 142, 44)",
  "rgb(225, 87, 89)",
  "rgb(118, 183, 178)",
  "rgb(89, 161, 79)",
  "rgb(237, 201, 73)",
  "rgb(175, 122, 161)",
  "rgb(255, 157, 167)",
  "rgb(156, 117, 95)",
  "rgb(186, 176, 171)"
];
const oranges = [
  "rgb(255, 245, 235)",
  "rgb(254, 230, 206)",
  "rgb(253, 208, 162)",
  "rgb(253, 174, 107)",
  "rgb(253, 141, 60)",
  "rgb(241, 105, 19)",
  "rgb(217, 72, 1)",
  "rgb(166, 54, 3)",
  "rgb(127, 39, 4)"
];
const greens = [
  "rgb(247, 252, 245)",
  "rgb(229, 245, 224)",
  "rgb(199, 233, 192)",
  "rgb(161, 217, 155)",
  "rgb(116, 196, 118)",
  "rgb(65, 171, 93)",
  "rgb(35, 139, 69)",
  "rgb(0, 109, 44)",
  "rgb(0, 68, 27)"
];
const blues = [
  "rgb(247, 251, 255)",
  "rgb(222, 235, 247)",
  "rgb(198, 219, 239)",
  "rgb(158, 202, 225)",
  "rgb(107, 174, 214)",
  "rgb(66, 146, 198)",
  "rgb(33, 113, 181)",
  "rgb(8, 81, 156)",
  "rgb(8, 48, 107)"
];
class BasePlugin extends BaseExtension {
}
function createPluginContainer(type, cover = true, style) {
  const container = document.createElement("div");
  container.setAttribute("class", `g6-${type}`);
  Object.assign(container.style, {
    position: "absolute",
    display: "block"
  });
  if (cover) {
    Object.assign(container.style, {
      position: "unset",
      gridArea: "1 / 1 / 2 / 2",
      inset: "0px",
      height: "100%",
      width: "100%",
      overflow: "hidden",
      pointerEvents: "none"
    });
  }
  if (style)
    Object.assign(container.style, style);
  return container;
}
function insertDOM(id2, tag = "div", style = {}, innerHTML = "", container = document.body) {
  const dom = document.getElementById(id2);
  if (dom)
    dom.remove();
  const div = document.createElement(tag);
  div.innerHTML = innerHTML;
  div.id = id2;
  Object.assign(div.style, style);
  container.appendChild(div);
  return div;
}
var __awaiter$c = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Background extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Background.defaultOptions, options));
    this.$element = createPluginContainer("background");
    const $container = this.context.canvas.getContainer();
    $container.prepend(this.$element);
    this.update(options);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the background image configuration
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter$c(this, void 0, void 0, function* () {
      _super.update.call(this, options);
      Object.assign(this.$element.style, omit$1(this.options, ["key", "type"]));
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the background image
   * @internal
   */
  destroy() {
    super.destroy();
    this.$element.remove();
  }
}
Background.defaultOptions = {
  transition: "background 0.5s",
  backgroundSize: "cover",
  zIndex: "-1"
  // aviod to cover the other plugin's dom, eg: grid-line.
};
function linePtSegDistSq(lx1, ly1, lx2, ly2, x2, y2) {
  const x1 = lx1;
  const y1 = ly1;
  const x22 = lx2 - x1;
  const y22 = ly2 - y1;
  let px2 = x2 - x1;
  let py = y2 - y1;
  let dotprod = px2 * x22 + py * y22;
  let projlenSq = 0;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px2 = x22 - px2;
    py = y22 - py;
    dotprod = px2 * x22 + py * y22;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x22 * x22 + y22 * y22);
    }
  }
  const lenSq = px2 * px2 + py * py - projlenSq;
  if (lenSq < 0) {
    return 0;
  }
  return lenSq;
}
function ptsDistanceSq(x1, y1, x2, y2) {
  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}
function doublePointsEqual(x1, y1, x2, y2, delta) {
  return ptsDistanceSq(x1, y1, x2, y2) < delta * delta;
}
function round(digits) {
  if (!Number.isFinite(digits)) {
    return (v2) => v2;
  }
  if (digits === 0) {
    return Math.round;
  }
  const factor = Math.pow(10, digits);
  return (v2) => Math.round(v2 * factor) / factor;
}
function lineBoundingBox(line2) {
  const minX = Math.min(line2.x1, line2.x2);
  const maxX = Math.max(line2.x1, line2.x2);
  const minY = Math.min(line2.y1, line2.y2);
  const maxY = Math.max(line2.y1, line2.y2);
  return {
    x: minX,
    y: minY,
    x2: maxX,
    y2: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
class Line2 {
  constructor(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  equals(that) {
    return this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;
  }
  draw(ctx2) {
    ctx2.moveTo(this.x1, this.y1);
    ctx2.lineTo(this.x2, this.y2);
  }
  toString() {
    return `Line(from=(${this.x1},${this.y1}),to=(${this.x2},${this.y2}))`;
  }
  static from(l2) {
    return new Line2(l2.x1, l2.y1, l2.x2, l2.y2);
  }
  cuts(px2, py) {
    if (this.y1 === this.y2) {
      return false;
    }
    if (py < this.y1 && py <= this.y2 || py > this.y1 && py >= this.y2) {
      return false;
    }
    if (px2 > this.x1 && px2 >= this.x2) {
      return false;
    }
    if (px2 < this.x1 && px2 <= this.x2) {
      return true;
    }
    const cross2 = this.x1 + (py - this.y1) * (this.x2 - this.x1) / (this.y2 - this.y1);
    return px2 <= cross2;
  }
  distSquare(x2, y2) {
    return linePtSegDistSq(this.x1, this.y1, this.x2, this.y2, x2, y2);
  }
  ptClose(x2, y2, r2) {
    if (this.x1 < this.x2) {
      if (x2 < this.x1 - r2 || x2 > this.x2 + r2) {
        return false;
      }
    } else {
      if (x2 < this.x2 - r2 || x2 > this.x1 + r2) {
        return false;
      }
    }
    if (this.y1 < this.y2) {
      if (y2 < this.y1 - r2 || y2 > this.y2 + r2) {
        return false;
      }
    } else {
      if (y2 < this.y2 - r2 || y2 > this.y1 + r2) {
        return false;
      }
    }
    return true;
  }
}
var EState;
(function(EState2) {
  EState2[EState2["POINT"] = 1] = "POINT";
  EState2[EState2["PARALLEL"] = 2] = "PARALLEL";
  EState2[EState2["COINCIDENT"] = 3] = "COINCIDENT";
  EState2[EState2["NONE"] = 4] = "NONE";
})(EState || (EState = {}));
class Intersection {
  constructor(state, x2 = 0, y2 = 0) {
    this.state = state;
    this.x = x2;
    this.y = y2;
  }
}
function intersectLineLine(la, lb) {
  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);
  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);
  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);
  if (uB) {
    const ua = uaT / uB;
    const ub = ubT / uB;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return new Intersection(EState.POINT, la.x1 + ua * (la.x2 - la.x1), la.y1 + ua * (la.y2 - la.y1));
    }
    return new Intersection(EState.NONE);
  }
  return new Intersection(uaT === 0 || ubT === 0 ? EState.COINCIDENT : EState.PARALLEL);
}
function fractionAlongLineA(la, lb) {
  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);
  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);
  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);
  if (uB) {
    const ua = uaT / uB;
    const ub = ubT / uB;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return ua;
    }
  }
  return Number.POSITIVE_INFINITY;
}
function hasFractionToLineCenter(bounds, line2) {
  function testLine(xa, ya, xb, yb) {
    let testDistance = fractionAlongLineA(line2, new Line2(xa, ya, xb, yb));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      return 1;
    }
    return 0;
  }
  let countIntersections = testLine(bounds.x, bounds.y, bounds.x2, bounds.y);
  countIntersections += testLine(bounds.x, bounds.y, bounds.x, bounds.y2);
  if (countIntersections > 1) {
    return true;
  }
  countIntersections += testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);
  if (countIntersections > 1) {
    return true;
  }
  countIntersections += testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);
  return countIntersections > 0;
}
var OutCode;
(function(OutCode2) {
  OutCode2[OutCode2["LEFT"] = 0] = "LEFT";
  OutCode2[OutCode2["TOP"] = 1] = "TOP";
  OutCode2[OutCode2["RIGHT"] = 2] = "RIGHT";
  OutCode2[OutCode2["BOTTOM"] = 3] = "BOTTOM";
})(OutCode || (OutCode = {}));
function outcode(bounds, px2, py) {
  const out = /* @__PURE__ */ new Set();
  if (bounds.width <= 0) {
    out.add(OutCode.LEFT);
    out.add(OutCode.RIGHT);
  } else if (px2 < bounds.x) {
    out.add(OutCode.LEFT);
  } else if (px2 > bounds.x + bounds.width) {
    out.add(OutCode.RIGHT);
  }
  if (bounds.height <= 0) {
    out.add(OutCode.TOP);
    out.add(OutCode.BOTTOM);
  } else if (py < bounds.y) {
    out.add(OutCode.TOP);
  } else if (py > bounds.y + bounds.height) {
    out.add(OutCode.BOTTOM);
  }
  return out;
}
function intersectsLine(bounds, line2) {
  let x1 = line2.x1;
  let y1 = line2.y1;
  const x2 = line2.x2;
  const y2 = line2.y2;
  const out2 = Array.from(outcode(bounds, x2, y2));
  if (out2.length === 0) {
    return true;
  }
  let out1 = outcode(bounds, x1, y1);
  while (out1.size !== 0) {
    for (const a2 of out2) {
      if (out1.has(a2)) {
        return false;
      }
    }
    if (out1.has(OutCode.RIGHT) || out1.has(OutCode.LEFT)) {
      let x3 = bounds.x;
      if (out1.has(OutCode.RIGHT)) {
        x3 += bounds.width;
      }
      y1 = y1 + (x3 - x1) * (y2 - y1) / (x2 - x1);
      x1 = x3;
    } else {
      let y3 = bounds.y;
      if (out1.has(OutCode.BOTTOM)) {
        y3 += bounds.height;
      }
      x1 = x1 + (y3 - y1) * (x2 - x1) / (y2 - y1);
      y1 = y3;
    }
    out1 = outcode(bounds, x1, y1);
  }
  return true;
}
function fractionToLineCenter(bounds, line2) {
  let minDistance = Number.POSITIVE_INFINITY;
  let countIntersections = 0;
  function testLine(xa, ya, xb, yb) {
    let testDistance = fractionAlongLineA(line2, new Line2(xa, ya, xb, yb));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      countIntersections++;
      if (testDistance < minDistance) {
        minDistance = testDistance;
      }
    }
  }
  testLine(bounds.x, bounds.y, bounds.x2, bounds.y);
  testLine(bounds.x, bounds.y, bounds.x, bounds.y2);
  if (countIntersections > 1) {
    return minDistance;
  }
  testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);
  if (countIntersections > 1) {
    return minDistance;
  }
  testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);
  if (countIntersections === 0) {
    return -1;
  }
  return minDistance;
}
function testIntersection(line2, bounds) {
  let count = 0;
  const top = intersectLineLine(line2, new Line2(bounds.x, bounds.y, bounds.x2, bounds.y));
  count += top.state === EState.POINT ? 1 : 0;
  const left = intersectLineLine(line2, new Line2(bounds.x, bounds.y, bounds.x, bounds.y2));
  count += left.state === EState.POINT ? 1 : 0;
  const bottom = intersectLineLine(line2, new Line2(bounds.x, bounds.y2, bounds.x2, bounds.y2));
  count += bottom.state === EState.POINT ? 1 : 0;
  const right = intersectLineLine(line2, new Line2(bounds.x2, bounds.y, bounds.x2, bounds.y2));
  count += right.state === EState.POINT ? 1 : 0;
  return { top, left, bottom, right, count };
}
class Rectangle {
  constructor(x2, y2, width2, height) {
    this.x = x2;
    this.y = y2;
    this.width = width2;
    this.height = height;
  }
  get x2() {
    return this.x + this.width;
  }
  get y2() {
    return this.y + this.height;
  }
  get cx() {
    return this.x + this.width / 2;
  }
  get cy() {
    return this.y + this.height / 2;
  }
  get radius() {
    return Math.max(this.width, this.height) / 2;
  }
  static from(r2) {
    return new Rectangle(r2.x, r2.y, r2.width, r2.height);
  }
  equals(that) {
    return this.x === that.x && this.y === that.y && this.width === that.width && this.height === that.height;
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  add(that) {
    const x2 = Math.min(this.x, that.x);
    const y2 = Math.min(this.y, that.y);
    const x22 = Math.max(this.x2, that.x + that.width);
    const y22 = Math.max(this.y2, that.y + that.height);
    this.x = x2;
    this.y = y2;
    this.width = x22 - x2;
    this.height = y22 - y2;
  }
  addPoint(p2) {
    const x2 = Math.min(this.x, p2.x);
    const y2 = Math.min(this.y, p2.y);
    const x22 = Math.max(this.x2, p2.x);
    const y22 = Math.max(this.y2, p2.y);
    this.x = x2;
    this.y = y2;
    this.width = x22 - x2;
    this.height = y22 - y2;
  }
  toString() {
    return `Rectangle[x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height}]`;
  }
  draw(ctx2) {
    ctx2.rect(this.x, this.y, this.width, this.height);
  }
  containsPt(px2, py) {
    return px2 >= this.x && px2 <= this.x2 && py >= this.y && py <= this.y2;
  }
  get area() {
    return this.width * this.height;
  }
  intersects(that) {
    if (this.area <= 0 || that.width <= 0 || that.height <= 0) {
      return false;
    }
    return that.x + that.width > this.x && that.y + that.height > this.y && that.x < this.x2 && that.y < this.y2;
  }
  distSquare(tempX, tempY) {
    if (this.containsPt(tempX, tempY)) {
      return 0;
    }
    const code = outcode(this, tempX, tempY);
    if (code.has(OutCode.TOP)) {
      if (code.has(OutCode.LEFT)) {
        return ptsDistanceSq(tempX, tempY, this.x, this.y);
      }
      if (code.has(OutCode.RIGHT)) {
        return ptsDistanceSq(tempX, tempY, this.x2, this.y);
      }
      return (this.y - tempY) * (this.y - tempY);
    }
    if (code.has(OutCode.BOTTOM)) {
      if (code.has(OutCode.LEFT)) {
        return ptsDistanceSq(tempX, tempY, this.x, this.y2);
      }
      if (code.has(OutCode.RIGHT)) {
        return ptsDistanceSq(tempX, tempY, this.x2, this.y2);
      }
      return (tempY - this.y2) * (tempY - this.y2);
    }
    if (code.has(OutCode.LEFT)) {
      return (this.x - tempX) * (this.x - tempX);
    }
    if (code.has(OutCode.RIGHT)) {
      return (tempX - this.x2) * (tempX - this.x2);
    }
    return 0;
  }
}
function boundingBox(path) {
  if (path.length === 0) {
    return null;
  }
  const first = path[0];
  const bb = new Rectangle(first.x, first.y, 0, 0);
  for (const point2 of path) {
    bb.addPoint(point2);
  }
  return bb;
}
class Circle2 {
  constructor(cx, cy, radius) {
    this.cx = cx;
    this.cy = cy;
    this.radius = radius;
  }
  get x() {
    return this.cx - this.radius;
  }
  get x2() {
    return this.cx + this.radius;
  }
  get width() {
    return this.radius * 2;
  }
  get y() {
    return this.cy - this.radius;
  }
  get y2() {
    return this.cy + this.radius;
  }
  get height() {
    return this.radius * 2;
  }
  static from(r2) {
    return new Circle2(r2.cx, r2.cy, r2.radius);
  }
  containsPt(x2, y2) {
    return ptsDistanceSq(this.cx, this.cy, x2, y2) < this.radius * this.radius;
  }
  distSquare(tempX, tempY) {
    const dist2 = ptsDistanceSq(this.cx, this.cy, tempX, tempY);
    if (dist2 < this.radius * this.radius) {
      return 0;
    }
    const offset = Math.sqrt(dist2) - this.radius;
    return offset * offset;
  }
  draw(ctx2) {
    ctx2.ellipse(this.cx, this.cy, this.radius, this.radius, 0, 0, Math.PI * 2);
  }
}
class Area {
  constructor(pixelGroup, i2 = 0, j = 0, pixelX = 0, pixelY = 0, width2 = 10, height = 10, pixels = new Float32Array(Math.max(0, width2 * height)).fill(0)) {
    this.pixelGroup = pixelGroup;
    this.i = i2;
    this.j = j;
    this.pixelX = pixelX;
    this.pixelY = pixelY;
    this.width = width2;
    this.height = height;
    this.area = pixels;
  }
  createSub(rect2, pixelPos) {
    return new Area(this.pixelGroup, rect2.x, rect2.y, pixelPos.x, pixelPos.y, rect2.width, rect2.height);
  }
  static fromPixelRegion(pixelRect, pixelGroup) {
    return new Area(pixelGroup, 0, 0, pixelRect.x, pixelRect.y, Math.ceil(pixelRect.width / pixelGroup), Math.ceil(pixelRect.height / pixelGroup));
  }
  copy(sub2, pixelPoint) {
    return new Area(this.pixelGroup, this.scaleX(pixelPoint.x), this.scaleY(pixelPoint.y), pixelPoint.x, pixelPoint.y, sub2.width, sub2.height, sub2.area);
  }
  boundX(pos) {
    if (pos < this.i) {
      return this.i;
    }
    if (pos >= this.width) {
      return this.width - 1;
    }
    return pos;
  }
  boundY(pos) {
    if (pos < this.j) {
      return this.j;
    }
    if (pos >= this.height) {
      return this.height - 1;
    }
    return pos;
  }
  scaleX(pixel) {
    return this.boundX(Math.floor((pixel - this.pixelX) / this.pixelGroup));
  }
  scaleY(pixel) {
    return this.boundY(Math.floor((pixel - this.pixelY) / this.pixelGroup));
  }
  scale(pixelRect) {
    const x2 = this.scaleX(pixelRect.x);
    const y2 = this.scaleY(pixelRect.y);
    const x22 = this.boundX(Math.ceil((pixelRect.x + pixelRect.width - this.pixelX) / this.pixelGroup));
    const y22 = this.boundY(Math.ceil((pixelRect.y + pixelRect.height - this.pixelY) / this.pixelGroup));
    const width2 = x22 - x2;
    const height = y22 - y2;
    return new Rectangle(x2, y2, width2, height);
  }
  invertScaleX(v2) {
    return Math.round(v2 * this.pixelGroup + this.pixelX);
  }
  invertScaleY(v2) {
    return Math.round(v2 * this.pixelGroup + this.pixelY);
  }
  addPadding(rect2, pixelPadding) {
    const padding = Math.ceil(pixelPadding / this.pixelGroup);
    const x2 = this.boundX(rect2.x - padding);
    const y2 = this.boundY(rect2.y - padding);
    const x22 = this.boundX(rect2.x2 + padding);
    const y22 = this.boundY(rect2.y2 + padding);
    const width2 = x22 - x2;
    const height = y22 - y2;
    return new Rectangle(x2, y2, width2, height);
  }
  get(i2, j) {
    if (i2 < 0 || j < 0 || i2 >= this.width || j >= this.height) {
      return Number.NaN;
    }
    return this.area[i2 + j * this.width];
  }
  inc(i2, j, v2) {
    if (i2 < 0 || j < 0 || i2 >= this.width || j >= this.height) {
      return;
    }
    this.area[i2 + j * this.width] += v2;
  }
  set(i2, j, v2) {
    if (i2 < 0 || j < 0 || i2 >= this.width || j >= this.height) {
      return;
    }
    this.area[i2 + j * this.width] = v2;
  }
  incArea(sub2, factor) {
    if (sub2.width <= 0 || sub2.height <= 0 || factor === 0) {
      return;
    }
    const w2 = this.width;
    const aw = sub2.width;
    const i1 = Math.max(0, sub2.i);
    const j1 = Math.max(0, sub2.j);
    const i2 = Math.min(sub2.i + sub2.width, w2);
    const j2 = Math.min(sub2.j + sub2.height, this.height);
    if (j2 <= 0 || i2 <= 0 || i1 >= w2 || j2 >= this.height) {
      return;
    }
    for (let j = j1; j < j2; j++) {
      const subRow = (j - sub2.j) * aw;
      const row2 = j * w2;
      for (let i3 = i1; i3 < i2; i3++) {
        const v2 = sub2.area[i3 - sub2.i + subRow];
        if (v2 === 0) {
          continue;
        }
        this.area[i3 + row2] += factor * v2;
      }
    }
  }
  fill(value) {
    this.area.fill(value);
  }
  fillArea(rect2, value) {
    const offset = rect2.x + rect2.y * this.width;
    for (let j = 0; j < rect2.height; j++) {
      const pos = offset + j * this.width;
      this.area.fill(value, pos, pos + rect2.width);
    }
  }
  fillHorizontalLine(i2, j, width2, value) {
    const offset = i2 + j * this.width;
    this.area.fill(value, offset, offset + width2);
  }
  fillVerticalLine(i2, j, height, value) {
    const offset = i2 + j * this.width;
    for (let k = 0; k < height; k++) {
      this.area[offset + k * this.width] = value;
    }
  }
  clear() {
    this.area.fill(0);
  }
  toString() {
    let r2 = "";
    for (let j = 0; j < this.height; j++) {
      const row2 = j * this.width;
      for (let i2 = 0; i2 < this.width; i2++) {
        const v2 = this.area[row2 + i2];
        r2 += v2.toFixed(1).padStart(6);
        r2 += " ";
      }
      r2 += "\n";
    }
    return r2;
  }
  draw(ctx2, offset = true) {
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    ctx2.save();
    if (offset) {
      ctx2.translate(this.pixelX, this.pixelY);
    }
    const min2 = this.area.reduce((acc, v2) => Math.min(acc, v2), Number.POSITIVE_INFINITY);
    const max2 = this.area.reduce((acc, v2) => Math.max(acc, v2), Number.NEGATIVE_INFINITY);
    const scale3 = (v2) => (v2 - min2) / (max2 - min2);
    ctx2.scale(this.pixelGroup, this.pixelGroup);
    for (let i2 = 0; i2 < this.width; i2++) {
      for (let j = 0; j < this.height; j++) {
        const v2 = this.area[i2 + j * this.width];
        ctx2.fillStyle = `rgba(0, 0, 0, ${scale3(v2)})`;
        ctx2.fillRect(i2, j, 1, 1);
      }
    }
    ctx2.restore();
  }
  drawThreshold(ctx2, threshold, offset = true) {
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    ctx2.save();
    if (offset) {
      ctx2.translate(this.pixelX, this.pixelY);
    }
    ctx2.scale(this.pixelGroup, this.pixelGroup);
    for (let i2 = 0; i2 < this.width; i2++) {
      for (let j = 0; j < this.height; j++) {
        const v2 = this.area[i2 + j * this.width];
        ctx2.fillStyle = v2 > threshold ? "black" : "white";
        ctx2.fillRect(i2, j, 1, 1);
      }
    }
    ctx2.restore();
  }
}
function addPadding(rect2, padding) {
  const map2 = (r2) => ({
    x: r2.x - padding,
    y: r2.y - padding,
    width: r2.width + 2 * padding,
    height: r2.height + 2 * padding
  });
  if (Array.isArray(rect2)) {
    return rect2.map(map2);
  }
  return map2(rect2);
}
function createLineInfluenceArea(line2, potentialArea, padding) {
  return createGenericInfluenceArea(Object.assign(lineBoundingBox(line2), {
    distSquare: (x2, y2) => linePtSegDistSq(line2.x1, line2.y1, line2.x2, line2.y2, x2, y2)
  }), potentialArea, padding);
}
function createGenericInfluenceArea(shape, potentialArea, padding) {
  const lr = addPadding(shape, padding);
  const scaled = potentialArea.scale(lr);
  const area = potentialArea.createSub(scaled, lr);
  sample(area, potentialArea, padding, (x2, y2) => shape.distSquare(x2, y2));
  return area;
}
function sample(area, potentialArea, padding, distanceFunction) {
  const padding2 = padding * padding;
  for (let y2 = 0; y2 < area.height; y2++) {
    for (let x2 = 0; x2 < area.width; x2++) {
      const tempX = potentialArea.invertScaleX(area.i + x2);
      const tempY = potentialArea.invertScaleY(area.j + y2);
      const distanceSq = distanceFunction(tempX, tempY);
      if (distanceSq === 0) {
        area.set(x2, y2, padding2);
        continue;
      }
      if (distanceSq < padding2) {
        const dr = padding - Math.sqrt(distanceSq);
        area.set(x2, y2, dr * dr);
      }
    }
  }
  return area;
}
function createRectangleInfluenceArea(rect2, potentialArea, padding) {
  const scaled = potentialArea.scale(rect2);
  const padded = potentialArea.addPadding(scaled, padding);
  const area = potentialArea.createSub(padded, { x: rect2.x - padding, y: rect2.y - padding });
  const paddingLeft2 = scaled.x - padded.x;
  const paddingTop2 = scaled.y - padded.y;
  const paddingRight2 = padded.x2 - scaled.x2;
  const paddingBottom2 = padded.y2 - scaled.y2;
  const innerWidth = padded.width - paddingLeft2 - paddingRight2;
  const innerHeight = padded.height - paddingTop2 - paddingBottom2;
  const padding2 = padding * padding;
  area.fillArea({
    x: paddingLeft2,
    y: paddingTop2,
    width: innerWidth + 1,
    height: innerHeight + 1
  }, padding2);
  const straightDistances = [0];
  const maxPadding = Math.max(paddingTop2, paddingLeft2, paddingRight2, paddingBottom2);
  {
    const tempX = potentialArea.invertScaleX(scaled.x + scaled.width / 2);
    for (let i2 = 1; i2 < maxPadding; i2++) {
      const tempY = potentialArea.invertScaleY(scaled.y - i2);
      const distanceSq = rect2.distSquare(tempX, tempY);
      if (distanceSq < padding2) {
        const dr = padding - Math.sqrt(distanceSq);
        straightDistances.push(dr * dr);
      } else {
        break;
      }
    }
  }
  const cornerDistances = [];
  const maxHorizontalPadding = Math.max(paddingLeft2, paddingRight2);
  const maxVerticalPadding = Math.max(paddingTop2, paddingRight2);
  for (let i2 = 1; i2 < maxHorizontalPadding; i2++) {
    const tempX = potentialArea.invertScaleX(scaled.x - i2);
    const row2 = [];
    for (let j = 1; j < maxVerticalPadding; j++) {
      const tempY = potentialArea.invertScaleY(scaled.y - j);
      const distanceSq = rect2.distSquare(tempX, tempY);
      if (distanceSq < padding2) {
        const dr = padding - Math.sqrt(distanceSq);
        row2.push(dr * dr);
      } else {
        row2.push(0);
      }
    }
    cornerDistances.push(row2);
  }
  for (let y2 = 1; y2 < Math.min(paddingTop2, straightDistances.length); y2++) {
    const value = straightDistances[y2];
    area.fillHorizontalLine(paddingLeft2, paddingTop2 - y2, innerWidth + 1, value);
  }
  for (let y2 = 1; y2 < Math.min(paddingBottom2, straightDistances.length); y2++) {
    const value = straightDistances[y2];
    area.fillHorizontalLine(paddingLeft2, paddingTop2 + innerHeight + y2, innerWidth + 1, value);
  }
  for (let x2 = 1; x2 < Math.min(paddingLeft2, straightDistances.length); x2++) {
    const value = straightDistances[x2];
    area.fillVerticalLine(paddingLeft2 - x2, paddingTop2, innerHeight + 1, value);
  }
  for (let x2 = 1; x2 < Math.min(paddingBottom2, straightDistances.length); x2++) {
    const value = straightDistances[x2];
    area.fillVerticalLine(paddingLeft2 + innerWidth + x2, paddingTop2, innerHeight + 1, value);
  }
  for (let i2 = 1; i2 < paddingLeft2; i2++) {
    const row2 = cornerDistances[i2 - 1];
    const ii = paddingLeft2 - i2;
    for (let j = 1; j < paddingTop2; j++) {
      area.set(ii, paddingTop2 - j, row2[j - 1]);
    }
    for (let j = 1; j < paddingBottom2; j++) {
      area.set(ii, paddingTop2 + innerHeight + j, row2[j - 1]);
    }
  }
  for (let i2 = 1; i2 < paddingRight2; i2++) {
    const row2 = cornerDistances[i2 - 1];
    const ii = paddingLeft2 + innerWidth + i2;
    for (let j = 1; j < paddingTop2; j++) {
      area.set(ii, paddingTop2 - j, row2[j - 1]);
    }
    for (let j = 1; j < paddingBottom2; j++) {
      area.set(ii, paddingTop2 + innerHeight + j, row2[j - 1]);
    }
  }
  return area;
}
function point$1(x2, y2) {
  return { x: x2, y: y2 };
}
function calculateVirtualEdges(items, nonMembers, maxRoutingIterations, morphBuffer) {
  if (items.length === 0) {
    return [];
  }
  const sorted = sortByDistanceToCentroid(items);
  return sorted.map((d3, i2) => {
    const visited = sorted.slice(0, i2);
    return connectItem(nonMembers, d3, visited, maxRoutingIterations, morphBuffer);
  }).flat();
}
function connectItem(nonMembers, item, visited, maxRoutingIterations, morphBuffer) {
  const itemCenter = point$1(item.cx, item.cy);
  const closestNeighbor = calculateClosestNeighbor(itemCenter, visited, nonMembers);
  if (closestNeighbor == null) {
    return [];
  }
  const directLine = new Line2(itemCenter.x, itemCenter.y, closestNeighbor.cx, closestNeighbor.cy);
  const scannedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);
  return mergeLines(scannedLines, nonMembers);
}
function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {
  const scannedLines = [];
  const linesToCheck = [];
  linesToCheck.push(directLine);
  let hasIntersection = true;
  for (let iterations = 0; iterations < maxRoutingIterations && hasIntersection; iterations++) {
    hasIntersection = false;
    while (!hasIntersection && linesToCheck.length > 0) {
      const line2 = linesToCheck.pop();
      const closestItem = getCenterItem(nonMembers, line2);
      const intersections = closestItem ? testIntersection(line2, closestItem) : null;
      if (!closestItem || !intersections || intersections.count !== 2) {
        if (!hasIntersection) {
          scannedLines.push(line2);
        }
        continue;
      }
      let tempMorphBuffer = morphBuffer;
      let movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);
      let foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
      let pointInside = isPointInRectangles(movePoint, nonMembers);
      while (!foundFirst && pointInside && tempMorphBuffer >= 1) {
        tempMorphBuffer /= 1.5;
        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);
        foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
        pointInside = isPointInRectangles(movePoint, nonMembers);
      }
      if (movePoint && !foundFirst && !pointInside) {
        linesToCheck.push(new Line2(line2.x1, line2.y1, movePoint.x, movePoint.y));
        linesToCheck.push(new Line2(movePoint.x, movePoint.y, line2.x2, line2.y2));
        hasIntersection = true;
      }
      if (hasIntersection) {
        continue;
      }
      tempMorphBuffer = morphBuffer;
      movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);
      let foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
      pointInside = isPointInRectangles(movePoint, nonMembers);
      while (!foundSecond && pointInside && tempMorphBuffer >= 1) {
        tempMorphBuffer /= 1.5;
        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);
        foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
        pointInside = isPointInRectangles(movePoint, nonMembers);
      }
      if (movePoint && !foundSecond) {
        linesToCheck.push(new Line2(line2.x1, line2.y1, movePoint.x, movePoint.y));
        linesToCheck.push(new Line2(movePoint.x, movePoint.y, line2.x2, line2.y2));
        hasIntersection = true;
      }
      if (!hasIntersection) {
        scannedLines.push(line2);
      }
    }
  }
  while (linesToCheck.length > 0) {
    scannedLines.push(linesToCheck.pop());
  }
  return scannedLines;
}
function mergeLines(scannedLines, nonMembers) {
  const finalRoute = [];
  while (scannedLines.length > 0) {
    const line1 = scannedLines.pop();
    if (scannedLines.length === 0) {
      finalRoute.push(line1);
      break;
    }
    const line2 = scannedLines.pop();
    const mergeLine = new Line2(line1.x1, line1.y1, line2.x2, line2.y2);
    const closestItem = getCenterItem(nonMembers, mergeLine);
    if (!closestItem) {
      scannedLines.push(mergeLine);
    } else {
      finalRoute.push(line1);
      scannedLines.push(line2);
    }
  }
  return finalRoute;
}
function calculateClosestNeighbor(itemCenter, visited, nonMembers) {
  let minLengthSq = Number.POSITIVE_INFINITY;
  return visited.reduce((closestNeighbor, neighborItem) => {
    const distanceSq = ptsDistanceSq(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);
    if (distanceSq > minLengthSq) {
      return closestNeighbor;
    }
    const directLine = new Line2(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);
    const numberInterferenceItems = itemsCuttingLine(nonMembers, directLine);
    if (distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1) < minLengthSq) {
      closestNeighbor = neighborItem;
      minLengthSq = distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1);
    }
    return closestNeighbor;
  }, null);
}
function sortByDistanceToCentroid(items) {
  if (items.length < 2) {
    return items;
  }
  let totalX = 0;
  let totalY = 0;
  items.forEach((item) => {
    totalX += item.cx;
    totalY += item.cy;
  });
  totalX /= items.length;
  totalY /= items.length;
  return items.map((item) => {
    const diffX = totalX - item.cx;
    const diffY = totalY - item.cy;
    const dist2 = diffX * diffX + diffY * diffY;
    return [item, dist2];
  }).sort((a2, b2) => a2[1] - b2[1]).map((d3) => d3[0]);
}
function isPointInRectangles(p2, rects) {
  return rects.some((r2) => r2.containsPt(p2.x, p2.y));
}
function pointExists(pointToCheck, lines) {
  return lines.some((checkEndPointsLine) => {
    if (doublePointsEqual(checkEndPointsLine.x1, checkEndPointsLine.y1, pointToCheck.x, pointToCheck.y, 1e-3)) {
      return true;
    }
    if (doublePointsEqual(checkEndPointsLine.x2, checkEndPointsLine.y2, pointToCheck.x, pointToCheck.y, 1e-3)) {
      return true;
    }
    return false;
  });
}
function getCenterItem(items, testLine) {
  let minDistance = Number.POSITIVE_INFINITY;
  let closestItem = null;
  for (const item of items) {
    if (!intersectsLine(item, testLine)) {
      continue;
    }
    const distance2 = fractionToLineCenter(item, testLine);
    if (distance2 >= 0 && distance2 < minDistance) {
      closestItem = item;
      minDistance = distance2;
    }
  }
  return closestItem;
}
function itemsCuttingLine(items, testLine) {
  return items.reduce((count, item) => {
    if (intersectsLine(item, testLine) && hasFractionToLineCenter(item, testLine)) {
      return count + 1;
    }
    return count;
  }, 0);
}
function rerouteLine(item, rerouteBuffer, intersections, wrapNormal) {
  const topIntersect = intersections.top;
  const leftIntersect = intersections.left;
  const bottomIntersect = intersections.bottom;
  const rightIntersect = intersections.right;
  if (wrapNormal) {
    if (leftIntersect.state === EState.POINT) {
      if (topIntersect.state === EState.POINT)
        return point$1(item.x - rerouteBuffer, item.y - rerouteBuffer);
      if (bottomIntersect.state === EState.POINT)
        return point$1(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      const totalArea3 = item.width * item.height;
      const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);
      if (topArea < totalArea3 * 0.5) {
        if (leftIntersect.y > rightIntersect.y)
          return point$1(item.x - rerouteBuffer, item.y - rerouteBuffer);
        return point$1(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      }
      if (leftIntersect.y < rightIntersect.y)
        return point$1(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      return point$1(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (rightIntersect.state === EState.POINT) {
      if (topIntersect.state === EState.POINT)
        return point$1(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      if (bottomIntersect.state === EState.POINT)
        return point$1(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    }
    const totalArea2 = item.height * item.width;
    const leftArea2 = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);
    if (leftArea2 < totalArea2 * 0.5) {
      if (topIntersect.x > bottomIntersect.x)
        return point$1(item.x - rerouteBuffer, item.y - rerouteBuffer);
      return point$1(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (topIntersect.x < bottomIntersect.x)
      return point$1(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    return point$1(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
  }
  if (leftIntersect.state === EState.POINT) {
    if (topIntersect.state === EState.POINT)
      return point$1(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    if (bottomIntersect.state === EState.POINT)
      return point$1(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    const totalArea2 = item.height * item.width;
    const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);
    if (topArea < totalArea2 * 0.5) {
      if (leftIntersect.y > rightIntersect.y)
        return point$1(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
      return point$1(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (leftIntersect.y < rightIntersect.y)
      return point$1(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    return point$1(item.x - rerouteBuffer, item.y - rerouteBuffer);
  }
  if (rightIntersect.state === EState.POINT) {
    if (topIntersect.state === EState.POINT)
      return point$1(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    if (bottomIntersect.state === EState.POINT)
      return point$1(item.x - rerouteBuffer, item.y - rerouteBuffer);
  }
  const totalArea = item.height * item.width;
  const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);
  if (leftArea < totalArea * 0.5) {
    if (topIntersect.x > bottomIntersect.x)
      return point$1(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    return point$1(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
  }
  if (topIntersect.x < bottomIntersect.x)
    return point$1(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
  return point$1(item.x - rerouteBuffer, item.y - rerouteBuffer);
}
function canTakeNext(path, start, end, toleranceSquared) {
  const validEnd = path.closed ? end < path.length : end < path.length - 1;
  if (!validEnd) {
    return false;
  }
  const s3 = path.get(start);
  const e3 = path.get(end + 1);
  for (let index2 = start + 1; index2 <= end; index2++) {
    const p2 = path.get(index2);
    const len2 = linePtSegDistSq(s3.x, s3.y, e3.x, e3.y, p2.x, p2.y);
    if (len2 > toleranceSquared) {
      return false;
    }
  }
  return true;
}
function shapeSimplifier(tolerance2 = 0) {
  return (path) => {
    if (tolerance2 < 0 || path.length < 3) {
      return path;
    }
    const points = [];
    let start = 0;
    const toleranceSquared = tolerance2 * tolerance2;
    while (start < path.length) {
      let end = start + 1;
      while (canTakeNext(path, start, end, toleranceSquared)) {
        end++;
      }
      points.push(path.get(start));
      start = end;
    }
    return new PointPath(points);
  };
}
function basicFunction(i2, t3) {
  switch (i2) {
    case -2:
      return (((-t3 + 3) * t3 - 3) * t3 + 1) / 6;
    case -1:
      return ((3 * t3 - 6) * t3 * t3 + 4) / 6;
    case 0:
      return (((-3 * t3 + 3) * t3 + 3) * t3 + 1) / 6;
    case 1:
      return t3 * t3 * t3 / 6;
    default:
      throw new Error("unknown error");
  }
}
function bSplineShapeGenerator(granularity = 6) {
  const ORDER = 3;
  const START_INDEX = ORDER - 1;
  const REL_END = 1;
  const REL_START = REL_END - ORDER;
  function calcPoint(path, i2, t3) {
    let px2 = 0;
    let py = 0;
    for (let j = REL_START; j <= REL_END; j++) {
      const p2 = path.get(i2 + j);
      const bf = basicFunction(j, t3);
      px2 += bf * p2.x;
      py += bf * p2.y;
    }
    return { x: px2, y: py };
  }
  return (path) => {
    if (path.length < 3) {
      return path;
    }
    const res = [];
    const closed = path.closed;
    const count = path.length + ORDER - 1 + (closed ? 0 : 2);
    res.push(calcPoint(path, START_INDEX - (closed ? 0 : 2), 0));
    for (let ix = START_INDEX - (closed ? 0 : 2); ix < count; ix++) {
      for (let k = 1; k <= granularity; k++) {
        res.push(calcPoint(path, ix, k / granularity));
      }
    }
    return new PointPath(res);
  };
}
function samplePath(skip = 8) {
  return (path) => {
    let actSkip = skip;
    let size = path.length;
    if (actSkip > 1) {
      size = Math.floor(path.length / actSkip);
      while (size < 3 && actSkip > 1) {
        actSkip -= 1;
        size = Math.floor(path.length / actSkip);
      }
    }
    const finalHull = [];
    for (let i2 = 0, j = 0; j < size; j++, i2 += actSkip) {
      finalHull.push(path.get(i2));
    }
    return new PointPath(finalHull);
  };
}
class PointPath {
  constructor(points = [], closed = true) {
    this.points = points;
    this.closed = closed;
  }
  get(index2) {
    const i2 = index2;
    const l2 = this.points.length;
    if (index2 < 0) {
      return this.closed ? this.get(index2 + l2) : this.points[0];
    } else if (index2 >= l2) {
      return this.closed ? this.get(index2 - l2) : this.points[l2 - 1];
    }
    return this.points[i2];
  }
  get length() {
    return this.points.length;
  }
  toString(roundToDigits = Infinity) {
    const points = this.points;
    if (points.length === 0) {
      return "";
    }
    const rounder = typeof roundToDigits === "function" ? roundToDigits : round(roundToDigits);
    let r2 = "M";
    for (const p2 of points) {
      r2 += `${rounder(p2.x)},${rounder(p2.y)} L`;
    }
    r2 = r2.slice(0, -1);
    if (this.closed) {
      r2 += " Z";
    }
    return r2;
  }
  draw(ctx2) {
    const points = this.points;
    if (points.length === 0) {
      return;
    }
    ctx2.beginPath();
    ctx2.moveTo(points[0].x, points[0].y);
    for (const p2 of points) {
      ctx2.lineTo(p2.x, p2.y);
    }
    if (this.closed) {
      ctx2.closePath();
    }
  }
  sample(skip) {
    return samplePath(skip)(this);
  }
  simplify(tolerance2) {
    return shapeSimplifier(tolerance2)(this);
  }
  bSplines(granularity) {
    return bSplineShapeGenerator(granularity)(this);
  }
  apply(transformer) {
    return transformer(this);
  }
  containsElements(members) {
    const bb = boundingBox(this.points);
    if (!bb) {
      return false;
    }
    return members.every((member) => {
      return bb.containsPt(member.cx, member.cy) && this.withinArea(member.cx, member.cy);
    });
  }
  withinArea(px2, py) {
    if (this.length === 0) {
      return false;
    }
    let crossings = 0;
    const first = this.points[0];
    const line2 = new Line2(first.x, first.y, first.x, first.y);
    for (let i2 = 1; i2 < this.points.length; i2++) {
      const cur = this.points[i2];
      line2.x1 = line2.x2;
      line2.y1 = line2.y2;
      line2.x2 = cur.x;
      line2.y2 = cur.y;
      if (line2.cuts(px2, py)) {
        crossings++;
      }
    }
    line2.x1 = line2.x2;
    line2.y1 = line2.y2;
    line2.x2 = first.x;
    line2.y2 = first.y;
    if (line2.cuts(px2, py)) {
      crossings++;
    }
    return crossings % 2 === 1;
  }
}
class PointList {
  constructor(size = 0) {
    this.count = 0;
    this.arr = [];
    this.set = /* @__PURE__ */ new Set();
    this.arr.length = size;
  }
  add(p2) {
    this.set.add(`${p2.x}x${p2.y}`);
    this.arr[this.count++] = p2;
  }
  contains(p2) {
    return this.set.has(`${p2.x}x${p2.y}`);
  }
  isFirst(p2) {
    if (this.count === 0) {
      return false;
    }
    const o2 = this.arr[0];
    return o2 != null && o2.x === p2.x && o2.y === p2.y;
  }
  path() {
    return new PointPath(this.arr.slice(0, this.count));
  }
  clear() {
    this.set.clear();
    this.count = 0;
  }
  get(ix) {
    return this.arr[ix];
  }
  get length() {
    return this.count;
  }
}
const N2 = 0;
const S = 1;
const E = 2;
const W = 3;
function marchingSquares(potentialArea, threshold) {
  const estLength = (Math.floor(potentialArea.width) + Math.floor(potentialArea.height)) * 2;
  const contour = new PointList(estLength);
  function updateDir(x2, y2, dir, res) {
    const v2 = potentialArea.get(x2, y2);
    if (Number.isNaN(v2)) {
      return Number.NaN;
    }
    if (v2 > threshold) {
      return dir + res;
    }
    return dir;
  }
  function getState(x2, y2) {
    let dir = N2;
    dir = updateDir(x2, y2, dir, 1);
    dir = updateDir(x2 + 1, y2, dir, 2);
    dir = updateDir(x2, y2 + 1, dir, 4);
    dir = updateDir(x2 + 1, y2 + 1, dir, 8);
    if (Number.isNaN(dir)) {
      return -1;
    }
    return dir;
  }
  let direction2 = S;
  function doMarch(xPos, yPos) {
    let x2 = xPos;
    let y2 = yPos;
    let xPixel = potentialArea.invertScaleX(x2);
    let yPixel = potentialArea.invertScaleY(y2);
    for (let i2 = 0; i2 < potentialArea.width * potentialArea.height; i2++) {
      const p2 = { x: xPixel, y: yPixel };
      if (contour.contains(p2)) {
        if (!contour.isFirst(p2)) ;
        else {
          return true;
        }
      } else {
        contour.add(p2);
      }
      const state = getState(x2, y2);
      switch (state) {
        case -1:
          return true;
        case 0:
        case 3:
        case 2:
        case 7:
          direction2 = E;
          break;
        case 12:
        case 14:
        case 4:
          direction2 = W;
          break;
        case 6:
          direction2 = direction2 === N2 ? W : E;
          break;
        case 1:
        case 13:
        case 5:
          direction2 = N2;
          break;
        case 9:
          direction2 = direction2 === E ? N2 : S;
          break;
        case 10:
        case 8:
        case 11:
          direction2 = S;
          break;
        default:
          console.warn("Marching squares invalid state: " + state);
          return true;
      }
      switch (direction2) {
        case N2:
          y2--;
          yPixel -= potentialArea.pixelGroup;
          break;
        case S:
          y2++;
          yPixel += potentialArea.pixelGroup;
          break;
        case W:
          x2--;
          xPixel -= potentialArea.pixelGroup;
          break;
        case E:
          x2++;
          xPixel += potentialArea.pixelGroup;
          break;
        default:
          console.warn("Marching squares invalid state: " + state);
          return true;
      }
    }
    return true;
  }
  for (let x2 = 0; x2 < potentialArea.width; x2++) {
    for (let y2 = 0; y2 < potentialArea.height; y2++) {
      if (potentialArea.get(x2, y2) <= threshold) {
        continue;
      }
      const state = getState(x2, y2);
      if (state < 0 || state === 15) {
        continue;
      }
      if (doMarch(x2, y2)) {
        return contour.path();
      }
    }
  }
  return null;
}
const defaultOptions$1 = {
  maxRoutingIterations: 100,
  maxMarchingIterations: 20,
  pixelGroup: 4,
  edgeR0: 10,
  edgeR1: 20,
  nodeR0: 15,
  nodeR1: 50,
  morphBuffer: 10,
  threshold: 1,
  memberInfluenceFactor: 1,
  edgeInfluenceFactor: 1,
  nonMemberInfluenceFactor: -0.8,
  virtualEdges: true
};
function isCircle$1(v2) {
  return v2 != null && typeof v2.radius === "number";
}
function isEqual(a2, b2) {
  if (isCircle$1(a2) !== isCircle$1(b2)) {
    return false;
  }
  if (isCircle$1(a2)) {
    const bc = b2;
    return a2.cx === bc.cx && a2.cy === bc.cy && a2.radius === bc.radius;
  }
  const br = b2;
  return a2.x === br.x && a2.y === br.y && a2.width === br.width && a2.height === br.height;
}
var EDirty;
(function(EDirty2) {
  EDirty2[EDirty2["MEMBERS"] = 0] = "MEMBERS";
  EDirty2[EDirty2["NON_MEMBERS"] = 1] = "NON_MEMBERS";
  EDirty2[EDirty2["EDGES"] = 2] = "EDGES";
})(EDirty || (EDirty = {}));
let BubbleSets$1 = class BubbleSets {
  constructor(options = {}) {
    this.dirty = /* @__PURE__ */ new Set();
    this.members = [];
    this.nonMembers = [];
    this.virtualEdges = [];
    this.edges = [];
    this.activeRegion = new Rectangle(0, 0, 0, 0);
    this.potentialArea = new Area(1, 0, 0, 0, 0, 0, 0);
    this.o = Object.assign({}, defaultOptions$1, options);
  }
  pushMember(...members) {
    if (members.length === 0) {
      return;
    }
    this.dirty.add(EDirty.MEMBERS);
    for (const v2 of members) {
      this.members.push({
        raw: v2,
        obj: isCircle$1(v2) ? Circle2.from(v2) : Rectangle.from(v2),
        area: null
      });
    }
  }
  removeMember(member) {
    const index2 = this.members.findIndex((d3) => isEqual(d3.raw, member));
    if (index2 < 0) {
      return false;
    }
    this.members.splice(index2, 1);
    this.dirty.add(EDirty.MEMBERS);
    return true;
  }
  removeNonMember(nonMember) {
    const index2 = this.nonMembers.findIndex((d3) => isEqual(d3.raw, nonMember));
    if (index2 < 0) {
      return false;
    }
    this.nonMembers.splice(index2, 1);
    this.dirty.add(EDirty.NON_MEMBERS);
    return true;
  }
  removeEdge(edge) {
    const index2 = this.edges.findIndex((d3) => d3.obj.equals(edge));
    if (index2 < 0) {
      return false;
    }
    this.edges.splice(index2, 1);
    this.dirty.add(EDirty.NON_MEMBERS);
    return true;
  }
  pushNonMember(...nonMembers) {
    if (nonMembers.length === 0) {
      return;
    }
    this.dirty.add(EDirty.NON_MEMBERS);
    for (const v2 of nonMembers) {
      this.nonMembers.push({
        raw: v2,
        obj: isCircle$1(v2) ? Circle2.from(v2) : Rectangle.from(v2),
        area: null
      });
    }
  }
  pushEdge(...edges) {
    if (edges.length === 0) {
      return;
    }
    this.dirty.add(EDirty.EDGES);
    for (const v2 of edges) {
      this.edges.push({
        raw: v2,
        obj: Line2.from(v2),
        area: null
      });
    }
  }
  update() {
    const dirtyMembers = this.dirty.has(EDirty.MEMBERS);
    const dirtyNonMembers = this.dirty.has(EDirty.NON_MEMBERS);
    let dirtyEdges = this.dirty.has(EDirty.EDGES);
    this.dirty.clear();
    const memberObjs = this.members.map((d3) => d3.obj);
    if (this.o.virtualEdges && (dirtyMembers || dirtyNonMembers)) {
      const nonMembersAsRects = this.nonMembers.map((d3) => d3.obj);
      const virtualEdges = calculateVirtualEdges(memberObjs, nonMembersAsRects, this.o.maxRoutingIterations, this.o.morphBuffer);
      const old = new Map(this.virtualEdges.map((e3) => [e3.obj.toString(), e3.area]));
      this.virtualEdges = virtualEdges.map((e3) => {
        var _a3;
        return {
          raw: e3,
          obj: e3,
          area: (_a3 = old.get(e3.toString())) !== null && _a3 !== void 0 ? _a3 : null
        };
      });
      dirtyEdges = true;
    }
    let activeRegionDirty = false;
    if (dirtyMembers || dirtyEdges) {
      const edgesObj = this.virtualEdges.concat(this.edges).map((e3) => e3.obj);
      const bb = unionBoundingBox(memberObjs, edgesObj);
      const padding = Math.max(this.o.edgeR1, this.o.nodeR1) + this.o.morphBuffer;
      const activeRegion = Rectangle.from(addPadding(bb, padding));
      if (!activeRegion.equals(this.activeRegion)) {
        activeRegionDirty = true;
        this.activeRegion = activeRegion;
      }
    }
    if (activeRegionDirty) {
      const potentialWidth = Math.ceil(this.activeRegion.width / this.o.pixelGroup);
      const potentialHeight = Math.ceil(this.activeRegion.height / this.o.pixelGroup);
      if (this.activeRegion.x !== this.potentialArea.pixelX || this.activeRegion.y !== this.potentialArea.pixelY) {
        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);
        this.members.forEach((m3) => m3.area = null);
        this.nonMembers.forEach((m3) => m3.area = null);
        this.edges.forEach((m3) => m3.area = null);
        this.virtualEdges.forEach((m3) => m3.area = null);
      } else if (potentialWidth !== this.potentialArea.width || potentialHeight !== this.potentialArea.height) {
        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);
      }
    }
    const existing = /* @__PURE__ */ new Map();
    const addCache = (m3) => {
      if (m3.area) {
        const key = `${m3.obj.width}x${m3.obj.height}x${m3.obj instanceof Rectangle ? "R" : "C"}`;
        existing.set(key, m3.area);
      }
    };
    const createOrAddCache = (m3) => {
      if (m3.area) {
        return;
      }
      const key = `${m3.obj.width}x${m3.obj.height}x${m3.obj instanceof Rectangle ? "R" : "C"}`;
      if (existing.has(key)) {
        const r3 = existing.get(key);
        m3.area = this.potentialArea.copy(r3, { x: m3.obj.x - this.o.nodeR1, y: m3.obj.y - this.o.nodeR1 });
        return;
      }
      const r2 = m3.obj instanceof Rectangle ? createRectangleInfluenceArea(m3.obj, this.potentialArea, this.o.nodeR1) : createGenericInfluenceArea(m3.obj, this.potentialArea, this.o.nodeR1);
      m3.area = r2;
      existing.set(key, r2);
    };
    this.members.forEach(addCache);
    this.nonMembers.forEach(addCache);
    this.members.forEach(createOrAddCache);
    this.nonMembers.forEach((m3) => {
      if (!this.activeRegion.intersects(m3.obj)) {
        m3.area = null;
      } else {
        createOrAddCache(m3);
      }
    });
    this.edges.forEach((edge) => {
      if (!edge.area) {
        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);
      }
    });
    this.virtualEdges.forEach((edge) => {
      if (!edge.area) {
        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);
      }
    });
  }
  drawMembers(ctx2) {
    for (const member of this.members) {
      member.obj.draw(ctx2);
    }
  }
  drawNonMembers(ctx2) {
    for (const member of this.nonMembers) {
      member.obj.draw(ctx2);
    }
  }
  drawEdges(ctx2) {
    for (const edge of this.edges) {
      edge.obj.draw(ctx2);
    }
  }
  drawPotentialArea(ctx2, offset = true) {
    this.potentialArea.draw(ctx2, offset);
  }
  compute() {
    if (this.members.length === 0) {
      return new PointPath([]);
    }
    if (this.dirty.size > 0) {
      this.update();
    }
    const { o: o2, potentialArea } = this;
    const members = this.members.map((m3) => m3.area);
    const edges = this.virtualEdges.concat(this.edges).map((d3) => d3.area);
    const nonMembers = this.nonMembers.filter((d3) => d3.area != null).map((d3) => d3.area);
    const memberObjs = this.members.map((m3) => m3.obj);
    return calculatePotentialOutline(potentialArea, members, edges, nonMembers, (p2) => p2.containsElements(memberObjs), o2);
  }
};
function calculatePotentialOutline(potentialArea, members, edges, nonMembers, validPath, options = {}) {
  const o2 = Object.assign({}, defaultOptions$1, options);
  let threshold = o2.threshold;
  let memberInfluenceFactor = o2.memberInfluenceFactor;
  let edgeInfluenceFactor = o2.edgeInfluenceFactor;
  let nonMemberInfluenceFactor = o2.nonMemberInfluenceFactor;
  const nodeInfA = (o2.nodeR0 - o2.nodeR1) * (o2.nodeR0 - o2.nodeR1);
  const edgeInfA = (o2.edgeR0 - o2.edgeR1) * (o2.edgeR0 - o2.edgeR1);
  for (let iterations = 0; iterations < o2.maxMarchingIterations; iterations++) {
    potentialArea.clear();
    if (memberInfluenceFactor !== 0) {
      const f2 = memberInfluenceFactor / nodeInfA;
      for (const item of members) {
        potentialArea.incArea(item, f2);
      }
    }
    if (edgeInfluenceFactor !== 0) {
      const f2 = edgeInfluenceFactor / edgeInfA;
      for (const area of edges) {
        potentialArea.incArea(area, f2);
      }
    }
    if (nonMemberInfluenceFactor !== 0) {
      const f2 = nonMemberInfluenceFactor / nodeInfA;
      for (const area of nonMembers) {
        potentialArea.incArea(area, f2);
      }
    }
    const contour = marchingSquares(potentialArea, threshold);
    if (contour && validPath(contour)) {
      return contour;
    }
    threshold *= 0.95;
    if (iterations <= o2.maxMarchingIterations * 0.5) {
      memberInfluenceFactor *= 1.2;
      edgeInfluenceFactor *= 1.2;
    } else if (nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {
      nonMemberInfluenceFactor *= 0.8;
    } else {
      break;
    }
  }
  return new PointPath([]);
}
function unionBoundingBox(memberItems, edgeItems) {
  if (memberItems.length === 0) {
    return new Rectangle(0, 0, 0, 0);
  }
  const activeRegion = Rectangle.from(memberItems[0]);
  for (const m3 of memberItems) {
    activeRegion.add(m3);
  }
  for (const l2 of edgeItems) {
    activeRegion.add(lineBoundingBox(l2));
  }
  return activeRegion;
}
var __rest$8 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class BubbleSets2 extends BasePlugin {
  constructor(context, options) {
    super(context, deepMix({}, BubbleSets2.defaultOptions, options));
    this.path = null;
    this.members = /* @__PURE__ */ new Map();
    this.avoidMembers = /* @__PURE__ */ new Map();
    this.bubbleSetOptions = {};
    this.drawBubbleSets = () => {
      const { style, bubbleSetOptions } = this.parseOptions();
      if (!isEqual$1(this.bubbleSetOptions, bubbleSetOptions))
        this.init();
      this.bubbleSetOptions = Object.assign({}, bubbleSetOptions);
      const finalStyle = Object.assign(Object.assign({}, style), { d: this.getPath() });
      if (!this.shape) {
        this.shape = new Contour({ style: finalStyle });
        this.context.canvas.appendChild(this.shape);
      } else {
        this.shape.update(finalStyle);
      }
    };
    this.updateBubbleSetsPath = (event) => {
      if (!this.shape)
        return;
      const id2 = idOf(event.data);
      if (![...this.options.members, ...this.options.avoidMembers].includes(id2))
        return;
      this.shape.update(Object.assign(Object.assign({}, this.parseOptions().style), { d: this.getPath(id2) }));
    };
    this.getPath = (forceUpdateId) => {
      const { graph: graph2 } = this.context;
      const currMembers = this.options.members;
      const prevMembers = [...this.members.keys()];
      const currAvoidMembers = this.options.avoidMembers;
      const prevAvoidMembers = [...this.avoidMembers.keys()];
      if (currMembers.length === 0 && currAvoidMembers.length === 0) {
        this.members.clear();
        this.avoidMembers.clear();
        this.path = [];
        return this.path;
      }
      if (!forceUpdateId && this.path && isEqual$1(currMembers, prevMembers) && isEqual$1(currAvoidMembers, prevAvoidMembers)) {
        return this.path;
      }
      const { enter: membersToEnter = [], exit: membersToExit = [] } = arrayDiff(prevMembers, currMembers, (d3) => d3);
      const { enter: avoidMembersToEnter = [], exit: avoidMembersToExit = [] } = arrayDiff(prevAvoidMembers, currAvoidMembers, (d3) => d3);
      if (forceUpdateId) {
        const isMemberNow = currMembers.includes(forceUpdateId);
        const isAvoidNow = currAvoidMembers.includes(forceUpdateId);
        if (isMemberNow) {
          membersToExit.push(forceUpdateId);
          membersToEnter.push(forceUpdateId);
        }
        if (isAvoidNow) {
          avoidMembersToExit.push(forceUpdateId);
          avoidMembersToEnter.push(forceUpdateId);
        }
      }
      const updateBubbleSets = (ids, isEntering, isMember) => {
        ids.forEach((id2) => {
          const members = isMember ? this.members : this.avoidMembers;
          const pushMember = isMember ? "pushMember" : "pushNonMember";
          const removeMember = isMember ? "removeMember" : "removeNonMember";
          if (isEntering) {
            let area;
            if (graph2.getElementType(id2) === "edge") {
              [area] = convertToLine(graph2, id2);
              this.bubbleSets.pushEdge(area);
            } else {
              [area] = convertToRectangle(graph2, id2);
              this.bubbleSets[pushMember](area);
            }
            members.set(id2, area);
          } else {
            const area = members.get(id2);
            if (area) {
              if (graph2.getElementType(id2) === "edge") {
                this.bubbleSets.removeEdge(area);
              } else {
                this.bubbleSets[removeMember](area);
              }
              members.delete(id2);
            }
          }
        });
      };
      updateBubbleSets(membersToExit, false, true);
      updateBubbleSets(membersToEnter, true, true);
      updateBubbleSets(avoidMembersToExit, false, false);
      updateBubbleSets(avoidMembersToEnter, true, false);
      const pointPath = this.bubbleSets.compute();
      const cleanPath = pointPath.sample(8).simplify(0).bSplines().simplify(0);
      this.path = getClosedSpline(cleanPath.points.map(parsePoint));
      return this.path;
    };
    this.bindEvents();
    this.bubbleSets = new BubbleSets$1(this.options);
  }
  bindEvents() {
    this.context.graph.on(GraphEvent.AFTER_RENDER, this.drawBubbleSets);
    this.context.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateBubbleSetsPath);
  }
  init() {
    this.bubbleSets = new BubbleSets$1(this.options);
    this.members.clear();
    this.avoidMembers.clear();
    this.path = null;
  }
  parseOptions() {
    const _a3 = this.options, { type, key, members, avoidMembers } = _a3, rest = __rest$8(_a3, ["type", "key", "members", "avoidMembers"]);
    const res = Object.keys(rest).reduce((acc, key2) => {
      if (key2 in defaultOptions$1) {
        acc.bubbleSetOptions[key2] = rest[key2];
      } else {
        acc.style[key2] = rest[key2];
      }
      return acc;
    }, { style: {}, bubbleSetOptions: {} });
    return Object.assign({ type, key, members, avoidMembers }, res);
  }
  /**
   * <zh/> 
   *
   * <en/> Add member elements
   * @param members - <zh/>  | <en/> single or multiple
   */
  addMember(members) {
    const membersToAdd = Array.isArray(members) ? members : [members];
    if (membersToAdd.some((member) => this.options.avoidMembers.includes(member))) {
      this.options.avoidMembers = this.options.avoidMembers.filter((id2) => !membersToAdd.includes(id2));
    }
    this.options.members = [.../* @__PURE__ */ new Set([...this.options.members, ...membersToAdd])];
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Remove member elements
   * @param members - <zh/>  | <en/> single or multiple
   */
  removeMember(members) {
    const membersToRemove = Array.isArray(members) ? members : [members];
    this.options.members = this.options.members.filter((id2) => !membersToRemove.includes(id2));
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Update member elements
   * @param members - <zh/>  | <en/> value or callback function
   */
  updateMember(members) {
    this.options.members = isFunction$1(members) ? members(this.options.members) : members;
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Get member elements
   * @returns <zh/>  | <en/> member elements array
   */
  getMember() {
    return this.options.members;
  }
  /**
   * <zh/> 
   *
   * <en/> Add elements to avoid
   * @param avoidMembers - <zh/>  | <en/> single or multiple
   */
  addAvoidMember(avoidMembers) {
    const avoidMembersToAdd = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
    if (avoidMembersToAdd.some((avoidMember) => this.options.members.includes(avoidMember))) {
      this.options.members = this.options.members.filter((id2) => !avoidMembersToAdd.includes(id2));
    }
    this.options.avoidMembers = [.../* @__PURE__ */ new Set([...this.options.avoidMembers, ...avoidMembersToAdd])];
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Remove elements to avoid
   * @param avoidMembers - <zh/>  | <en/> single or multiple
   */
  removeAvoidMember(avoidMembers) {
    const avoidMembersToRemove = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
    if (this.options.avoidMembers.some((member) => avoidMembersToRemove.includes(member))) {
      this.options.avoidMembers = this.options.avoidMembers.filter((id2) => !avoidMembersToRemove.includes(id2));
      this.drawBubbleSets();
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Update elements to avoid
   * @param avoidMembers - <zh/>  | <en/> single or multiple
   */
  updateAvoidMember(avoidMembers) {
    this.options.avoidMembers = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Get elements to avoid
   * @returns avoidMembers <zh/>  | <en/> member elements array
   */
  getAvoidMember() {
    return this.options.avoidMembers;
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy
   * @internal
   */
  destroy() {
    this.context.graph.off(GraphEvent.AFTER_RENDER, this.drawBubbleSets);
    this.context.graph.off(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateBubbleSetsPath);
    if (this.shape) {
      this.shape.destroy();
      this.shape = void 0;
    }
    super.destroy();
  }
}
BubbleSets2.defaultOptions = Object.assign({
  members: [],
  avoidMembers: [],
  /** shape style */
  fill: "lightblue",
  fillOpacity: 0.2,
  stroke: "blue",
  strokeOpacity: 0.2
}, defaultOptions$1);
const convertToRectangle = (graph2, ids) => {
  const idArr = Array.isArray(ids) ? ids : [ids];
  return idArr.map((id2) => {
    const bbox = graph2.getElementRenderBounds(id2);
    return new Rectangle(bbox.min[0], bbox.min[1], getBBoxWidth(bbox), getBBoxHeight(bbox));
  });
};
const convertToLine = (graph2, ids) => {
  const idArr = Array.isArray(ids) ? ids : [ids];
  return idArr.map((id2) => {
    const data2 = graph2.getEdgeData(id2);
    const source = graph2.getElementPosition(data2.source);
    const target = graph2.getElementPosition(data2.target);
    return Line2.from({ x1: source[0], y1: source[1], x2: target[0], y2: target[1] });
  });
};
function getContentFromItems(items) {
  return `
    <ul class="g6-contextmenu-ul">
      ${items.map((item) => `<li  class="g6-contextmenu-li" value="${item.value}">${item.name}</li>`).join("")}
    </ul>
  `;
}
const CONTEXTMENU_CSS = `
  .g6-contextmenu {
    font-size: 12px;
    background-color: rgba(255, 255, 255, 0.96);
    border-radius: 4px;
    overflow: hidden;
    box-shadow: rgba(0, 0, 0, 0.12) 0px 6px 12px 0px;
    transition: visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1) 0s, left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s;
  }

  .g6-contextmenu-ul {
    max-width: 256px;
    min-width: 96px;
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .g6-contextmenu-li {
    padding: 8px 12px;
    cursor: pointer;
    user-select: none;
  }

  .g6-contextmenu-li:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
`;
var __awaiter$b = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Contextmenu extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Contextmenu.defaultOptions, options));
    this.targetElement = null;
    this.onTriggerEvent = (event) => {
      var _a3;
      (_a3 = event.preventDefault) === null || _a3 === void 0 ? void 0 : _a3.call(event);
      this.show(event);
    };
    this.onMenuItemClick = (event) => {
      const { onClick, trigger } = this.options;
      if (event.target instanceof HTMLElement) {
        if (event.target.className.includes("g6-contextmenu-li")) {
          const value = event.target.getAttribute("value");
          onClick === null || onClick === void 0 ? void 0 : onClick(value, event.target, this.targetElement);
          this.hide();
        }
      }
      if (trigger !== "click")
        this.hide();
    };
    this.initElement();
    this.update(options);
  }
  initElement() {
    this.$element = createPluginContainer("contextmenu", false, { zIndex: "99" });
    const { className } = this.options;
    if (className)
      this.$element.classList.add(className);
    const $container = this.context.canvas.getContainer();
    $container.appendChild(this.$element);
    insertDOM("g6-contextmenu-css", "style", {}, CONTEXTMENU_CSS, document.head);
  }
  /**
   * <zh/> 
   *
   * <en/> Show the contextmenu
   * @param event - <zh/>  | <en/> Element pointer event
   * @internal
   */
  show(event) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const { enable, offset } = this.options;
      if (typeof enable === "function" && !enable(event) || !enable) {
        this.hide();
        return;
      }
      const content = yield this.getDOMContent(event);
      if (content instanceof HTMLElement) {
        this.$element.innerHTML = "";
        this.$element.appendChild(content);
      } else {
        this.$element.innerHTML = content;
      }
      const clientRect = this.context.graph.getCanvas().getContainer().getBoundingClientRect();
      this.$element.style.left = `${event.client.x - clientRect.left + offset[0]}px`;
      this.$element.style.top = `${event.client.y - clientRect.top + offset[1]}px`;
      this.$element.style.display = "block";
      this.targetElement = event.target;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Hide the contextmenu
   */
  hide() {
    this.$element.style.display = "none";
    this.targetElement = null;
  }
  /**
   * <zh/> 
   *
   * <en/> Update the contextmenu options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the contextmenu
   * @internal
   */
  destroy() {
    this.unbindEvents();
    super.destroy();
    this.$element.remove();
  }
  getDOMContent(event) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const { getContent, getItems } = this.options;
      if (getItems) {
        return getContentFromItems(yield getItems(event));
      }
      return yield getContent(event);
    });
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    const { trigger } = this.options;
    graph2.on(`canvas:${trigger}`, this.onTriggerEvent);
    graph2.on(`node:${trigger}`, this.onTriggerEvent);
    graph2.on(`edge:${trigger}`, this.onTriggerEvent);
    graph2.on(`combo:${trigger}`, this.onTriggerEvent);
    document.addEventListener("click", this.onMenuItemClick);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    const { trigger } = this.options;
    graph2.off(`canvas:${trigger}`, this.onTriggerEvent);
    graph2.off(`node:${trigger}`, this.onTriggerEvent);
    graph2.off(`edge:${trigger}`, this.onTriggerEvent);
    graph2.off(`combo:${trigger}`, this.onTriggerEvent);
    document.removeEventListener("click", this.onMenuItemClick);
  }
}
Contextmenu.defaultOptions = {
  trigger: "contextmenu",
  offset: [4, 4],
  loadingContent: '<div class="g6-contextmenu-loading">Loading...</div>',
  getContent: () => "It is a empty context menu.",
  enable: () => true
};
class EdgeBundling extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, EdgeBundling.defaultOptions, options));
    this.edgeBundles = {};
    this.edgePoints = {};
    this.onBundle = () => {
      const { model, element } = this.context;
      const edges = model.getEdgeData();
      this.divideEdges(this.options.divisions);
      const { cycles, iterRate, divRate } = this.options;
      let { lambda, divisions, iterations } = this.options;
      for (let i2 = 0; i2 < cycles; i2++) {
        for (let j = 0; j < iterations; j++) {
          const forces = {};
          edges.forEach((edge) => {
            var _a3;
            if (edge.source === edge.target)
              return;
            const edgeId = idOf(edge);
            forces[edgeId] = this.getEdgeForces(edge, divisions, lambda);
            for (let p2 = 0; p2 < divisions + 1; p2++) {
              (_a3 = this.edgePoints)[edgeId] || (_a3[edgeId] = []);
              this.edgePoints[edgeId][p2] = add$4(this.edgePoints[edgeId][p2], forces[edgeId][p2]);
            }
          });
        }
        lambda /= 2;
        divisions *= divRate;
        iterations *= iterRate;
        this.divideEdges(divisions);
      }
      edges.forEach((edge) => {
        const edgeId = idOf(edge);
        const edgeEl = element.getElement(edgeId);
        edgeEl === null || edgeEl === void 0 ? void 0 : edgeEl.update({ d: getPolylinePath(this.edgePoints[edgeId]) });
      });
    };
    this.bindEvents();
  }
  get nodeMap() {
    const nodes = this.context.model.getNodeData();
    return Object.fromEntries(nodes.map((node) => [idOf(node), toVector2(positionOf(node))]));
  }
  divideEdges(divisions) {
    const edges = this.context.model.getEdgeData();
    edges.forEach((edge) => {
      var _a3;
      const edgeId = idOf(edge);
      (_a3 = this.edgePoints)[edgeId] || (_a3[edgeId] = []);
      const source = this.nodeMap[edge.source];
      const target = this.nodeMap[edge.target];
      if (divisions === 1) {
        this.edgePoints[edgeId].push(source);
        this.edgePoints[edgeId].push(divide(add$4(source, target), 2));
        this.edgePoints[edgeId].push(target);
      } else {
        const edgeLength = this.edgePoints[edgeId].length === 0 ? (
          // edge is a straight line
          distance$3(source, target)
        ) : (
          // edge is a polyline
          getEdgeLength(this.edgePoints[edgeId])
        );
        const divisionLength = edgeLength / (divisions + 1);
        let currentDivisionLength = divisionLength;
        const newEdgePoints = [source];
        for (let i2 = 1; i2 < this.edgePoints[edgeId].length; i2++) {
          const prevEp = this.edgePoints[edgeId][i2 - 1];
          const ep = this.edgePoints[edgeId][i2];
          let oriDivisionLength = distance$3(ep, prevEp);
          while (oriDivisionLength > currentDivisionLength) {
            const ratio = currentDivisionLength / oriDivisionLength;
            const edgePoint = add$4(prevEp, multiply(subtract(ep, prevEp), ratio));
            newEdgePoints.push(edgePoint);
            oriDivisionLength -= currentDivisionLength;
            currentDivisionLength = divisionLength;
          }
          currentDivisionLength -= oriDivisionLength;
        }
        newEdgePoints.push(target);
        this.edgePoints[edgeId] = newEdgePoints;
      }
    });
  }
  getVectorPosition(edge) {
    const source = this.nodeMap[edge.source];
    const target = this.nodeMap[edge.target];
    const [vx, vy] = subtract(target, source);
    const length2 = distance$3(source, target);
    return { source, target, vx, vy, length: length2 };
  }
  measureEdgeCompatibility(edge1, edge2) {
    const vector1 = this.getVectorPosition(edge1);
    const vector2 = this.getVectorPosition(edge2);
    const ac = getAngleCompatibility(vector1, vector2);
    const sc = getScaleCompatibility(vector1, vector2);
    const pc = getPositionCompatibility(vector1, vector2);
    const vc = getVisibilityCompatibility(vector1, vector2);
    return ac * sc * pc * vc;
  }
  getEdgeBundles() {
    const edgeBundles = {};
    const bundleThreshold = this.options.bundleThreshold;
    const edges = this.context.model.getEdgeData();
    edges.forEach((edge1, i2) => {
      edges.forEach((edge2, j) => {
        var _a3, _b;
        if (j <= i2)
          return;
        const compatibility = this.measureEdgeCompatibility(edge1, edge2);
        if (compatibility >= bundleThreshold) {
          edgeBundles[_a3 = idOf(edge1)] || (edgeBundles[_a3] = []);
          edgeBundles[idOf(edge1)].push(edge2);
          edgeBundles[_b = idOf(edge2)] || (edgeBundles[_b] = []);
          edgeBundles[idOf(edge2)].push(edge1);
        }
      });
    });
    return edgeBundles;
  }
  getSpringForce(divisions, kp) {
    const { pre, cur, next } = divisions;
    return multiply(subtract(add$4(pre, next), multiply(cur, 2)), kp);
  }
  getElectrostaticForce(pidx, edge) {
    if (isEmpty(this.edgeBundles)) {
      this.edgeBundles = this.getEdgeBundles();
    }
    const edgeBundle = this.edgeBundles[idOf(edge)];
    let resForce = [0, 0];
    edgeBundle === null || edgeBundle === void 0 ? void 0 : edgeBundle.forEach((eb) => {
      const p1 = this.edgePoints[idOf(eb)][pidx];
      const p2 = this.edgePoints[idOf(edge)][pidx];
      const force = subtract(p1, p2);
      const length2 = distance$3(p1, p2);
      resForce = add$4(resForce, multiply(force, 1 / length2));
    });
    return resForce;
  }
  getEdgeForces(edge, divisions, lambda) {
    const source = this.nodeMap[edge.source];
    const target = this.nodeMap[edge.target];
    const kp = this.options.K / (distance$3(source, target) * (divisions + 1));
    const edgePointForces = [[0, 0]];
    const edgeId = idOf(edge);
    for (let i2 = 1; i2 < divisions; i2++) {
      const spring = this.getSpringForce({
        pre: this.edgePoints[edgeId][i2 - 1],
        cur: this.edgePoints[edgeId][i2],
        next: this.edgePoints[edgeId][i2 + 1] || [0, 0]
      }, kp);
      const electrostatic = this.getElectrostaticForce(i2, edge);
      edgePointForces.push(multiply(add$4(spring, electrostatic), lambda));
    }
    edgePointForces.push([0, 0]);
    return edgePointForces;
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.AFTER_RENDER, this.onBundle);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.AFTER_RENDER, this.onBundle);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
}
EdgeBundling.defaultOptions = {
  K: 0.1,
  lambda: 0.1,
  divisions: 1,
  divRate: 2,
  cycles: 6,
  iterations: 90,
  iterRate: 2 / 3,
  bundleThreshold: 0.6
};
const getAngleCompatibility = (p2, q) => {
  return Math.abs(dot$1([p2.vx, p2.vy], [q.vx, q.vy]) / (p2.length * q.length));
};
const getScaleCompatibility = (p2, q) => {
  const aLength = (p2.length + q.length) / 2;
  return 2 / (aLength / Math.min(p2.length, q.length) + Math.max(p2.length, q.length) / aLength);
};
const getPositionCompatibility = (p2, q) => {
  const aLength = (p2.length + q.length) / 2;
  const pMid = divide(add$4(p2.source, p2.target), 2);
  const qMid = divide(add$4(q.source, q.target), 2);
  return aLength / (aLength + distance$3(pMid, qMid));
};
const projectPointToEdge = (p2, e3) => {
  if (e3.source[0] === e3.target[0])
    return [e3.source[0], p2[1]];
  if (e3.source[1] === e3.target[1])
    return [p2[0], e3.source[1]];
  const k = (e3.source[1] - e3.target[1]) / (e3.source[0] - e3.target[0]);
  const x2 = (k * k * e3.source[0] + k * (p2[1] - e3.source[1]) + p2[0]) / (k * k + 1);
  const y2 = k * (x2 - e3.source[0]) + e3.source[1];
  return [x2, y2];
};
const getEdgeVisibility = (p2, q) => {
  const is = projectPointToEdge(q.source, p2);
  const it = projectPointToEdge(q.target, p2);
  const iMid = divide(add$4(is, it), 2);
  const pMid = divide(add$4(p2.source, p2.target), 2);
  if (distance$3(is, it) === 0)
    return 0;
  return Math.max(0, 1 - 2 * distance$3(pMid, iMid) / distance$3(is, it));
};
const getVisibilityCompatibility = (p2, q) => {
  return Math.min(getEdgeVisibility(p2, q), getEdgeVisibility(q, p2));
};
const getEdgeLength = (points) => {
  let length2 = 0;
  for (let i2 = 1; i2 < points.length; i2++) {
    length2 += distance$3(points[i2], points[i2 - 1]);
  }
  return length2;
};
const defaultLensStyle$1 = {
  fill: "#fff",
  fillOpacity: 1,
  lineWidth: 1,
  stroke: "#000",
  strokeOpacity: 0.8,
  zIndex: -Infinity
};
const DELTA = 0.05;
class EdgeFilterLens extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, EdgeFilterLens.defaultOptions, options));
    this.shapes = /* @__PURE__ */ new Map();
    this.r = this.options.r;
    this.onEdgeFilter = (event) => {
      if (this.options.trigger === "drag" && this.isLensOn)
        return;
      const origin = parsePoint(event.canvas);
      this.renderLens(origin);
      this.renderFocusElements();
    };
    this.renderLens = (origin) => {
      const style = Object.assign({}, defaultLensStyle$1, this.options.style);
      if (!this.isLensOn) {
        this.lens = new Circle$1({ style });
        this.canvas.appendChild(this.lens);
      }
      Object.assign(style, toPointObject(origin), { size: this.r * 2 });
      this.lens.update(style);
    };
    this.getFilterData = () => {
      const { filter: filter2 } = this.options;
      const { model } = this.context;
      const data2 = model.getData();
      if (!filter2)
        return data2;
      const { nodes, edges, combos } = data2;
      return {
        nodes: nodes.filter((node) => filter2(idOf(node), "node")),
        edges: edges.filter((edge) => filter2(idOf(edge), "edge")),
        combos: combos.filter((combo) => filter2(idOf(combo), "combo"))
      };
    };
    this.getFocusElements = (origin) => {
      const { nodes, edges } = this.getFilterData();
      const focusNodes = nodes.filter((datum) => distance$3(positionOf(datum), origin) < this.r);
      const focusNodeIds = focusNodes.map((node) => idOf(node));
      const focusEdges = edges.filter((datum) => {
        const { source, target } = datum;
        const isSourceFocus = focusNodeIds.includes(source);
        const isTargetFocus = focusNodeIds.includes(target);
        switch (this.options.nodeType) {
          case "both":
            return isSourceFocus && isTargetFocus;
          case "either":
            return isSourceFocus !== isTargetFocus;
          case "source":
            return isSourceFocus && !isTargetFocus;
          case "target":
            return !isSourceFocus && isTargetFocus;
          default:
            return false;
        }
      });
      return { nodes: focusNodes, edges: focusEdges };
    };
    this.renderFocusElements = () => {
      const { element, graph: graph2 } = this.context;
      if (!this.isLensOn)
        return;
      const origin = this.lens.getCenter();
      const { nodes, edges } = this.getFocusElements(origin);
      const ids = /* @__PURE__ */ new Set();
      const iterate = (datum) => {
        const id2 = idOf(datum);
        ids.add(id2);
        const shape = element.getElement(id2);
        if (!shape)
          return;
        const cloneShape = this.shapes.get(id2) || shape.cloneNode();
        cloneShape.setPosition(shape.getPosition());
        cloneShape.id = shape.id;
        if (!this.shapes.has(id2)) {
          this.canvas.appendChild(cloneShape);
          this.shapes.set(id2, cloneShape);
        } else {
          Object.entries(shape.attributes).forEach(([key, value]) => {
            if (cloneShape.style[key] !== value)
              cloneShape.style[key] = value;
          });
        }
        const elementType = graph2.getElementType(id2);
        const style = this.getElementStyle(elementType, datum);
        cloneShape.update(style);
      };
      nodes.forEach(iterate);
      edges.forEach(iterate);
      this.shapes.forEach((shape, id2) => {
        if (!ids.has(id2)) {
          shape.destroy();
          this.shapes.delete(id2);
        }
      });
    };
    this.scaleRByWheel = (event) => {
      var _a3;
      if (this.options.preventDefault)
        event.preventDefault();
      const { clientX, clientY, deltaX, deltaY } = event;
      const { graph: graph2, canvas: canvas2 } = this.context;
      const scaleOrigin = graph2.getCanvasByClient([clientX, clientY]);
      const origin = (_a3 = this.lens) === null || _a3 === void 0 ? void 0 : _a3.getCenter();
      if (!this.isLensOn || distance$3(scaleOrigin, origin) > this.r) {
        return;
      }
      const { maxR, minR } = this.options;
      const ratio = deltaX + deltaY > 0 ? 1 / (1 - DELTA) : 1 - DELTA;
      const canvasR = Math.min(...canvas2.getSize()) / 2;
      this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));
      this.renderLens(origin);
      this.renderFocusElements();
    };
    this.isLensDragging = false;
    this.onDragStart = (event) => {
      var _a3;
      const dragOrigin = parsePoint(event.canvas);
      const origin = (_a3 = this.lens) === null || _a3 === void 0 ? void 0 : _a3.getCenter();
      if (!this.isLensOn || distance$3(dragOrigin, origin) > this.r)
        return;
      this.isLensDragging = true;
    };
    this.onDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const dragOrigin = parsePoint(event.canvas);
      this.renderLens(dragOrigin);
      this.renderFocusElements();
    };
    this.onDragEnd = () => {
      this.isLensDragging = false;
    };
    this.bindEvents();
  }
  get canvas() {
    return this.context.canvas.getLayer("transient");
  }
  get isLensOn() {
    return this.lens && !this.lens.destroyed;
  }
  getElementStyle(elementType, datum) {
    const styler = elementType === "node" ? this.options.nodeStyle : this.options.edgeStyle;
    if (typeof styler === "function")
      return styler(datum);
    return styler;
  }
  get graphDom() {
    return this.context.graph.getCanvas().getContextService().getDomElement();
  }
  bindEvents() {
    var _a3;
    const { graph: graph2 } = this.context;
    const { trigger, scaleRBy } = this.options;
    const canvas2 = graph2.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.addEventListener(CommonEvent.CLICK, this.onEdgeFilter);
    }
    if (trigger === "pointermove") {
      canvas2.addEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);
    } else if (trigger === "drag") {
      canvas2.addEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.addEventListener(CommonEvent.DRAG, this.onDrag);
      canvas2.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);
    }
    if (scaleRBy === "wheel") {
      (_a3 = this.graphDom) === null || _a3 === void 0 ? void 0 : _a3.addEventListener(CommonEvent.WHEEL, this.scaleRByWheel, { passive: false });
    }
  }
  unbindEvents() {
    var _a3;
    const { graph: graph2 } = this.context;
    const { trigger, scaleRBy } = this.options;
    const canvas2 = graph2.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.removeEventListener(CommonEvent.CLICK, this.onEdgeFilter);
    }
    if (trigger === "pointermove") {
      canvas2.removeEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);
    } else if (trigger === "drag") {
      canvas2.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.removeEventListener(CommonEvent.DRAG, this.onDrag);
      canvas2.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);
    }
    if (scaleRBy === "wheel") {
      (_a3 = this.graphDom) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(CommonEvent.WHEEL, this.scaleRByWheel);
    }
  }
  update(options) {
    var _a3;
    this.unbindEvents();
    super.update(options);
    this.r = (_a3 = options.r) !== null && _a3 !== void 0 ? _a3 : this.r;
    this.bindEvents();
  }
  destroy() {
    this.unbindEvents();
    if (this.isLensOn) {
      this.lens.destroy();
    }
    this.shapes.forEach((shape, id2) => {
      shape.destroy();
      this.shapes.delete(id2);
    });
    super.destroy();
  }
}
EdgeFilterLens.defaultOptions = {
  trigger: "pointermove",
  r: 60,
  nodeType: "both",
  filter: () => true,
  style: { lineWidth: 2 },
  nodeStyle: { label: false },
  edgeStyle: { label: true },
  scaleRBy: "wheel",
  preventDefault: true
};
const defaultLensStyle = {
  fill: "#ccc",
  fillOpacity: 0.1,
  lineWidth: 2,
  stroke: "#000",
  strokeOpacity: 0.8,
  labelFontSize: 12
};
const R_DELTA = 0.05;
const D_DELTA = 0.1;
class Fisheye extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Fisheye.defaultOptions, options));
    this.r = this.options.r;
    this.d = this.options.d;
    this.onCreateFisheye = (event) => {
      if (this.options.trigger === "drag" && this.isLensOn)
        return;
      const origin = parsePoint(event.canvas);
      this.onMagnify(origin);
    };
    this.onMagnify = (origin) => {
      if (origin.some(isNaN))
        return;
      this.renderLens(origin);
      this.renderFocusElements();
    };
    this.renderLens = (origin) => {
      const style = Object.assign({}, defaultLensStyle, this.options.style);
      if (!this.isLensOn) {
        this.lens = new Circle$1({ style });
        this.canvas.appendChild(this.lens);
      }
      Object.assign(style, toPointObject(origin), {
        size: this.r * 2,
        label: this.options.showDPercent,
        labelText: this.getDPercent()
      });
      this.lens.update(style);
    };
    this.getDPercent = () => {
      const { minD, maxD } = this.options;
      const percent2 = Math.round((this.d - minD) / (maxD - minD) * 100);
      return `${percent2}%`;
    };
    this.prevMagnifiedStyleMap = /* @__PURE__ */ new Map();
    this.prevOriginStyleMap = /* @__PURE__ */ new Map();
    this.renderFocusElements = () => {
      if (!this.isLensOn)
        return;
      const { graph: graph2 } = this.context;
      const origin = this.lens.getCenter();
      const molecularParam = (this.d + 1) * this.r;
      const magnifiedStyleMap = /* @__PURE__ */ new Map();
      const originStyleMap = /* @__PURE__ */ new Map();
      const nodeData = graph2.getNodeData();
      nodeData.forEach((datum) => {
        const position2 = positionOf(datum);
        const distanceToOrigin = distance$3(position2, origin);
        if (distanceToOrigin > this.r)
          return;
        const magnifiedDistance = molecularParam * distanceToOrigin / (this.d * distanceToOrigin + this.r);
        const [nodeX, nodeY] = position2;
        const [originX, originY] = origin;
        const cos = (nodeX - originX) / distanceToOrigin;
        const sin = (nodeY - originY) / distanceToOrigin;
        const newPoint = [originX + magnifiedDistance * cos, originY + magnifiedDistance * sin];
        const nodeId = idOf(datum);
        const style = this.getNodeStyle(datum);
        const originStyle = pick(graph2.getElementRenderStyle(nodeId), Object.keys(style));
        magnifiedStyleMap.set(nodeId, Object.assign(Object.assign({}, toPointObject(newPoint)), style));
        originStyleMap.set(nodeId, Object.assign(Object.assign({}, toPointObject(position2)), originStyle));
      });
      this.updateStyle(magnifiedStyleMap, originStyleMap);
    };
    this.getNodeStyle = (datum) => {
      const { nodeStyle } = this.options;
      return typeof nodeStyle === "function" ? nodeStyle(datum) : nodeStyle;
    };
    this.updateStyle = (magnifiedStyleMap, originStyleMap) => {
      const { graph: graph2, element } = this.context;
      const { enter, exit, keep } = arrayDiff(Array.from(this.prevMagnifiedStyleMap.keys()), Array.from(magnifiedStyleMap.keys()), (d3) => d3);
      const relatedEdges = /* @__PURE__ */ new Set();
      const update = (nodeId, style) => {
        const node = element.getElement(nodeId);
        node === null || node === void 0 ? void 0 : node.update(style);
        graph2.getRelatedEdgesData(nodeId).forEach((datum) => {
          relatedEdges.add(idOf(datum));
        });
      };
      [...enter, ...keep].forEach((nodeId) => {
        update(nodeId, magnifiedStyleMap.get(nodeId));
      });
      exit.forEach((nodeId) => {
        update(nodeId, this.prevOriginStyleMap.get(nodeId));
        this.prevOriginStyleMap.delete(nodeId);
      });
      relatedEdges.forEach((edgeId) => {
        const edge = element.getElement(edgeId);
        edge === null || edge === void 0 ? void 0 : edge.update({});
      });
      this.prevMagnifiedStyleMap = magnifiedStyleMap;
      originStyleMap.forEach((style, nodeId) => {
        if (!this.prevOriginStyleMap.has(nodeId)) {
          this.prevOriginStyleMap.set(nodeId, style);
        }
      });
    };
    this.isWheelValid = (event) => {
      if (this.options.preventDefault)
        event.preventDefault();
      if (!this.isLensOn)
        return false;
      const { clientX, clientY } = event;
      const scaleOrigin = this.context.graph.getCanvasByClient([clientX, clientY]);
      const origin = this.lens.getCenter();
      if (distance$3(scaleOrigin, origin) > this.r)
        return false;
      return true;
    };
    this.scaleR = (positive) => {
      const { maxR, minR } = this.options;
      const ratio = positive ? 1 / (1 - R_DELTA) : 1 - R_DELTA;
      const canvasR = Math.min(...this.context.canvas.getSize()) / 2;
      this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));
    };
    this.scaleD = (positive) => {
      const { maxD, minD } = this.options;
      const newD = positive ? this.d + D_DELTA : this.d - D_DELTA;
      this.d = Math.max(minD, Math.min(maxD, newD));
    };
    this.scaleRByWheel = (event) => {
      if (!this.isWheelValid(event))
        return;
      const { deltaX, deltaY } = event;
      this.scaleR(deltaX + deltaY > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.scaleDByWheel = (event) => {
      if (!this.isWheelValid(event))
        return;
      const { deltaX, deltaY } = event;
      this.scaleD(deltaX + deltaY > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.isDragValid = (event) => {
      if (this.options.preventDefault)
        event.preventDefault();
      if (!this.isLensOn)
        return false;
      const dragOrigin = parsePoint(event.canvas);
      const origin = this.lens.getCenter();
      if (distance$3(dragOrigin, origin) > this.r)
        return false;
      return true;
    };
    this.isLensDragging = false;
    this.onDragStart = (event) => {
      if (!this.isDragValid(event))
        return;
      this.isLensDragging = true;
    };
    this.onDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const dragOrigin = parsePoint(event.canvas);
      this.onMagnify(dragOrigin);
    };
    this.onDragEnd = () => {
      this.isLensDragging = false;
    };
    this.scaleRByDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const { dx, dy } = event;
      this.scaleR(dx - dy > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.scaleDByDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const { dx, dy } = event;
      this.scaleD(dx - dy > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.bindEvents();
  }
  get canvas() {
    return this.context.canvas.getLayer("transient");
  }
  get isLensOn() {
    return this.lens && !this.lens.destroyed;
  }
  get graphDom() {
    return this.context.graph.getCanvas().getContextService().getDomElement();
  }
  bindEvents() {
    var _a3;
    const { graph: graph2 } = this.context;
    const { trigger, scaleRBy, scaleDBy } = this.options;
    const canvas2 = graph2.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.addEventListener(CommonEvent.CLICK, this.onCreateFisheye);
    }
    if (trigger === "pointermove") {
      canvas2.addEventListener(CommonEvent.POINTER_MOVE, this.onCreateFisheye);
    }
    if (trigger === "drag" || scaleRBy === "drag" || scaleDBy === "drag") {
      canvas2.addEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);
      const dragFunc = trigger === "drag" ? this.onDrag : scaleRBy === "drag" ? this.scaleRByDrag : this.scaleDByDrag;
      canvas2.addEventListener(CommonEvent.DRAG, dragFunc);
    }
    if (scaleRBy === "wheel" || scaleDBy === "wheel") {
      const wheelFunc = scaleRBy === "wheel" ? this.scaleRByWheel : this.scaleDByWheel;
      (_a3 = this.graphDom) === null || _a3 === void 0 ? void 0 : _a3.addEventListener(CommonEvent.WHEEL, wheelFunc, { passive: false });
    }
  }
  unbindEvents() {
    var _a3;
    const { graph: graph2 } = this.context;
    const { trigger, scaleRBy, scaleDBy } = this.options;
    const canvas2 = graph2.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.removeEventListener(CommonEvent.CLICK, this.onCreateFisheye);
    }
    if (trigger === "pointermove") {
      canvas2.removeEventListener(CommonEvent.POINTER_MOVE, this.onCreateFisheye);
    }
    if (trigger === "drag" || scaleRBy === "drag" || scaleDBy === "drag") {
      canvas2.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);
      const dragFunc = trigger === "drag" ? this.onDrag : scaleRBy === "drag" ? this.scaleRByDrag : this.scaleDByDrag;
      canvas2.removeEventListener(CommonEvent.DRAG, dragFunc);
    }
    if (scaleRBy === "wheel" || scaleDBy === "wheel") {
      const wheelFunc = scaleRBy === "wheel" ? this.scaleRByWheel : this.scaleDByWheel;
      (_a3 = this.graphDom) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(CommonEvent.WHEEL, wheelFunc);
    }
  }
  update(options) {
    var _a3, _b;
    this.unbindEvents();
    super.update(options);
    this.r = (_a3 = options.r) !== null && _a3 !== void 0 ? _a3 : this.r;
    this.d = (_b = options.d) !== null && _b !== void 0 ? _b : this.d;
    this.bindEvents();
  }
  destroy() {
    var _a3;
    this.unbindEvents();
    if (this.isLensOn) {
      (_a3 = this.lens) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    }
    this.prevMagnifiedStyleMap.clear();
    this.prevOriginStyleMap.clear();
    super.destroy();
  }
}
Fisheye.defaultOptions = {
  trigger: "pointermove",
  r: 120,
  d: 1.5,
  maxD: 5,
  minD: 0,
  showDPercent: true,
  style: {},
  nodeStyle: { label: true },
  preventDefault: true
};
class Fullscreen extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Fullscreen.defaultOptions, options));
    this.$el = this.context.canvas.getContainer();
    this.graphSize = [0, 0];
    this.onFullscreenChange = () => {
      var _a3, _b, _c, _d;
      const isFull = !!document.fullscreenElement;
      if (this.options.autoFit)
        this.setGraphSize(isFull);
      if (isFull) {
        (_b = (_a3 = this.options).onEnter) === null || _b === void 0 ? void 0 : _b.call(_a3);
      } else {
        (_d = (_c = this.options).onExit) === null || _d === void 0 ? void 0 : _d.call(_c);
      }
    };
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
    this.style = document.createElement("style");
    document.head.appendChild(this.style);
    this.style.innerHTML = `
      :not(:root):fullscreen::backdrop {
        background: transparent;
      }
    `;
  }
  bindEvents() {
    this.unbindEvents();
    this.shortcut.unbindAll();
    const { request = [], exit = [] } = this.options.trigger;
    this.shortcut.bind(request, this.request);
    this.shortcut.bind(exit, this.exit);
    const events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];
    events.forEach((eventName) => {
      document.addEventListener(eventName, this.onFullscreenChange, false);
    });
  }
  unbindEvents() {
    this.shortcut.unbindAll();
    const events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];
    events.forEach((eventName) => {
      document.removeEventListener(eventName, this.onFullscreenChange, false);
    });
  }
  setGraphSize(fullScreen = true) {
    var _a3, _b;
    let width2, height;
    if (fullScreen) {
      width2 = ((_a3 = globalThis.screen) === null || _a3 === void 0 ? void 0 : _a3.width) || 0;
      height = ((_b = globalThis.screen) === null || _b === void 0 ? void 0 : _b.height) || 0;
      this.graphSize = this.context.graph.getSize();
    } else {
      [width2, height] = this.graphSize;
    }
    this.context.graph.setSize(width2, height);
    this.context.graph.render();
  }
  /**
   * <zh/> 
   *
   * <en/> Request full screen
   */
  request() {
    if (document.fullscreenElement || !isFullscreenEnabled())
      return;
    this.$el.requestFullscreen().catch((err) => {
      print.warn(`Error attempting to enable full-screen: ${err.message} (${err.name})`);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Exit full screen
   */
  exit() {
    if (!document.fullscreenElement)
      return;
    document.exitFullscreen();
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  destroy() {
    this.exit();
    this.style.remove();
    super.destroy();
  }
}
Fullscreen.defaultOptions = {
  trigger: {},
  autoFit: true
};
function isFullscreenEnabled() {
  return document.fullscreenEnabled || // <zh/>  Reflect  ts  | <en/> use Reflect to avoid ts checking
  Reflect.get(document, "webkitFullscreenEnabled") || Reflect.get(document, "mozFullscreenEnabled") || Reflect.get(document, "msFullscreenEnabled");
}
class GridLine extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, GridLine.defaultOptions, options));
    this.$element = createPluginContainer("grid-line", true);
    this.offset = [0, 0];
    this.currentScale = 1;
    this.followZoom = (event) => {
      const { data: { scale: scale3, origin } } = event;
      if (!scale3 || origin === void 0 && this.context.viewport === void 0)
        return;
      const prevScale = this.currentScale;
      this.currentScale = scale3;
      const deltaScale = scale3 / prevScale;
      const positionOffset = multiply(origin || this.context.graph.getCanvasCenter(), 1 - deltaScale);
      const scaledSize = this.baseSize * scale3;
      const scaledOffset = multiply(this.offset, deltaScale);
      const modulatedOffset = mod(scaledOffset, scaledSize);
      const newOffset = add$4(modulatedOffset, positionOffset);
      this.$element.style.backgroundSize = `${scaledSize}px ${scaledSize}px`;
      this.$element.style.backgroundPosition = `${newOffset[0]}px ${newOffset[1]}px`;
      this.offset = mod(newOffset, scaledSize);
    };
    this.followTranslate = (event) => {
      if (!this.options.follow)
        return;
      const { data: { translate: translate4 } } = event;
      if (translate4)
        this.updateOffset(translate4);
    };
    this.onTransform = (event) => {
      const follow = this.parseFollow(this.options.follow);
      if (follow.zoom)
        this.followZoom(event);
      if (follow.translate)
        this.followTranslate(event);
    };
    const $container = this.context.canvas.getContainer();
    $container.prepend(this.$element);
    this.baseSize = this.options.size;
    this.updateStyle();
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update the configuration of the grid line
   * @param options - <zh/>  | <en/> options
   * @internal
   */
  update(options) {
    super.update(options);
    if (options.size !== void 0) {
      this.baseSize = options.size;
    }
    this.updateStyle();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  updateStyle() {
    const { stroke, lineWidth, border, borderLineWidth, borderStroke, borderStyle } = this.options;
    const scaledSize = this.baseSize * this.currentScale;
    Object.assign(this.$element.style, {
      border: border ? `${borderLineWidth}px ${borderStyle} ${borderStroke}` : "none",
      backgroundImage: `linear-gradient(${stroke} ${lineWidth}px, transparent ${lineWidth}px), linear-gradient(90deg, ${stroke} ${lineWidth}px, transparent ${lineWidth}px)`,
      backgroundSize: `${scaledSize}px ${scaledSize}px`,
      backgroundRepeat: "repeat"
    });
  }
  updateOffset(delta) {
    const scaledSize = this.baseSize * this.currentScale;
    this.offset = mod(add$4(this.offset, delta), scaledSize);
    this.$element.style.backgroundPosition = `${this.offset[0]}px ${this.offset[1]}px`;
  }
  parseFollow(follow) {
    var _a3, _b;
    return isBoolean(follow) ? { translate: follow, zoom: follow } : { translate: (_a3 = follow === null || follow === void 0 ? void 0 : follow.translate) !== null && _a3 !== void 0 ? _a3 : false, zoom: (_b = follow === null || follow === void 0 ? void 0 : follow.zoom) !== null && _b !== void 0 ? _b : false };
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the grid line
   * @internal
   */
  destroy() {
    this.context.graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    this.$element.remove();
    super.destroy();
  }
}
GridLine.defaultOptions = {
  border: true,
  borderLineWidth: 1,
  borderStroke: "#eee",
  borderStyle: "solid",
  lineWidth: 1,
  size: 20,
  stroke: "#eee"
};
function reduceDataChanges(changes) {
  const results = {
    Added: /* @__PURE__ */ new Map(),
    Updated: /* @__PURE__ */ new Map(),
    Removed: /* @__PURE__ */ new Map()
  };
  changes.forEach((change) => {
    const { type, value } = change;
    const id2 = idOf(value);
    if (type === "NodeAdded" || type === "EdgeAdded" || type === "ComboAdded") {
      results.Added.set(id2, change);
    } else if (type === "NodeUpdated" || type === "EdgeUpdated" || type === "ComboUpdated") {
      if (results.Added.has(id2)) {
        results.Added.set(id2, { type: type.replace("Updated", "Added"), value });
      } else if (results.Updated.has(id2)) {
        const { original } = results.Updated.get(id2);
        results.Updated.set(id2, { type, value, original });
      } else if (results.Removed.has(id2)) ;
      else
        results.Updated.set(id2, change);
    } else if (type === "NodeRemoved" || type === "EdgeRemoved" || type === "ComboRemoved") {
      if (results.Added.has(id2)) {
        results.Added.delete(id2);
      } else if (results.Updated.has(id2)) {
        results.Updated.delete(id2);
        results.Removed.set(id2, change);
      } else {
        results.Removed.set(id2, change);
      }
    }
  });
  return [
    ...Array.from(results.Added.values()),
    ...Array.from(results.Updated.values()),
    ...Array.from(results.Removed.values())
  ];
}
function groupByChangeType(changes) {
  const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [] } = groupBy$1(changes, (change) => change.type);
  return {
    add: {
      nodes: NodeAdded,
      edges: EdgeAdded,
      combos: ComboAdded
    },
    update: {
      nodes: NodeUpdated,
      edges: EdgeUpdated,
      combos: ComboUpdated
    },
    remove: {
      nodes: NodeRemoved,
      edges: EdgeRemoved,
      combos: ComboRemoved
    }
  };
}
function alignFields(refObject, targetObject) {
  for (const key in refObject) {
    if (isObject$2(refObject[key]) && !Array.isArray(refObject[key]) && refObject[key] !== null) {
      if (!targetObject[key])
        targetObject[key] = {};
      alignFields(refObject[key], targetObject[key]);
    } else if (targetObject[key] === void 0) {
      targetObject[key] = inferDefaultValue(key);
    }
  }
}
function parseCommand(changes, animation = false, context) {
  const cmd = {
    animation,
    current: { add: {}, update: {}, remove: {} },
    original: { add: {}, update: {}, remove: {} }
  };
  const { add: add2, update, remove } = groupByChangeType(reduceDataChanges(changes));
  ["nodes", "edges", "combos"].forEach((category) => {
    if (update[category]) {
      update[category].forEach((item) => {
        var _a3, _b;
        const newValue = Object.assign({}, item.value);
        let newOriginal = Object.assign({}, item.original);
        if (context) {
          const itemType = context.graph.getElementType(idOf(item.original));
          const colorKey = itemType === "edge" ? "stroke" : "fill";
          const style = context.element.getElementComputedStyle(itemType, item.original);
          newOriginal = Object.assign(Object.assign({}, item.original), { style: Object.assign({ [colorKey]: style[colorKey] }, item.original.style) });
        }
        alignFields(newValue, newOriginal);
        (_a3 = cmd.current.update)[category] || (_a3[category] = []);
        cmd.current.update[category].push(newValue);
        (_b = cmd.original.update)[category] || (_b[category] = []);
        cmd.original.update[category].push(newOriginal);
      });
    }
    if (add2[category]) {
      add2[category].forEach((item) => {
        var _a3, _b;
        const newValue = Object.assign({}, item.value);
        (_a3 = cmd.current.add)[category] || (_a3[category] = []);
        cmd.current.add[category].push(newValue);
        (_b = cmd.original.remove)[category] || (_b[category] = []);
        cmd.original.remove[category].push(newValue);
      });
    }
    if (remove[category]) {
      remove[category].forEach((item) => {
        var _a3, _b;
        const newValue = Object.assign({}, item.value);
        (_a3 = cmd.current.remove)[category] || (_a3[category] = []);
        cmd.current.remove[category].push(newValue);
        (_b = cmd.original.add)[category] || (_b[category] = []);
        cmd.original.add[category].push(newValue);
      });
    }
  });
  return cmd;
}
class History extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, History.defaultOptions, options));
    this.batchChanges = null;
    this.batchAnimation = false;
    this.undoStack = [];
    this.redoStack = [];
    this.freezed = false;
    this.executeCommand = (cmd, revert = true) => {
      var _a3, _b, _c;
      this.freezed = true;
      (_b = (_a3 = this.options).executeCommand) === null || _b === void 0 ? void 0 : _b.call(_a3, cmd);
      const values2 = revert ? cmd.original : cmd.current;
      this.context.graph.addData(values2.add);
      this.context.graph.updateData(values2.update);
      this.context.graph.removeData(idsOf(values2.remove, false));
      (_c = this.context.element) === null || _c === void 0 ? void 0 : _c.draw({ silence: true, animation: cmd.animation });
      this.freezed = false;
    };
    this.addCommand = (event) => {
      var _a3;
      if (this.freezed)
        return;
      if (event.type === GraphEvent.AFTER_DRAW) {
        const { dataChanges = [], animation = true } = event.data;
        if ((_a3 = this.context.batch) === null || _a3 === void 0 ? void 0 : _a3.isBatching) {
          if (!this.batchChanges)
            return;
          this.batchChanges.push(dataChanges);
          this.batchAnimation && (this.batchAnimation = animation);
          return;
        }
        this.batchChanges = [dataChanges];
        this.batchAnimation = animation;
      }
      this.undoStackPush(parseCommand(this.batchChanges.flat(), this.batchAnimation, this.context));
      this.notify(HistoryEvent.ADD, this.undoStack[this.undoStack.length - 1]);
    };
    this.initBatchCommand = (event) => {
      const { initiate } = event.data;
      this.batchAnimation = false;
      if (initiate) {
        this.batchChanges = [];
      } else {
        const cmd = this.undoStack.pop();
        if (!cmd)
          this.batchChanges = null;
      }
    };
    this.emitter = new EventEmitter();
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.AFTER_DRAW, this.addCommand);
    graph2.on(GraphEvent.BATCH_START, this.initBatchCommand);
    graph2.on(GraphEvent.BATCH_END, this.addCommand);
  }
  /**
   * <zh/> 
   *
   * <en/> Whether undo can be done
   * @returns <zh/>  | <en/> Whether undo can be done
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * <zh/> 
   *
   * <en/> Whether redo can be done
   * @returns <zh/>  | <en/> Whether redo can be done
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  /**
   * <zh/> 
   *
   * <en/> Execute undo
   * @returns <zh/>  | <en/> Return the current instance
   */
  undo() {
    var _a3, _b, _c, _d;
    const cmd = this.undoStack.pop();
    if (cmd) {
      this.executeCommand(cmd);
      const before = (_b = (_a3 = this.options).beforeAddCommand) === null || _b === void 0 ? void 0 : _b.call(_a3, cmd, false);
      if (before === false)
        return;
      this.redoStack.push(cmd);
      (_d = (_c = this.options).afterAddCommand) === null || _d === void 0 ? void 0 : _d.call(_c, cmd, false);
      this.notify(HistoryEvent.UNDO, cmd);
    }
    return this;
  }
  /**
   * <zh/> 
   *
   * <en/> Execute redo
   * @returns <zh/>  | <en/> Return the current instance
   */
  redo() {
    const cmd = this.redoStack.pop();
    if (cmd) {
      this.executeCommand(cmd, false);
      this.undoStackPush(cmd);
      this.notify(HistoryEvent.REDO, cmd);
    }
    return this;
  }
  /**
   * <zh/> 
   *
   * <en/> Execute undo and do not record in history
   * @returns <zh/>  | <en/> Return the current instance
   */
  undoAndCancel() {
    const cmd = this.undoStack.pop();
    if (cmd) {
      this.executeCommand(cmd, false);
      this.redoStack = [];
      this.notify(HistoryEvent.CANCEL, cmd);
    }
    return this;
  }
  undoStackPush(cmd) {
    var _a3, _b, _c, _d;
    const { stackSize } = this.options;
    if (stackSize !== 0 && this.undoStack.length >= stackSize) {
      this.undoStack.shift();
    }
    const before = (_b = (_a3 = this.options).beforeAddCommand) === null || _b === void 0 ? void 0 : _b.call(_a3, cmd, true);
    if (before === false)
      return;
    this.undoStack.push(cmd);
    (_d = (_c = this.options).afterAddCommand) === null || _d === void 0 ? void 0 : _d.call(_c, cmd, true);
  }
  /**
   * <zh/> 
   *
   * <en/> Clear history
   */
  clear() {
    this.undoStack = [];
    this.redoStack = [];
    this.batchChanges = null;
    this.batchAnimation = false;
    this.notify(HistoryEvent.CLEAR, null);
  }
  notify(event, cmd) {
    this.emitter.emit(event, { cmd });
    this.emitter.emit(HistoryEvent.CHANGE, { cmd });
  }
  /**
   * <zh/> 
   *
   * <en/> Listen to history events
   * @param event  - <zh/>  | <en/> Event name
   * @param handler - <zh/>  | <en/> Event handler
   */
  on(event, handler) {
    this.emitter.on(event, handler);
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy
   * @internal
   */
  destroy() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.AFTER_DRAW, this.addCommand);
    graph2.off(GraphEvent.BATCH_START, this.initBatchCommand);
    graph2.off(GraphEvent.BATCH_END, this.addCommand);
    this.emitter.off();
    super.destroy();
    this.undoStack = [];
    this.redoStack = [];
  }
}
History.defaultOptions = {
  stackSize: 0
};
const formatUtil = {
  toXy(pointset, format2) {
    if (!format2)
      return [...pointset];
    const xProperty = format2[0].slice(1);
    const yProperty = format2[1].slice(1);
    return pointset.map((pt) => [pt[xProperty], pt[yProperty]]);
  },
  fromXy(coordinates, format2) {
    if (!format2)
      return [...coordinates];
    const xProperty = format2[0].slice(1);
    const yProperty = format2[1].slice(1);
    return coordinates.map(([x2, y2]) => ({
      [xProperty]: x2,
      [yProperty]: y2
    }));
  }
};
let Grid$1 = class Grid {
  constructor(points, cellSize) {
    this._cells = [];
    this._cellSize = cellSize;
    this._reverseCellSize = 1 / cellSize;
    for (const point2 of points) {
      const x2 = this.coordToCellNum(point2[0]);
      const y2 = this.coordToCellNum(point2[1]);
      if (!this._cells[x2]) {
        this._cells[x2] = [];
      }
      if (!this._cells[x2][y2]) {
        this._cells[x2][y2] = [];
      }
      this._cells[x2][y2].push(point2);
    }
  }
  cellPoints(x2, y2) {
    var _a3;
    return ((_a3 = this._cells[x2]) === null || _a3 === void 0 ? void 0 : _a3[y2]) || [];
  }
  rangePoints(bbox) {
    const tlCellX = this.coordToCellNum(bbox[0]);
    const tlCellY = this.coordToCellNum(bbox[1]);
    const brCellX = this.coordToCellNum(bbox[2]);
    const brCellY = this.coordToCellNum(bbox[3]);
    const points = [];
    for (let x2 = tlCellX; x2 <= brCellX; x2++) {
      for (let y2 = tlCellY; y2 <= brCellY; y2++) {
        const cell = this.cellPoints(x2, y2);
        for (const point2 of cell) {
          points.push(point2);
        }
      }
    }
    return points;
  }
  removePoint(point2) {
    const cellX = this.coordToCellNum(point2[0]);
    const cellY = this.coordToCellNum(point2[1]);
    const cell = this._cells[cellX][cellY];
    const index2 = cell.findIndex(([px2, py]) => px2 === point2[0] && py === point2[1]);
    if (index2 > -1) {
      cell.splice(index2, 1);
    }
    return cell;
  }
  trunc(val) {
    return Math.trunc(val);
  }
  coordToCellNum(x2) {
    return this.trunc(x2 * this._reverseCellSize);
  }
  extendBbox(bbox, scaleFactor) {
    return [
      bbox[0] - scaleFactor * this._cellSize,
      bbox[1] - scaleFactor * this._cellSize,
      bbox[2] + scaleFactor * this._cellSize,
      bbox[3] + scaleFactor * this._cellSize
    ];
  }
};
function grid(points, cellSize) {
  return new Grid$1(points, cellSize);
}
const SPLITTER = +(Math.pow(2, 27) + 1);
function twoProduct(a2, b2, result) {
  const x2 = a2 * b2;
  const c2 = SPLITTER * a2;
  const a_big = c2 - a2;
  const ahi = c2 - a_big;
  const alo = a2 - ahi;
  const d3 = SPLITTER * b2;
  const b_big = d3 - b2;
  const bhi = d3 - b_big;
  const blo = b2 - bhi;
  const err1 = x2 - ahi * bhi;
  const err2 = err1 - alo * bhi;
  const err3 = err2 - ahi * blo;
  const y2 = alo * blo - err3;
  if (result) {
    result[0] = y2;
    result[1] = x2;
    return result;
  }
  return [y2, x2];
}
function fastTwoSum(a2, b2, result) {
  const x2 = a2 + b2;
  const bv = x2 - a2;
  const av = x2 - bv;
  const br = b2 - bv;
  const ar = a2 - av;
  if (result) {
    result[0] = ar + br;
    result[1] = x2;
    return result;
  }
  return [ar + br, x2];
}
function scaleLinearExpansion(e3, scale3) {
  const n2 = e3.length;
  if (n2 === 1) {
    const ts = twoProduct(e3[0], scale3);
    if (ts[0]) {
      return ts;
    }
    return [ts[1]];
  }
  const g2 = new Array(2 * n2);
  const q = [0.1, 0.1];
  const t3 = [0.1, 0.1];
  let count = 0;
  twoProduct(e3[0], scale3, q);
  if (q[0]) {
    g2[count++] = q[0];
  }
  for (let i2 = 1; i2 < n2; ++i2) {
    twoProduct(e3[i2], scale3, t3);
    const pq = q[1];
    fastTwoSum(pq, t3[0], q);
    if (q[0]) {
      g2[count++] = q[0];
    }
    const a2 = t3[1];
    const b2 = q[1];
    const x2 = a2 + b2;
    const bv = x2 - a2;
    const y2 = b2 - bv;
    q[1] = x2;
    if (y2) {
      g2[count++] = y2;
    }
  }
  if (q[1]) {
    g2[count++] = q[1];
  }
  if (count === 0) {
    g2[count++] = 0;
  }
  g2.length = count;
  return g2;
}
function scalarScalar$1(a2, b2) {
  const x2 = a2 + b2;
  const bv = x2 - a2;
  const av = x2 - bv;
  const br = b2 - bv;
  const ar = a2 - av;
  const y2 = ar + br;
  if (y2) {
    return [y2, x2];
  }
  return [x2];
}
function robustSubtract(e3, f2) {
  const ne = e3.length | 0;
  const nf = f2.length | 0;
  if (ne === 1 && nf === 1) {
    return scalarScalar$1(e3[0], -f2[0]);
  }
  const n2 = ne + nf;
  const g2 = new Array(n2);
  let count = 0;
  let ep_tr = 0;
  let fp_tr = 0;
  const abs = Math.abs;
  let ei = e3[ep_tr];
  let ea = abs(ei);
  let fi = -f2[fp_tr];
  let fa = abs(fi);
  let a2, b2;
  if (ea < fa) {
    b2 = ei;
    ep_tr += 1;
    if (ep_tr < ne) {
      ei = e3[ep_tr];
      ea = abs(ei);
    }
  } else {
    b2 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = -f2[fp_tr];
      fa = abs(fi);
    }
  }
  if (ep_tr < ne && ea < fa || fp_tr >= nf) {
    a2 = ei;
    ep_tr += 1;
    if (ep_tr < ne) {
      ei = e3[ep_tr];
      ea = abs(ei);
    }
  } else {
    a2 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = -f2[fp_tr];
      fa = abs(fi);
    }
  }
  let x2 = a2 + b2;
  let bv = x2 - a2;
  let y2 = b2 - bv;
  let q0 = y2;
  let q1 = x2;
  let _x, _bv, _av, _br, _ar;
  while (ep_tr < ne && fp_tr < nf) {
    if (ea < fa) {
      a2 = ei;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e3[ep_tr];
        ea = abs(ei);
      }
    } else {
      a2 = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = -f2[fp_tr];
        fa = abs(fi);
      }
    }
    b2 = q0;
    x2 = a2 + b2;
    bv = x2 - a2;
    y2 = b2 - bv;
    if (y2) {
      g2[count++] = y2;
    }
    _x = q1 + x2;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x2 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while (ep_tr < ne) {
    a2 = ei;
    b2 = q0;
    x2 = a2 + b2;
    bv = x2 - a2;
    y2 = b2 - bv;
    if (y2) {
      g2[count++] = y2;
    }
    _x = q1 + x2;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x2 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    ep_tr += 1;
    if (ep_tr < ne) {
      ei = e3[ep_tr];
    }
  }
  while (fp_tr < nf) {
    a2 = fi;
    b2 = q0;
    x2 = a2 + b2;
    bv = x2 - a2;
    y2 = b2 - bv;
    if (y2) {
      g2[count++] = y2;
    }
    _x = q1 + x2;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x2 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = -f2[fp_tr];
    }
  }
  if (q0) {
    g2[count++] = q0;
  }
  if (q1) {
    g2[count++] = q1;
  }
  if (!count) {
    g2[count++] = 0;
  }
  g2.length = count;
  return g2;
}
function scalarScalar(a2, b2) {
  const x2 = a2 + b2;
  const bv = x2 - a2;
  const av = x2 - bv;
  const br = b2 - bv;
  const ar = a2 - av;
  const y2 = ar + br;
  if (y2) {
    return [y2, x2];
  }
  return [x2];
}
function linearExpansionSum(e3, f2) {
  const ne = e3.length | 0;
  const nf = f2.length | 0;
  if (ne === 1 && nf === 1) {
    return scalarScalar(e3[0], f2[0]);
  }
  const n2 = ne + nf;
  const g2 = new Array(n2);
  let count = 0;
  let ep_tr = 0;
  let fp_tr = 0;
  const abs = Math.abs;
  let ei = e3[ep_tr];
  let ea = abs(ei);
  let fi = f2[fp_tr];
  let fa = abs(fi);
  let a2, b2;
  if (ea < fa) {
    b2 = ei;
    ep_tr += 1;
    if (ep_tr < ne) {
      ei = e3[ep_tr];
      ea = abs(ei);
    }
  } else {
    b2 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = f2[fp_tr];
      fa = abs(fi);
    }
  }
  if (ep_tr < ne && ea < fa || fp_tr >= nf) {
    a2 = ei;
    ep_tr += 1;
    if (ep_tr < ne) {
      ei = e3[ep_tr];
      ea = abs(ei);
    }
  } else {
    a2 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = f2[fp_tr];
      fa = abs(fi);
    }
  }
  let x2 = a2 + b2;
  let bv = x2 - a2;
  let y2 = b2 - bv;
  let q0 = y2;
  let q1 = x2;
  let _x, _bv, _av, _br, _ar;
  while (ep_tr < ne && fp_tr < nf) {
    if (ea < fa) {
      a2 = ei;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e3[ep_tr];
        ea = abs(ei);
      }
    } else {
      a2 = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = f2[fp_tr];
        fa = abs(fi);
      }
    }
    b2 = q0;
    x2 = a2 + b2;
    bv = x2 - a2;
    y2 = b2 - bv;
    if (y2) {
      g2[count++] = y2;
    }
    _x = q1 + x2;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x2 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while (ep_tr < ne) {
    a2 = ei;
    b2 = q0;
    x2 = a2 + b2;
    bv = x2 - a2;
    y2 = b2 - bv;
    if (y2) {
      g2[count++] = y2;
    }
    _x = q1 + x2;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x2 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    ep_tr += 1;
    if (ep_tr < ne) {
      ei = e3[ep_tr];
    }
  }
  while (fp_tr < nf) {
    a2 = fi;
    b2 = q0;
    x2 = a2 + b2;
    bv = x2 - a2;
    y2 = b2 - bv;
    if (y2) {
      g2[count++] = y2;
    }
    _x = q1 + x2;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x2 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = f2[fp_tr];
    }
  }
  if (q0) {
    g2[count++] = q0;
  }
  if (q1) {
    g2[count++] = q1;
  }
  if (!count) {
    g2[count++] = 0;
  }
  g2.length = count;
  return g2;
}
const NUM_EXPAND = 5;
const EPSILON = 11102230246251565e-32;
const ERR_BOUND_3 = (3 + 16 * EPSILON) * EPSILON;
const ERR_BOUND_4 = (7 + 56 * EPSILON) * EPSILON;
function orientation_3(sum, prod, scale3, sub2) {
  return function orientation3Exact2(m0, m1, m22) {
    const p2 = sum(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
    const n2 = sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0]));
    const d3 = sub2(p2, n2);
    return d3[d3.length - 1];
  };
}
function orientation_4(sum, prod, scale3, sub2) {
  return function orientation4Exact2(m0, m1, m22, m3) {
    const p2 = sum(sum(scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m1[2]), sum(scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m22[2]), scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m3[2]))), sum(scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));
    const n2 = sum(sum(scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m0[2]), sum(scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m22[2]), scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m3[2]))), sum(scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m22[2]))));
    const d3 = sub2(p2, n2);
    return d3[d3.length - 1];
  };
}
function orientation_5(sum, prod, scale3, sub2) {
  return function orientation5Exact(m0, m1, m22, m3, m4) {
    const p2 = sum(sum(sum(scale3(sum(scale3(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m22[2]), sum(scale3(sum(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), -m3[2]), scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m4[2]))), m1[3]), sum(scale3(sum(scale3(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale3(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m22[3]), scale3(sum(scale3(sum(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m1[2]), sum(scale3(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m22[2]), scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m4[2]))), m3[3]))), sum(scale3(sum(scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m1[2]), sum(scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m22[2]), scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m3[2]))), -m4[3]), sum(scale3(sum(scale3(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale3(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale3(sum(scale3(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale3(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale3(sum(scale3(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale3(sum(scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale3(sum(scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m1[2]), sum(scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m22[2]), scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m3[2]))), m0[3]))), sum(scale3(sum(scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m0[2]), sum(scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m22[2]), scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m3[2]))), -m1[3]), sum(scale3(sum(scale3(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m22[3]), scale3(sum(scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m22[2]))), -m3[3])))));
    const n2 = sum(sum(sum(scale3(sum(scale3(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m22[2]), sum(scale3(sum(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), -m3[2]), scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m4[2]))), m0[3]), scale3(sum(scale3(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale3(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m22[3])), sum(scale3(sum(scale3(sum(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m0[2]), sum(scale3(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m22[2]), scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m4[2]))), m3[3]), scale3(sum(scale3(sum(prod(m22[1], m3[0]), prod(-m3[1], m22[0])), m0[2]), sum(scale3(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m22[2]), scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale3(sum(scale3(sum(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m1[2]), sum(scale3(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m22[2]), scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m4[2]))), m0[3]), scale3(sum(scale3(sum(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m0[2]), sum(scale3(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m22[2]), scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m4[2]))), -m1[3])), sum(scale3(sum(scale3(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m22[3]), scale3(sum(scale3(sum(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m0[2]), sum(scale3(sum(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), -m1[2]), scale3(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m22[2]))), -m4[3]))));
    const d3 = sub2(p2, n2);
    return d3[d3.length - 1];
  };
}
function orientation(n2) {
  const fn = n2 === 3 ? orientation_3 : n2 === 4 ? orientation_4 : orientation_5;
  return fn(linearExpansionSum, twoProduct, scaleLinearExpansion, robustSubtract);
}
const orientation3Exact = orientation(3);
const orientation4Exact = orientation(4);
const CACHED = [
  function orientation0() {
    return 0;
  },
  function orientation1() {
    return 0;
  },
  function orientation2(a2, b2) {
    return b2[0] - a2[0];
  },
  function orientation3(a2, b2, c2) {
    const l2 = (a2[1] - c2[1]) * (b2[0] - c2[0]);
    const r2 = (a2[0] - c2[0]) * (b2[1] - c2[1]);
    const det = l2 - r2;
    let s3;
    if (l2 > 0) {
      if (r2 <= 0) {
        return det;
      } else {
        s3 = l2 + r2;
      }
    } else if (l2 < 0) {
      if (r2 >= 0) {
        return det;
      } else {
        s3 = -(l2 + r2);
      }
    } else {
      return det;
    }
    const tol = ERR_BOUND_3 * s3;
    if (det >= tol || det <= -tol) {
      return det;
    }
    return orientation3Exact(a2, b2, c2);
  },
  function orientation4(a2, b2, c2, d3) {
    const adx = a2[0] - d3[0];
    const bdx = b2[0] - d3[0];
    const cdx = c2[0] - d3[0];
    const ady = a2[1] - d3[1];
    const bdy = b2[1] - d3[1];
    const cdy = c2[1] - d3[1];
    const adz = a2[2] - d3[2];
    const bdz = b2[2] - d3[2];
    const cdz = c2[2] - d3[2];
    const bdx_cdy = bdx * cdy;
    const cdx_bdy = cdx * bdy;
    const cdx_ady = cdx * ady;
    const adx_cdy = adx * cdy;
    const adx_bdy = adx * bdy;
    const bdx_ady = bdx * ady;
    const det = adz * (bdx_cdy - cdx_bdy) + bdz * (cdx_ady - adx_cdy) + cdz * (adx_bdy - bdx_ady);
    const permanent = (Math.abs(bdx_cdy) + Math.abs(cdx_bdy)) * Math.abs(adz) + (Math.abs(cdx_ady) + Math.abs(adx_cdy)) * Math.abs(bdz) + (Math.abs(adx_bdy) + Math.abs(bdx_ady)) * Math.abs(cdz);
    const tol = ERR_BOUND_4 * permanent;
    if (det > tol || -det > tol) {
      return det;
    }
    return orientation4Exact(a2, b2, c2, d3);
  }
];
function slowOrient(args) {
  let proc2 = CACHED[args.length];
  if (!proc2) {
    proc2 = CACHED[args.length] = orientation(args.length);
  }
  return proc2.apply(void 0, ...args);
}
function proc(slow, o0, o1, o2, o3, o4, o5) {
  return function getOrientation(...args) {
    switch (args.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(args[0], args[1]);
      case 3:
        return o3(args[0], args[1], args[2]);
      case 4:
        return o4(args[0], args[1], args[2], args[3]);
      case 5:
        return o5(args[0], args[1], args[2], args[3], args[4]);
    }
    return slow(args);
  };
}
function generateOrientationProc() {
  while (CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length));
  }
  const orientationProc = proc(void 0, slowOrient, ...CACHED);
  for (let i2 = 0; i2 <= NUM_EXPAND; ++i2) {
    orientationProc[i2] = CACHED[i2];
  }
  return orientationProc;
}
const orient$1 = generateOrientationProc();
const orient = orient$1[3];
function monotoneConvexHull2D(points) {
  const n2 = points.length;
  if (n2 < 3) {
    const result2 = new Array(n2);
    for (let i2 = 0; i2 < n2; ++i2) {
      result2[i2] = i2;
    }
    if (n2 === 2 && points[0][0] === points[1][0] && points[0][1] === points[1][1]) {
      return [0];
    }
    return result2;
  }
  const sorted = new Array(n2);
  for (let i2 = 0; i2 < n2; ++i2) {
    sorted[i2] = i2;
  }
  sorted.sort((a2, b2) => {
    const d3 = points[a2][0] - points[b2][0];
    if (d3) {
      return d3;
    }
    return points[a2][1] - points[b2][1];
  });
  const lower2 = [sorted[0], sorted[1]];
  const upper2 = [sorted[0], sorted[1]];
  for (let i2 = 2; i2 < n2; ++i2) {
    const idx = sorted[i2];
    const p2 = points[idx];
    let m3 = lower2.length;
    while (m3 > 1 && orient(points[lower2[m3 - 2]], points[lower2[m3 - 1]], p2) <= 0) {
      m3 -= 1;
      lower2.pop();
    }
    lower2.push(idx);
    m3 = upper2.length;
    while (m3 > 1 && orient(points[upper2[m3 - 2]], points[upper2[m3 - 1]], p2) >= 0) {
      m3 -= 1;
      upper2.pop();
    }
    upper2.push(idx);
  }
  const result = new Array(upper2.length + lower2.length - 2);
  let ptr = 0;
  for (let i2 = 0, nl = lower2.length; i2 < nl; ++i2) {
    result[ptr++] = lower2[i2];
  }
  for (let j = upper2.length - 2; j > 0; --j) {
    result[ptr++] = upper2[j];
  }
  return result;
}
function checkCollinear(a0, a1, b0, b1) {
  for (let d3 = 0; d3 < 2; ++d3) {
    const x0 = a0[d3];
    const y0 = a1[d3];
    const [l0, h0] = [Math.min(x0, y0), Math.max(x0, y0)];
    const x1 = b0[d3];
    const y1 = b1[d3];
    const [l1, h1] = [Math.min(x1, y1), Math.max(x1, y1)];
    if (h1 < l0 || h0 < l1)
      return false;
  }
  return true;
}
function segmentsIntersect(a0, a1, b0, b1) {
  const x0 = orient$1(a0, b0, b1);
  const y0 = orient$1(a1, b0, b1);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0)
    return false;
  const x1 = orient$1(b0, a0, a1);
  const y1 = orient$1(b1, a0, a1);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0)
    return false;
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1);
  }
  return true;
}
function _filterDuplicates(pointset) {
  const unique = [pointset[0]];
  let lastPoint = pointset[0];
  for (let i2 = 1; i2 < pointset.length; i2++) {
    const currentPoint = pointset[i2];
    if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
      unique.push(currentPoint);
    }
    lastPoint = currentPoint;
  }
  return unique;
}
function _sortByX(pointset) {
  return pointset.sort(function(a2, b2) {
    return a2[0] - b2[0] || a2[1] - b2[1];
  });
}
function _sqLength(a2, b2) {
  return Math.pow(b2[0] - a2[0], 2) + Math.pow(b2[1] - a2[1], 2);
}
function _cos(o2, a2, b2) {
  const aShifted = [a2[0] - o2[0], a2[1] - o2[1]], bShifted = [b2[0] - o2[0], b2[1] - o2[1]], sqALen = _sqLength(o2, a2), sqBLen = _sqLength(o2, b2), dot2 = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];
  return dot2 / Math.sqrt(sqALen * sqBLen);
}
function _intersect(segment, pointset) {
  for (let i2 = 0; i2 < pointset.length - 1; i2++) {
    const seg = [pointset[i2], pointset[i2 + 1]];
    if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
      continue;
    }
    if (segmentsIntersect(segment[0], segment[1], seg[0], seg[1])) {
      return true;
    }
  }
  return false;
}
function _occupiedArea(pointset) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (let i2 = pointset.length - 1; i2 >= 0; i2--) {
    if (pointset[i2][0] < minX) {
      minX = pointset[i2][0];
    }
    if (pointset[i2][1] < minY) {
      minY = pointset[i2][1];
    }
    if (pointset[i2][0] > maxX) {
      maxX = pointset[i2][0];
    }
    if (pointset[i2][1] > maxY) {
      maxY = pointset[i2][1];
    }
  }
  return [
    maxX - minX,
    // width
    maxY - minY
    // height
  ];
}
function _bBoxAround(edge) {
  return [
    Math.min(edge[0][0], edge[1][0]),
    // left
    Math.min(edge[0][1], edge[1][1]),
    // top
    Math.max(edge[0][0], edge[1][0]),
    // right
    Math.max(edge[0][1], edge[1][1])
    // bottom
  ];
}
function _midPoint(edge, innerPoints, convex) {
  let point2 = null, angle1Cos = MAX_CONCAVE_ANGLE_COS, angle2Cos = MAX_CONCAVE_ANGLE_COS, a1Cos, a2Cos;
  for (let i2 = 0; i2 < innerPoints.length; i2++) {
    a1Cos = _cos(edge[0], edge[1], innerPoints[i2]);
    a2Cos = _cos(edge[1], edge[0], innerPoints[i2]);
    if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([edge[0], innerPoints[i2]], convex) && !_intersect([edge[1], innerPoints[i2]], convex)) {
      angle1Cos = a1Cos;
      angle2Cos = a2Cos;
      point2 = innerPoints[i2];
    }
  }
  return point2;
}
function _concave(convex, maxSqEdgeLen, maxSearchArea, grid2, edgeSkipList) {
  let midPointInserted = false;
  for (let i2 = 0; i2 < convex.length - 1; i2++) {
    const edge = [convex[i2], convex[i2 + 1]];
    const keyInSkipList = edge[0][0] + "," + edge[0][1] + "," + edge[1][0] + "," + edge[1][1];
    if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) {
      continue;
    }
    let scaleFactor = 0;
    let bBoxAround = _bBoxAround(edge);
    let bBoxWidth;
    let bBoxHeight;
    let midPoint2;
    do {
      bBoxAround = grid2.extendBbox(bBoxAround, scaleFactor);
      bBoxWidth = bBoxAround[2] - bBoxAround[0];
      bBoxHeight = bBoxAround[3] - bBoxAround[1];
      midPoint2 = _midPoint(edge, grid2.rangePoints(bBoxAround), convex);
      scaleFactor++;
    } while (midPoint2 === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));
    if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
      edgeSkipList.add(keyInSkipList);
    }
    if (midPoint2 !== null) {
      convex.splice(i2 + 1, 0, midPoint2);
      grid2.removePoint(midPoint2);
      midPointInserted = true;
    }
  }
  if (midPointInserted) {
    return _concave(convex, maxSqEdgeLen, maxSearchArea, grid2, edgeSkipList);
  }
  return convex;
}
function hull(pointset, concavity, format2) {
  const maxEdgeLen = concavity || 20;
  const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format2)));
  if (points.length < 4) {
    const concave2 = points.concat([points[0]]);
    return format2 ? formatUtil.fromXy(concave2, format2) : concave2;
  }
  const occupiedArea = _occupiedArea(points);
  const maxSearchArea = [
    occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,
    occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT
  ];
  const convex = monotoneConvexHull2D(points).reverse().map((idx) => points[idx]);
  convex.push(convex[0]);
  const innerPoints = points.filter(function(pt) {
    return convex.indexOf(pt) < 0;
  });
  const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));
  const concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), /* @__PURE__ */ new Set());
  return format2 ? formatUtil.fromXy(concave, format2) : concave;
}
const MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI));
const MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;
function computeHullPath(points, padding, corner) {
  if (points.length === 1)
    return genSinglePointHullPath(points[0], padding, corner);
  if (points.length === 2)
    return genTwoPointsHullPath(points, padding, corner);
  if (points.length === 3) {
    const [p1, p2, p3] = sortByClockwise(points);
    if (isCollinear(p1, p2, p3))
      return genTwoPointsHullPath([p1, p3], padding, corner);
  }
  switch (corner) {
    case "smooth":
      return genMultiPointsSmoothHull(points, padding);
    case "sharp":
      return genMultiPointsSharpHull(points, padding);
    case "rounded":
    default:
      return genMultiPointsRoundedHull(points, padding);
  }
}
const genSinglePointHullPath = (point2, padding, corner) => {
  if (corner === "sharp")
    return [
      ["M", point2[0] - padding, point2[1] - padding],
      ["L", point2[0] + padding, point2[1] - padding],
      ["L", point2[0] + padding, point2[1] + padding],
      ["L", point2[0] - padding, point2[1] + padding],
      ["Z"]
    ];
  const arcData = [padding, padding, 0, 0, 0];
  return [
    ["M", point2[0], point2[1] - padding],
    ["A", ...arcData, point2[0], point2[1] + padding],
    ["A", ...arcData, point2[0], point2[1] - padding]
  ];
};
const genTwoPointsHullPath = (points, padding, corner) => {
  const arcData = [padding, padding, 0, 0, 0];
  const point1 = corner === "sharp" ? add$4(points[0], scale$1(normalize$4(subtract(points[0], points[1])), padding)) : points[0];
  const point2 = corner === "sharp" ? add$4(points[1], scale$1(normalize$4(subtract(points[1], points[0])), padding)) : points[1];
  const offsetVector = scale$1(normalize$4(perpendicular(subtract(point1, point2), false)), padding);
  const invOffsetVector = scale$1(offsetVector, -1);
  const prev = add$4(point1, offsetVector);
  const current2 = add$4(point2, offsetVector);
  const p2 = add$4(point2, invOffsetVector);
  const p3 = add$4(point1, invOffsetVector);
  if (corner === "sharp") {
    return [["M", prev[0], prev[1]], ["L", current2[0], current2[1]], ["L", p2[0], p2[1]], ["L", p3[0], p3[1]], ["Z"]];
  }
  return [
    ["M", prev[0], prev[1]],
    ["L", current2[0], current2[1]],
    ["A", ...arcData, p2[0], p2[1]],
    ["L", p3[0], p3[1]],
    ["A", ...arcData, prev[0], prev[1]]
  ];
};
const genMultiPointsRoundedHull = (points, padding) => {
  const segments = sortByClockwise(points).map((current2, i2) => {
    const prev2Index = (i2 - 2 + points.length) % points.length;
    const prevIndex = (i2 - 1 + points.length) % points.length;
    const nextIndex = (i2 + 1) % points.length;
    const prev2 = points[prev2Index];
    const prev = points[prevIndex];
    const next = points[nextIndex];
    const v0 = subtract(prev2, prev);
    const v1 = subtract(prev, current2);
    const v2 = subtract(current2, next);
    const isConcave = (v12, v22) => {
      return angle(v12, v22, true) < Math.PI;
    };
    const concavePrev = isConcave(v0, v1);
    const concaveNext = isConcave(v1, v2);
    const offsetVector = (v3) => scale$1(normalize$4(perpendicular(v3, false)), padding);
    const offset = offsetVector(v1);
    return [
      {
        p: toVector2(concavePrev ? add$4(prev, offsetVector(v0)) : add$4(prev, offset)),
        concave: concavePrev && prev
      },
      {
        p: toVector2(concaveNext ? add$4(current2, offsetVector(v2)) : add$4(current2, offset)),
        concave: concaveNext && current2
      }
    ];
  });
  const arcData = [padding, padding, 0, 0, 0];
  const startIndex = segments.findIndex((segment, i2) => !segments[(i2 - 1 + segments.length) % segments.length][0].concave && !segments[(i2 - 1 + segments.length) % segments.length][1].concave && !segment[0].concave && !segment[0].concave && !segment[1].concave);
  const sortedSegments = segments.slice(startIndex).concat(segments.slice(0, startIndex));
  let concavePoints = [];
  return sortedSegments.flatMap((segment, i2) => {
    const pathFragment = [];
    const lastSegment = sortedSegments[segments.length - 1];
    if (i2 === 0)
      pathFragment.push(["M", ...lastSegment[1].p]);
    if (!segment[0].concave) {
      pathFragment.push(["A", ...arcData, ...segment[0].p]);
    } else {
      concavePoints.push(segment[0].p, segment[1].p);
    }
    if (!segment[1].concave) {
      pathFragment.push(["L", ...segment[1].p]);
    } else {
      concavePoints.unshift(segment[1].p);
    }
    if (concavePoints.length === 3) {
      pathFragment.pop();
      pathFragment.push(["C", ...concavePoints.flat()]);
      concavePoints = [];
    }
    return pathFragment;
  });
};
const genMultiPointsSmoothHull = (points, padding) => {
  const hullPoints = sortByClockwise(points).map((p2, i2) => {
    const pNext = points[(i2 + 1) % points.length];
    return { p: p2, v: normalize$4(subtract(pNext, p2)) };
  });
  hullPoints.forEach((hp, i2) => {
    const priorIndex = i2 > 0 ? i2 - 1 : points.length - 1;
    const prevV = hullPoints[priorIndex].v;
    const extensionVec = normalize$4(add$4(prevV, scale$1(hp.v, angle(prevV, hp.v, true) < Math.PI ? 1 : -1)));
    hp.p = add$4(hp.p, scale$1(extensionVec, padding));
  });
  return getClosedSpline(hullPoints.map((obj) => obj.p));
};
const genMultiPointsSharpHull = (points, padding) => {
  const segments = points.map((current2, i2) => {
    const prev = points[i2 === 0 ? points.length - 1 : i2 - 1];
    const offset = toVector3(scale$1(normalize$4(perpendicular(subtract(prev, current2), false)), padding));
    return [add$4(prev, offset), add$4(current2, offset)];
  });
  const arr = segments.flat();
  const vertices = arr.map((_2, i2) => {
    if (i2 % 2 === 0)
      return null;
    const l1 = [arr[(i2 - 1) % arr.length], arr[i2 % arr.length]];
    const l2 = [arr[(i2 + 1) % arr.length], arr[(i2 + 2) % arr.length]];
    return getLinesIntersection(l1, l2, true);
  }).filter(Boolean);
  return vertices.map((point2, i2) => [i2 === 0 ? "M" : "L", point2[0], point2[1]]).concat([["Z"]]);
};
var __rest$7 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class Hull extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Hull.defaultOptions, options));
    this.hullMemberIds = [];
    this.drawHull = () => {
      if (!this.shape) {
        this.shape = new Contour({ style: this.getHullStyle() });
        this.context.canvas.appendChild(this.shape);
      } else {
        const forceUpdate = !isEqual$1(this.optionsCache, this.options);
        this.shape.update(this.getHullStyle(forceUpdate));
      }
      this.optionsCache = Object.assign({}, this.options);
    };
    this.updateHullPath = (event) => {
      if (!this.shape)
        return;
      if (!this.options.members.includes(idOf(event.data)))
        return;
      this.shape.update({ d: this.getHullPath(true) });
    };
    this.getHullPath = (forceUpdate = false) => {
      const { graph: graph2 } = this.context;
      const members = this.getMember();
      if (members.length === 0)
        return "";
      const data2 = members.map((id2) => graph2.getNodeData(id2));
      const vertices = hull(data2.map(positionOf), this.options.concavity).slice(1).reverse();
      const hullMemberIds = vertices.flatMap((point2) => data2.filter((m3) => isEqual$1(positionOf(m3), point2)).map(idOf));
      if (isEqual$1(hullMemberIds, this.hullMemberIds) && !forceUpdate)
        return this.path;
      this.hullMemberIds = hullMemberIds;
      this.path = computeHullPath(vertices, this.getPadding(), this.options.corner);
      return this.path;
    };
    this.bindEvents();
  }
  bindEvents() {
    this.context.graph.on(GraphEvent.AFTER_RENDER, this.drawHull);
    this.context.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateHullPath);
  }
  unbindEvents() {
    this.context.graph.off(GraphEvent.AFTER_RENDER, this.drawHull);
    this.context.graph.off(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateHullPath);
  }
  getHullStyle(forceUpdate) {
    const _a3 = this.options, { members, padding, corner } = _a3, style = __rest$7(_a3, ["members", "padding", "corner"]);
    return Object.assign(Object.assign({}, style), { d: this.getHullPath(forceUpdate) });
  }
  getPadding() {
    const { graph: graph2 } = this.context;
    const memberPadding = this.hullMemberIds.reduce((acc, id2) => {
      const { halfExtents } = graph2.getElementRenderBounds(id2);
      const size = Math.max(halfExtents[0], halfExtents[1]);
      return Math.max(acc, size);
    }, 0);
    return memberPadding + this.options.padding;
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Add Hull member
   * @param members - <zh/>  Ids | <en/> Element Ids
   */
  addMember(members) {
    const membersToAdd = Array.isArray(members) ? members : [members];
    this.options.members = [.../* @__PURE__ */ new Set([...this.options.members, ...membersToAdd])];
    this.shape.update({ d: this.getHullPath() });
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Remove Hull member
   * @param members - <zh/>  Ids | <en/> Element Ids
   */
  removeMember(members) {
    const membersToRemove = Array.isArray(members) ? members : [members];
    this.options.members = this.options.members.filter((id2) => !membersToRemove.includes(id2));
    if (membersToRemove.some((id2) => this.hullMemberIds.includes(id2))) {
      this.shape.update({ d: this.getHullPath() });
    }
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Update Hull member
   * @param members - <zh/>  Ids | <en/> Element Ids
   */
  updateMember(members) {
    this.options.members = isFunction$1(members) ? members(this.options.members) : members;
    this.shape.update(this.getHullStyle(true));
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Get Hull member
   * @returns <zh/>  Ids | <en/> Element Ids
   */
  getMember() {
    return this.options.members;
  }
  /**
   * <zh/>  Hull
   *
   * <en/> Destroy Hull
   * @internal
   */
  destroy() {
    this.unbindEvents();
    this.shape.destroy();
    this.hullMemberIds = [];
    super.destroy();
  }
}
Hull.defaultOptions = {
  members: [],
  padding: 10,
  corner: "rounded",
  concavity: Infinity,
  /** hull style */
  fill: "lightblue",
  fillOpacity: 0.2,
  labelOpacity: 1,
  stroke: "blue",
  strokeOpacity: 0.2
};
function traverse(element, callback) {
  callback(element);
  if (element.children) {
    element.children.forEach(function(child) {
      if (child)
        traverse(child, callback);
    });
  }
}
function show(element) {
  visibility(element, true);
}
function hide(element) {
  visibility(element, false);
}
function visibility(element, visible) {
  var value = visible ? "visible" : "hidden";
  traverse(element, function(node) {
    node.attr("visibility", value);
  });
}
var OffscreenGroup = (
  /** @class */
  function(_super) {
    __extends$1(OffscreenGroup2, _super);
    function OffscreenGroup2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this2 = _super.apply(this, __spreadArray([], __read(args), false)) || this;
      _this2.isMutationObserved = true;
      _this2.addEventListener(ElementEvent.INSERTED, function() {
        hide(_this2);
      });
      return _this2;
    }
    return OffscreenGroup2;
  }(Group)
);
function createOffscreenGroup(container) {
  var group2 = container.appendChild(new OffscreenGroup({
    class: "offscreen"
  }));
  hide(group2);
  return group2;
}
function isInOffscreenGroup(group2) {
  var ancestor = group2;
  while (ancestor) {
    if (ancestor.className === "offscreen") {
      return true;
    }
    ancestor = ancestor.parent;
  }
  return false;
}
var Text = (
  /** @class */
  function(_super) {
    __extends$1(Text2, _super);
    function Text2(_a3) {
      if (_a3 === void 0) {
        _a3 = {};
      }
      var style = _a3.style, restOptions = __rest$m(_a3, ["style"]);
      return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
    }
    Object.defineProperty(Text2.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Text2.prototype.disconnectedCallback = function() {
      var _a3;
      (_a3 = this._offscreen) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    };
    return Text2;
  }(Text$1)
);
function degToRad(deg3) {
  return deg3 * Math.PI / 180;
}
function radToDeg(rad3) {
  return Number((rad3 * 180 / Math.PI).toPrecision(5));
}
var BBox = (
  /** @class */
  function() {
    function BBox2(x2, y2, width2, height) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width2 === void 0) {
        width2 = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.x = x2;
      this.y = y2;
      this.width = width2;
      this.height = height;
    }
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    BBox2.fromRect = function(other) {
      return new BBox2(other.x, other.y, other.width, other.height);
    };
    BBox2.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        top: this.top,
        right: this.right,
        bottom: this.bottom,
        left: this.left
      };
    };
    BBox2.prototype.isPointIn = function(x2, y2) {
      return x2 >= this.left && x2 <= this.right && y2 >= this.top && y2 <= this.bottom;
    };
    return BBox2;
  }()
);
function getCallbackValue(value, params) {
  return isFunction$1(value) ? value.apply(void 0, __spreadArray([], __read(params), false)) : value;
}
var classNames = function(cls, prefix) {
  var PREFIX = function(str2) {
    return "".concat(prefix, "-").concat(str2);
  };
  var obj = Object.fromEntries(Object.entries(cls).map(function(_a3) {
    var _b = __read(_a3, 2), k = _b[0], v2 = _b[1];
    var name = PREFIX(v2);
    return [
      k,
      {
        name,
        class: ".".concat(name),
        id: "#".concat(name),
        toString: function() {
          return name;
        }
      }
    ];
  }));
  Object.assign(obj, { prefix: PREFIX });
  return obj;
};
var MAX_MIX_LEVEL = 5;
var deep = function(dist2, src, level, maxLevel) {
  if (level === void 0) {
    level = 0;
  }
  if (maxLevel === void 0) {
    maxLevel = MAX_MIX_LEVEL;
  }
  Object.entries(src).forEach(function(_a3) {
    var _b = __read(_a3, 2), key = _b[0], value = _b[1];
    var res = dist2;
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      if (!value) {
        res[key] = value;
      } else if (isPlainObject(value)) {
        if (!isPlainObject(dist2[key])) {
          res[key] = {};
        }
        if (level < maxLevel) {
          deep(dist2[key], value, level + 1, maxLevel);
        } else {
          res[key] = src[key];
        }
      } else if (isArray$2(value)) {
        res[key] = [];
        res[key] = res[key].concat(value);
      } else {
        res[key] = value;
      }
    }
  });
};
var deepAssign = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    deep(rst, args[i2]);
  }
  return rst;
};
var defined = function(x2) {
  return x2 !== void 0 && x2 != null && !Number.isNaN(x2);
};
var ctx;
var measureTextWidth = memoize$2(function(text, font) {
  var fontSize2 = font.fontSize, fontFamily2 = font.fontFamily, fontWeight2 = font.fontWeight, fontStyle2 = font.fontStyle, fontVariant2 = font.fontVariant;
  if (!ctx) {
    ctx = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
  }
  ctx.font = [fontStyle2, fontVariant2, fontWeight2, "".concat(fontSize2, "px"), fontFamily2].join(" ");
  return ctx.measureText(text).width;
}, function(text, font) {
  return [text, Object.values(font || getFont(text)).join()].join("");
}, 4096);
var getFont = function(textShape) {
  var fontFamily2 = textShape.style.fontFamily || "sans-serif";
  var fontWeight2 = textShape.style.fontWeight || "normal";
  var fontStyle2 = textShape.style.fontStyle || "normal";
  var fontVariant2 = textShape.style.fontVariant;
  var fontSize2 = textShape.style.fontSize;
  fontSize2 = typeof fontSize2 === "object" ? fontSize2.value : fontSize2;
  return { fontSize: fontSize2, fontFamily: fontFamily2, fontWeight: fontWeight2, fontStyle: fontStyle2, fontVariant: fontVariant2 };
};
function textOf(node) {
  if (node.nodeName === "text") {
    return node;
  }
  if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
    return node.children[0];
  }
  return null;
}
function applyToText(node, style) {
  var text = textOf(node);
  if (text)
    text.attr(style);
}
function ellipsisIt(node, w2, suffix) {
  if (suffix === void 0) {
    suffix = "...";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth: w2, maxLines: 1, textOverflow: suffix });
}
function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
  if (maxLines === void 0) {
    maxLines = 2;
  }
  if (textBaseline === void 0) {
    textBaseline = "top";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
}
function getEventViewportPos(e3) {
  var nativeEvent = e3.nativeEvent, touches = e3.touches, clientX = e3.clientX, clientY = e3.clientY;
  if (nativeEvent) {
    return [nativeEvent.clientX, nativeEvent.clientY];
  }
  if (touches) {
    var _a3 = touches[0], clientX_1 = _a3.clientX, clientY_1 = _a3.clientY;
    return [clientX_1, clientY_1];
  }
  if (typeof clientX === "number" && typeof clientY === "number")
    return [clientX, clientY];
  return [0, 0];
}
function renderExtDo(el) {
  if (typeof el === "function")
    return el();
  return isString$1(el) || isNumber(el) ? new Text({ style: { text: String(el) } }) : el;
}
function renderHtmlExtDo(el, style) {
  if (typeof el === "function")
    return el();
  return isString$1(el) || isNumber(el) ? new HTML$1({
    style: __assign(__assign({ pointerEvents: "auto" }, style), { innerHTML: el })
  }) : el;
}
function groupBy(source, by) {
  return source.reduce(function(acc, curr) {
    (acc[curr[by]] = acc[curr[by]] || []).push(curr);
    return acc;
  }, {});
}
function ifShow(show2, container, creator, removeChildren, removeHandler) {
  if (removeChildren === void 0) {
    removeChildren = true;
  }
  if (removeHandler === void 0) {
    removeHandler = function(g2) {
      g2.node().removeChildren();
    };
  }
  if (show2) {
    return creator(container);
  }
  if (removeChildren)
    removeHandler(container);
  return null;
}
function inRange(n2, start, end, includeLeft, includeRight) {
  if (includeLeft === void 0) {
    includeLeft = true;
  }
  if (includeRight === void 0) {
    includeRight = false;
  }
  if (includeLeft && n2 === start || includeRight && n2 === end)
    return true;
  return n2 > start && n2 < end;
}
var numberInterpolate = function(from, to) {
  return function(t3) {
    return from * (1 - t3) + to * t3;
  };
};
function arrayInterpolate(from, to) {
  var nb = to ? to.length : 0;
  var na = from ? Math.min(nb, from.length) : 0;
  return function(t3) {
    var x2 = new Array(na);
    var c2 = new Array(nb);
    var i2 = 0;
    for (i2 = 0; i2 < na; ++i2)
      x2[i2] = interpolate(from[i2], to[i2]);
    for (; i2 < nb; ++i2)
      c2[i2] = to[i2];
    for (i2 = 0; i2 < na; ++i2)
      c2[i2] = x2[i2](t3);
    return c2;
  };
}
function objectInterpolate(from, to) {
  if (from === void 0) {
    from = {};
  }
  if (to === void 0) {
    to = {};
  }
  var i2 = {};
  var c2 = {};
  Object.entries(to).forEach(function(_a3) {
    var _b = __read(_a3, 2), k = _b[0], v2 = _b[1];
    if (k in from)
      i2[k] = interpolate(from[k], v2);
    else
      c2[k] = v2;
  });
  return function(t3) {
    Object.entries(i2).forEach(function(_a3) {
      var _b = __read(_a3, 2), k = _b[0], v2 = _b[1];
      return c2[k] = v2(t3);
    });
    return c2;
  };
}
function interpolate(from, to) {
  if (typeof from === "number" && typeof to === "number") {
    return numberInterpolate(from, to);
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    return arrayInterpolate(from, to);
  }
  if (typeof from === "object" && typeof to === "object") {
    return objectInterpolate(from, to);
  }
  return function(t3) {
    return from;
  };
}
function keyframeInterpolate(element, from, to, options) {
  if (!options) {
    element.attr("__keyframe_data__", to);
    return null;
  }
  var _a3 = options.duration, duration2 = _a3 === void 0 ? 0 : _a3;
  var int = interpolate(from, to);
  var count = Math.ceil(+duration2 / 16);
  var keyframes = new Array(count).fill(0).map(function(datum, index2, array) {
    return { __keyframe_data__: int(index2 / (array.length - 1)) };
  });
  return element.animate(keyframes, __assign({ fill: "both" }, options));
}
function scale2(vec, s3) {
  return [vec[0] * s3, vec[1] * s3];
}
function add(vec1, vec2) {
  return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
}
function sub(vec1, vec2) {
  return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
}
function min(vec1, vec2) {
  return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
}
function max(vec1, vec2) {
  return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
}
function distance$1(vec1, vec2) {
  return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
}
function normalize$1(vec) {
  if (vec[0] === 0 && vec[1] === 0)
    return [0, 0];
  var len2 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
  return [vec[0] / len2, vec[1] / len2];
}
function vertical(vec, flag) {
  return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
}
function toPrecision(num, precision) {
  return +num.toPrecision(precision);
}
function omit(obj, keys) {
  var res = {};
  var innerKeys = Array.isArray(keys) ? keys : [keys];
  for (var key in obj) {
    if (!innerKeys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}
function smoothBezier(points, smooth2, isLoop, constraint) {
  var _a3;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min$12 = [Infinity, Infinity];
  var max$12 = [-Infinity, -Infinity];
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a3 = __read(constraint, 2), min$12 = _a3[0], max$12 = _a3[1];
    for (var i2 = 0, l2 = points.length; i2 < l2; i2 += 1) {
      var point2 = points[i2];
      min$12 = min(min$12, point2);
      max$12 = max(max$12, point2);
    }
  }
  for (var i2 = 0, len2 = points.length; i2 < len2; i2 += 1) {
    var point2 = points[i2];
    if (i2 === 0 && true) {
      cp0 = point2;
    } else if (i2 === len2 - 1 && true) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i2 ? i2 - 1 : len2 - 1, i2 - 1][1];
      prevPoint = points[prevIdx];
      nextPoint = points[i2 + 1];
      var v2 = [0, 0];
      v2 = sub(nextPoint, prevPoint);
      v2 = scale2(v2, smooth2);
      var d0 = distance$1(point2, prevPoint);
      var d1 = distance$1(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale2(v2, -d0);
      var v22 = scale2(v2, d1);
      cp1 = add(point2, v1);
      nextCp0 = add(point2, v22);
      nextCp0 = min(nextCp0, max(nextPoint, point2));
      nextCp0 = max(nextCp0, min(nextPoint, point2));
      v1 = sub(nextCp0, point2);
      v1 = scale2(v1, -d0 / d1);
      cp1 = add(point2, v1);
      cp1 = min(cp1, max(prevPoint, point2));
      cp1 = max(cp1, min(prevPoint, point2));
      v22 = sub(point2, cp1);
      v22 = scale2(v22, d1 / d0);
      nextCp0 = add(point2, v22);
      if (hasConstraint) {
        cp1 = max(cp1, min$12);
        cp1 = min(cp1, max$12);
        nextCp0 = max(nextCp0, min$12);
        nextCp0 = min(nextCp0, max$12);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  return cps;
}
function catmullRom2Bezier(crp, z2, constraint) {
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = false;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len2 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i2 = 0; i2 < len2 - 1; i2 += 1) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p2 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}
var PRIMILTIVE_ATTRIBUTES = [
  "$el",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "fill",
  "fillOpacity",
  "filter",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "height",
  "img",
  "increasedLineWidthForHitTesting",
  "innerHTML",
  "isBillboard",
  "billboardRotation",
  "isSizeAttenuation",
  "isClosed",
  "isOverflowing",
  "leading",
  "letterSpacing",
  "lineDash",
  "lineHeight",
  "lineWidth",
  "markerEnd",
  "markerEndOffset",
  "markerMid",
  "markerStart",
  "markerStartOffset",
  "maxLines",
  "metrics",
  "miterLimit",
  "offsetX",
  "offsetY",
  "opacity",
  "path",
  "points",
  "r",
  "radius",
  "rx",
  "ry",
  "shadowColor",
  "src",
  "stroke",
  "strokeOpacity",
  "text",
  "textAlign",
  "textBaseline",
  "textDecorationColor",
  "textDecorationLine",
  "textDecorationStyle",
  "textOverflow",
  "textPath",
  "textPathSide",
  "textPathStartOffset",
  "transform",
  "transformOrigin",
  "visibility",
  "width",
  "wordWrap",
  "wordWrapWidth",
  "x",
  "x1",
  "x2",
  "y",
  "y1",
  "y2",
  "z1",
  "z2",
  "zIndex"
];
function isPrimitiveAttribute(key) {
  return PRIMILTIVE_ATTRIBUTES.includes(key);
}
function getPrimitiveAttributes(attributes) {
  var object = {};
  for (var key in attributes) {
    if (isPrimitiveAttribute(key))
      object[key] = attributes[key];
  }
  return object;
}
function sampling(data2, size) {
  if (data2.length <= size)
    return data2;
  var step2 = Math.floor(data2.length / size);
  var result = [];
  for (var i2 = 0; i2 < data2.length; i2 += step2) {
    result.push(data2[i2]);
  }
  return result;
}
function scaleToPixel(el, size, applyScale) {
  var _a3 = el.getBBox(), width2 = _a3.width, height = _a3.height;
  var scale3 = size / Math.max(width2, height);
  {
    el.style.transform = "scale(".concat(scale3, ")");
  }
  return scale3;
}
function group(array, keyFunc) {
  var grouped = /* @__PURE__ */ new Map();
  array.forEach(function(item) {
    var key = keyFunc(item);
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(item);
  });
  return grouped;
}
function error(msg) {
  throw new Error(msg);
}
var Selection = (
  /** @class */
  function() {
    function Selection2(elements, data2, parent, document2, selections, transitions, updateElements) {
      if (elements === void 0) {
        elements = null;
      }
      if (data2 === void 0) {
        data2 = null;
      }
      if (parent === void 0) {
        parent = null;
      }
      if (document2 === void 0) {
        document2 = null;
      }
      if (selections === void 0) {
        selections = [null, null, null, null, null];
      }
      if (transitions === void 0) {
        transitions = [];
      }
      if (updateElements === void 0) {
        updateElements = [];
      }
      _Selection_instances.add(this);
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    Selection2.prototype.selectAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a3(elements, null, this._elements[0], this._document);
    };
    Selection2.prototype.selectFacetAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a3(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    };
    Selection2.prototype.select = function(selector) {
      var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _a3([element], null, element, this._document);
    };
    Selection2.prototype.append = function(node) {
      var _this2 = this;
      var callback = typeof node === "function" ? node : function() {
        return _this2.createElement(node);
      };
      var elements = [];
      if (this._data !== null) {
        for (var i2 = 0; i2 < this._data.length; i2++) {
          var d3 = this._data[i2];
          var _b = __read(Array.isArray(d3) ? d3 : [d3, null], 2), datum = _b[0], from = _b[1];
          var newElement = callback(datum, i2);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a3(elements, null, this._parent, this._document);
      }
      for (var i2 = 0; i2 < this._elements.length; i2++) {
        var element = this._elements[i2];
        var datum = element.__data__;
        var newElement = callback(datum, i2);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _a3(elements, null, elements[0], this._document);
    };
    Selection2.prototype.maybeAppend = function(id2, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id2[0] === "#" ? id2 : "#".concat(id2), node);
      element.attr("id", id2);
      return element;
    };
    Selection2.prototype.maybeAppendByClassName = function(className, node) {
      var cls = className.toString();
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
      element.attr("className", cls);
      return element;
    };
    Selection2.prototype.maybeAppendByName = function(name, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name, '"]'), node);
      element.attr("name", name);
      return element;
    };
    Selection2.prototype.data = function(data2, id2, groupId) {
      var e_1, _b;
      if (id2 === void 0) {
        id2 = function(d3) {
          return d3;
        };
      }
      if (groupId === void 0) {
        groupId = function() {
          return null;
        };
      }
      var enter = [];
      var update = [];
      var exit = new Set(this._elements);
      var merge = [];
      var split = /* @__PURE__ */ new Set();
      var keyElement = new Map(this._elements.map(function(d3, i3) {
        return [id2(d3.__data__, i3), d3];
      }));
      var keyUpdateElement = new Map(this._facetElements.map(function(d3, i3) {
        return [id2(d3.__data__, i3), d3];
      }));
      var groupKeyElements = group(this._elements, function(d3) {
        return groupId(d3.__data__);
      });
      for (var i2 = 0; i2 < data2.length; i2++) {
        var datum = data2[i2];
        var key = id2(datum, i2);
        var groupKey = groupId(datum, i2);
        if (keyElement.has(key)) {
          var element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          var element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          var group_2 = groupKeyElements.get(key);
          merge.push([datum, group_2]);
          try {
            for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
              var element = group_1_1.value;
              exit.delete(element);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (group_1_1 && !group_1_1.done && (_b = group_1.return)) _b.call(group_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          var element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      var S2 = [
        new _a3([], enter, this._parent, this._document),
        new _a3(update, null, this._parent, this._document),
        new _a3(exit, null, this._parent, this._document),
        new _a3([], merge, this._parent, this._document),
        new _a3(split, null, this._parent, this._document)
      ];
      return new _a3(this._elements, null, this._parent, this._document, S2);
    };
    Selection2.prototype.merge = function(other) {
      var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
      var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
      return new _a3(elements, null, this._parent, this._document, void 0, transitions);
    };
    Selection2.prototype.createElement = function(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      var Ctor = _a3.registry[type];
      if (Ctor)
        return new Ctor();
      return error("Unknown node type: ".concat(type));
    };
    Selection2.prototype.join = function(enter, update, exit, merge, split) {
      if (enter === void 0) {
        enter = function(d3) {
          return d3;
        };
      }
      if (update === void 0) {
        update = function(d3) {
          return d3;
        };
      }
      if (exit === void 0) {
        exit = function(d3) {
          return d3.remove();
        };
      }
      if (merge === void 0) {
        merge = function(d3) {
          return d3;
        };
      }
      if (split === void 0) {
        split = function(d3) {
          return d3.remove();
        };
      }
      var newEnter = enter(this._enter);
      var newUpdate = update(this._update);
      var newExit = exit(this._exit);
      var newMerge = merge(this._merge);
      var newSplit = split(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    };
    Selection2.prototype.remove = function() {
      var _loop_1 = function(i3) {
        var element = this_1._elements[i3];
        var transition2 = this_1._transitions[i3];
        if (transition2) {
          transition2.then(function() {
            return element.remove();
          });
        } else {
          element.remove();
        }
      };
      var this_1 = this;
      for (var i2 = 0; i2 < this._elements.length; i2++) {
        _loop_1(i2);
      }
      return new _a3([], null, this._parent, this._document, void 0, this._transitions);
    };
    Selection2.prototype.each = function(callback) {
      for (var i2 = 0; i2 < this._elements.length; i2++) {
        var element = this._elements[i2];
        var datum = element.__data__;
        callback.call(element, datum, i2);
      }
      return this;
    };
    Selection2.prototype.attr = function(key, value) {
      var callback = typeof value !== "function" ? function() {
        return value;
      } : value;
      return this.each(function(d3, i2) {
        if (value !== void 0)
          this[key] = callback.call(this, d3, i2);
      });
    };
    Selection2.prototype.style = function(key, value, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof value !== "function" || !callable ? function() {
        return value;
      } : value;
      return this.each(function(d3, i2) {
        if (value !== void 0)
          this.style[key] = callback.call(this, d3, i2);
      });
    };
    Selection2.prototype.styles = function(style, callable) {
      if (style === void 0) {
        style = {};
      }
      if (callable === void 0) {
        callable = true;
      }
      return this.each(function(d3, i2) {
        var _this2 = this;
        Object.entries(style).forEach(function(_b) {
          var _c = __read(_b, 2), key = _c[0], value = _c[1];
          var callback = typeof value !== "function" || !callable ? function() {
            return value;
          } : value;
          if (value !== void 0)
            _this2.attr(key, callback.call(_this2, d3, i2));
        });
      });
    };
    Selection2.prototype.update = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d3, i2) {
        if (option && this.update)
          this.update(callback.call(this, d3, i2));
      });
    };
    Selection2.prototype.maybeUpdate = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d3, i2) {
        if (option && this.update)
          this.update(callback.call(this, d3, i2));
      });
    };
    Selection2.prototype.transition = function(callback) {
      this._transitions;
      var newTransitions = new Array(this._elements.length);
      this.each(function(d3, i2) {
        newTransitions[i2] = callback.call(this, d3, i2);
      });
      this._transitions = flatten(newTransitions);
      return this;
    };
    Selection2.prototype.on = function(event, handler) {
      this.each(function() {
        this.addEventListener(event, handler);
      });
      return this;
    };
    Selection2.prototype.call = function(callback) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
      return this;
    };
    Selection2.prototype.node = function() {
      return this._elements[0];
    };
    Selection2.prototype.nodes = function() {
      return this._elements;
    };
    Selection2.prototype.transitions = function() {
      return this._transitions.filter(function(t3) {
        return !!t3;
      });
    };
    Selection2.prototype.parent = function() {
      return this._parent;
    };
    var _Selection_instances, _a3, _Selection_maybeAppend;
    _a3 = Selection2, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
      var element = this._elements[0];
      var child = element.querySelector(selector);
      if (child)
        return new _a3([child], null, this._parent, this._document);
      var newChild = typeof node === "string" ? this.createElement(node) : node();
      element.appendChild(newChild);
      return new _a3([newChild], null, this._parent, this._document);
    };
    Selection2.registry = {
      g: Group,
      rect: Rect$1,
      circle: Circle$2,
      path: Path,
      text: Text,
      ellipse: Ellipse$1,
      image: Image$3,
      line: Line$2,
      polygon: Polygon$1,
      polyline: Polyline$1,
      html: HTML$1
    };
    return Selection2;
  }()
);
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
function maybeAppend(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select(parent).append(node);
  }
  return select(parent).select(selector);
}
function parseSeriesAttr(series) {
  if (isNumber(series)) {
    return [series, series, series, series];
  }
  if (isArray$2(series)) {
    var len2 = series.length;
    if (len2 === 1) {
      return [series[0], series[0], series[0], series[0]];
    }
    if (len2 === 2) {
      return [series[0], series[1], series[0], series[1]];
    }
    if (len2 === 3) {
      return [series[0], series[1], series[2], series[1]];
    }
    if (len2 === 4) {
      return series;
    }
  }
  return [0, 0, 0, 0];
}
function getLocalBBox(shape) {
  var _a3 = shape.getLocalBounds(), min2 = _a3.min, max2 = _a3.max;
  var _b = __read([min2, max2], 2), _c = __read(_b[0], 2), x1 = _c[0], y1 = _c[1], _d = __read(_b[1], 2), x2 = _d[0], y2 = _d[1];
  return { x: x1, y: y1, width: x2 - x1, height: y2 - y1, left: x1, bottom: y2, top: y1, right: x2 };
}
function isHorizontal(p1, p2) {
  var _a3 = __read(p1, 2), x1 = _a3[0], y1 = _a3[1];
  var _b = __read(p2, 2), x2 = _b[0], y2 = _b[1];
  return x1 !== x2 && y1 === y2;
}
function copyAttributes(target, source) {
  var e_1, _a3;
  var attributes = source.attributes;
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
      if (key !== "id" && key !== "className")
        target.attr(key, value);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return)) _a3.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}
function toUppercaseFirstLetter(string) {
  return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
}
function toLowercaseFirstLetter(string) {
  return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
}
function addPrefix(string, prefix) {
  return "".concat(prefix).concat(toUppercaseFirstLetter(string));
}
function removePrefix(string, prefix, lowercaseFirstLetter) {
  var _a3;
  if (lowercaseFirstLetter === void 0) {
    lowercaseFirstLetter = true;
  }
  var inferPrefix = prefix || ((_a3 = string.match(/^([a-z][a-z0-9]+)/)) === null || _a3 === void 0 ? void 0 : _a3[0]) || "";
  var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
  return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
}
function applyStyleSheet(element, style) {
  Object.entries(style).forEach(function(_a3) {
    var _b = __read(_a3, 2), selector = _b[0], styleString = _b[1];
    __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
      return el.matches(selector);
    }).forEach(function(target) {
      if (!target)
        return;
      var temp = target;
      temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
        return "".concat(total).concat(currVal.join(":"), ";");
      }, "");
    });
  });
}
var startsWith = function(text, prefix) {
  if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
    return false;
  var nextChart = text[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
};
function subStyleProps(style, prefix, invert2) {
  if (invert2 === void 0) {
    invert2 = false;
  }
  var result = {};
  Object.entries(style).forEach(function(_a3) {
    var _b = __read(_a3, 2), key = _b[0], value = _b[1];
    if (key === "className" || key === "class") ;
    else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert2) {
      if (key === addPrefix(prefix, "show"))
        result[key] = value;
      else
        result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value;
    } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert2) {
      var name_1 = removePrefix(key, prefix);
      if (name_1 === "filter" && typeof value === "function") ;
      else
        result[name_1] = value;
    }
  });
  return result;
}
function superStyleProps(style, prefix) {
  return Object.entries(style).reduce(function(acc, _a3) {
    var _b = __read(_a3, 2), key = _b[0], value = _b[1];
    if (key.startsWith("show"))
      acc["show".concat(prefix).concat(key.slice(4))] = value;
    else
      acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value;
    return acc;
  }, {});
}
function splitStyle(style, ignoreStyleDict) {
  if (ignoreStyleDict === void 0) {
    ignoreStyleDict = ["x", "y", "class", "className"];
  }
  var groupStyleDict = [
    "transform",
    "transformOrigin",
    "anchor",
    "visibility",
    "pointerEvents",
    "zIndex",
    "cursor",
    "clipPath",
    "clipPathTargets",
    "offsetPath",
    "offsetPathTargets",
    "offsetDistance",
    "draggable",
    "droppable"
  ];
  var output = {};
  var groupStyle = {};
  Object.entries(style).forEach(function(_a3) {
    var _b = __read(_a3, 2), key = _b[0], val = _b[1];
    if (ignoreStyleDict.includes(key)) ;
    else if (groupStyleDict.indexOf(key) !== -1)
      groupStyle[key] = val;
    else
      output[key] = val;
  });
  return [output, groupStyle];
}
function formatTime(date, mask) {
  var timeMap = {
    YYYY: date.getFullYear(),
    MM: date.getMonth() + 1,
    DD: date.getDate(),
    HH: date.getHours(),
    mm: date.getMinutes(),
    ss: date.getSeconds()
  };
  var strftime = mask;
  Object.keys(timeMap).forEach(function(key) {
    var val = timeMap[key];
    strftime = strftime.replace(key, key === "YYYY" ? "".concat(val) : "".concat(val).padStart(2, "0"));
  });
  return strftime;
}
function getTranslate(node, x2, y2) {
  var _a3 = node.getBBox(), width2 = _a3.width, height = _a3.height;
  var _b = __read([x2, y2].map(function(v2, i2) {
    var _a4;
    return v2.includes("%") ? parseFloat(((_a4 = v2.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a4 === void 0 ? void 0 : _a4[0]) || "0") / 100 * (i2 === 0 ? width2 : height) : v2;
  }), 2), tx = _b[0], ty = _b[1];
  return [tx, ty];
}
function percentTransform(node, val) {
  if (!val)
    return;
  try {
    var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
    var computedVal = val.replace(reg, function(match2, x2, y2) {
      return "translate(".concat(getTranslate(node, x2, y2), ")");
    });
    node.attr("transform", computedVal);
  } catch (e3) {
  }
}
function transpose(m3) {
  var _a3;
  return ((_a3 = m3[0]) === null || _a3 === void 0 ? void 0 : _a3.map(function(x2, i2) {
    return m3.map(function(x3) {
      return x3[i2];
    });
  })) || [];
}
var replaceChildren = function(el, content) {
  if (content == null) {
    el.innerHTML = "";
    return;
  }
  if (el.replaceChildren) {
    if (Array.isArray(content)) {
      el.replaceChildren.apply(el, __spreadArray([], __read(content), false));
    } else {
      el.replaceChildren(content);
    }
  } else {
    el.innerHTML = "";
    if (Array.isArray(content)) {
      content.forEach(function(child) {
        return el.appendChild(child);
      });
    } else {
      el.appendChild(content);
    }
  }
};
function parsePosition(position2) {
  if (!/\S+-\S+/g.test(position2))
    return position2.length > 2 ? [position2[0]] : position2.split("");
  return position2.split("-").map(function(str2) {
    return str2[0];
  });
}
var parseHeightFromHTML = function(html) {
  var parser2 = new DOMParser();
  var doc = parser2.parseFromString(html, "text/html");
  var el = doc.body.firstElementChild;
  console.log(el === null || el === void 0 ? void 0 : el.getClientRects(), 11);
  if (!el)
    return 0;
  var style = el.getAttribute("style") || "";
  var rules = Object.fromEntries(style.split(";").map(function(r2) {
    return r2.trim();
  }).filter(function(r2) {
    return r2.includes(":");
  }).map(function(r2) {
    var _a3 = __read(r2.split(":").map(function(s3) {
      return s3.trim();
    }), 2), key = _a3[0], value = _a3[1];
    return [key.toLowerCase(), value];
  }));
  var parsePx = function(v2) {
    if (!v2)
      return 0;
    var match3 = v2.match(/([\d.]+)px/);
    return match3 ? parseFloat(match3[1]) : 0;
  };
  if (rules.height) {
    return parsePx(rules.height);
  }
  var fontSize2 = parsePx(rules["font-size"]) || 16;
  var lineHeight2 = rules["line-height"];
  var baseHeight;
  if (!lineHeight2 || lineHeight2 === "normal") {
    baseHeight = 1.2 * fontSize2;
  } else if (lineHeight2.endsWith("px")) {
    baseHeight = parsePx(lineHeight2);
  } else if (/^[\d.]+$/.test(lineHeight2)) {
    baseHeight = parseFloat(lineHeight2) * fontSize2;
  } else {
    baseHeight = fontSize2;
  }
  var paddingTop2 = parsePx(rules["padding-top"]);
  var paddingBottom2 = parsePx(rules["padding-bottom"]);
  if (rules.padding) {
    var parts = rules.padding.split(/\s+/).map(parsePx);
    if (parts.length === 1) {
      paddingTop2 = parts[0];
      paddingBottom2 = parts[0];
    } else if (parts.length === 2) {
      paddingTop2 = parts[0];
      paddingBottom2 = parts[0];
    } else if (parts.length === 3) {
      paddingTop2 = parts[0];
      paddingBottom2 = parts[2];
    } else if (parts.length === 4) {
      paddingTop2 = parts[0];
      paddingBottom2 = parts[2];
    }
  }
  var borderTop = parsePx(rules["border-top-width"]);
  var borderBottom = parsePx(rules["border-bottom-width"]);
  if (rules.border) {
    var match2 = rules.border.match(/([\d.]+)px/);
    if (match2) {
      borderTop = parseFloat(match2[1]);
      borderBottom = parseFloat(match2[1]);
    }
  }
  if (rules["border-width"]) {
    var parts = rules["border-width"].split(/\s+/).map(parsePx);
    if (parts.length === 1) {
      borderTop = parts[0];
      borderBottom = parts[0];
    } else if (parts.length === 2) {
      borderTop = parts[0];
      borderBottom = parts[0];
    } else if (parts.length === 3) {
      borderTop = parts[0];
      borderBottom = parts[2];
    } else if (parts.length === 4) {
      borderTop = parts[0];
      borderBottom = parts[2];
    }
  }
  return baseHeight + paddingTop2 + paddingBottom2 + borderTop + borderBottom;
};
function applyVisibility() {
  visibility(this, this.attributes.visibility !== "hidden");
}
var Component = (
  /** @class */
  function(_super) {
    __extends$1(Component2, _super);
    function Component2(options, defaultStyleProps) {
      if (defaultStyleProps === void 0) {
        defaultStyleProps = {};
      }
      var _this2 = _super.call(this, deepAssign({}, { style: defaultStyleProps }, options)) || this;
      _this2.initialized = false;
      _this2._defaultOptions = defaultStyleProps;
      return _this2;
    }
    Object.defineProperty(Component2.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "defaultOptions", {
      get: function() {
        return this._defaultOptions;
      },
      enumerable: false,
      configurable: true
    });
    Component2.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
      this.initialized = true;
    };
    Component2.prototype.disconnectedCallback = function() {
      var _a3;
      (_a3 = this._offscreen) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    };
    Component2.prototype.attributeChangedCallback = function(name) {
      if (name === "visibility") {
        applyVisibility.call(this);
      }
    };
    Component2.prototype.update = function(attr2, animate2) {
      var _a3;
      this.attr(deepAssign({}, this.attributes, attr2 || {}));
      return (_a3 = this.render) === null || _a3 === void 0 ? void 0 : _a3.call(this, this.attributes, this, animate2);
    };
    Component2.prototype.clear = function() {
      this.removeChildren();
    };
    Component2.prototype.bindEvents = function(attributes, container) {
    };
    Component2.prototype.getSubShapeStyle = function(attributes) {
      attributes.x;
      attributes.y;
      attributes.transform;
      attributes.transformOrigin;
      attributes.class;
      attributes.className;
      attributes.zIndex;
      var style = __rest$m(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
      return style;
    };
    return Component2;
  }(CustomElement)
);
var circle = function(x2, y2, r2) {
  return [["M", x2 - r2, y2], ["A", r2, r2, 0, 1, 0, x2 + r2, y2], ["A", r2, r2, 0, 1, 0, x2 - r2, y2], ["Z"]];
};
var point = circle;
var square = function(x2, y2, r2) {
  return [["M", x2 - r2, y2 - r2], ["L", x2 + r2, y2 - r2], ["L", x2 + r2, y2 + r2], ["L", x2 - r2, y2 + r2], ["Z"]];
};
var diamond = function(x2, y2, r2) {
  return [["M", x2 - r2, y2], ["L", x2, y2 - r2], ["L", x2 + r2, y2], ["L", x2, y2 + r2], ["Z"]];
};
var triangle = function(x2, y2, r2) {
  var diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [["M", x2 - r2, y2 + diffY], ["L", x2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["Z"]];
};
var triangleDown = function(x2, y2, r2) {
  var diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 - diffY], ["L", x2, y2 + diffY], ["Z"]];
};
var hexagon = function(x2, y2, r2) {
  var diffX = r2 / 2 * Math.sqrt(3);
  return [
    ["M", x2, y2 - r2],
    ["L", x2 + diffX, y2 - r2 / 2],
    ["L", x2 + diffX, y2 + r2 / 2],
    ["L", x2, y2 + r2],
    ["L", x2 - diffX, y2 + r2 / 2],
    ["L", x2 - diffX, y2 - r2 / 2],
    ["Z"]
  ];
};
var bowtie = function(x2, y2, r2) {
  var diffY = r2 - 1.5;
  return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["L", x2 + r2, y2 - diffY], ["L", x2 - r2, y2 + diffY], ["Z"]];
};
var line = function(x2, y2, r2) {
  return [
    ["M", x2, y2 + r2],
    ["L", x2, y2 - r2]
  ];
};
var cross = function(x2, y2, r2) {
  return [
    ["M", x2 - r2, y2 - r2],
    ["L", x2 + r2, y2 + r2],
    ["M", x2 + r2, y2 - r2],
    ["L", x2 - r2, y2 + r2]
  ];
};
var tick = function(x2, y2, r2) {
  return [
    ["M", x2 - r2 / 2, y2 - r2],
    ["L", x2 + r2 / 2, y2 - r2],
    ["M", x2, y2 - r2],
    ["L", x2, y2 + r2],
    ["M", x2 - r2 / 2, y2 + r2],
    ["L", x2 + r2 / 2, y2 + r2]
  ];
};
var plus = function(x2, y2, r2) {
  return [
    ["M", x2 - r2, y2],
    ["L", x2 + r2, y2],
    ["M", x2, y2 - r2],
    ["L", x2, y2 + r2]
  ];
};
var hyphen = function(x2, y2, r2) {
  return [
    ["M", x2 - r2, y2],
    ["L", x2 + r2, y2]
  ];
};
var dot = function(x2, y2, r2) {
  return [
    ["M", x2 - r2, y2],
    ["L", x2 + r2, y2]
  ];
};
var dash = dot;
var smooth = function(x2, y2, r2) {
  return [
    ["M", x2 - r2, y2],
    ["A", r2 / 2, r2 / 2, 0, 1, 1, x2, y2],
    ["A", r2 / 2, r2 / 2, 0, 1, 0, x2 + r2, y2]
  ];
};
var hv = function(x2, y2, r2) {
  return [
    ["M", x2 - r2 - 1, y2 - 2.5],
    ["L", x2, y2 - 2.5],
    ["L", x2, y2 + 2.5],
    ["L", x2 + r2 + 1, y2 + 2.5]
  ];
};
var vh = function(x2, y2, r2) {
  return [
    ["M", x2 - r2 - 1, y2 + 2.5],
    ["L", x2, y2 + 2.5],
    ["L", x2, y2 - 2.5],
    ["L", x2 + r2 + 1, y2 - 2.5]
  ];
};
var hvh = function(x2, y2, r2) {
  return [
    ["M", x2 - (r2 + 1), y2 + 2.5],
    ["L", x2 - r2 / 2, y2 + 2.5],
    ["L", x2 - r2 / 2, y2 - 2.5],
    ["L", x2 + r2 / 2, y2 - 2.5],
    ["L", x2 + r2 / 2, y2 + 2.5],
    ["L", x2 + r2 + 1, y2 + 2.5]
  ];
};
function vhv(x2, y2) {
  return [
    ["M", x2 - 5, y2 + 2.5],
    ["L", x2 - 5, y2],
    ["L", x2, y2],
    ["L", x2, y2 - 3],
    ["L", x2, y2 + 3],
    ["L", x2 + 6.5, y2 + 3]
  ];
}
var button = function(x2, y2, r2) {
  return [["M", x2 - r2, y2 - r2], ["L", x2 + r2, y2], ["L", x2 - r2, y2 + r2], ["Z"]];
};
var focus = function(x2, y2, r2) {
  var outerRadius = r2;
  var innerRadius = r2 * 0.2;
  var crossLength = r2 * 0.7;
  return [
    // 
    ["M", x2 - outerRadius, y2],
    ["A", outerRadius, outerRadius, 0, 1, 0, x2 + outerRadius, y2],
    ["A", outerRadius, outerRadius, 0, 1, 0, x2 - outerRadius, y2],
    ["Z"],
    //  ()
    ["M", x2 - crossLength, y2],
    ["L", x2 - innerRadius, y2],
    ["M", x2 + innerRadius, y2],
    ["L", x2 + crossLength, y2],
    //  ()
    ["M", x2, y2 - crossLength],
    ["L", x2, y2 - innerRadius],
    ["M", x2, y2 + innerRadius],
    ["L", x2, y2 + crossLength]
  ];
};
function parseMarker(icon) {
  var type = "default";
  if (isObject$2(icon) && icon instanceof Image)
    type = "image";
  else if (isFunction$1(icon))
    type = "symbol";
  else if (isString$1(icon)) {
    var dataURLsPattern = new RegExp("data:(image|text)");
    if (icon.match(dataURLsPattern)) {
      type = "base64";
    } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
      type = "url";
    } else {
      type = "symbol";
    }
  }
  return type;
}
function getType(symbol) {
  var markerType = parseMarker(symbol);
  if (["base64", "url", "image"].includes(markerType)) {
    return "image";
  }
  if (symbol && markerType === "symbol") {
    return "path";
  }
  return null;
}
var Marker = (
  /** @class */
  function(_super) {
    __extends$1(Marker2, _super);
    function Marker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker2.prototype.render = function(attributes, container) {
      var _a3 = attributes.x, x2 = _a3 === void 0 ? 0 : _a3, _b = attributes.y, y2 = _b === void 0 ? 0 : _b;
      var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size = _d === void 0 ? 16 : _d, style = __rest$m(_c, ["symbol", "size"]);
      var type = getType(symbol);
      ifShow(!!type, select(container), function(group2) {
        group2.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
          if (type === "image") {
            var r2 = size * 2;
            selection.styles({
              img: symbol,
              width: r2,
              height: r2,
              x: x2 - size,
              y: y2 - size
            });
          } else {
            var r2 = size / 2;
            var symbolFn = isFunction$1(symbol) ? symbol : Marker2.getSymbol(symbol);
            selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x2, y2, r2) }, style));
          }
        });
      });
    };
    Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
    Marker2.registerSymbol = function(type, symbol) {
      Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
    };
    Marker2.getSymbol = function(type) {
      return Marker2.MARKER_SYMBOL_MAP.get(type);
    };
    Marker2.getSymbols = function() {
      return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
    };
    return Marker2;
  }(Component)
);
Marker.registerSymbol("cross", cross);
Marker.registerSymbol("hyphen", hyphen);
Marker.registerSymbol("line", line);
Marker.registerSymbol("plus", plus);
Marker.registerSymbol("tick", tick);
Marker.registerSymbol("circle", circle);
Marker.registerSymbol("point", point);
Marker.registerSymbol("bowtie", bowtie);
Marker.registerSymbol("hexagon", hexagon);
Marker.registerSymbol("square", square);
Marker.registerSymbol("diamond", diamond);
Marker.registerSymbol("triangle", triangle);
Marker.registerSymbol("triangle-down", triangleDown);
Marker.registerSymbol("line", line);
Marker.registerSymbol("dot", dot);
Marker.registerSymbol("dash", dash);
Marker.registerSymbol("smooth", smooth);
Marker.registerSymbol("hv", hv);
Marker.registerSymbol("vh", vh);
Marker.registerSymbol("hvh", hvh);
Marker.registerSymbol("vhv", vhv);
Marker.registerSymbol("focus", focus);
function compose(fn, ...rest) {
  return rest.reduce((pre, cur) => (x2) => pre(cur(x2)), fn);
}
function createNormalize(a2, b2) {
  return b2 - a2 ? (t3) => (t3 - a2) / (b2 - a2) : (_2) => 0.5;
}
function createClamp(a2, b2) {
  const lo = b2 < a2 ? b2 : a2;
  const hi = a2 > b2 ? a2 : b2;
  return (x2) => Math.min(Math.max(lo, x2), hi);
}
function bisect(array, x2, lo, hi, getter) {
  let i2 = lo;
  let j = hi || array.length;
  const get2 = (x3) => x3;
  while (i2 < j) {
    const mid = Math.floor((i2 + j) / 2);
    if (get2(array[mid]) > x2) {
      j = mid;
    } else {
      i2 = mid + 1;
    }
  }
  return i2;
}
const e10 = Math.sqrt(50);
const e5 = Math.sqrt(10);
const e2 = Math.sqrt(2);
function tickIncrement(start, stop, count) {
  const step2 = (stop - start) / Math.max(0, count);
  const power = Math.floor(Math.log(step2) / Math.LN10);
  const error2 = step2 / 10 ** power;
  if (power >= 0) {
    return (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * 10 ** power;
  }
  return -(10 ** -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}
const d3LinearNice = (min2, max2, count = 5) => {
  const d3 = [min2, max2];
  let i0 = 0;
  let i1 = d3.length - 1;
  let start = d3[i0];
  let stop = d3[i1];
  let step2;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step2 = tickIncrement(start, stop, count);
  if (step2 > 0) {
    start = Math.floor(start / step2) * step2;
    stop = Math.ceil(stop / step2) * step2;
    step2 = tickIncrement(start, stop, count);
  } else if (step2 < 0) {
    start = Math.ceil(start * step2) / step2;
    stop = Math.floor(stop * step2) / step2;
    step2 = tickIncrement(start, stop, count);
  }
  if (step2 > 0) {
    d3[i0] = Math.floor(start / step2) * step2;
    d3[i1] = Math.ceil(stop / step2) * step2;
  } else if (step2 < 0) {
    d3[i0] = Math.ceil(start * step2) / step2;
    d3[i1] = Math.floor(stop * step2) / step2;
  }
  return d3;
};
function isValid(x2) {
  return !isUndefined(x2) && !isNull(x2) && !Number.isNaN(x2);
}
var colorString$1 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var simpleSwizzle = { exports: {} };
var isArrayish$1 = function isArrayish(obj) {
  if (!obj || typeof obj === "string") {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
};
var isArrayish2 = isArrayish$1;
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
  var results = [];
  for (var i2 = 0, len2 = args.length; i2 < len2; i2++) {
    var arg = args[i2];
    if (isArrayish2(arg)) {
      results = concat.call(results, slice.call(arg));
    } else {
      results.push(arg);
    }
  }
  return results;
};
swizzle$1.wrap = function(fn) {
  return function() {
    return fn(swizzle$1(arguments));
  };
};
var simpleSwizzleExports = simpleSwizzle.exports;
var colorNames = colorName;
var swizzle2 = simpleSwizzleExports;
var hasOwnProperty = Object.hasOwnProperty;
var reverseNames = /* @__PURE__ */ Object.create(null);
for (var name in colorNames) {
  if (hasOwnProperty.call(colorNames, name)) {
    reverseNames[colorNames[name]] = name;
  }
}
var cs = colorString$1.exports = {
  to: {},
  get: {}
};
cs.get = function(string) {
  var prefix = string.substring(0, 3).toLowerCase();
  var val;
  var model;
  switch (prefix) {
    case "hsl":
      val = cs.get.hsl(string);
      model = "hsl";
      break;
    case "hwb":
      val = cs.get.hwb(string);
      model = "hwb";
      break;
    default:
      val = cs.get.rgb(string);
      model = "rgb";
      break;
  }
  if (!val) {
    return null;
  }
  return { model, value: val };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  var abbr = /^#([a-f0-9]{3,4})$/i;
  var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
  var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var keyword = /^(\w+)$/;
  var rgb2 = [0, 0, 0, 1];
  var match2;
  var i2;
  var hexAlpha;
  if (match2 = string.match(hex2)) {
    hexAlpha = match2[2];
    match2 = match2[1];
    for (i2 = 0; i2 < 3; i2++) {
      var i22 = i2 * 2;
      rgb2[i2] = parseInt(match2.slice(i22, i22 + 2), 16);
    }
    if (hexAlpha) {
      rgb2[3] = parseInt(hexAlpha, 16) / 255;
    }
  } else if (match2 = string.match(abbr)) {
    match2 = match2[1];
    hexAlpha = match2[3];
    for (i2 = 0; i2 < 3; i2++) {
      rgb2[i2] = parseInt(match2[i2] + match2[i2], 16);
    }
    if (hexAlpha) {
      rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match2 = string.match(rgba2)) {
    for (i2 = 0; i2 < 3; i2++) {
      rgb2[i2] = parseInt(match2[i2 + 1], 0);
    }
    if (match2[4]) {
      if (match2[5]) {
        rgb2[3] = parseFloat(match2[4]) * 0.01;
      } else {
        rgb2[3] = parseFloat(match2[4]);
      }
    }
  } else if (match2 = string.match(per)) {
    for (i2 = 0; i2 < 3; i2++) {
      rgb2[i2] = Math.round(parseFloat(match2[i2 + 1]) * 2.55);
    }
    if (match2[4]) {
      if (match2[5]) {
        rgb2[3] = parseFloat(match2[4]) * 0.01;
      } else {
        rgb2[3] = parseFloat(match2[4]);
      }
    }
  } else if (match2 = string.match(keyword)) {
    if (match2[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!hasOwnProperty.call(colorNames, match2[1])) {
      return null;
    }
    rgb2 = colorNames[match2[1]];
    rgb2[3] = 1;
    return rgb2;
  } else {
    return null;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb2[i2] = clamp(rgb2[i2], 0, 255);
  }
  rgb2[3] = clamp(rgb2[3], 0, 1);
  return rgb2;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  var hsl2 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match2 = string.match(hsl2);
  if (match2) {
    var alpha = parseFloat(match2[4]);
    var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
    var s3 = clamp(parseFloat(match2[2]), 0, 100);
    var l2 = clamp(parseFloat(match2[3]), 0, 100);
    var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h2, s3, l2, a2];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match2 = string.match(hwb);
  if (match2) {
    var alpha = parseFloat(match2[4]);
    var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
    var w2 = clamp(parseFloat(match2[2]), 0, 100);
    var b2 = clamp(parseFloat(match2[3]), 0, 100);
    var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h2, w2, b2, a2];
  }
  return null;
};
cs.to.hex = function() {
  var rgba2 = swizzle2(arguments);
  return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
};
cs.to.rgb = function() {
  var rgba2 = swizzle2(arguments);
  return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
};
cs.to.rgb.percent = function() {
  var rgba2 = swizzle2(arguments);
  var r2 = Math.round(rgba2[0] / 255 * 100);
  var g2 = Math.round(rgba2[1] / 255 * 100);
  var b2 = Math.round(rgba2[2] / 255 * 100);
  return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b2 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b2 + "%, " + rgba2[3] + ")";
};
cs.to.hsl = function() {
  var hsla2 = swizzle2(arguments);
  return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
};
cs.to.hwb = function() {
  var hwba = swizzle2(arguments);
  var a2 = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a2 = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
};
cs.to.keyword = function(rgb2) {
  return reverseNames[rgb2.slice(0, 3)];
};
function clamp(num, min2, max2) {
  return Math.min(Math.max(min2, num), max2);
}
function hexDouble(num) {
  var str2 = Math.round(num).toString(16).toUpperCase();
  return str2.length < 2 ? "0" + str2 : str2;
}
var colorStringExports = colorString$1.exports;
const colorString = /* @__PURE__ */ getDefaultExportFromCjs(colorStringExports);
function hue2rgb(p2, q, m3) {
  let t3 = m3;
  if (t3 < 0)
    t3 += 1;
  if (t3 > 1)
    t3 -= 1;
  if (t3 < 1 / 6)
    return p2 + (q - p2) * 6 * t3;
  if (t3 < 1 / 2)
    return q;
  if (t3 < 2 / 3)
    return p2 + (q - p2) * (2 / 3 - t3) * 6;
  return p2;
}
function hsl2rbg(hsl2) {
  const h2 = hsl2[0] / 360;
  const s3 = hsl2[1] / 100;
  const l2 = hsl2[2] / 100;
  const a2 = hsl2[3];
  if (s3 === 0)
    return [l2 * 255, l2 * 255, l2 * 255, a2];
  const q = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3;
  const p2 = 2 * l2 - q;
  const r2 = hue2rgb(p2, q, h2 + 1 / 3);
  const g2 = hue2rgb(p2, q, h2);
  const b2 = hue2rgb(p2, q, h2 - 1 / 3);
  return [r2 * 255, g2 * 255, b2 * 255, a2];
}
function string2rbg(s3) {
  const color2 = colorString.get(s3);
  if (!color2)
    return null;
  const { model, value } = color2;
  if (model === "rgb")
    return value;
  if (model === "hsl")
    return hsl2rbg(value);
  return null;
}
const createInterpolateNumber = (a2, b2) => {
  return (t3) => a2 * (1 - t3) + b2 * t3;
};
const createInterpolateColor = (a2, b2) => {
  const c1 = string2rbg(a2);
  const c2 = string2rbg(b2);
  if (c1 === null || c2 === null)
    return c1 ? () => a2 : () => b2;
  return (t3) => {
    const values2 = new Array(4);
    for (let i2 = 0; i2 < 4; i2 += 1) {
      const from = c1[i2];
      const to = c2[i2];
      values2[i2] = from * (1 - t3) + to * t3;
    }
    const [r2, g2, b3, a3] = values2;
    return `rgba(${Math.round(r2)}, ${Math.round(g2)}, ${Math.round(b3)}, ${a3})`;
  };
};
const createInterpolateValue = (a2, b2) => {
  if (typeof a2 === "number" && typeof b2 === "number")
    return createInterpolateNumber(a2, b2);
  if (typeof a2 === "string" && typeof b2 === "string")
    return createInterpolateColor(a2, b2);
  return () => a2;
};
const createInterpolateRound = (a2, b2) => {
  const interpolateNumber = createInterpolateNumber(a2, b2);
  return (t3) => Math.round(interpolateNumber(t3));
};
function internGet({ map: map2, initKey }, value) {
  const key = initKey(value);
  return map2.has(key) ? map2.get(key) : value;
}
function internSet({ map: map2, initKey }, value) {
  const key = initKey(value);
  if (map2.has(key))
    return map2.get(key);
  map2.set(key, value);
  return value;
}
function internDelete({ map: map2, initKey }, value) {
  const key = initKey(value);
  if (map2.has(key)) {
    value = map2.get(key);
    map2.delete(key);
  }
  return value;
}
function keyof(value) {
  return typeof value === "object" ? value.valueOf() : value;
}
class InternMap extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof;
    if (entries !== null) {
      for (const [key, value] of entries) {
        this.set(key, value);
      }
    }
  }
  get(key) {
    return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value) {
    return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value);
  }
  delete(key) {
    return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
  }
}
class Base {
  /**
   * 
   * @param options 
   */
  constructor(options) {
    this.options = deepMix({}, this.getDefaultOptions());
    this.update(options);
  }
  /**
   * 
   * @returns 
   */
  getOptions() {
    return this.options;
  }
  /**
   * 
   * @param updateOptions 
   */
  update(updateOptions = {}) {
    this.options = deepMix({}, this.options, updateOptions);
    this.rescale(updateOptions);
  }
  /**
   *  options  options  scale 
   *  this.options  options
   * @param options  options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
}
const defaultUnknown = Symbol("defaultUnknown");
function updateIndexMap(target, arr, key) {
  for (let i2 = 0; i2 < arr.length; i2 += 1) {
    if (!target.has(arr[i2])) {
      target.set(key(arr[i2]), i2);
    }
  }
}
function mapBetweenArrByMapIndex(options) {
  const { value, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value) - 1;
    mapper.set(value, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey(d3) {
  if (d3 instanceof Date)
    return (d4) => `${d4}`;
  if (typeof d3 === "object")
    return (d4) => JSON.stringify(d4);
  return (d4) => d4;
}
class Ordinal extends Base {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  map(x2) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.domainKey(x2),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y2) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.rangeKey(y2),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  //  ordinal 
  rescale(options) {
    const [d3] = this.options.domain;
    const [r2] = this.options.range;
    this.domainKey = createKey(d3);
    this.rangeKey = createKey(r2);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
}
function normalize(array) {
  const min2 = Math.min(...array);
  return array.map((d3) => d3 / min2);
}
function splice(array, n2) {
  const sn = array.length;
  const diff = n2 - sn;
  return diff > 0 ? [...array, ...new Array(diff).fill(1)] : diff < 0 ? array.slice(0, n2) : array;
}
function pretty(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function computeFlexBandState(options) {
  const { domain, range, paddingOuter, paddingInner, flex: F2, round: round2, align } = options;
  const n2 = domain.length;
  const flex = splice(F2, n2);
  const [start, end] = range;
  const width2 = end - start;
  const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
  const stepSum = width2 / ratio;
  const PI3 = stepSum * paddingInner / n2;
  const bandWidthSum = stepSum - n2 * PI3;
  const normalizedFlex = normalize(flex);
  const flexSum = normalizedFlex.reduce((sum, value) => sum + value);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap(domain.map((d3, i2) => {
    const bandWidth = normalizedFlex[i2] * minBandWidth;
    return [d3, round2 ? Math.floor(bandWidth) : bandWidth];
  }));
  const valueStep = new InternMap(domain.map((d3, i2) => {
    const bandWidth = normalizedFlex[i2] * minBandWidth;
    const step2 = bandWidth + PI3;
    return [d3, round2 ? Math.floor(step2) : step2];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum, value) => sum + value);
  const outerPaddingSum = width2 - (finalStepSum - finalStepSum / n2 * paddingInner);
  const offset = outerPaddingSum * align;
  const bandStart = start + offset;
  let prev = round2 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n2);
  for (let i2 = 0; i2 < n2; i2 += 1) {
    adjustedRange[i2] = pretty(prev);
    const value = domain[i2];
    prev += valueStep.get(value);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState(options) {
  var _a3;
  const { domain } = options;
  const n2 = domain.length;
  if (n2 === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a3 = options.flex) === null || _a3 === void 0 ? void 0 : _a3.length);
  if (hasFlex) {
    return computeFlexBandState(options);
  }
  const { range, paddingOuter, paddingInner, round: round2, align } = options;
  let step2;
  let bandWidth;
  let rangeStart = range[0];
  const rangeEnd = range[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n2 - paddingInner;
  step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round2) {
    step2 = Math.floor(step2);
  }
  rangeStart += (deltaRange - step2 * (n2 - paddingInner)) * align;
  bandWidth = step2 * (1 - paddingInner);
  if (round2) {
    rangeStart = Math.round(rangeStart);
    bandWidth = Math.round(bandWidth);
  }
  const adjustedRange = new Array(n2).fill(0).map((_2, i2) => rangeStart + i2 * step2);
  return {
    valueStep: step2,
    valueBandWidth: bandWidth,
    adjustedRange
  };
}
class Band extends Ordinal {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown,
      flex: []
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  clone() {
    return new Band(this.options);
  }
  getStep(x2) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x2 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x2);
  }
  getBandWidth(x2) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x2 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x2);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range, round: round2, flex } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
      align,
      range,
      round: round2,
      flex,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
}
const d3Ticks = (begin, end, count) => {
  let n2;
  let ticks;
  let start = begin;
  let stop = end;
  if (start === stop && count > 0) {
    return [start];
  }
  let step2 = tickIncrement(start, stop, count);
  if (step2 === 0 || !Number.isFinite(step2)) {
    return [];
  }
  if (step2 > 0) {
    start = Math.ceil(start / step2);
    stop = Math.floor(stop / step2);
    ticks = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks[i2] = (start + i2) * step2;
    }
  } else {
    step2 = -step2;
    start = Math.ceil(start * step2);
    stop = Math.floor(stop * step2);
    ticks = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks[i2] = (start + i2) / step2;
    }
  }
  return ticks;
};
const createBiMap = (domain, range, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  let normalize2;
  let interpolate2;
  if (d0 < d1) {
    normalize2 = createNormalize(d0, d1);
    interpolate2 = createInterpolate(r0, r1);
  } else {
    normalize2 = createNormalize(d1, d0);
    interpolate2 = createInterpolate(r1, r0);
  }
  return compose(interpolate2, normalize2);
};
const createPolyMap = (domain, range, createInterpolate) => {
  const len2 = Math.min(domain.length, range.length) - 1;
  const normalizeList = new Array(len2);
  const interpolateList = new Array(len2);
  const reverse = domain[0] > domain[len2];
  const ascendingDomain = reverse ? [...domain].reverse() : domain;
  const ascendingRange = reverse ? [...range].reverse() : range;
  for (let i2 = 0; i2 < len2; i2 += 1) {
    normalizeList[i2] = createNormalize(ascendingDomain[i2], ascendingDomain[i2 + 1]);
    interpolateList[i2] = createInterpolate(ascendingRange[i2], ascendingRange[i2 + 1]);
  }
  return (x2) => {
    const i2 = bisect(domain, x2, 1, len2) - 1;
    const normalize2 = normalizeList[i2];
    const interpolate2 = interpolateList[i2];
    return compose(interpolate2, normalize2)(x2);
  };
};
const choosePiecewise = (domain, range, interpolate2, shouldRound) => {
  const n2 = Math.min(domain.length, range.length);
  const createPiecewise = n2 > 2 ? createPolyMap : createBiMap;
  const createInterpolate = shouldRound ? createInterpolateRound : interpolate2;
  return createPiecewise(domain, range, createInterpolate);
};
class Continuous extends Base {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x2) {
    if (!isValid(x2))
      return this.options.unknown;
    return this.output(x2);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x2) {
    if (!isValid(x2))
      return this.options.unknown;
    return this.input(x2);
  }
  nice() {
    if (!this.options.nice)
      return;
    const [min2, max2, tickCount, ...rest] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min2, max2, tickCount, ...rest);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min2, max2, tickCount, ...rest] = this.getTickMethodOptions();
    return tickMethod(min2, max2, tickCount, ...rest);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min2 = domain[0];
    const max2 = domain[domain.length - 1];
    return [min2, max2, tickCount];
  }
  chooseNice() {
    return d3LinearNice;
  }
  rescale() {
    this.nice();
    const [transform2, untransform] = this.chooseTransforms();
    this.composeOutput(transform2, this.chooseClamp(transform2));
    this.composeInput(transform2, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform2) {
    const { clamp: shouldClamp, range } = this.options;
    const domain = this.options.domain.map(transform2);
    const n2 = Math.min(domain.length, range.length);
    return shouldClamp ? createClamp(domain[0], domain[n2 - 1]) : identity;
  }
  composeOutput(transform2, clamp2) {
    const { domain, range, round: round2, interpolate: interpolate2 } = this.options;
    const piecewise = choosePiecewise(domain.map(transform2), range, interpolate2, round2);
    this.output = compose(piecewise, clamp2, transform2);
  }
  composeInput(transform2, untransform, clamp2) {
    const { domain, range } = this.options;
    const piecewise = choosePiecewise(range, domain.map(transform2), createInterpolateNumber);
    this.input = compose(untransform, clamp2, piecewise);
  }
}
class Linear extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  chooseTransforms() {
    return [identity, identity];
  }
  clone() {
    return new Linear(this.options);
  }
}
var Columns = (
  /** @class */
  function(_super) {
    __extends$1(Columns2, _super);
    function Columns2(_a3) {
      var _this2 = this;
      var style = _a3.style, rest = __rest$m(_a3, ["style"]);
      _this2 = _super.call(this, deepMix({}, { type: "column" }, __assign({ style }, rest))) || this;
      _this2.columnsGroup = new Group({ name: "columns" });
      _this2.appendChild(_this2.columnsGroup);
      _this2.render();
      return _this2;
    }
    Columns2.prototype.render = function() {
      var _a3 = this.attributes, columns = _a3.columns, x2 = _a3.x, y2 = _a3.y;
      this.columnsGroup.style.transform = "translate(".concat(x2, ", ").concat(y2, ")");
      select(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
        return enter.append("rect").attr("className", "column").each(function(style) {
          this.attr(style);
        });
      }, function(update) {
        return update.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Columns2.prototype.update = function(attr2) {
      this.attr(deepAssign({}, this.attributes, attr2));
      this.render();
    };
    Columns2.prototype.clear = function() {
      this.removeChildren();
    };
    return Columns2;
  }(DisplayObject)
);
var Lines = (
  /** @class */
  function(_super) {
    __extends$1(Lines2, _super);
    function Lines2(_a3) {
      var _this2 = this;
      var style = _a3.style, rest = __rest$m(_a3, ["style"]);
      _this2 = _super.call(this, deepMix({}, { type: "lines" }, __assign({ style }, rest))) || this;
      _this2.linesGroup = _this2.appendChild(new Group());
      _this2.areasGroup = _this2.appendChild(new Group());
      _this2.render();
      return _this2;
    }
    Lines2.prototype.render = function() {
      var _a3 = this.attributes, lines = _a3.lines, areas = _a3.areas, x2 = _a3.x, y2 = _a3.y;
      this.style.transform = "translate(".concat(x2, ", ").concat(y2, ")");
      if (lines)
        this.renderLines(lines);
      if (areas)
        this.renderAreas(areas);
    };
    Lines2.prototype.clear = function() {
      this.linesGroup.removeChildren();
      this.areasGroup.removeChildren();
    };
    Lines2.prototype.update = function(attr2) {
      this.attr(deepAssign({}, this.attributes, attr2));
      this.render();
    };
    Lines2.prototype.renderLines = function(lines) {
      select(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
        return enter.append("path").attr("className", "line").each(function(style) {
          this.attr(style);
        });
      }, function(update) {
        return update.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Lines2.prototype.renderAreas = function(areas) {
      select(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
        return enter.append("path").attr("className", "area").each(function(style) {
          this.attr(style);
        });
      }, function(update) {
        return update.each(function(style) {
          this.style(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    return Lines2;
  }(DisplayObject)
);
function dataToLines(data2, scales) {
  var _a3;
  var x2 = scales.x, y2 = scales.y;
  var _b = __read(y2.getOptions().range || [0, 0], 2), max2 = _b[0], min2 = _b[1];
  if (min2 > max2)
    _a3 = __read([max2, min2], 2), min2 = _a3[0], max2 = _a3[1];
  return data2.map(function(points) {
    var lines = points.map(function(val, idx) {
      return [x2.map(idx), clamp$1(y2.map(val), min2, max2)];
    });
    return lines;
  });
}
function lineToLinePath(line2, reverse) {
  if (reverse === void 0) {
    reverse = false;
  }
  var M2 = reverse ? line2.length - 1 : 0;
  var linePath = line2.map(function(point2, idx) {
    return __spreadArray([idx === M2 ? "M" : "L"], __read(point2), false);
  });
  return reverse ? linePath.reverse() : linePath;
}
function lineToCurvePath(line2, reverse) {
  if (reverse === void 0) {
    reverse = false;
  }
  if (line2.length <= 2) {
    return lineToLinePath(line2);
  }
  var data2 = [];
  var len2 = line2.length;
  for (var idx = 0; idx < len2; idx += 1) {
    var point2 = reverse ? line2[len2 - idx - 1] : line2[idx];
    if (!isEqual$1(point2, data2.slice(-2))) {
      data2.push.apply(data2, __spreadArray([], __read(point2), false));
    }
  }
  var path = catmullRom2Bezier(data2);
  if (reverse) {
    path.unshift(__spreadArray(["M"], __read(line2[len2 - 1]), false));
  } else {
    path.unshift(__spreadArray(["M"], __read(line2[0]), false));
  }
  return path;
}
function closePathByBaseLine(path, width2, baseline) {
  var closedPath = clone$1(path);
  closedPath.push(["L", width2, baseline], ["L", 0, baseline], ["Z"]);
  return closedPath;
}
function linesToAreaPaths(lines, smooth2, width2, baseline) {
  return lines.map(function(line2) {
    return closePathByBaseLine(smooth2 ? lineToCurvePath(line2) : lineToLinePath(line2), width2, baseline);
  });
}
function linesToStackAreaPaths(lines, width2, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToLinePath(currLine);
    var path = void 0;
    if (idx === 0) {
      path = closePathByBaseLine(currCurvePath, width2, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToLinePath(belowLine, true);
      belowCurvePath[0][0] = "L";
      path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
    }
    paths.push(path);
  }
  return paths;
}
function linesToStackCurveAreaPaths(lines, width2, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToCurvePath(currLine);
    var path = void 0;
    if (idx === 0) {
      path = closePathByBaseLine(currCurvePath, width2, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToCurvePath(belowLine, true);
      var A3 = currLine[0];
      belowCurvePath[0][0] = "L";
      path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A3), false), ["Z"]], false);
    }
    paths.push(path);
  }
  return paths;
}
function getRange(data2) {
  if (data2.length === 0)
    return [0, 0];
  return [
    min$2(minBy$1(data2, function(arr) {
      return min$2(arr) || 0;
    })),
    max$2(maxBy(data2, function(arr) {
      return max$2(arr) || 0;
    }))
  ];
}
function getStackedData(_2) {
  var data2 = clone$1(_2);
  var datumLen = data2[0].length;
  var _a3 = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a3[0], negativePrev = _a3[1];
  for (var i2 = 0; i2 < data2.length; i2 += 1) {
    var datum = data2[i2];
    for (var j = 0; j < datumLen; j += 1) {
      if (datum[j] >= 0) {
        datum[j] += positivePrev[j];
        positivePrev[j] = datum[j];
      } else {
        datum[j] += negativePrev[j];
        negativePrev[j] = datum[j];
      }
    }
  }
  return data2;
}
var Sparkline = (
  /** @class */
  function(_super) {
    __extends$1(Sparkline2, _super);
    function Sparkline2(options) {
      return _super.call(this, options, {
        type: "line",
        x: 0,
        y: 0,
        width: 200,
        height: 20,
        isStack: false,
        color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
        smooth: true,
        lineLineWidth: 1,
        areaOpacity: 0,
        isGroup: false,
        columnLineWidth: 1,
        columnStroke: "#fff",
        scale: 1,
        spacing: 0
      }) || this;
    }
    Object.defineProperty(Sparkline2.prototype, "rawData", {
      /**
       * data
       * 
       */
      get: function() {
        var rawData = this.attributes.data;
        if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
          return [[]];
        var data2 = clone$1(rawData);
        return isNumber(data2[0]) ? [data2] : data2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "data", {
      get: function() {
        if (this.attributes.isStack)
          return getStackedData(this.rawData);
        return this.rawData;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "scales", {
      get: function() {
        return this.createScales(this.data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "baseline", {
      /**
       *  0
       */
      get: function() {
        var y2 = this.scales.y;
        var _a3 = __read(y2.getOptions().domain || [0, 0], 2), y1 = _a3[0], y22 = _a3[1];
        if (y22 < 0) {
          return y2.map(y22);
        }
        return y2.map(y1 < 0 ? 0 : y1);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "containerShape", {
      get: function() {
        var _a3 = this.attributes, width2 = _a3.width, height = _a3.height;
        return { width: width2, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "linesStyle", {
      get: function() {
        var _this2 = this;
        var _a3 = this.attributes, type = _a3.type, isStack = _a3.isStack, smooth2 = _a3.smooth;
        if (type !== "line")
          throw new Error("linesStyle can only be used in line type");
        var areaStyle = subStyleProps(this.attributes, "area");
        var lineStyle = subStyleProps(this.attributes, "line");
        var width2 = this.containerShape.width;
        var data2 = this.data;
        if (data2[0].length === 0)
          return { lines: [], areas: [] };
        var _b = this.scales, x2 = _b.x, y2 = _b.y;
        var lines = dataToLines(data2, { x: x2, y: y2 });
        var areas = [];
        if (areaStyle) {
          var baseline = this.baseline;
          if (isStack) {
            areas = smooth2 ? linesToStackCurveAreaPaths(lines, width2, baseline) : linesToStackAreaPaths(lines, width2, baseline);
          } else {
            areas = linesToAreaPaths(lines, smooth2, width2, baseline);
          }
        }
        return {
          lines: lines.map(function(line2, idx) {
            return __assign({ stroke: _this2.getColor(idx), d: smooth2 ? lineToCurvePath(line2) : lineToLinePath(line2) }, lineStyle);
          }),
          areas: areas.map(function(path, idx) {
            return __assign({ d: path, fill: _this2.getColor(idx) }, areaStyle);
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
      get: function() {
        var _this2 = this;
        var columnStyle = subStyleProps(this.attributes, "column");
        var _a3 = this.attributes, isStack = _a3.isStack, type = _a3.type, scale3 = _a3.scale;
        if (type !== "column")
          throw new Error("columnsStyle can only be used in column type");
        var height = this.containerShape.height;
        var data2 = this.rawData;
        if (!data2)
          return { columns: [] };
        if (isStack)
          data2 = getStackedData(data2);
        var _b = this.createScales(data2), x2 = _b.x, y2 = _b.y;
        var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
        var heightScale = new Linear({
          domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
          range: [0, height * scale3]
        });
        var bandWidth = x2.getBandWidth();
        var rawData = this.rawData;
        return {
          columns: data2.map(function(column, i2) {
            return column.map(function(val, j) {
              var barWidth = bandWidth / data2.length;
              var getShape2 = function() {
                return {
                  x: x2.map(j) + barWidth * i2,
                  y: val >= 0 ? y2.map(val) : y2.map(0),
                  width: barWidth,
                  height: heightScale.map(Math.abs(val))
                };
              };
              var getStackShape = function() {
                return {
                  x: x2.map(j),
                  y: y2.map(val),
                  width: bandWidth,
                  height: heightScale.map(rawData[i2][j])
                };
              };
              return __assign(__assign({ fill: _this2.getColor(i2) }, columnStyle), isStack ? getStackShape() : getShape2());
            });
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Sparkline2.prototype.render = function(attributes, container) {
      maybeAppend(container, ".container", "rect").attr("className", "container").node();
      var type = attributes.type, x2 = attributes.x, y2 = attributes.y;
      var className = "spark".concat(type);
      var style = __assign({ x: x2, y: y2 }, type === "line" ? this.linesStyle : this.columnsStyle);
      select(container).selectAll(".spark").data([type]).join(function(enter) {
        return enter.append(function(type2) {
          if (type2 === "line")
            return new Lines({ className, style });
          return new Columns({ className, style });
        }).attr("className", "spark ".concat(className));
      }, function(update) {
        return update.update(style);
      }, function(exit) {
        return exit.remove();
      });
    };
    Sparkline2.prototype.getColor = function(index2) {
      var color2 = this.attributes.color;
      if (isArray$2(color2)) {
        return color2[index2 % color2.length];
      }
      if (isFunction$1(color2)) {
        return color2.call(null, index2);
      }
      return color2;
    };
    Sparkline2.prototype.createScales = function(data2) {
      var _a3, _b;
      var _c = this.attributes, type = _c.type, scale3 = _c.scale, _d = _c.range, range = _d === void 0 ? [] : _d, spacing = _c.spacing;
      var _e = this.containerShape, width2 = _e.width, height = _e.height;
      var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
      var yScale = new Linear({
        domain: [(_a3 = range[0]) !== null && _a3 !== void 0 ? _a3 : minVal, (_b = range[1]) !== null && _b !== void 0 ? _b : maxVal],
        range: [height, height * (1 - scale3)]
      });
      if (type === "line") {
        return {
          type,
          x: new Linear({
            domain: [0, data2[0].length - 1],
            range: [0, width2]
          }),
          y: yScale
        };
      }
      return {
        type,
        x: new Band({
          domain: data2[0].map(function(val, idx) {
            return idx;
          }),
          range: [0, width2],
          paddingInner: spacing,
          paddingOuter: spacing / 2,
          align: 0.5
        }),
        y: yScale
      };
    };
    Sparkline2.tag = "sparkline";
    return Sparkline2;
  }(Component)
);
function isStandardAnimationOption(option) {
  if (typeof option === "boolean")
    return false;
  return "enter" in option && "update" in option && "exit" in option;
}
function parseAnimationOption(option) {
  if (!option)
    return { enter: false, update: false, exit: false };
  var keys = ["enter", "update", "exit"];
  var baseOption = Object.fromEntries(Object.entries(option).filter(function(_a3) {
    var _b = __read(_a3, 1), k = _b[0];
    return !keys.includes(k);
  }));
  return Object.fromEntries(keys.map(function(k) {
    if (isStandardAnimationOption(option)) {
      if (option[k] === false)
        return [k, false];
      return [k, __assign(__assign({}, option[k]), baseOption)];
    }
    return [k, baseOption];
  }));
}
function onAnimateFinished(animation, callback) {
  if (!animation)
    callback();
  else
    animation.finished.then(callback);
}
function onAnimatesFinished(animations, callback) {
  if (animations.length === 0)
    callback();
  else
    Promise.all(animations.map(function(a2) {
      return a2 === null || a2 === void 0 ? void 0 : a2.finished;
    })).then(callback);
}
function attr(target, value) {
  if ("update" in target)
    target.update(value);
  else
    target.attr(value);
}
function animate(target, keyframes, options) {
  if (keyframes.length === 0)
    return null;
  if (!options) {
    var state = keyframes.slice(-1)[0];
    attr(target, { style: state });
    return null;
  }
  return target.animate(keyframes, options);
}
function identicalTextNode(source, target) {
  if (source.nodeName !== "text" || target.nodeName !== "text")
    return false;
  if (source.attributes.text !== target.attributes.text)
    return false;
  return true;
}
function transitionShape(source, target, options, after) {
  if (after === void 0) {
    after = "destroy";
  }
  if (identicalTextNode(source, target)) {
    source.remove();
    return [null];
  }
  var afterTransition = function() {
    if (after === "destroy")
      source.destroy();
    else if (after === "hide")
      hide(source);
    if (target.isVisible())
      show(target);
  };
  if (!options) {
    afterTransition();
    return [null];
  }
  var _a3 = options.duration, duration2 = _a3 === void 0 ? 0 : _a3, _b = options.delay, delay = _b === void 0 ? 0 : _b;
  var middle = Math.ceil(+duration2 / 2);
  var offset = +duration2 / 4;
  var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
  var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
  var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
  var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
  var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
  var st = source.style.transform || "";
  var tt = target.style.transform || "";
  var sourceAnimation = source.animate([
    { opacity: so, transform: "translate(0, 0) ".concat(st) },
    { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
  ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset }));
  var targetAnimation = target.animate([
    { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
    { opacity: to, transform: "translate(0, 0) ".concat(tt) }
  ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset, delay: delay + middle - offset }));
  onAnimateFinished(targetAnimation, afterTransition);
  return [sourceAnimation, targetAnimation];
}
function transition(target, state, options) {
  var from = {};
  var to = {};
  Object.entries(state).forEach(function(_a3) {
    var _b = __read(_a3, 2), key = _b[0], tarStyle = _b[1];
    if (!isNil(tarStyle)) {
      var currStyle = target.style[key] || target.parsedStyle[key] || 0;
      if (currStyle !== tarStyle) {
        from[key] = currStyle;
        to[key] = tarStyle;
      }
    }
  });
  if (!options) {
    attr(target, to);
    return null;
  }
  return animate(target, [from, to], __assign({ fill: "both" }, options));
}
function fadeOut(element, options) {
  if (!element.style.opacity)
    element.style.opacity = 1;
  return transition(element, { opacity: 0 }, options);
}
var HANDLE_ICON_DEFAULT_CFG = {
  fill: "#fff",
  lineWidth: 1,
  radius: 2,
  size: 10,
  stroke: "#bfbfbf",
  strokeOpacity: 1,
  zIndex: 0
};
var HANDLE_LABEL_DEFAULT_CFG = {
  fill: "#000",
  fillOpacity: 0.45,
  fontSize: 12,
  textAlign: "center",
  textBaseline: "middle",
  zIndex: 1
};
var HANDLE_DEFAULT_CFG = {
  x: 0,
  y: 0,
  orientation: "horizontal",
  showLabel: true,
  type: "start"
};
var CLASS_NAMES$a = classNames({
  foreground: "foreground",
  handle: "handle",
  selection: "selection",
  sparkline: "sparkline",
  sparklineGroup: "sparkline-group",
  track: "track",
  brushArea: "brush-area"
}, "slider");
var CLASS_NAMES$9 = classNames({
  labelGroup: "label-group",
  label: "label",
  iconGroup: "icon-group",
  icon: "icon",
  iconRect: "icon-rect",
  iconLine: "icon-line"
}, "handle");
var HandleIcon = (
  /** @class */
  function(_super) {
    __extends$1(HandleIcon2, _super);
    function HandleIcon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HandleIcon2.prototype.render = function(attributes, container) {
      var x2 = attributes.x, y2 = attributes.y, _a3 = attributes.size, size = _a3 === void 0 ? 10 : _a3, _b = attributes.radius, radius = _b === void 0 ? size / 4 : _b, orientation5 = attributes.orientation, classNamePrefix = attributes.classNamePrefix, iconStyle = __rest$m(attributes, ["x", "y", "size", "radius", "orientation", "classNamePrefix"]);
      var width2 = size;
      var height = width2 * 2.4;
      var rectClassName = classNamePrefix ? "".concat(CLASS_NAMES$9.iconRect.name, " ").concat(classNamePrefix, "handle-icon-rect") : CLASS_NAMES$9.iconRect.name;
      var lineClassName = function(index2) {
        return classNamePrefix ? "".concat(CLASS_NAMES$9.iconLine, "-").concat(index2, " ").concat(classNamePrefix, "handle-icon-line") : "".concat(CLASS_NAMES$9.iconLine, "-").concat(index2);
      };
      var rect2 = select(container).maybeAppendByClassName(CLASS_NAMES$9.iconRect, "rect").attr("className", rectClassName).styles(__assign(__assign({}, iconStyle), { width: width2, height, radius, x: x2 - width2 / 2, y: y2 - height / 2, transformOrigin: "center" }));
      var x1 = x2 + 1 / 3 * width2 - width2 / 2;
      var x22 = x2 + 2 / 3 * width2 - width2 / 2;
      var y1 = y2 + 1 / 4 * height - height / 2;
      var y22 = y2 + 3 / 4 * height - height / 2;
      rect2.maybeAppendByClassName("".concat(CLASS_NAMES$9.iconLine, "-1"), "line").attr("className", lineClassName(1)).styles(__assign({ x1, x2: x1, y1, y2: y22 }, iconStyle));
      rect2.maybeAppendByClassName("".concat(CLASS_NAMES$9.iconLine, "-2"), "line").attr("className", lineClassName(2)).styles(__assign({ x1: x22, x2: x22, y1, y2: y22 }, iconStyle));
      if (orientation5 === "vertical")
        rect2.node().style.transform = "rotate(90)";
    };
    return HandleIcon2;
  }(Component)
);
var Handle = (
  /** @class */
  function(_super) {
    __extends$1(Handle2, _super);
    function Handle2(options) {
      return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
    }
    Handle2.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, showLabel = _a3.showLabel;
      var _b = subStyleProps(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform2 = _b.transform, transformOrigin2 = _b.transformOrigin, style = __rest$m(_b, ["x", "y", "transform", "transformOrigin"]);
      var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
      var labelGroup = select(container).maybeAppendByClassName(CLASS_NAMES$9.labelGroup, "g").styles(groupStyle);
      var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest$m(_f, ["text"]);
      ifShow(!!showLabel, labelGroup, function(group2) {
        _this2.label = group2.maybeAppendByClassName(CLASS_NAMES$9.label, "text").styles(__assign(__assign({}, rest), { x: x2 + labelX, y: y2 + labelY, transform: transform2, transformOrigin: transformOrigin2, text: "".concat(text) }));
        _this2.label.on("mousedown", function(e3) {
          e3.stopPropagation();
        });
        _this2.label.on("touchstart", function(e3) {
          e3.stopPropagation();
        });
      });
    };
    Handle2.prototype.renderIcon = function(container) {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, orientation5 = _a3.orientation, type = _a3.type, classNamePrefix = _a3.classNamePrefix;
      var iconStyle = __assign(__assign({ x: x2, y: y2, orientation: orientation5, classNamePrefix }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
      var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
        return new HandleIcon({ style: iconStyle });
      } : _b;
      var iconGroup = select(container).maybeAppendByClassName(CLASS_NAMES$9.iconGroup, "g");
      iconGroup.selectAll(CLASS_NAMES$9.icon.class).data([iconShape]).join(function(enter) {
        return enter.append(typeof iconShape === "string" ? iconShape : function() {
          return iconShape(type);
        }).attr("className", CLASS_NAMES$9.icon.name);
      }, function(update) {
        return update.update(iconStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Handle2.prototype.render = function(attributes, container) {
      this.renderIcon(container);
      this.renderLabel(container);
    };
    return Handle2;
  }(Component)
);
var Slider = (
  /** @class */
  function(_super) {
    __extends$1(Slider2, _super);
    function Slider2(options) {
      var _this2 = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
        return val.toString();
      }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
      _this2.range = [0, 1];
      _this2.onDragStart = function(target) {
        return function(e3) {
          e3.stopPropagation();
          _this2.target = target;
          _this2.prevPos = _this2.getOrientVal(getEventViewportPos(e3));
          var _a3 = _this2.availableSpace, x2 = _a3.x, y2 = _a3.y;
          var _b = _this2.getBBox(), X = _b.x, Y2 = _b.y;
          _this2.selectionStartPos = _this2.getRatio(_this2.prevPos - _this2.getOrientVal([x2, y2]) - _this2.getOrientVal([+X, +Y2]));
          _this2.selectionWidth = 0;
          document.addEventListener("pointermove", _this2.onDragging);
          document.addEventListener("pointerup", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e3) {
        var _a3 = _this2.attributes, slidable = _a3.slidable, brushable = _a3.brushable, type = _a3.type;
        e3.stopPropagation();
        var currPos = _this2.getOrientVal(getEventViewportPos(e3));
        var diffPos = currPos - _this2.prevPos;
        if (!diffPos)
          return;
        var deltaVal = _this2.getRatio(diffPos);
        switch (_this2.target) {
          case "start":
            if (slidable)
              _this2.setValuesOffset(deltaVal);
            break;
          case "end":
            if (slidable)
              _this2.setValuesOffset(0, deltaVal);
            break;
          case "selection":
            if (slidable)
              _this2.setValuesOffset(deltaVal, deltaVal);
            break;
          case "track":
            if (!brushable)
              return;
            _this2.selectionWidth += deltaVal;
            if (type === "range") {
              _this2.innerSetValues([_this2.selectionStartPos, _this2.selectionStartPos + _this2.selectionWidth].sort(), true);
            } else
              _this2.innerSetValues([0, _this2.selectionStartPos + _this2.selectionWidth], true);
            break;
        }
        _this2.prevPos = currPos;
      };
      _this2.onDragEnd = function() {
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointerup", _this2.onDragEnd);
        _this2.target = "";
        _this2.updateHandlesPosition(false);
      };
      _this2.onValueChange = function(oldValue) {
        var _a3 = _this2.attributes, onChange = _a3.onChange, type = _a3.type;
        var internalOldValue = type === "range" ? oldValue : oldValue[1];
        var value = type === "range" ? _this2.getValues() : _this2.getValues()[1];
        var evt = new CustomEvent("valuechange", {
          detail: { oldValue: internalOldValue, value }
        });
        _this2.dispatchEvent(evt);
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
      };
      _this2.selectionStartPos = 0;
      _this2.selectionWidth = 0;
      _this2.prevPos = 0;
      _this2.target = "";
      return _this2;
    }
    Object.defineProperty(Slider2.prototype, "values", {
      get: function() {
        return this.attributes.values;
      },
      set: function(values2) {
        this.attributes.values = this.clampValues(values2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider2.prototype, "sparklineStyle", {
      get: function() {
        var orientation5 = this.attributes.orientation;
        if (orientation5 !== "horizontal")
          return null;
        var attr2 = subStyleProps(this.attributes, "sparkline");
        return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider2.prototype, "shape", {
      get: function() {
        var _a3 = this.attributes, trackLength = _a3.trackLength, trackSize = _a3.trackSize;
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width2 = _b[0], height = _b[1];
        return { width: width2, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider2.prototype, "availableSpace", {
      get: function() {
        var _a3 = this.attributes;
        _a3.x;
        _a3.y;
        var padding = _a3.padding;
        var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right = _b[1], bottom = _b[2], left = _b[3];
        var _c = this.shape, width2 = _c.width, height = _c.height;
        return {
          x: left,
          y: top,
          width: width2 - (left + right),
          height: height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Slider2.prototype.getValues = function() {
      return this.values;
    };
    Slider2.prototype.setValues = function(values2, animate2) {
      if (values2 === void 0) {
        values2 = [0, 0];
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      this.attributes.values = values2;
      var animation = animate2 === false ? false : this.attributes.animate;
      this.updateSelectionArea(animation);
      this.updateHandlesPosition(animation);
    };
    Slider2.prototype.updateSelectionArea = function(animation) {
      var newSelectionArea = this.calcSelectionArea();
      this.foregroundGroup.selectAll(CLASS_NAMES$a.selection.class).each(function(datum, index2) {
        transition(this, newSelectionArea[index2], animation);
      });
    };
    Slider2.prototype.updateHandlesPosition = function(animation) {
      if (!this.attributes.showHandle)
        return;
      this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
      this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
    };
    Slider2.prototype.innerSetValues = function(values2, trigger) {
      if (values2 === void 0) {
        values2 = [0, 0];
      }
      if (trigger === void 0) {
        trigger = false;
      }
      var oldValues = this.values;
      var newValues = this.clampValues(values2);
      this.attributes.values = newValues;
      this.setValues(newValues);
      if (trigger) {
        this.onValueChange(oldValues);
      }
    };
    Slider2.prototype.renderTrack = function(container) {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y;
      var style = subStyleProps(this.attributes, "track");
      this.trackShape = select(container).maybeAppendByClassName(CLASS_NAMES$a.track, "rect").styles(__assign(__assign({ x: x2, y: y2 }, this.shape), style));
    };
    Slider2.prototype.renderBrushArea = function(container) {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, brushable = _a3.brushable;
      this.brushArea = select(container).maybeAppendByClassName(CLASS_NAMES$a.brushArea, "rect").styles(__assign({ x: x2, y: y2, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
    };
    Slider2.prototype.renderSparkline = function(container) {
      var _this2 = this;
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, orientation5 = _a3.orientation;
      var sparklineGroup = select(container).maybeAppendByClassName(CLASS_NAMES$a.sparklineGroup, "g");
      ifShow(orientation5 === "horizontal", sparklineGroup, function(group2) {
        var style = __assign(__assign({}, _this2.sparklineStyle), { x: x2, y: y2 });
        group2.maybeAppendByClassName(CLASS_NAMES$a.sparkline, function() {
          return new Sparkline({ style });
        }).update(style);
      });
    };
    Slider2.prototype.renderHandles = function() {
      var _this2 = this;
      var _a3;
      var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
      var availableHandle = type === "range" ? ["start", "end"] : ["end"];
      var data2 = showHandle ? availableHandle : [];
      var that = this;
      (_a3 = this.foregroundGroup) === null || _a3 === void 0 ? void 0 : _a3.selectAll(CLASS_NAMES$a.handle.class).data(data2.map(function(type2) {
        return { type: type2 };
      }), function(d3) {
        return d3.type;
      }).join(function(enter) {
        return enter.append(function(_a4) {
          var type2 = _a4.type;
          return new Handle({ style: _this2.getHandleStyle(type2) });
        }).each(function(_a4) {
          var type2 = _a4.type;
          this.attr("class", "".concat(CLASS_NAMES$a.handle.name, " ").concat(type2, "-handle"));
          var name = "".concat(type2, "Handle");
          that[name] = this;
          this.addEventListener("pointerdown", that.onDragStart(type2));
        });
      }, function(update) {
        return update.each(function(_a4) {
          var type2 = _a4.type;
          this.update(that.getHandleStyle(type2));
        });
      }, function(exit) {
        return exit.each(function(_a4) {
          var type2 = _a4.type;
          var name = "".concat(type2, "Handle");
          that[name] = void 0;
        }).remove();
      });
    };
    Slider2.prototype.renderSelection = function(container) {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, type = _a3.type, selectionType = _a3.selectionType;
      this.foregroundGroup = select(container).maybeAppendByClassName(CLASS_NAMES$a.foreground, "g");
      var selectionStyle = subStyleProps(this.attributes, "selection");
      var applyStyle = function(selection) {
        return selection.style("visibility", function(d3) {
          return d3.show ? "visible" : "hidden";
        }).style("cursor", function(d3) {
          if (selectionType === "select")
            return "grab";
          if (selectionType === "invert")
            return "crosshair";
          return "default";
        }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x2, ", ").concat(y2, ")") }));
      };
      var that = this;
      this.foregroundGroup.selectAll(CLASS_NAMES$a.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area, index2) {
        return {
          style: __assign({}, area),
          index: index2,
          // 
          show: selectionType === "select" ? index2 === 1 : index2 !== 1
        };
      }), function(d3) {
        return d3.index;
      }).join(function(enter) {
        return enter.append("rect").attr("className", CLASS_NAMES$a.selection.name).call(applyStyle).each(function(datum, index2) {
          var _this2 = this;
          if (index2 === 1) {
            that.selectionShape = select(this);
            this.on("pointerdown", function(e3) {
              _this2.attr("cursor", "grabbing");
              that.onDragStart("selection")(e3);
            });
            that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
            that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
            that.dispatchCustomEvent(this, "click", "selectionClick");
            this.addEventListener("pointerdown", function() {
              _this2.attr("cursor", "grabbing");
            });
            this.addEventListener("pointerup", function() {
              _this2.attr("cursor", "pointer");
            });
            this.addEventListener("pointerover", function() {
              _this2.attr("cursor", "pointer");
            });
          } else {
            this.on("pointerdown", that.onDragStart("track"));
          }
        });
      }, function(update) {
        return update.call(applyStyle);
      }, function(exit) {
        return exit.remove();
      });
      this.updateSelectionArea(false);
      this.renderHandles();
    };
    Slider2.prototype.render = function(attributes, container) {
      this.renderTrack(container);
      this.renderSparkline(container);
      this.renderBrushArea(container);
      this.renderSelection(container);
    };
    Slider2.prototype.clampValues = function(values2, precision) {
      var _a3;
      if (precision === void 0) {
        precision = 4;
      }
      var _b = __read(this.range, 2), min2 = _b[0], max2 = _b[1];
      var _c = __read(this.getValues().map(function(num) {
        return toPrecision(num, precision);
      }), 2), prevStart = _c[0], prevEnd = _c[1];
      var internalValues = Array.isArray(values2) ? values2 : [prevStart, values2 !== null && values2 !== void 0 ? values2 : prevEnd];
      var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
        return toPrecision(num, precision);
      }), 2), startVal = _d[0], endVal = _d[1];
      if (this.attributes.type === "value")
        return [0, clamp$1(endVal, min2, max2)];
      if (startVal > endVal) {
        _a3 = __read([endVal, startVal], 2), startVal = _a3[0], endVal = _a3[1];
      }
      var range = endVal - startVal;
      if (range > max2 - min2)
        return [min2, max2];
      if (startVal < min2) {
        if (prevStart === min2 && prevEnd === endVal)
          return [min2, endVal];
        return [min2, range + min2];
      }
      if (endVal > max2) {
        if (prevEnd === max2 && prevStart === startVal)
          return [startVal, max2];
        return [max2 - range, max2];
      }
      return [startVal, endVal];
    };
    Slider2.prototype.calcSelectionArea = function(values2) {
      var _a3 = __read(this.clampValues(values2), 2), start = _a3[0], end = _a3[1];
      var _b = this.availableSpace, x2 = _b.x, y2 = _b.y, width2 = _b.width, height = _b.height;
      return this.getOrientVal([
        [
          { y: y2, height, x: x2, width: start * width2 },
          { y: y2, height, x: start * width2 + x2, width: (end - start) * width2 },
          { y: y2, height, x: end * width2, width: (1 - end) * width2 }
        ],
        [
          { x: x2, width: width2, y: y2, height: start * height },
          { x: x2, width: width2, y: start * height + y2, height: (end - start) * height },
          { x: x2, width: width2, y: end * height, height: (1 - end) * height }
        ]
      ]);
    };
    Slider2.prototype.calcHandlePosition = function(handleType) {
      var handleIconOffset = this.attributes.handleIconOffset;
      var _a3 = this.availableSpace, x2 = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height;
      var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
      var offset = handleType === "start" ? -handleIconOffset : handleIconOffset;
      var L2 = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width2, height]) + offset;
      return {
        x: x2 + this.getOrientVal([L2, width2 / 2]),
        y: y2 + this.getOrientVal([height / 2, L2])
      };
    };
    Slider2.prototype.inferTextStyle = function(handleType) {
      var orientation5 = this.attributes.orientation;
      if (orientation5 === "horizontal")
        return {};
      if (handleType === "start")
        return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
      if (handleType === "end")
        return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
      return {};
    };
    Slider2.prototype.calcHandleText = function(handleType) {
      var _a3;
      var _b = this.attributes, type = _b.type, orientation5 = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var labelStyle = subStyleProps(handleStyle, "label");
      var spacing = handleStyle.spacing;
      var size = this.getHandleSize();
      var values2 = this.clampValues();
      var value = handleType === "start" ? values2[0] : values2[1];
      var text = formatter2(value);
      var temp = new Text({
        style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
      });
      var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
      temp.destroy();
      if (!autoFitLabel) {
        if (type === "value")
          return { text, x: 0, y: -textHeight - spacing };
        var finaleWidth = spacing + size + (orientation5 === "horizontal" ? textWidth / 2 : 0);
        return _a3 = { text }, _a3[orientation5 === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a3;
      }
      var x2 = 0;
      var y2 = 0;
      var _d = this.availableSpace, iW = _d.width, iH = _d.height;
      var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
      var totalSpacing = spacing + size;
      if (orientation5 === "horizontal") {
        var finalWidth = totalSpacing + textWidth / 2;
        if (handleType === "start") {
          var left = fX - totalSpacing - textWidth;
          x2 = left > 0 ? -finalWidth : finalWidth;
        } else {
          var sign = iW - fX - fW - totalSpacing > textWidth;
          x2 = sign ? finalWidth : -finalWidth;
        }
      } else {
        var positiveSize = totalSpacing;
        var negativeSize = textHeight + totalSpacing;
        if (handleType === "start") {
          y2 = fY - size > textHeight ? -negativeSize : positiveSize;
        } else {
          y2 = iH - (fY + fH) - size > textHeight ? negativeSize : -positiveSize;
        }
      }
      return { x: x2, y: y2, text };
    };
    Slider2.prototype.getHandleLabelStyle = function(handleType) {
      var style = subStyleProps(this.attributes, "handleLabel");
      return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
    };
    Slider2.prototype.getHandleIconStyle = function() {
      var shape = this.attributes.handleIconShape;
      var style = subStyleProps(this.attributes, "handleIcon");
      var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
      var size = this.getHandleSize();
      return __assign({ cursor, shape, size }, style);
    };
    Slider2.prototype.getHandleStyle = function(handleType) {
      var _a3 = this.attributes, ox = _a3.x, oy = _a3.y, showLabel = _a3.showLabel, showLabelOnInteraction = _a3.showLabelOnInteraction, orientation5 = _a3.orientation;
      var _b = this.calcHandlePosition(handleType), x2 = _b.x, y2 = _b.y;
      var textStyle = this.calcHandleText(handleType);
      var internalShowLabel = showLabel;
      if (!showLabel && showLabelOnInteraction) {
        if (this.target)
          internalShowLabel = true;
        else
          internalShowLabel = false;
      }
      return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x2 + ox, ", ").concat(y2 + oy, ")"), orientation: orientation5, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
    };
    Slider2.prototype.getHandleSize = function() {
      var _a3 = this.attributes, size = _a3.handleIconSize, width2 = _a3.width, height = _a3.height;
      if (size)
        return size;
      return Math.floor((this.getOrientVal([+height, +width2]) + 4) / 2.4);
    };
    Slider2.prototype.getOrientVal = function(_a3) {
      var _b = __read(_a3, 2), x2 = _b[0], y2 = _b[1];
      var orientation5 = this.attributes.orientation;
      return orientation5 === "horizontal" ? x2 : y2;
    };
    Slider2.prototype.setValuesOffset = function(stOffset, endOffset) {
      if (endOffset === void 0) {
        endOffset = 0;
      }
      var type = this.attributes.type;
      var _a3 = __read(this.getValues(), 2), oldStartVal = _a3[0], oldEndVal = _a3[1];
      var internalStartOffset = type === "range" ? stOffset : 0;
      var values2 = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
      this.innerSetValues(values2, true);
    };
    Slider2.prototype.getRatio = function(val) {
      var _a3 = this.availableSpace, width2 = _a3.width, height = _a3.height;
      return val / this.getOrientVal([width2, height]);
    };
    Slider2.prototype.dispatchCustomEvent = function(target, event, name) {
      var _this2 = this;
      target.on(event, function(e3) {
        e3.stopPropagation();
        _this2.dispatchEvent(new CustomEvent(name, { detail: e3 }));
      });
    };
    Slider2.prototype.bindEvents = function() {
      this.addEventListener("wheel", this.onScroll);
      var brushArea = this.brushArea;
      this.dispatchCustomEvent(brushArea, "click", "trackClick");
      this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
      this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
      brushArea.on("pointerdown", this.onDragStart("track"));
    };
    Slider2.prototype.onScroll = function(event) {
      var scrollable = this.attributes.scrollable;
      if (scrollable) {
        var deltaX = event.deltaX, deltaY = event.deltaY;
        var offset = deltaY || deltaX;
        var deltaVal = this.getRatio(offset);
        this.setValuesOffset(deltaVal, deltaVal);
      }
    };
    Slider2.tag = "slider";
    return Slider2;
  }(Component)
);
var CLASSNAME_SUFFIX_MAP$1 = {
  // group
  gridGroup: "grid-group",
  mainGroup: "main-group",
  lineGroup: "line-group",
  tickGroup: "tick-group",
  labelGroup: "label-group",
  titleGroup: "title-group",
  // content
  grid: "grid",
  line: "line",
  lineFirst: "line-first",
  lineSecond: "line-second",
  tick: "tick",
  tickItem: "tick-item",
  label: "label",
  labelItem: "label-item",
  title: "title"
};
var AXIS_BASE_DEFAULT_ATTR = {
  data: [],
  animate: {
    enter: false,
    update: {
      duration: 100,
      easing: "ease-in-out-sine",
      fill: "both"
    },
    exit: {
      duration: 100,
      fill: "both"
    }
  },
  showArrow: true,
  showGrid: true,
  showLabel: true,
  showLine: true,
  showTick: true,
  showTitle: true,
  showTrunc: false,
  dataThreshold: 100,
  lineLineWidth: 1,
  lineStroke: "black",
  crossPadding: 10,
  titleFill: "black",
  titleFontSize: 12,
  titlePosition: "lb",
  titleSpacing: 0,
  titleTextAlign: "center",
  titleTextBaseline: "middle",
  lineArrow: function() {
    return new Path({
      style: {
        d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
        fill: "black",
        transformOrigin: "center"
      }
    });
  },
  labelAlign: "parallel",
  labelDirection: "positive",
  labelFontSize: 12,
  labelSpacing: 0,
  gridConnect: "line",
  gridControlAngles: [],
  gridDirection: "positive",
  gridLength: 0,
  gridType: "segment",
  lineArrowOffset: 15,
  lineArrowSize: 10,
  tickDirection: "positive",
  tickLength: 5,
  tickLineWidth: 1,
  tickStroke: "black",
  labelOverlap: [
    // { type: 'rotate', optionalAngles: [0, 45, 90] },
    // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
    // { type: 'hide' },
  ]
};
deepMix({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {
    type: "arc"
  }
});
deepMix({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {}
});
var CLASS_NAMES$8 = classNames({
  mainGroup: CLASSNAME_SUFFIX_MAP$1.mainGroup,
  gridGroup: CLASSNAME_SUFFIX_MAP$1.gridGroup,
  grid: CLASSNAME_SUFFIX_MAP$1.grid,
  lineGroup: CLASSNAME_SUFFIX_MAP$1.lineGroup,
  line: CLASSNAME_SUFFIX_MAP$1.line,
  tickGroup: CLASSNAME_SUFFIX_MAP$1.tickGroup,
  tick: CLASSNAME_SUFFIX_MAP$1.tick,
  tickItem: CLASSNAME_SUFFIX_MAP$1.tickItem,
  labelGroup: CLASSNAME_SUFFIX_MAP$1.labelGroup,
  label: CLASSNAME_SUFFIX_MAP$1.label,
  labelItem: CLASSNAME_SUFFIX_MAP$1.labelItem,
  titleGroup: CLASSNAME_SUFFIX_MAP$1.titleGroup,
  title: CLASSNAME_SUFFIX_MAP$1.title,
  lineFirst: CLASSNAME_SUFFIX_MAP$1.lineFirst,
  lineSecond: CLASSNAME_SUFFIX_MAP$1.lineSecond
}, "axis");
var CLASS_NAMES$7 = classNames({
  lineGroup: "line-group",
  line: "line",
  regionGroup: "region-group",
  region: "region"
}, "grid");
function getStraightPath(points) {
  return points.reduce(function(acc, curr, idx) {
    acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
    return acc;
  }, []);
}
function getSurroundPath(points, attr2, reversed) {
  var _a3 = attr2.connect, connect = _a3 === void 0 ? "line" : _a3, center = attr2.center;
  if (connect === "line")
    return getStraightPath(points);
  if (!center)
    return [];
  var radius = distance$1(points[0], center);
  var sweepFlag = reversed ? 0 : 1;
  return points.reduce(function(r2, p2, idx) {
    if (idx === 0)
      r2.push(__spreadArray(["M"], __read(p2), false));
    else
      r2.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p2), false));
    return r2;
  }, []);
}
function getLinePath$1(points, cfg, reversed) {
  if (cfg.type === "surround")
    return getSurroundPath(points, cfg, reversed);
  return getStraightPath(points);
}
function connectPaths(from, to, cfg) {
  var type = cfg.type, connect = cfg.connect, center = cfg.center, closed = cfg.closed;
  var closeFlag = closed ? [["Z"]] : [];
  var _a3 = __read([getLinePath$1(from, cfg), getLinePath$1(to.slice().reverse(), cfg, true)], 2), path1 = _a3[0], path2 = _a3[1];
  var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
  var createPath = function(insertA, insertB) {
    return [path1, insertA, path2, insertB, closeFlag].flat();
  };
  if (connect === "line" || type === "surround") {
    return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
  }
  if (!center)
    throw new Error("Arc grid need to specified center");
  var _c = __read([distance$1(endOfTo, center), distance$1(startOfFrom, center)], 2), raduis1 = _c[0], radius2 = _c[1];
  return createPath([
    __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
    __spreadArray(["L"], __read(endOfTo), false)
  ], [
    __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
    __spreadArray(["L"], __read(startOfFrom), false)
  ]);
}
function renderGridLine(container, data2, attr2, style) {
  var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
  var lines = data2.map(function(item, idx) {
    return {
      id: item.id || "grid-line-".concat(idx),
      d: getLinePath$1(item.points, attr2)
    };
  });
  return container.selectAll(CLASS_NAMES$7.line.class).data(lines, function(d3) {
    return d3.id;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index2) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index2, lines]);
      this.attr(__assign({ class: CLASS_NAMES$7.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
    });
  }, function(update) {
    return update.transition(function(datum, index2) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index2, lines]);
      return transition(this, lineStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function renderAlternateRegion(container, data2, style) {
  var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
  if (data2.length < 2 || !areaFill || !connect)
    return [];
  var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
  var getColor2 = function(idx2) {
    return colors[idx2 % colors.length];
  };
  var regions = [];
  for (var idx = 0; idx < data2.length - 1; idx++) {
    var _a3 = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a3[0], curr = _a3[1];
    var path = connectPaths(prev, curr, style);
    regions.push({ d: path, fill: getColor2(idx) });
  }
  return container.selectAll(CLASS_NAMES$7.region.class).data(regions, function(_2, i2) {
    return i2;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index2) {
      var regionStyle = getCallbackValue(datum, [datum, index2, regions]);
      this.attr(regionStyle);
    }).attr("className", CLASS_NAMES$7.region.name);
  }, function(update) {
    return update.transition(function(datum, index2) {
      var regionStyle = getCallbackValue(datum, [datum, index2, regions]);
      return transition(this, regionStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function getData(attr2) {
  var _a3 = attr2.data, data2 = _a3 === void 0 ? [] : _a3, closed = attr2.closed;
  if (!closed)
    return data2;
  return data2.map(function(datum) {
    var points = datum.points;
    var _a4 = __read(points, 1), start = _a4[0];
    return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
  });
}
var Grid2 = (
  /** @class */
  function(_super) {
    __extends$1(Grid3, _super);
    function Grid3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Grid3.prototype.render = function(attributes, container) {
      attributes.type;
      attributes.center;
      attributes.areaFill;
      attributes.closed;
      var style = __rest$m(attributes, ["type", "center", "areaFill", "closed"]);
      var data2 = getData(attributes);
      var lineGroup = select(container).maybeAppendByClassName(CLASS_NAMES$7.lineGroup, "g");
      var regionGroup = select(container).maybeAppendByClassName(CLASS_NAMES$7.regionGroup, "g");
      var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
      var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
      return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
    };
    return Grid3;
  }(Component)
);
function getCallbackStyle(style, params) {
  return Object.fromEntries(Object.entries(style).map(function(_a3) {
    var _b = __read(_a3, 2), key = _b[0], val = _b[1];
    return [key, getCallbackValue(val, params)];
  }));
}
function filterExec(data2, filter2) {
  return !!filter2 && isFunction$1(filter2) ? data2.filter(filter2) : data2;
}
function getLineAngle(value, attr2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
  return (endAngle - startAngle) * value + startAngle;
}
function getLineTangentVector(value, attr2) {
  if (attr2.type === "linear") {
    var _a3 = __read(attr2.startPos, 2), startX = _a3[0], startY = _a3[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
    var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
    return normalize$1([dx, dy]);
  }
  var angle2 = degToRad(getLineAngle(value, attr2));
  return [-Math.sin(angle2), Math.cos(angle2)];
}
function getDirectionVector(value, direction2, attr2) {
  var tangentVector = getLineTangentVector(value, attr2);
  return vertical(tangentVector, direction2 !== "positive");
}
function getLabelVector(value, attr2) {
  return getDirectionVector(value, attr2.labelDirection, attr2);
}
function getAxisClassName(baseClassName, suffix, classNamePrefix) {
  if (!classNamePrefix)
    return baseClassName;
  return "".concat(baseClassName, " ").concat(classNamePrefix, "axis-").concat(suffix);
}
function applyClassName(selection, baseClassName, suffix, classNamePrefix) {
  if (classNamePrefix) {
    selection.attr("className", getAxisClassName(baseClassName.name, suffix, classNamePrefix));
  }
  return selection;
}
function getLinearValuePos(value, attr2) {
  var _a3 = __read(attr2.startPos, 2), sx = _a3[0], sy = _a3[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
  var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
  return [sx + dx * value, sy + dy * value];
}
function getArcValuePos(value, attr2) {
  var radius = attr2.radius, _a3 = __read(attr2.center, 2), cx = _a3[0], cy = _a3[1];
  var angle2 = degToRad(getLineAngle(value, attr2));
  return [cx + radius * Math.cos(angle2), cy + radius * Math.sin(angle2)];
}
function getValuePos(value, attr2) {
  if (attr2.type === "linear")
    return getLinearValuePos(value, attr2);
  return getArcValuePos(value, attr2);
}
function isAxisHorizontal(attr2) {
  return getLineTangentVector(0, attr2)[1] === 0;
}
function isAxisVertical(attr2) {
  return getLineTangentVector(0, attr2)[0] === 0;
}
function isCircle(startAngle, endAngle) {
  return endAngle - startAngle === 360;
}
function getArcPath(startAngle, endAngle, cx, cy, radius) {
  var diffAngle = endAngle - startAngle;
  var _a3 = __read([radius, radius], 2), rx = _a3[0], ry = _a3[1];
  var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
  var getPosByAngle = function(angle2) {
    return [cx + radius * Math.cos(angle2), cy + radius * Math.sin(angle2)];
  };
  var _c = __read(getPosByAngle(startAngleRadians), 2), x1 = _c[0], y1 = _c[1];
  var _d = __read(getPosByAngle(endAngleRadians), 2), x2 = _d[0], y2 = _d[1];
  if (isCircle(startAngle, endAngle)) {
    var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
    var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
    return [
      ["M", x1, y1],
      ["A", rx, ry, 0, 1, 0, xm, ym],
      ["A", rx, ry, 0, 1, 0, x2, y2]
    ];
  }
  var large2 = diffAngle > 180 ? 1 : 0;
  var sweep = startAngle > endAngle ? 0 : 1;
  return "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large2, ",").concat(sweep, ",").concat(x2, ",").concat(y2);
}
function getArcAttr(arc2) {
  var _a3 = arc2.attributes, startAngle = _a3.startAngle, endAngle = _a3.endAngle, center = _a3.center, radius = _a3.radius;
  return __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false);
}
function renderArc(container, attr2, style, animate2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center = attr2.center, radius = attr2.radius, classNamePrefix = attr2.classNamePrefix;
  return container.selectAll(CLASS_NAMES$8.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false)) }], function(d3, i2) {
    return i2;
  }).join(function(enter) {
    var line2 = enter.append("path").attr("className", CLASS_NAMES$8.line.name).styles(attr2).styles({ d: function(d3) {
      return d3.d;
    } });
    applyClassName(line2, CLASS_NAMES$8.line, CLASSNAME_SUFFIX_MAP$1.line, classNamePrefix);
    return line2;
  }, function(update) {
    return update.transition(function() {
      var _this2 = this;
      var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false), animate2.update);
      if (animation) {
        var layout2 = function() {
          var data2 = get$1(_this2.attributes, "__keyframe_data__");
          _this2.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
        };
        animation.onframe = layout2;
        animation.onfinish = layout2;
      }
      return animation;
    }).styles(attr2);
  }, function(exit) {
    return exit.remove();
  }).styles(style).transitions();
}
function renderTruncation(container, _a3) {
  _a3.truncRange;
  _a3.truncShape;
  _a3.lineExtension;
}
function extendLine(startPos, endPos, range) {
  if (range === void 0) {
    range = [0, 0];
  }
  var _a3 = __read([startPos, endPos, range], 3), _b = __read(_a3[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a3[1], 2), x2 = _c[0], y2 = _c[1], _d = __read(_a3[2], 2), l1 = _d[0], l2 = _d[1];
  var _e = __read([x2 - x1, y2 - y1], 2), x3 = _e[0], y3 = _e[1];
  var L2 = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
  var _f = __read([-l1 / L2, l2 / L2], 2), s1 = _f[0], s22 = _f[1];
  return [s1 * x3, s1 * y3, s22 * x3, s22 * y3];
}
function getLinePath(points) {
  var _a3 = __read(points, 2), _b = __read(_a3[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a3[1], 2), x2 = _c[0], y2 = _c[1];
  return { x1, y1, x2, y2 };
}
function renderLinear(container, attr2, style, animate2) {
  var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension, classNamePrefix = attr2.classNamePrefix;
  var _a3 = __read([startPos, endPos], 2), _b = __read(_a3[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a3[1], 2), x2 = _c[0], y2 = _c[1];
  var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
  var renderLine = function(data2) {
    return container.selectAll(CLASS_NAMES$8.line.class).data(data2, function(d3, i2) {
      return i2;
    }).join(function(enter) {
      var lines = enter.append("line").styles(style).transition(function(d3) {
        return transition(this, getLinePath(d3.line), false);
      });
      lines.attr("className", function(d3) {
        if (!classNamePrefix) {
          return "".concat(CLASS_NAMES$8.line.name, " ").concat(d3.className);
        }
        var baseLineClassName = getAxisClassName(CLASS_NAMES$8.line.name, CLASSNAME_SUFFIX_MAP$1.line, classNamePrefix);
        if (d3.className === CLASS_NAMES$8.lineFirst.name) {
          var specificClassName = getAxisClassName(CLASS_NAMES$8.lineFirst.name, CLASSNAME_SUFFIX_MAP$1.lineFirst, classNamePrefix);
          return "".concat(baseLineClassName, " ").concat(specificClassName);
        }
        if (d3.className === CLASS_NAMES$8.lineSecond.name) {
          var specificClassName = getAxisClassName(CLASS_NAMES$8.lineSecond.name, CLASSNAME_SUFFIX_MAP$1.lineSecond, classNamePrefix);
          return "".concat(baseLineClassName, " ").concat(specificClassName);
        }
        return baseLineClassName;
      });
      return lines;
    }, function(update) {
      return update.styles(style).transition(function(_a4) {
        var line2 = _a4.line;
        return transition(this, getLinePath(line2), animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  };
  if (!showTrunc || !truncRange) {
    return renderLine([
      {
        line: [
          [x1 + ox1, y1 + oy1],
          [x2 + ox2, y2 + oy2]
        ],
        className: CLASS_NAMES$8.line.name
      }
    ]);
  }
  var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var _f = __read([x1 + dx * r1, y1 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read([x1 + dx * r2, y1 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
  var animation = renderLine([
    {
      line: [
        [x1 + ox1, y1 + oy1],
        [x3, y3]
      ],
      className: CLASS_NAMES$8.lineFirst.name
    },
    {
      line: [
        [x4, y4],
        [x2 + ox2, y2 + oy2]
      ],
      className: CLASS_NAMES$8.lineSecond.name
    }
  ]);
  renderTruncation(container, attr2);
  return animation;
}
function renderAxisArrow(container, type, attr2, style) {
  var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
  var shapeToAddArrow;
  if (type === "arc") {
    shapeToAddArrow = container.select(CLASS_NAMES$8.line.class);
  } else if (showTrunc) {
    shapeToAddArrow = container.select(CLASS_NAMES$8.lineSecond.class);
  } else {
    shapeToAddArrow = container.select(CLASS_NAMES$8.line.class);
  }
  if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
    var node = shapeToAddArrow.node();
    if (node)
      node.style.markerEnd = void 0;
    return;
  }
  var arrow2 = renderExtDo(lineArrow);
  arrow2.attr(style);
  scaleToPixel(arrow2, lineArrowSize);
  shapeToAddArrow.style("markerEnd", arrow2).style("markerEndOffset", -lineArrowOffset);
}
function renderAxisLine(container, attr2, animate2) {
  var type = attr2.type;
  var animation;
  var style = subStyleProps(attr2, "line");
  if (type === "linear")
    animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
  else
    animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
  renderAxisArrow(container, type, attr2, style);
  return animation;
}
function getGridVector(value, attr2) {
  return getDirectionVector(value, attr2.gridDirection, attr2);
}
function getGridCenter(attr2) {
  var type = attr2.type, gridCenter = attr2.gridCenter;
  if (type === "linear")
    return gridCenter;
  return gridCenter || attr2.center;
}
function renderStraight(data2, attr2) {
  var gridLength = attr2.gridLength;
  return data2.map(function(_a3, index2) {
    var value = _a3.value;
    var _b = __read(getValuePos(value, attr2), 2), x2 = _b[0], y2 = _b[1];
    var _c = __read(scale2(getGridVector(value, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
    return {
      id: index2,
      points: [
        [x2, y2],
        [x2 + dx, y2 + dy]
      ]
    };
  });
}
function renderSurround(data2, attr2) {
  var controlAngles = attr2.gridControlAngles;
  var center = getGridCenter(attr2);
  if (!center)
    throw new Error("grid center is not provide");
  if (data2.length < 2)
    throw new Error("Invalid grid data");
  if (!controlAngles || controlAngles.length === 0)
    throw new Error("Invalid gridControlAngles");
  var _a3 = __read(center, 2), cx = _a3[0], cy = _a3[1];
  return data2.map(function(_a4, index2) {
    var value = _a4.value;
    var _b = __read(getValuePos(value, attr2), 2), sx = _b[0], sy = _b[1];
    var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
    var points = [];
    controlAngles.forEach(function(angle2) {
      var angleInRad = degToRad(angle2);
      var _a5 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a5[0], sina = _a5[1];
      var x2 = dx * cosa - dy * sina + cx;
      var y2 = dx * sina + dy * cosa + cy;
      points.push([x2, y2]);
    });
    return { points, id: index2 };
  });
}
function renderGrid(container, data2, attr2, animate2) {
  var classNamePrefix = attr2.classNamePrefix;
  var gridAttr = subStyleProps(attr2, "grid");
  var type = gridAttr.type, areaFill = gridAttr.areaFill;
  var center = getGridCenter(attr2);
  var finalData = filterExec(data2, attr2.gridFilter);
  var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
  var style = __assign(__assign({}, gridAttr), { center, areaFill: isFunction$1(areaFill) ? finalData.map(function(datum, index2) {
    return getCallbackValue(areaFill, [datum, index2, finalData]);
  }) : areaFill, animate: animate2, data: gridItems });
  return container.selectAll(CLASS_NAMES$8.grid.class).data([1]).join(function(enter) {
    var grid2 = enter.append(function() {
      return new Grid2({ style });
    }).attr("className", CLASS_NAMES$8.grid.name);
    applyClassName(grid2, CLASS_NAMES$8.grid, CLASSNAME_SUFFIX_MAP$1.grid, classNamePrefix);
    return grid2;
  }, function(update) {
    return update.transition(function() {
      return this.update(style);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}
var Bounds = (
  /** @class */
  function() {
    function Bounds2(x1, y1, x2, y2) {
      this.set(x1, y1, x2, y2);
    }
    Object.defineProperty(Bounds2.prototype, "left", {
      get: function() {
        return this.x1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "top", {
      get: function() {
        return this.y1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "right", {
      get: function() {
        return this.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "bottom", {
      get: function() {
        return this.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "width", {
      get: function() {
        return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "height", {
      get: function() {
        return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Bounds2.prototype.rotatedPoints = function(radian, x2, y2) {
      var _a3 = this, x1 = _a3.x1, y1 = _a3.y1, x22 = _a3.x2, y22 = _a3.y2;
      var cos = Math.cos(radian);
      var sin = Math.sin(radian);
      var cx = x2 - x2 * cos + y2 * sin;
      var cy = y2 - x2 * sin - y2 * cos;
      var points = [
        [cos * x1 - sin * y22 + cx, sin * x1 + cos * y22 + cy],
        [cos * x22 - sin * y22 + cx, sin * x22 + cos * y22 + cy],
        [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy],
        [cos * x22 - sin * y1 + cx, sin * x22 + cos * y1 + cy]
      ];
      return points;
    };
    Bounds2.prototype.set = function(x1, y1, x2, y2) {
      if (x2 < x1) {
        this.x2 = x1;
        this.x1 = x2;
      } else {
        this.x1 = x1;
        this.x2 = x2;
      }
      if (y2 < y1) {
        this.y2 = y1;
        this.y1 = y2;
      } else {
        this.y1 = y1;
        this.y2 = y2;
      }
      return this;
    };
    Bounds2.prototype.defined = function(key) {
      return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
    };
    return Bounds2;
  }()
);
function getBounds(item, margin) {
  var angle2 = item.getEulerAngles() || 0;
  item.setEulerAngles(0);
  var _a3 = item.getBounds(), _b = __read(_a3.min, 2), x2 = _b[0], y2 = _b[1], _c = __read(_a3.max, 2), right = _c[0], bottom = _c[1];
  var _d = item.getBBox(), w2 = _d.width, h2 = _d.height;
  var height = h2;
  var dx = 0;
  var dy = 0;
  var anchorX = x2;
  var anchorY = y2;
  var text = textOf(item);
  if (text) {
    height -= 1.5;
    var a2 = text.style.textAlign;
    var b_1 = text.style.textBaseline;
    if (a2 === "center") {
      anchorX = (x2 + right) / 2;
    } else if (a2 === "right" || a2 === "end") {
      anchorX = right;
    } else ;
    if (b_1 === "middle") {
      anchorY = (y2 + bottom) / 2;
    } else if (b_1 === "bottom") {
      anchorY = bottom;
    }
  }
  var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t3 = _f === void 0 ? 0 : _f, _g = _e[1], r2 = _g === void 0 ? 0 : _g, _h = _e[2], b2 = _h === void 0 ? t3 : _h, _j = _e[3], l2 = _j === void 0 ? r2 : _j;
  var bounds = new Bounds((dx += x2) - l2, (dy += y2) - t3, dx + w2 + r2, dy + height + b2);
  item.setEulerAngles(angle2);
  return bounds.rotatedPoints(degToRad(angle2), anchorX, anchorY);
}
function onLine(line2, point2) {
  return point2[0] <= Math.max(line2[0][0], line2[1][0]) && point2[0] <= Math.min(line2[0][0], line2[1][0]) && point2[1] <= Math.max(line2[0][1], line2[1][1]) && point2[1] <= Math.min(line2[0][1], line2[1][1]);
}
function direction(a2, b2, c2) {
  var val = (b2[1] - a2[1]) * (c2[0] - b2[0]) - (b2[0] - a2[0]) * (c2[1] - b2[1]);
  if (val === 0)
    return 0;
  return val < 0 ? 2 : 1;
}
function isIntersect(line1, line2) {
  var dir1 = direction(line1[0], line1[1], line2[0]);
  var dir2 = direction(line1[0], line1[1], line2[1]);
  var dir3 = direction(line2[0], line2[1], line1[0]);
  var dir4 = direction(line2[0], line2[1], line1[1]);
  if (dir1 !== dir2 && dir3 !== dir4)
    return true;
  if (dir1 === 0 && onLine(line1, line2[0]))
    return true;
  if (dir2 === 0 && onLine(line1, line2[1]))
    return true;
  if (dir3 === 0 && onLine(line2, line1[0]))
    return true;
  if (dir4 === 0 && onLine(line2, line1[1]))
    return true;
  return false;
}
function isPointInsideRectangle(polygon, point2) {
  var n2 = polygon.length;
  if (n2 < 3)
    return false;
  var lineToInfinity = [point2, [9999, point2[1]]];
  var count = 0;
  var i2 = 0;
  do {
    var side = [polygon[i2], polygon[(i2 + 1) % n2]];
    if (isIntersect(side, lineToInfinity)) {
      if (direction(side[0], point2, side[1]) === 0)
        return onLine(side, point2);
      count++;
    }
    i2 = (i2 + 1) % n2;
  } while (i2 !== 0);
  return !!(count & 1);
}
function isRectangleBInsideA(rectA, rectB) {
  return rectB.every(function(point2) {
    return isPointInsideRectangle(rectA, point2);
  });
}
function contain(container, child, margin) {
  var x1 = container.x1, x2 = container.x2, y1 = container.y1, y2 = container.y2;
  var parent = [
    [x1, y1],
    [x2, y1],
    [x2, y2],
    [x1, y2]
  ];
  var element = getBounds(child, margin);
  return isRectangleBInsideA(parent, element);
}
function lineToLine(line1, line2) {
  var _a3 = __read(line1, 4), x0 = _a3[0], y0 = _a3[1], x1 = _a3[2], y1 = _a3[3];
  var _b = __read(line2, 4), x2 = _b[0], y2 = _b[1], x3 = _b[2], y3 = _b[3];
  var s10x = x1 - x0;
  var s10y = y1 - y0;
  var s32x = x3 - x2;
  var s32y = y3 - y2;
  var denom = s10x * s32y - s32x * s10y;
  if (denom === 0)
    return false;
  var denomPositive = denom > 0;
  var s02x = x0 - x2;
  var s02y = y0 - y2;
  var sNum = s10x * s02y - s10y * s02x;
  if (sNum < 0 === denomPositive)
    return false;
  var tNum = s32x * s02y - s32y * s02x;
  if (tNum < 0 === denomPositive)
    return false;
  if (sNum > denom === denomPositive || tNum > denom === denomPositive)
    return false;
  return true;
}
function intersectBoxLine(box2, line2) {
  var lines = [
    [box2[0], box2[1], box2[2], box2[3]],
    [box2[2], box2[3], box2[4], box2[5]],
    [box2[4], box2[5], box2[6], box2[7]],
    [box2[6], box2[7], box2[0], box2[1]]
  ];
  return lines.some(function(boxLine) {
    return lineToLine(line2, boxLine);
  });
}
function intersect(a2, b2, margin) {
  var e_1, _a3;
  var p2 = getBounds(a2, margin).flat(1);
  var q = getBounds(b2, margin).flat(1);
  var linesP = [
    [p2[0], p2[1], p2[2], p2[3]],
    [p2[0], p2[1], p2[4], p2[5]],
    [p2[4], p2[5], p2[6], p2[7]],
    [p2[2], p2[3], p2[6], p2[7]]
  ];
  try {
    for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
      var line2 = linesP_1_1.value;
      if (intersectBoxLine(q, line2))
        return true;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (linesP_1_1 && !linesP_1_1.done && (_a3 = linesP_1.return)) _a3.call(linesP_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function createCrossBBox(attr2, padding) {
  var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
  if (!crossSize)
    return false;
  if (type === "arc") {
    var center = attr2.center, radius = attr2.radius;
    var _a3 = __read(center, 2), cx = _a3[0], cy = _a3[1];
    var size = labelDirection === "negative" ? 0 : crossSize;
    var dMin = -radius - size;
    var dMax = radius + size;
    var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
    return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
  }
  var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
  var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right = _e[1], bottom = _e[2], left = _e[3];
  var labelVector = getLabelVector(0, attr2);
  var diff = scale2(labelVector, crossSize);
  var bbox = new Bounds(sx, sy, ex, ey);
  bbox.x1 += left;
  bbox.y1 += top;
  bbox.x2 += right + diff[0];
  bbox.y2 += bottom + diff[1];
  return bbox;
}
function boundTest(items, attr2, margin) {
  var e_1, _a3;
  var crossPadding = attr2.crossPadding;
  var resultSet = /* @__PURE__ */ new Set();
  var prev = null;
  var crossBBox = createCrossBBox(attr2, crossPadding);
  var testContain = function(item) {
    if (crossBBox)
      return contain(crossBBox, item);
    return true;
  };
  var testIntersect = function(prevItem, currItem) {
    if (!prevItem || !prevItem.firstChild)
      return true;
    return !intersect(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
  };
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var curr = items_1_1.value;
      if (!testContain(curr)) {
        resultSet.add(curr);
      } else if (!prev || testIntersect(prev, curr)) {
        prev = curr;
      } else {
        resultSet.add(prev);
        resultSet.add(curr);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a3 = items_1.return)) _a3.call(items_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return Array.from(resultSet);
}
function parseLengthString(str2, font) {
  if (font === void 0) {
    font = {};
  }
  if (isNil(str2))
    return 0;
  if (typeof str2 === "number")
    return str2;
  return Math.floor(measureTextWidth(str2, font));
}
function ellipseLabels(labels, overlapCfg, attr2, utils) {
  if (labels.length <= 0)
    return;
  var _a3 = overlapCfg.suffix, suffix = _a3 === void 0 ? "..." : _a3, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var font = getFont(utils.getTextShape(labels[0]));
  var step2 = parseLengthString(ellipsisStep, font);
  var min2 = minLength ? parseLengthString(minLength, font) : step2;
  var max2 = parseLengthString(maxLength, font);
  if (isNil(max2) || max2 === Infinity) {
    max2 = Math.max.apply(null, labels.map(function(d3) {
      return d3.getBBox().width;
    }));
  }
  var source = labels.slice();
  var _e = __read(margin, 4);
  _e[0];
  _e[1];
  _e[2];
  _e[3];
  var _loop_1 = function(allowedLength2) {
    source.forEach(function(label) {
      utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
    });
    source = boundTest(labels, attr2, margin);
    if (source.length < 1)
      return { value: void 0 };
  };
  for (var allowedLength = max2; allowedLength > min2 + step2; allowedLength -= step2) {
    var state_1 = _loop_1(allowedLength);
    if (typeof state_1 === "object")
      return state_1.value;
  }
}
var methods = {
  parity: function(items, _a3) {
    var _b = _a3.seq, seq = _b === void 0 ? 2 : _b;
    return items.filter(function(item, i2) {
      return i2 % seq ? (hide(item), false) : true;
    });
  }
};
var filterDefined = function(arr) {
  return arr.filter(defined);
};
function hideLabels(labels, overlapCfg, attr2, utils) {
  var count = labels.length;
  var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
  if (count <= 1 || count === 2 && keepHeader && keepTail)
    return;
  var parityHide = methods.parity;
  var reset = function(els) {
    return els.forEach(utils.show), els;
  };
  var seq = 2;
  var source = labels.slice();
  var target = labels.slice();
  var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d3) {
    return d3.getBBox().width;
  })), false));
  if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
    var minX = getLocalBBox(labels[0]).left;
    var maxX = getLocalBBox(labels[count - 1]).right;
    var distance2 = Math.abs(maxX - minX) || 1;
    seq = Math.max(Math.floor(count * minLabelWidth / distance2), seq);
  }
  var first;
  var last;
  if (keepHeader)
    first = source.splice(0, 1)[0];
  if (keepTail) {
    last = source.splice(-1, 1)[0];
    source.reverse();
  }
  reset(source);
  while (seq < labels.length && boundTest(filterDefined(last ? __spreadArray(__spreadArray([last], __read(target), false), [first], false) : __spreadArray([first], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
    if (last && !first && seq % 2 === 0) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    } else if (last && first) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    }
    target = parityHide(reset(source), { seq });
    seq++;
  }
}
function rotateLabels(labels, overlapCfg, attr2, utils) {
  var e_1, _a3;
  var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
  var defaultAngles = labels.map(function(label) {
    return label.getLocalEulerAngles();
  });
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var setLabelsRotate = function(angle3) {
    return labels.forEach(function(label, index2) {
      var rotate3 = Array.isArray(angle3) ? angle3[index2] : angle3;
      utils.rotate(label, +rotate3);
    });
  };
  try {
    for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
      var angle2 = optionalAngles_1_1.value;
      setLabelsRotate(angle2);
      if (runAndPassed())
        return;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a3 = optionalAngles_1.return)) _a3.call(optionalAngles_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  if (recoverWhenFailed) {
    setLabelsRotate(defaultAngles);
  }
}
function inferTextBaseline(attr2) {
  var type = attr2.type, labelDirection = attr2.labelDirection;
  if (type === "linear" && isAxisHorizontal(attr2)) {
    return labelDirection === "negative" ? "bottom" : "top";
  }
  return "middle";
}
function wrapLabels(labels, overlapCfg, attr2, utils, main) {
  var _a3;
  var _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var wordWrapWidth = getCallbackValue((_a3 = overlapCfg.wordWrapWidth) !== null && _a3 !== void 0 ? _a3 : 50, [main]);
  var defaultLines = labels.map(function(label) {
    return label.attr("maxLines") || 1;
  });
  var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var textBaseline = inferTextBaseline(attr2);
  var setLabelsWrap = function(lines2) {
    return labels.forEach(function(label, index2) {
      var maxLines2 = Array.isArray(lines2) ? lines2[index2] : lines2;
      utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
    });
  };
  if (minLines > maxLines)
    return;
  if (attr2.type === "linear" && isAxisHorizontal(attr2)) {
    setLabelsWrap(maxLines);
    if (runAndPassed()) {
      return;
    }
  } else {
    for (var lines = minLines; lines <= maxLines; lines++) {
      setLabelsWrap(lines);
      if (runAndPassed())
        return;
    }
  }
  if (recoverWhenFailed) {
    setLabelsWrap(defaultLines);
  }
}
var OverlapUtils = /* @__PURE__ */ new Map([
  ["hide", hideLabels],
  ["rotate", rotateLabels],
  ["ellipsis", ellipseLabels],
  ["wrap", wrapLabels]
]);
function canProcessOverlap(labels, attr2, type) {
  if (attr2.labelOverlap.length < 1)
    return false;
  if (type === "hide")
    return !isInOffscreenGroup(labels[0]);
  if (type === "rotate")
    return !labels.some(function(label) {
      var _a3;
      return !!((_a3 = label.attr("transform")) === null || _a3 === void 0 ? void 0 : _a3.includes("rotate"));
    });
  if (type === "ellipsis" || type === "wrap")
    return labels.filter(function(item) {
      return item.querySelector("text");
    }).length >= 1;
  return true;
}
function processOverlap(labels, attr2, main, utils) {
  var _a3 = attr2.labelOverlap, labelOverlap = _a3 === void 0 ? [] : _a3;
  if (!labelOverlap.length)
    return;
  labelOverlap.forEach(function(overlapCfg) {
    var type = overlapCfg.type;
    var util2 = OverlapUtils.get(type);
    if (canProcessOverlap(labels, attr2, type))
      util2 === null || util2 === void 0 ? void 0 : util2(labels, overlapCfg, attr2, utils, main);
  });
}
function getFactor() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var fn = function(str2) {
    return str2 === "positive" ? -1 : 1;
  };
  return args.reduce(function(acc, cur) {
    return acc * fn(cur);
  }, 1);
}
function angleNormalizer(angle2) {
  var normalizedAngle = angle2;
  while (normalizedAngle < 0)
    normalizedAngle += 360;
  return Math.round(normalizedAngle % 360);
}
function getAngle(v1, v2) {
  var _a3 = __read(v1, 2), x1 = _a3[0], y1 = _a3[1];
  var _b = __read(v2, 2), x2 = _b[0], y2 = _b[1];
  var _c = __read([x1 * x2 + y1 * y2, x1 * y2 - y1 * x2], 2), dot2 = _c[0], det = _c[1];
  return Math.atan2(det, dot2);
}
function correctLabelRotation(_rotate) {
  var rotate3 = (_rotate + 360) % 180;
  if (!inRange(rotate3, -90, 90))
    rotate3 += 180;
  return rotate3;
}
function getLabelRotation(datum, label, attr2) {
  var _a3;
  var labelAlign = attr2.labelAlign;
  var customRotate = (_a3 = label.style.transform) === null || _a3 === void 0 ? void 0 : _a3.includes("rotate");
  if (customRotate)
    return label.getLocalEulerAngles();
  var rotate3 = 0;
  var labelVector = getLabelVector(datum.value, attr2);
  var tangentVector = getLineTangentVector(datum.value, attr2);
  if (labelAlign === "horizontal")
    return 0;
  if (labelAlign === "perpendicular")
    rotate3 = getAngle([1, 0], labelVector);
  else
    rotate3 = getAngle([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
  return correctLabelRotation(radToDeg(rotate3));
}
function getLabelStyle(value, rotate3, attr2) {
  var type = attr2.type, labelAlign = attr2.labelAlign;
  var labelVector = getLabelVector(value, attr2);
  var labelAngle = angleNormalizer(rotate3);
  var tickAngle = angleNormalizer(radToDeg(getAngle([1, 0], labelVector)));
  var textAlign2 = "center";
  var textBaseline = "middle";
  if (type === "linear") {
    if ([90, 270].includes(tickAngle) && labelAngle === 0) {
      textAlign2 = "center";
      textBaseline = labelVector[1] === 1 ? "top" : "bottom";
    } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
      textAlign2 = "center";
    } else if (tickAngle === 0) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign2 = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign2 = "start";
      }
    } else if (tickAngle === 90) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign2 = "start";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign2 = "end";
      }
    } else if (tickAngle === 270) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign2 = "end";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign2 = "start";
      }
    } else if (tickAngle === 180) {
      if (labelAngle === 90) {
        textAlign2 = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign2 = "end";
      }
    }
  } else {
    if (labelAlign === "parallel") {
      if (inRange(tickAngle, 0, 180, true)) {
        textBaseline = "top";
      } else {
        textBaseline = "bottom";
      }
    } else if (labelAlign === "horizontal") {
      if (inRange(tickAngle, 90, 270, false)) {
        textAlign2 = "end";
      } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
        textAlign2 = "start";
      }
    } else if (labelAlign === "perpendicular") {
      if (inRange(tickAngle, 90, 270)) {
        textAlign2 = "end";
      } else {
        textAlign2 = "start";
      }
    }
  }
  return { textAlign: textAlign2, textBaseline };
}
function setRotateAndAdjustLabelAlign(rotate3, group2, attr2) {
  group2.setLocalEulerAngles(rotate3);
  var value = group2.__data__.value;
  var textStyle = getLabelStyle(value, rotate3, attr2);
  var label = group2.querySelector(CLASS_NAMES$8.labelItem.class);
  if (label)
    applyTextStyle(label, textStyle);
}
function getLabelPos(datum, data2, attr2) {
  var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
  var index2 = data2.indexOf(datum);
  var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index2, data2]);
  var _a3 = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a3[0], unionFactor = _a3[1];
  var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index2, data2]) : 0;
  var _b = __read(add(scale2(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x2 = _b[0], y2 = _b[1];
  return { x: x2, y: y2 };
}
function formatter(datum, index2, data2, attr2) {
  var labelFormatter2 = attr2.labelFormatter;
  var element = isFunction$1(labelFormatter2) ? function() {
    return renderExtDo(getCallbackValue(labelFormatter2, [datum, index2, data2, getLabelVector(datum.value, attr2)]));
  } : function() {
    return renderExtDo(datum.label || "");
  };
  return element;
}
function renderHTMLLabel(datum, index2, data2, attr2) {
  var labelRender = attr2.labelRender;
  var elementWidth = (get$1(attr2, "endPos.0", 400) - get$1(attr2, "startPos.0", 0)) / data2.length;
  var elStr = isFunction$1(labelRender) ? getCallbackValue(labelRender, [datum, index2, data2, getLabelVector(datum.value, attr2)]) : datum.label || "";
  var elementHeight = parseHeightFromHTML(elStr) || 30;
  return function() {
    return renderHtmlExtDo(elStr, {
      width: elementWidth,
      height: elementHeight
    });
  };
}
var STYLE_OMIT_MAP = {
  html: ["fill"],
  text: []
};
function applyTextStyle(node, style) {
  if (["text", "html"].includes(node.nodeName))
    node.attr(omit(style, STYLE_OMIT_MAP[node.nodeName]));
}
function overlapHandler(attr2, main) {
  processOverlap(this.node().childNodes, attr2, main, {
    hide,
    show,
    rotate: function(label, angle2) {
      setRotateAndAdjustLabelAlign(+angle2, label, attr2);
    },
    ellipsis: function(label, len2, suffix) {
      label && ellipsisIt(label, len2 || Infinity, suffix);
    },
    wrap: function(label, width2, lines) {
      label && wrapIt(label, width2, lines);
    },
    getTextShape: function(label) {
      return label.querySelector(CLASS_NAMES$8.labelItem.class);
    }
  });
}
function renderLabel(container, datum, data2, style, attr2) {
  var index2 = data2.indexOf(datum);
  var labelRender = attr2.labelRender, classNamePrefix = attr2.classNamePrefix;
  var label = select(container).append(labelRender ? renderHTMLLabel(datum, index2, data2, attr2) : formatter(datum, index2, data2, attr2)).attr("className", CLASS_NAMES$8.labelItem.name).node();
  applyClassName(select(label), CLASS_NAMES$8.labelItem, CLASSNAME_SUFFIX_MAP$1.labelItem, classNamePrefix);
  var _a3 = __read(splitStyle(getCallbackStyle(style, [datum, index2, data2])), 2), labelStyle = _a3[0], _b = _a3[1], transform2 = _b.transform, groupStyle = __rest$m(_b, ["transform"]);
  percentTransform(label, transform2);
  var rotate3 = getLabelRotation(datum, label, attr2);
  if (!label.getLocalEulerAngles()) {
    label.setLocalEulerAngles(rotate3);
  }
  applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate3, attr2)), labelStyle));
  if (label.nodeName === "html") {
    var bbox = label.getBBox();
    var currentX = label.style.x || 0;
    label.attr("x", currentX - bbox.width / 2);
  }
  container.attr(groupStyle);
  return label;
}
function renderLabels(container, data2, attr2, animate2, main) {
  var classNamePrefix = attr2.classNamePrefix;
  var finalData = filterExec(data2, attr2.labelFilter);
  var style = subStyleProps(attr2, "label");
  var _exit;
  var transitions = container.selectAll(CLASS_NAMES$8.label.class).data(finalData, function(d3, i2) {
    return i2;
  }).join(function(enter) {
    var labels = enter.append("g").attr("className", CLASS_NAMES$8.label.name).transition(function(datum) {
      renderLabel(this, datum, data2, style, attr2);
      var _a3 = getLabelPos(datum, data2, attr2), x2 = _a3.x, y2 = _a3.y;
      this.style.transform = "translate(".concat(x2, ", ").concat(y2, ")");
      return null;
    });
    applyClassName(labels, CLASS_NAMES$8.label, CLASSNAME_SUFFIX_MAP$1.label, classNamePrefix);
    return labels;
  }, function(update) {
    return update.transition(function(datum) {
      var prevLabel = this.querySelector(CLASS_NAMES$8.labelItem.class);
      var label = renderLabel(this, datum, data2, style, attr2);
      var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
      var _a3 = getLabelPos(datum, data2, attr2), x2 = _a3.x, y2 = _a3.y;
      var animation = transition(this, { transform: "translate(".concat(x2, ", ").concat(y2, ")") }, animate2.update);
      return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
    });
  }, function(exit) {
    _exit = exit;
    exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return select(_this2).remove();
      });
      return animation;
    });
    return _exit;
  }).transitions();
  onAnimatesFinished(transitions, function() {
    overlapHandler.call(container, attr2, main);
  });
  return transitions;
}
function getTickVector(value, attr2) {
  return getDirectionVector(value, attr2.tickDirection, attr2);
}
function getTickPoints(unitVector, tickLength) {
  var _a3 = __read(unitVector, 2), dx = _a3[0], dy = _a3[1];
  return [
    [0, 0],
    [dx * tickLength, dy * tickLength]
  ];
}
function getTickLineLayout(datum, index2, data2, tickVector, attr2) {
  var tickLength = attr2.tickLength;
  var _a3 = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index2, data2])), 2), _b = __read(_a3[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a3[1], 2), x2 = _c[0], y2 = _c[1];
  return { x1, x2, y1, y2 };
}
function createTickEl(container, datum, index2, data2, attr2) {
  var formatter2 = attr2.tickFormatter, classNamePrefix = attr2.classNamePrefix;
  var tickVector = getTickVector(datum.value, attr2);
  var el = "line";
  if (isFunction$1(formatter2))
    el = function() {
      return getCallbackValue(formatter2, [datum, index2, data2, tickVector]);
    };
  var tick2 = container.append(el).attr("className", CLASS_NAMES$8.tickItem.name);
  applyClassName(tick2, CLASS_NAMES$8.tickItem, CLASSNAME_SUFFIX_MAP$1.tickItem, classNamePrefix);
  return tick2;
}
function applyTickStyle(datum, index2, data2, tick2, group2, attr2, style) {
  var tickVector = getTickVector(datum.value, attr2);
  var _a3 = getTickLineLayout(datum, index2, data2, tickVector, attr2), x1 = _a3.x1, x2 = _a3.x2, y1 = _a3.y1, y2 = _a3.y2;
  var _b = __read(splitStyle(getCallbackStyle(style, [datum, index2, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
  tick2.node().nodeName === "line" && tick2.styles(__assign({ x1, x2, y1, y2 }, tickStyle));
  group2.attr(groupStyle);
  tick2.styles(tickStyle);
}
function createTick(datum, index2, data2, attr2, tickAttr, animate2) {
  var tick2 = createTickEl(select(this), datum, index2, data2, attr2);
  applyTickStyle(datum, index2, data2, tick2, this, attr2, tickAttr);
  var _a3 = __read(getValuePos(datum.value, attr2), 2), x2 = _a3[0], y2 = _a3[1];
  return transition(this, { transform: "translate(".concat(x2, ", ").concat(y2, ")") }, animate2);
}
function renderTicks(container, axisData, attr2, animate2) {
  var classNamePrefix = attr2.classNamePrefix;
  var finalData = filterExec(axisData, attr2.tickFilter);
  var tickAttr = subStyleProps(attr2, "tick");
  return container.selectAll(CLASS_NAMES$8.tick.class).data(finalData, function(d3) {
    return d3.id || d3.label;
  }).join(function(enter) {
    var ticks = enter.append("g").attr("className", CLASS_NAMES$8.tick.name).transition(function(datum, index2) {
      return createTick.call(this, datum, index2, finalData, attr2, tickAttr, false);
    });
    applyClassName(ticks, CLASS_NAMES$8.tick, CLASSNAME_SUFFIX_MAP$1.tick, classNamePrefix);
    return ticks;
  }, function(update) {
    return update.transition(function(datum, index2) {
      this.removeChildren();
      return createTick.call(this, datum, index2, finalData, attr2, tickAttr, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function getTitlePosition(mainGroup, titleGroup, attr2) {
  var _a3 = attr2.titlePosition, position2 = _a3 === void 0 ? "lb" : _a3, spacing = attr2.titleSpacing;
  var pos = parsePosition(position2);
  var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
  var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
  var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x2 = _f[0], y2 = _f[1];
  var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
  if (["start", "end"].includes(position2) && attr2.type === "linear") {
    var startPos = attr2.startPos, endPos = attr2.endPos;
    var _h = __read(position2 === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
    var direction2 = normalize$1([-to[0] + from[0], -to[1] + from[1]]);
    var _j = __read(scale2(direction2, spacingTop), 2), dx = _j[0], dy = _j[1];
    return { x: from[0] + dx, y: from[1] + dy };
  }
  if (pos.includes("t"))
    y2 -= mainHalfHeight + titleHalfHeight + spacingTop;
  if (pos.includes("r"))
    x2 += mainHalfWidth + titleHalfWidth + spacingRight;
  if (pos.includes("l"))
    x2 -= mainHalfWidth + titleHalfWidth + spacingLeft;
  if (pos.includes("b"))
    y2 += mainHalfHeight + titleHalfHeight + spacingBottom;
  return { x: x2, y: y2 };
}
function inferTransform(n2, direction2, position2) {
  var halfExtents = n2.getGeometryBounds().halfExtents;
  var height = halfExtents[1] * 2;
  if (direction2 === "vertical") {
    if (position2 === "left")
      return "rotate(-90) translate(0, ".concat(height / 2, ")");
    if (position2 === "right")
      return "rotate(-90) translate(0, -".concat(height / 2, ")");
  }
  return "";
}
function applyTitleStyle(title, group2, axis, attr2, animate2) {
  var style = subStyleProps(attr2, "title");
  var _a3 = __read(splitStyle(style), 2), titleStyle = _a3[0], _b = _a3[1], specified = _b.transform, transformOrigin2 = _b.transformOrigin, groupStyle = __rest$m(_b, ["transform", "transformOrigin"]);
  group2.styles(groupStyle);
  var transform2 = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
  title.styles(__assign(__assign({}, titleStyle), { transformOrigin: transformOrigin2 }));
  percentTransform(title.node(), transform2);
  var _c = getTitlePosition(
    // @ts-ignore
    select(axis._offscreen || axis.querySelector(CLASS_NAMES$8.mainGroup.class)),
    group2,
    attr2
  ), x2 = _c.x, y2 = _c.y;
  var animation = transition(group2.node(), { transform: "translate(".concat(x2, ", ").concat(y2, ")") }, animate2);
  return animation;
}
function renderTitle(container, axis, attr2, animate2) {
  var titleText = attr2.titleText, classNamePrefix = attr2.classNamePrefix;
  return container.selectAll(CLASS_NAMES$8.title.class).data([{ title: titleText }].filter(function(d3) {
    return !!d3.title;
  }), function(d3, i2) {
    return d3.title;
  }).join(function(enter) {
    var titles = enter.append(function() {
      return renderExtDo(titleText);
    }).attr("className", CLASS_NAMES$8.title.name).transition(function() {
      return applyTitleStyle(select(this), container, axis, attr2, animate2.enter);
    });
    applyClassName(titles, CLASS_NAMES$8.title, CLASSNAME_SUFFIX_MAP$1.title, classNamePrefix);
    return titles;
  }, function(update) {
    return update.transition(function() {
      return applyTitleStyle(select(this), container, axis, attr2, animate2.update);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}
function renderAxisMain(attributes, container, data2, animation) {
  var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel, classNamePrefix = attributes.classNamePrefix;
  var lineGroup = container.maybeAppendByClassName(CLASS_NAMES$8.lineGroup, "g");
  applyClassName(lineGroup, CLASS_NAMES$8.lineGroup, CLASSNAME_SUFFIX_MAP$1.lineGroup, classNamePrefix);
  var lineTransitions = ifShow(showLine, lineGroup, function(group2) {
    return renderAxisLine(group2, attributes, animation);
  }) || [];
  var tickGroup = container.maybeAppendByClassName(CLASS_NAMES$8.tickGroup, "g");
  applyClassName(tickGroup, CLASS_NAMES$8.tickGroup, CLASSNAME_SUFFIX_MAP$1.tickGroup, classNamePrefix);
  var tickTransitions = ifShow(showTick, tickGroup, function(group2) {
    return renderTicks(group2, data2, attributes, animation);
  }) || [];
  var labelGroup = container.maybeAppendByClassName(CLASS_NAMES$8.labelGroup, "g");
  applyClassName(labelGroup, CLASS_NAMES$8.labelGroup, CLASSNAME_SUFFIX_MAP$1.labelGroup, classNamePrefix);
  var labelTransitions = ifShow(showLabel, labelGroup, function(group2) {
    return renderLabels(group2, data2, attributes, animation, container.node());
  }) || [];
  return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t3) {
    return !!t3;
  });
}
var Axis = (
  /** @class */
  function(_super) {
    __extends$1(Axis2, _super);
    function Axis2(options) {
      return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
    }
    Axis2.prototype.render = function(attributes, container, specificAnimation) {
      var _this2 = this;
      var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange, classNamePrefix = attributes.classNamePrefix;
      var baseClassName = container.className || "axis";
      if (classNamePrefix) {
        container.attr("className", "".concat(baseClassName, " ").concat(classNamePrefix, "axis"));
      } else if (!container.className) {
        container.attr("className", "axis");
      }
      var sampledData = sampling(data2, dataThreshold).filter(function(_a3) {
        var value = _a3.value;
        if (truncRange && value > truncRange[0] && value < truncRange[1])
          return false;
        return true;
      });
      var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
      var gridGroup = select(container).maybeAppendByClassName(CLASS_NAMES$8.gridGroup, "g");
      applyClassName(gridGroup, CLASS_NAMES$8.gridGroup, CLASSNAME_SUFFIX_MAP$1.gridGroup, classNamePrefix);
      var gridTransitions = ifShow(showGrid, gridGroup, function(group2) {
        return renderGrid(group2, sampledData, attributes, finalAnimation);
      }) || [];
      var mainGroup = select(container).maybeAppendByClassName(CLASS_NAMES$8.mainGroup, "g");
      applyClassName(mainGroup, CLASS_NAMES$8.mainGroup, CLASSNAME_SUFFIX_MAP$1.mainGroup, classNamePrefix);
      if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
        renderAxisMain(attributes, select(this.offscreenGroup), sampledData, parseAnimationOption(false));
      }
      var mainTransitions = renderAxisMain(attributes, select(mainGroup.node()), sampledData, finalAnimation);
      var titleGroup = select(container).maybeAppendByClassName(CLASS_NAMES$8.titleGroup, "g");
      applyClassName(titleGroup, CLASS_NAMES$8.titleGroup, CLASSNAME_SUFFIX_MAP$1.titleGroup, classNamePrefix);
      var titleTransitions = ifShow(showTitle, titleGroup, function(group2) {
        return renderTitle(group2, _this2, attributes, finalAnimation);
      }) || [];
      return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t3) {
        return !!t3;
      });
    };
    return Axis2;
  }(Component)
);
function getLegendClassName(baseClassName, suffix, classNamePrefix) {
  if (!classNamePrefix)
    return baseClassName;
  return "".concat(baseClassName, " ").concat(classNamePrefix, "legend-").concat(suffix);
}
function hiddenHandle(x2, y2, r2) {
  var ratio = 1.4;
  var diffY = ratio * r2;
  return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["L", x2 - r2, y2 + diffY], ["Z"]];
}
var HANDLE_HEIGHT_RATIO = 1.4;
var HANDLE_TRIANGLE_RATIO = 0.4;
function verticalHandle(x2, y2, r2) {
  var width2 = r2;
  var height = width2 * HANDLE_HEIGHT_RATIO;
  var halfWidth = width2 / 2;
  var oneSixthWidth = width2 / 6;
  var triangleX = x2 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x2, y2],
    ["L", triangleX, y2 + halfWidth],
    ["L", x2 + height, y2 + halfWidth],
    ["L", x2 + height, y2 - halfWidth],
    ["L", triangleX, y2 - halfWidth],
    ["Z"],
    // 
    ["M", triangleX, y2 + oneSixthWidth],
    ["L", x2 + height - 2, y2 + oneSixthWidth],
    ["M", triangleX, y2 - oneSixthWidth],
    ["L", x2 + height - 2, y2 - oneSixthWidth]
  ];
}
function horizontalHandle(x2, y2, r2) {
  var width2 = r2;
  var height = width2 * HANDLE_HEIGHT_RATIO;
  var halfWidth = width2 / 2;
  var oneSixthWidth = width2 / 6;
  var triangleY = y2 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x2, y2],
    ["L", x2 - halfWidth, triangleY],
    ["L", x2 - halfWidth, y2 + height],
    ["L", x2 + halfWidth, y2 + height],
    ["L", x2 + halfWidth, triangleY],
    ["Z"],
    // 
    ["M", x2 - oneSixthWidth, triangleY],
    ["L", x2 - oneSixthWidth, y2 + height - 2],
    ["M", x2 + oneSixthWidth, triangleY],
    ["L", x2 + oneSixthWidth, y2 + height - 2]
  ];
}
Marker.registerSymbol("hiddenHandle", hiddenHandle);
Marker.registerSymbol("verticalHandle", verticalHandle);
Marker.registerSymbol("horizontalHandle", horizontalHandle);
function ifHorizontal(orientation5, a2, b2) {
  if (orientation5 === void 0) {
    orientation5 = "horizontal";
  }
  return orientation5 === "horizontal" ? a2 : b2;
}
var CLASSNAME_SUFFIX_MAP = {
  // Common elements
  title: "title",
  // Category legend elements
  item: "item",
  marker: "marker",
  label: "label",
  value: "value",
  focusIcon: "focus-icon",
  background: "background",
  handleMarker: "handle-marker",
  handleLabel: "handle-label",
  // Navigator elements (reserved)
  prevBtn: "prev-btn",
  nextBtn: "next-btn",
  pageInfo: "page-info"
};
var CLASS_NAMES$6 = classNames({
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label"
}, "handle");
var DEFAULT_HANDLE_CFG = {
  showLabel: true,
  formatter: function(val) {
    return val.toString();
  },
  markerSize: 25,
  markerStroke: "#c5c5c5",
  markerFill: "#fff",
  markerLineWidth: 1,
  labelFontSize: 12,
  labelFill: "#c5c5c5",
  labelText: "",
  orientation: "vertical",
  spacing: 0
};
(function(_super) {
  __extends$1(Handle2, _super);
  function Handle2(options) {
    return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
  }
  Handle2.prototype.render = function(attributes, container) {
    var markerGroup = select(container).maybeAppendByClassName(CLASS_NAMES$6.markerGroup, "g");
    this.renderMarker(markerGroup);
    var labelGroup = select(container).maybeAppendByClassName(CLASS_NAMES$6.labelGroup, "g");
    this.renderLabel(labelGroup);
  };
  Handle2.prototype.renderMarker = function(container) {
    var _this2 = this;
    var _a3 = this.attributes, orientation5 = _a3.orientation, classNamePrefix = _a3.classNamePrefix, _b = _a3.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation5, "horizontalHandle", "verticalHandle") : _b;
    ifShow(!!markerSymbol, container, function(group2) {
      var handleStyle = subStyleProps(_this2.attributes, "marker");
      var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
      var markerClassName = getLegendClassName(CLASS_NAMES$6.marker.name, CLASSNAME_SUFFIX_MAP.handleMarker, classNamePrefix);
      _this2.marker = group2.maybeAppendByClassName(CLASS_NAMES$6.marker, function() {
        return new Marker({
          style: markerStyle,
          className: markerClassName
        });
      }).update(markerStyle);
      if (classNamePrefix) {
        var markerElement = _this2.marker.node().querySelector(".marker");
        if (markerElement) {
          var currentClass = markerElement.getAttribute("class") || "";
          var baseClass = currentClass.split(" ")[0];
          var legendClassName = getLegendClassName(baseClass, CLASSNAME_SUFFIX_MAP.handleMarker, classNamePrefix);
          markerElement.setAttribute("class", legendClassName);
        }
      }
    });
  };
  Handle2.prototype.renderLabel = function(container) {
    var _this2 = this;
    var _a3 = this.attributes, showLabel = _a3.showLabel, orientation5 = _a3.orientation, _b = _a3.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a3.formatter, classNamePrefix = _a3.classNamePrefix;
    ifShow(showLabel, container, function(group2) {
      var _a4;
      var _b2 = subStyleProps(_this2.attributes, "label"), text = _b2.text, labelStyle = __rest$m(_b2, ["text"]);
      var _c = ((_a4 = group2.select(CLASS_NAMES$6.marker.class)) === null || _a4 === void 0 ? void 0 : _a4.node().getBBox()) || {}, _d = _c.width, width2 = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
      var _f = __read(ifHorizontal(orientation5, [0, height + spacing, "center", "top"], [width2 + spacing, 0, "start", "middle"]), 4), x2 = _f[0], y2 = _f[1], textAlign2 = _f[2], textBaseline = _f[3];
      var labelClassName = getLegendClassName(CLASS_NAMES$6.label.name, CLASSNAME_SUFFIX_MAP.handleLabel, classNamePrefix);
      group2.maybeAppendByClassName(CLASS_NAMES$6.label, "text").attr("className", labelClassName).styles(__assign(__assign({}, labelStyle), { x: x2, y: y2, text: formatter2(text).toString(), textAlign: textAlign2, textBaseline }));
    });
  };
  return Handle2;
})(Component);
var LEGEND_BASE_DEFAULT_OPTIONS = {
  showTitle: true,
  padding: 0,
  orientation: "horizontal",
  backgroundFill: "transparent",
  titleText: "",
  titleSpacing: 4,
  titlePosition: "top-left",
  titleFill: "#2C3542",
  titleFontWeight: "bold",
  titleFontFamily: "sans-serif",
  titleFontSize: 12
};
var CATEGORY_DEFAULT_OPTIONS = deepAssign({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
deepAssign({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
  color: [
    "#d0e3fa",
    "#acc7f6",
    "#8daaf2",
    "#6d8eea",
    "#4d73cd",
    "#325bb1",
    "#5a3e75",
    "#8c3c79",
    "#e23455",
    "#e7655b"
  ],
  indicatorBackgroundFill: "#262626",
  indicatorLabelFill: "white",
  indicatorLabelFontSize: 12,
  indicatorVisibility: "hidden",
  labelAlign: "value",
  labelDirection: "positive",
  labelSpacing: 5,
  showHandle: true,
  showIndicator: true,
  showLabel: true,
  slidable: true,
  titleText: "",
  type: "continuous"
});
var CLASS_NAMES$5 = classNames({
  title: "title",
  html: "html",
  titleGroup: "title-group",
  items: "items",
  itemsGroup: "items-group",
  contentGroup: "content-group",
  ribbonGroup: "ribbon-group",
  ribbon: "ribbon",
  handlesGroup: "handles-group",
  handle: "handle",
  startHandle: "start-handle",
  endHandle: "end-handle",
  labelGroup: "label-group",
  label: "label",
  indicator: "indicator"
}, "legend");
var CLASS_NAMES$4 = classNames({
  text: "text"
}, "title");
function getBBox(title, content) {
  var _a3 = title.attributes, position2 = _a3.position, spacing = _a3.spacing, inset = _a3.inset, text = _a3.text;
  var titleBBox = title.getBBox();
  var contentBBox = content.getBBox();
  var pos = parsePosition(position2);
  var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
  var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
  var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
  var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
  if (pos[0] === "l") {
    return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
  }
  if (pos[0] === "t") {
    return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
  }
  var _f = __read([
    content.attributes.width || contentBBox.width,
    content.attributes.height || contentBBox.height
  ], 2), contentWidth = _f[0], contentHeight = _f[1];
  return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
}
function mayApplyStyle(el, style) {
  var finalStyle = Object.entries(style).reduce(function(acc, _a3) {
    var _b = __read(_a3, 2), key = _b[0], value = _b[1];
    var currAttr = el.node().attr(key);
    if (!currAttr)
      acc[key] = value;
    return acc;
  }, {});
  el.styles(finalStyle);
}
function getTitleLayout(cfg) {
  var _a3, _b, _c, _d;
  var _e = cfg, width2 = _e.width, height = _e.height, position2 = _e.position;
  var _f = __read([+width2 / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
  var _g = __read([+hW, +hH, "center", "middle"], 4), x2 = _g[0], y2 = _g[1], textAlign2 = _g[2], textBaseline = _g[3];
  var pos = parsePosition(position2);
  if (pos.includes("l"))
    _a3 = __read([0, "start"], 2), x2 = _a3[0], textAlign2 = _a3[1];
  if (pos.includes("r"))
    _b = __read([+width2, "end"], 2), x2 = _b[0], textAlign2 = _b[1];
  if (pos.includes("t"))
    _c = __read([0, "top"], 2), y2 = _c[0], textBaseline = _c[1];
  if (pos.includes("b"))
    _d = __read([+height, "bottom"], 2), y2 = _d[0], textBaseline = _d[1];
  return { x: x2, y: y2, textAlign: textAlign2, textBaseline };
}
var Title$1 = (
  /** @class */
  function(_super) {
    __extends$1(Title2, _super);
    function Title2(options) {
      return _super.call(this, options, {
        text: "",
        width: 0,
        height: 0,
        fill: "#4a505a",
        fontWeight: "bold",
        fontSize: 12,
        fontFamily: "sans-serif",
        inset: 0,
        spacing: 0,
        position: "top-left"
      }) || this;
    }
    Title2.prototype.getAvailableSpace = function() {
      var container = this;
      var _a3 = this.attributes, containerWidth = _a3.width, containerHeight = _a3.height, position2 = _a3.position, spacing = _a3.spacing, inset = _a3.inset;
      var title = container.querySelector(CLASS_NAMES$4.text.class);
      if (!title)
        return new BBox(0, 0, +containerWidth, +containerHeight);
      var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
      var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
      var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x2 = _d[0], y2 = _d[1], width2 = _d[2], height = _d[3];
      var pos = parsePosition(position2);
      if (pos.includes("i"))
        return new BBox(x2, y2, width2, height);
      pos.forEach(function(p2, i2) {
        var _a4, _b2, _c2, _d2;
        if (p2 === "t")
          _a4 = __read(i2 === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y2 = _a4[0], height = _a4[1];
        if (p2 === "r")
          _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width2 = _b2[0];
        if (p2 === "b")
          _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
        if (p2 === "l")
          _d2 = __read(i2 === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x2 = _d2[0], width2 = _d2[1];
      });
      var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
      var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
      return new BBox(x2 + insetLeft, y2 + insetTop, width2 - insetWidth, height - insetHeight);
    };
    Title2.prototype.getBBox = function() {
      if (this.title)
        return this.title.getBBox();
      return new BBox(0, 0, 0, 0);
    };
    Title2.prototype.render = function(attributes, container) {
      var _this2 = this;
      attributes.width;
      attributes.height;
      attributes.position;
      attributes.spacing;
      var classNamePrefix = attributes.classNamePrefix, restStyle = __rest$m(attributes, ["width", "height", "position", "spacing", "classNamePrefix"]);
      var _a3 = __read(splitStyle(restStyle), 1), titleStyle = _a3[0];
      var _b = getTitleLayout(attributes), x2 = _b.x, y2 = _b.y, textAlign2 = _b.textAlign, textBaseline = _b.textBaseline;
      ifShow(!!restStyle.text, select(container), function(group2) {
        var titleClassName = getLegendClassName(CLASS_NAMES$4.text.name, CLASSNAME_SUFFIX_MAP.title, classNamePrefix);
        _this2.title = group2.maybeAppendByClassName(CLASS_NAMES$4.text, "text").attr("className", titleClassName).styles(titleStyle).call(mayApplyStyle, { x: x2, y: y2, textAlign: textAlign2, textBaseline }).node();
      });
    };
    return Title2;
  }(Component)
);
var CLASS_NAMES$3 = classNames({
  prevBtnGroup: "prev-btn-group",
  prevBtn: "prev-btn",
  nextBtnGroup: "next-btn-group",
  nextBtn: "next-btn",
  pageInfoGroup: "page-info-group",
  pageInfo: "page-info",
  playWindow: "play-window",
  contentGroup: "content-group",
  controller: "controller",
  clipPath: "clip-path"
}, "navigator");
var Navigator = (
  /** @class */
  function(_super) {
    __extends$1(Navigator2, _super);
    function Navigator2(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        animate: {
          easing: "linear",
          duration: 200,
          fill: "both"
        },
        buttonCursor: "pointer",
        buttonFill: "black",
        buttonD: button(0, 0, 6),
        buttonSize: 12,
        controllerPadding: 5,
        controllerSpacing: 5,
        formatter: function(curr, total) {
          return "".concat(curr, "/").concat(total);
        },
        defaultPage: 0,
        loop: false,
        orientation: "horizontal",
        pageNumFill: "black",
        pageNumFontSize: 12,
        pageNumTextAlign: "start",
        pageNumTextBaseline: "middle"
      }) || this;
      _this2.playState = "idle";
      _this2.contentGroup = _this2.appendChild(new Group({ class: CLASS_NAMES$3.contentGroup.name }));
      _this2.playWindow = _this2.contentGroup.appendChild(new Group({ class: CLASS_NAMES$3.playWindow.name }));
      _this2.innerCurrPage = _this2.defaultPage;
      return _this2;
    }
    Object.defineProperty(Navigator2.prototype, "defaultPage", {
      get: function() {
        var defaultPage = this.attributes.defaultPage;
        return clamp$1(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageViews", {
      get: function() {
        return this.playWindow.children;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "controllerShape", {
      // todo fixme
      get: function() {
        return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageShape", {
      get: function() {
        var pageViews = this.pageViews;
        var _a3 = __read(transpose(pageViews.map(function(pageView) {
          var _a4 = pageView.getBBox(), width2 = _a4.width, height = _a4.height;
          return [width2, height];
        })).map(function(arr) {
          return Math.max.apply(Math, __spreadArray([], __read(arr), false));
        }), 2), maxWidth = _a3[0], maxHeight = _a3[1];
        var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
        return { pageWidth, pageHeight };
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getContainer = function() {
      return this.playWindow;
    };
    Object.defineProperty(Navigator2.prototype, "totalPages", {
      get: function() {
        return this.pageViews.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "currPage", {
      get: function() {
        return this.innerCurrPage;
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getBBox = function() {
      var _a3 = _super.prototype.getBBox.call(this), x2 = _a3.x, y2 = _a3.y;
      var controllerShape = this.controllerShape;
      var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
      return new BBox(x2, y2, pageWidth + controllerShape.width, pageHeight);
    };
    Navigator2.prototype.goTo = function(pageNum) {
      var _this2 = this;
      var animateOptions = this.attributes.animate;
      var _a3 = this, currPage = _a3.currPage, playState = _a3.playState, playWindow = _a3.playWindow, pageViews = _a3.pageViews;
      if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
        return null;
      pageViews[currPage].setLocalPosition(0, 0);
      this.prepareFollowingPage(pageNum);
      var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
      this.playState = "running";
      var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
      onAnimateFinished(animation, function() {
        _this2.innerCurrPage = pageNum;
        _this2.playState = "idle";
        _this2.setVisiblePages([pageNum]);
        _this2.updatePageInfo();
      });
      return animation;
    };
    Navigator2.prototype.prev = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page <= 0)
        return null;
      var following = loop ? (page - 1 + pages) % pages : clamp$1(page - 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.next = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page >= pages - 1)
        return null;
      var following = loop ? (page + 1) % pages : clamp$1(page + 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.renderClipPath = function(container) {
      var _a3 = this.pageShape, pageWidth = _a3.pageWidth, pageHeight = _a3.pageHeight;
      if (!pageWidth || !pageHeight) {
        this.contentGroup.style.clipPath = void 0;
        return;
      }
      this.clipPath = container.maybeAppendByClassName(CLASS_NAMES$3.clipPath, "rect").styles({
        width: pageWidth,
        height: pageHeight
      });
      this.contentGroup.attr("clipPath", this.clipPath.node());
    };
    Navigator2.prototype.setVisiblePages = function(pages) {
      this.playWindow.children.forEach(function(page, index2) {
        if (pages.includes(index2))
          show(page);
        else
          hide(page);
      });
    };
    Navigator2.prototype.adjustControllerLayout = function() {
      var _a3 = this, prevBtn = _a3.prevBtnGroup, nextBtn = _a3.nextBtnGroup, pageNum = _a3.pageInfoGroup;
      var _b = this.attributes, orientation5 = _b.orientation, padding = _b.controllerPadding;
      var _c = pageNum.getBBox(), pW = _c.width;
      _c.height;
      var _d = __read(orientation5 === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
      prevBtn.setLocalEulerAngles(r1);
      nextBtn.setLocalEulerAngles(r2);
      var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
      var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
      var maxWidth = Math.max(bpW, pW, bnW);
      var _g = orientation5 === "horizontal" ? {
        offset: [
          [0, 0],
          [bpW / 2 + padding, 0],
          [bpW + pW + padding * 2, 0]
        ],
        textAlign: "start"
      } : {
        offset: [
          [maxWidth / 2, -bpH - padding],
          [maxWidth / 2, 0],
          [maxWidth / 2, bnH + padding]
        ],
        textAlign: "center"
      }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign2 = _g.textAlign;
      var pageNumText = pageNum.querySelector("text");
      pageNumText && (pageNumText.style.textAlign = textAlign2);
      prevBtn.setLocalPosition(o1x, o1y);
      pageNum.setLocalPosition(o2x, o2y);
      nextBtn.setLocalPosition(o3x, o3y);
    };
    Navigator2.prototype.updatePageInfo = function() {
      var _a3;
      var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
      if (pageViews.length < 2)
        return;
      (_a3 = this.pageInfoGroup.querySelector(CLASS_NAMES$3.pageInfo.class)) === null || _a3 === void 0 ? void 0 : _a3.attr("text", formatter2(currPage + 1, pageViews.length));
      this.adjustControllerLayout();
    };
    Navigator2.prototype.getFollowingPageDiff = function(pageNum) {
      var currPage = this.currPage;
      if (currPage === pageNum)
        return [0, 0];
      var orientation5 = this.attributes.orientation;
      var _a3 = this.pageShape, pageWidth = _a3.pageWidth, pageHeight = _a3.pageHeight;
      var sign = pageNum < currPage ? -1 : 1;
      return orientation5 === "horizontal" ? [sign * pageWidth, 0] : [0, sign * pageHeight];
    };
    Navigator2.prototype.prepareFollowingPage = function(pageNum) {
      var _a3 = this, currPage = _a3.currPage, pageViews = _a3.pageViews;
      this.setVisiblePages([pageNum, currPage]);
      if (pageNum !== currPage) {
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        pageViews[pageNum].setLocalPosition(dx, dy);
      }
    };
    Navigator2.prototype.renderController = function(container) {
      var _this2 = this;
      var _a3 = this.attributes, spacing = _a3.controllerSpacing, _b = _a3.classNamePrefix, classNamePrefix = _b === void 0 ? "" : _b;
      var _c = this.pageShape, pageWidth = _c.pageWidth, pageHeight = _c.pageHeight;
      var visible = this.pageViews.length >= 2;
      var group2 = container.maybeAppendByClassName(CLASS_NAMES$3.controller, "g");
      visibility(group2.node(), visible);
      if (!visible)
        return;
      var style = subStyleProps(this.attributes, "button");
      var textStyle = subStyleProps(this.attributes, "pageNum");
      var _d = __read(splitStyle(style), 2), _e = _d[0], groupStyle = _d[1], size = _e.size, pathStyle = __rest$m(_e, ["size"]);
      var whetherToAddEventListener = !group2.select(CLASS_NAMES$3.prevBtnGroup.class).node();
      var prevBtnGroup = group2.maybeAppendByClassName(CLASS_NAMES$3.prevBtnGroup, "g").styles(groupStyle);
      this.prevBtnGroup = prevBtnGroup.node();
      var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES$3.prevBtn, "path");
      if (classNamePrefix) {
        var prevBtnClassName = getLegendClassName(CLASS_NAMES$3.prevBtn.name, CLASSNAME_SUFFIX_MAP.prevBtn, classNamePrefix);
        prevBtn.node().setAttribute("class", prevBtnClassName);
      }
      var nextBtnGroup = group2.maybeAppendByClassName(CLASS_NAMES$3.nextBtnGroup, "g").styles(groupStyle);
      this.nextBtnGroup = nextBtnGroup.node();
      var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES$3.nextBtn, "path");
      if (classNamePrefix) {
        var nextBtnClassName = getLegendClassName(CLASS_NAMES$3.nextBtn.name, CLASSNAME_SUFFIX_MAP.nextBtn, classNamePrefix);
        nextBtn.node().setAttribute("class", nextBtnClassName);
      }
      [prevBtn, nextBtn].forEach(function(btn) {
        btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
        scaleToPixel(btn.node(), size);
      });
      var pageInfoGroup = group2.maybeAppendByClassName(CLASS_NAMES$3.pageInfoGroup, "g");
      this.pageInfoGroup = pageInfoGroup.node();
      var pageInfoElement = pageInfoGroup.maybeAppendByClassName(CLASS_NAMES$3.pageInfo, "text");
      pageInfoElement.styles(textStyle);
      if (classNamePrefix) {
        var pageInfoClassName = getLegendClassName(CLASS_NAMES$3.pageInfo.name, CLASSNAME_SUFFIX_MAP.pageInfo, classNamePrefix);
        pageInfoElement.node().setAttribute("class", pageInfoClassName);
      }
      this.updatePageInfo();
      group2.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
      if (whetherToAddEventListener) {
        this.prevBtnGroup.addEventListener("click", function() {
          _this2.prev();
        });
        this.nextBtnGroup.addEventListener("click", function() {
          _this2.next();
        });
      }
    };
    Navigator2.prototype.render = function(attributes, container) {
      var _a3 = attributes.x, x2 = _a3 === void 0 ? 0 : _a3, _b = attributes.y, y2 = _b === void 0 ? 0 : _b;
      this.attr("transform", "translate(".concat(x2, ", ").concat(y2, ")"));
      var containerSelection = select(container);
      this.renderClipPath(containerSelection);
      this.renderController(containerSelection);
      this.setVisiblePages([this.defaultPage]);
      this.goTo(this.defaultPage);
    };
    Navigator2.prototype.bindEvents = function() {
      var _this2 = this;
      var render = debounce(function() {
        return _this2.render(_this2.attributes, _this2);
      }, 50);
      this.playWindow.addEventListener(ElementEvent.INSERTED, render);
      this.playWindow.addEventListener(ElementEvent.REMOVED, render);
    };
    return Navigator2;
  }(Component)
);
var _a2;
var POPTIP_ID = "component-poptip";
var CLASS_NAME = {
  CONTAINER: "component-poptip",
  ARROW: "component-poptip-arrow",
  TEXT: "component-poptip-text"
};
var POPTIP_STYLE = (_a2 = {}, //   style
_a2[".".concat(CLASS_NAME.CONTAINER)] = {
  visibility: "visible",
  position: "absolute",
  "background-color": "rgba(0, 0, 0)",
  "box-shadow": "0px 0px 10px #aeaeae",
  "border-radius": "3px",
  color: "#fff",
  opacity: 0.8,
  "font-size": "12px",
  padding: "4px 6px",
  display: "flex",
  "justify-content": "center",
  "align-items": "center",
  "z-index": 8,
  transition: "visibility 50ms"
}, //   style
_a2[".".concat(CLASS_NAME.TEXT)] = {
  "text-align": "center"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, -100%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(-100%, -50%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(0, -50%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 0)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0,-100%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%,-100%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(-100%, 0)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(-100%, -100%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(0, 0)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(0, -100%)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 0)"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 0)"
}, _a2[".".concat(CLASS_NAME.ARROW)] = {
  width: "4px",
  height: "4px",
  transform: "rotate(45deg)",
  "background-color": "rgba(0, 0, 0)",
  position: "absolute",
  "z-index": -1
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, calc(-100% - 5px))"
}, _a2["[data-position='top'] .".concat(CLASS_NAME.ARROW)] = {
  bottom: "-2px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(calc(-100% - 5px), -50%)"
}, _a2["[data-position='left'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(5px, -50%)"
}, _a2["[data-position='right'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 5px)"
}, _a2["[data-position='bottom'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0, calc(-100% - 5px))"
}, _a2["[data-position='top-left'] .".concat(CLASS_NAME.ARROW)] = {
  left: "10px",
  bottom: "-2px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%, calc(-100% - 5px))"
}, _a2["[data-position='top-right'] .".concat(CLASS_NAME.ARROW)] = {
  right: "10px",
  bottom: "-2px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(calc(-100% - 5px), 0)"
}, _a2["[data-position='left-top'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  top: "8px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(calc(-100% - 5px), -100%)"
}, _a2["[data-position='left-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  bottom: "8px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(5px, 0)"
}, _a2["[data-position='right-top'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  top: "8px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(5px, -100%)"
}, _a2["[data-position='right-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  bottom: "8px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 5px)"
}, _a2["[data-position='bottom-left'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  left: "8px"
}, _a2[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 5px)"
}, _a2["[data-position='bottom-right'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  right: "8px"
}, _a2);
var _this = void 0;
function getPositionXY(clientX, clientY, target, position2, arrowPointAtCenter, follow) {
  if (arrowPointAtCenter === void 0) {
    arrowPointAtCenter = false;
  }
  if (follow === void 0) {
    follow = false;
  }
  if (follow)
    return [clientX, clientY];
  var _a3 = target.getBoundingClientRect(), x2 = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height;
  switch (position2) {
    case "top":
      return arrowPointAtCenter ? [x2 + width2 / 2, y2] : [clientX, y2];
    case "left":
      return arrowPointAtCenter ? [x2, y2 + height / 2] : [x2, clientY];
    case "bottom":
      return arrowPointAtCenter ? [x2 + width2 / 2, y2 + height] : [clientX, y2 + height];
    case "right":
      return arrowPointAtCenter ? [x2 + width2, y2 + height / 2] : [x2 + width2, clientY];
    case "top-right":
    case "right-top":
      return [x2 + width2, y2];
    case "left-bottom":
    case "bottom-left":
      return [x2, y2 + height];
    case "right-bottom":
    case "bottom-right":
      return [x2 + width2, y2 + height];
    case "top-left":
    case "left-top":
    default:
      return [x2, y2];
  }
}
var getSingleTon = function(fn) {
  var instance;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!instance)
      instance = fn.apply(_this, args);
    return instance;
  };
};
function createElement(id2) {
  var div = id2 && document.getElementById(id2);
  if (!div) {
    div = document.createElement("div");
    div.setAttribute("id", id2);
    document.body.appendChild(div);
  }
  return div;
}
function getSingleTonElement(id2) {
  var element = getSingleTon(createElement)(id2);
  return element;
}
var Poptip = (
  /** @class */
  function(_super) {
    __extends$1(Poptip2, _super);
    function Poptip2(options) {
      var _this2 = _super.call(this, deepMix({ style: { id: POPTIP_ID } }, Poptip2.defaultOptions, options)) || this;
      _this2.visibility = "visible";
      _this2.map = /* @__PURE__ */ new Map();
      _this2.domStyles = "";
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Poptip2.prototype, "visible", {
      get: function() {
        return this.visibility === "visible";
      },
      enumerable: false,
      configurable: true
    });
    Poptip2.prototype.render = function(attributes, container) {
      this.visibility = this.style.visibility;
      this.updatePoptipElement();
    };
    Poptip2.prototype.update = function(cfg) {
      this.attr(deepMix({}, this.style, cfg));
      this.render(this.attributes, this);
    };
    Poptip2.prototype.bind = function(element, callback) {
      var _this2 = this;
      if (!element)
        return;
      var defaultText = this.style.text;
      var onmousemove = function(e3) {
        var target = element;
        var options = _this2.style;
        var text = defaultText;
        if (callback) {
          var _a3 = typeof callback === "function" ? callback.call(null, e3) : callback, html = _a3.html, ele = _a3.target, restOptions = __rest$m(_a3, ["html", "target"]);
          options = mix({}, _this2.style, restOptions);
          if (ele || ele === false)
            target = ele;
          if (typeof html === "string")
            text = html;
        }
        var position2 = options.position, arrowPointAtCenter = options.arrowPointAtCenter, follow = options.follow, offset = options.offset;
        if (target) {
          var _b = e3, clientX = _b.clientX, clientY = _b.clientY;
          var _c = __read(getPositionXY(clientX, clientY, target, position2, arrowPointAtCenter, follow), 2), x2 = _c[0], y2 = _c[1];
          _this2.showTip(x2, y2, { text, position: position2, offset });
        } else {
          _this2.hideTip();
        }
      };
      var onmouseleave = function() {
        _this2.hideTip();
      };
      element.addEventListener("mousemove", onmousemove);
      element.addEventListener("mouseleave", onmouseleave);
      this.map.set(element, [onmousemove, onmouseleave]);
    };
    Poptip2.prototype.unbind = function(element) {
      if (this.map.has(element)) {
        var _a3 = __read(this.map.get(element) || [], 2), listener1 = _a3[0], listener2 = _a3[1];
        listener1 && element.removeEventListener("mousemove", listener1);
        listener2 && element.removeEventListener("mouseleave", listener2);
        this.map.delete(element);
      }
    };
    Poptip2.prototype.clear = function() {
      this.container.innerHTML = "";
    };
    Poptip2.prototype.destroy = function() {
      var _this2 = this;
      var _a3;
      __spreadArray([], __read(this.map.keys()), false).forEach(function(ele) {
        return _this2.unbind(ele);
      });
      (_a3 = this.container) === null || _a3 === void 0 ? void 0 : _a3.remove();
      _super.prototype.destroy.call(this);
    };
    Poptip2.prototype.showTip = function(x2, y2, options) {
      var text = get$1(options, "text");
      if (text && typeof text !== "string")
        return;
      this.applyStyles();
      if (x2 && y2 && options) {
        var offset = options.offset, position2 = options.position;
        position2 && this.container.setAttribute("data-position", position2);
        this.setOffsetPosition(x2, y2, offset);
        if (typeof text === "string") {
          var textElement = this.container.querySelector(".".concat(CLASS_NAME.TEXT));
          if (textElement) {
            textElement.innerHTML = text;
          }
        }
        this.visibility = "visible";
        this.container.style.visibility = "visible";
      }
    };
    Poptip2.prototype.hideTip = function() {
      this.visibility = "hidden";
      this.container.style.visibility = "hidden";
    };
    Poptip2.prototype.getContainer = function() {
      return this.container;
    };
    Poptip2.prototype.getClassName = function() {
      var containerClassName = this.style.containerClassName;
      return "".concat(CLASS_NAME.CONTAINER).concat(containerClassName ? " ".concat(containerClassName) : "");
    };
    Poptip2.prototype.initShape = function() {
      var _this2 = this;
      var id2 = this.style.id;
      this.container = getSingleTonElement(id2);
      this.container.className = this.getClassName();
      this.container.addEventListener("mousemove", function() {
        return _this2.showTip();
      });
      this.container.addEventListener("mouseleave", function() {
        return _this2.hideTip();
      });
    };
    Poptip2.prototype.updatePoptipElement = function() {
      var container = this.container;
      this.clear();
      var _a3 = this.style, id2 = _a3.id, template = _a3.template, text = _a3.text;
      this.container.setAttribute("id", id2);
      this.container.className = this.getClassName();
      var arrowNode = '<span class="'.concat(CLASS_NAME.ARROW, '"></span>');
      container.innerHTML = arrowNode;
      if (isString$1(template)) {
        container.innerHTML += template;
      } else if (template && isElement$2(template)) {
        container.appendChild(template);
      }
      if (text) {
        container.getElementsByClassName(CLASS_NAME.TEXT)[0].textContent = text;
      }
      this.applyStyles();
      this.container.style.visibility = this.visibility;
    };
    Poptip2.prototype.applyStyles = function() {
      var styles = deepAssign({}, POPTIP_STYLE, this.style.domStyles);
      var styleStr = Object.entries(styles).reduce(function(r2, _a3) {
        var _b = __read(_a3, 2), key = _b[0], value = _b[1];
        var styleStr2 = Object.entries(value).reduce(function(r3, _a4) {
          var _b2 = __read(_a4, 2), k = _b2[0], v2 = _b2[1];
          return "".concat(r3).concat(k, ": ").concat(v2, ";");
        }, "");
        return "".concat(r2).concat(key, "{").concat(styleStr2, "}");
      }, "");
      if (this.domStyles !== styleStr) {
        this.domStyles = styleStr;
        var styleDOM = this.container.querySelector("style");
        if (styleDOM)
          this.container.removeChild(styleDOM);
        styleDOM = document.createElement("style");
        styleDOM.innerHTML = styleStr;
        this.container.appendChild(styleDOM);
      }
    };
    Poptip2.prototype.setOffsetPosition = function(x2, y2, offset) {
      if (offset === void 0) {
        offset = this.style.offset;
      }
      var _a3 = __read(offset, 2), _b = _a3[0], offsetX = _b === void 0 ? 0 : _b, _c = _a3[1], offsetY = _c === void 0 ? 0 : _c;
      this.container.style.left = "".concat(x2 + offsetX, "px");
      this.container.style.top = "".concat(y2 + offsetY, "px");
    };
    Poptip2.tag = "poptip";
    Poptip2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        target: null,
        visibility: "hidden",
        text: "",
        position: "top",
        follow: false,
        offset: [0, 0],
        domStyles: POPTIP_STYLE,
        template: '<div class="'.concat(CLASS_NAME.TEXT, '"></div>')
      }
    };
    return Poptip2;
  }(Component)
);
var CLASS_NAMES$2 = classNames({
  layout: "flex",
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label",
  valueGroup: "value-group",
  focusGroup: "focus-group",
  focus: "focus",
  value: "value",
  backgroundGroup: "background-group",
  background: "background"
}, "legend-category-item");
var DEFAULT_POPTIP_PROPS = {
  offset: [0, 20],
  domStyles: {
    ".component-poptip": {
      opacity: "1",
      padding: "8px 12px",
      background: "#fff",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)"
    },
    ".component-poptip-arrow": {
      display: "none"
    },
    ".component-poptip-text": {
      color: "#000",
      lineHeight: "20px"
    }
  }
};
function styleOfMarker(group2) {
  var marker = group2.querySelector(CLASS_NAMES$2.marker.class);
  if (marker)
    return marker.style;
  return {};
}
var CategoryItem = (
  /** @class */
  function(_super) {
    __extends$1(CategoryItem2, _super);
    function CategoryItem2(options, keyFields) {
      var _this2 = _super.call(this, options, {
        span: [1, 1],
        marker: function() {
          return new Circle$2({ style: { r: 6 } });
        },
        markerSize: 10,
        labelFill: "#646464",
        valueFill: "#646464",
        labelFontSize: 12,
        valueFontSize: 12,
        labelTextBaseline: "middle",
        valueTextBaseline: "middle"
      }) || this;
      _this2.keyFields = {};
      _this2.keyFields = keyFields || {};
      return _this2;
    }
    Object.defineProperty(CategoryItem2.prototype, "showValue", {
      get: function() {
        var valueText = this.attributes.valueText;
        if (!valueText)
          return false;
        if (typeof valueText === "string" || typeof valueText === "number")
          return valueText !== "";
        if (typeof valueText === "function")
          return true;
        return valueText.attr("text") !== "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
      get: function() {
        var label = this.labelGroup;
        var value = this.valueGroup;
        var _a3 = this.attributes, markerSize = _a3.markerSize, focus2 = _a3.focus, focusMarkerSize = _a3.focusMarkerSize;
        var _b = label.node().getBBox(), labelWidth = _b.width, labelHeight = _b.height;
        var _c = value.node().getBBox(), valueWidth = _c.width, valueHeight = _c.height;
        var focusWidth = focus2 ? focusMarkerSize !== null && focusMarkerSize !== void 0 ? focusMarkerSize : 12 : 0;
        return {
          markerWidth: markerSize,
          labelWidth,
          valueWidth,
          focusWidth,
          height: Math.max(markerSize, labelHeight, valueHeight)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "span", {
      get: function() {
        var span = this.attributes.span;
        if (!span)
          return [1, 1];
        var _a3 = __read(parseSeriesAttr(span), 2), span1 = _a3[0], innerSpan = _a3[1];
        var span2 = this.showValue ? innerSpan : 0;
        var basis = span1 + span2;
        return [span1 / basis, span2 / basis];
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.setAttribute = function(n2, v2) {
      _super.prototype.setAttribute.call(this, n2, v2);
    };
    Object.defineProperty(CategoryItem2.prototype, "shape", {
      get: function() {
        var _a3;
        var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
        var actualSpace = this.actualSpace;
        var markerWidth = actualSpace.markerWidth, focusWidth = actualSpace.focusWidth, height = actualSpace.height;
        var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
        var _d = __read(this.spacing, 3), spacing1 = _d[0], spacing2 = _d[1], spacing3 = _d[2];
        if (fullWidth) {
          var width_1 = fullWidth - markerSize - spacing1 - spacing2 - focusWidth - spacing3;
          var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
          _a3 = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a3[0], valueWidth = _a3[1];
        }
        var width2 = markerWidth + labelWidth + valueWidth + spacing1 + spacing2 + focusWidth + spacing3;
        return { width: width2, height, markerWidth, labelWidth, valueWidth, focusWidth };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "spacing", {
      get: function() {
        var _a3 = this.attributes, spacing = _a3.spacing, focus2 = _a3.focus;
        if (!spacing)
          return [0, 0, 0];
        var _b = __read(parseSeriesAttr(spacing), 3), spacing1 = _b[0], spacing2 = _b[1], spacing3 = _b[2];
        return [spacing1, this.showValue ? spacing2 : 0, focus2 ? spacing3 : 0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "layout", {
      get: function() {
        var _a3 = this.shape, markerWidth = _a3.markerWidth, labelWidth = _a3.labelWidth, valueWidth = _a3.valueWidth, focusWidth = _a3.focusWidth, width2 = _a3.width, height = _a3.height;
        var _b = __read(this.spacing, 3), spacing1 = _b[0], spacing2 = _b[1], spacing3 = _b[2];
        return {
          height,
          width: width2,
          markerWidth,
          labelWidth,
          valueWidth,
          focusWidth,
          position: [
            markerWidth / 2,
            markerWidth + spacing1,
            markerWidth + labelWidth + spacing1 + spacing2,
            markerWidth + labelWidth + valueWidth + spacing1 + spacing2 + spacing3 + focusWidth / 2
          ]
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
      get: function() {
        var markerShapeStyle = styleOfMarker(this.markerGroup.node());
        var _a3 = this.attributes, markerSize = _a3.markerSize, _b = _a3.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a3.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a3.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
        var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
        var _e = this.markerGroup.node().getBBox(), width2 = _e.width, height = _e.height;
        return (1 - strokeWidth / Math.max(width2, height)) * markerSize;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.renderMarker = function(container) {
      var _this2 = this;
      var _a3 = this.attributes, marker = _a3.marker, classNamePrefix = _a3.classNamePrefix;
      var style = subStyleProps(this.attributes, "marker");
      this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES$2.markerGroup, "g").style("zIndex", 0);
      ifShow(!!marker, this.markerGroup, function() {
        var _a4;
        var parent = _this2.markerGroup.node();
        var oldMarker = (_a4 = parent.childNodes) === null || _a4 === void 0 ? void 0 : _a4[0];
        var markerClassName = getLegendClassName(CLASS_NAMES$2.marker.name, CLASSNAME_SUFFIX_MAP.marker, classNamePrefix);
        var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: markerClassName }) : marker();
        if (!oldMarker) {
          if (!(newMarker instanceof Marker)) {
            var markerClassName_1 = getLegendClassName(CLASS_NAMES$2.marker.name, CLASSNAME_SUFFIX_MAP.marker, classNamePrefix);
            newMarker.className = markerClassName_1;
            select(newMarker).styles(style);
          }
          parent.appendChild(newMarker);
        } else if (newMarker.nodeName === oldMarker.nodeName) {
          if (oldMarker instanceof Marker)
            oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
          else {
            copyAttributes(oldMarker, newMarker);
            select(oldMarker).styles(style);
          }
        } else {
          oldMarker.remove();
          if (!(newMarker instanceof Marker)) {
            var markerClassName_2 = getLegendClassName(CLASS_NAMES$2.marker.name, CLASSNAME_SUFFIX_MAP.marker, classNamePrefix);
            newMarker.className = markerClassName_2;
          }
          select(newMarker).styles(style);
          parent.appendChild(newMarker);
        }
        _this2.markerGroup.node().scale(1 / _this2.markerGroup.node().getScale()[0]);
        var scale3 = scaleToPixel(_this2.markerGroup.node(), _this2.scaleSize);
        _this2.markerGroup.node().style._transform = "scale(".concat(scale3, ")");
      });
    };
    CategoryItem2.prototype.renderLabel = function(container) {
      var _a3 = subStyleProps(this.attributes, "label"), label = _a3.text, style = __rest$m(_a3, ["text"]);
      var classNamePrefix = this.attributes.classNamePrefix;
      this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES$2.labelGroup, "g").style("zIndex", 0);
      var labelClassName = getLegendClassName(CLASS_NAMES$2.label.name, CLASSNAME_SUFFIX_MAP.label, classNamePrefix);
      var labelElement = this.labelGroup.maybeAppendByClassName(CLASS_NAMES$2.label, function() {
        return renderExtDo(label);
      });
      labelElement.node().setAttribute("class", labelClassName);
      labelElement.styles(style);
    };
    CategoryItem2.prototype.renderValue = function(container) {
      var _this2 = this;
      var _a3 = subStyleProps(this.attributes, "value"), value = _a3.text, style = __rest$m(_a3, ["text"]);
      var classNamePrefix = this.attributes.classNamePrefix;
      this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES$2.valueGroup, "g").style("zIndex", 0);
      ifShow(this.showValue, this.valueGroup, function() {
        var valueClassName = getLegendClassName(CLASS_NAMES$2.value.name, CLASSNAME_SUFFIX_MAP.value, classNamePrefix);
        var valueElement = _this2.valueGroup.maybeAppendByClassName(CLASS_NAMES$2.value, function() {
          return renderExtDo(value);
        });
        valueElement.node().setAttribute("class", valueClassName);
        valueElement.styles(style);
      });
    };
    CategoryItem2.prototype.createPoptip = function() {
      var poptip = this.attributes.poptip;
      var _a3 = poptip || {};
      _a3.render;
      var poptipStyle = __rest$m(_a3, ["render"]);
      var poptipGroup = new Poptip({ style: deepAssign(DEFAULT_POPTIP_PROPS, poptipStyle) });
      this.poptipGroup = poptipGroup;
      return poptipGroup;
    };
    CategoryItem2.prototype.bindPoptip = function(node) {
      var _this2 = this;
      var poptip = this.attributes.poptip;
      if (!poptip)
        return;
      var poptipGroup = this.poptipGroup || this.createPoptip();
      poptipGroup.bind(node, function() {
        var _a3 = _this2.attributes, labelText = _a3.labelText, valueText = _a3.valueText, markerFill = _a3.markerFill;
        var label = typeof labelText === "string" ? labelText : labelText === null || labelText === void 0 ? void 0 : labelText.attr("text");
        var value = typeof valueText === "string" ? valueText : valueText === null || valueText === void 0 ? void 0 : valueText.attr("text");
        if (typeof poptip.render === "function") {
          return { html: poptip.render(__assign(__assign({}, _this2.keyFields), { label, value, color: markerFill })) };
        }
        var html = "";
        if (typeof label === "string" || typeof label === "number") {
          html += '<div class="component-poptip-label">'.concat(label, "</div>");
        }
        if (typeof value === "string" || typeof value === "number") {
          html += '<div class="component-poptip-value">'.concat(value, "</div>");
        }
        return { html };
      });
    };
    CategoryItem2.prototype.renderFocus = function(ctn) {
      var _this2 = this;
      var _a3 = this.attributes, focus2 = _a3.focus, focusMarkerSize = _a3.focusMarkerSize, classNamePrefix = _a3.classNamePrefix;
      var defaultOptions2 = {
        x: 0,
        y: 0,
        size: focusMarkerSize,
        opacity: 0.6,
        symbol: "focus",
        stroke: "#aaaaaa",
        lineWidth: 1
      };
      if (isUndefined(focus2))
        return;
      this.focusGroup = ctn.maybeAppendByClassName(CLASS_NAMES$2.focusGroup, "g").style("zIndex", 0);
      ifShow(focus2, this.focusGroup, function() {
        var focusClassName = getLegendClassName(CLASS_NAMES$2.focus.name, CLASSNAME_SUFFIX_MAP.focusIcon, classNamePrefix);
        var marker = new Marker({
          style: __assign(__assign({}, defaultOptions2), { symbol: "focus" }),
          className: focusClassName
        });
        var interactiveCircle = new Circle$2({
          style: {
            r: defaultOptions2.size / 2,
            fill: "transparent"
          }
        });
        var container = _this2.focusGroup.node();
        container.appendChild(interactiveCircle);
        container.appendChild(marker);
        marker.update({ opacity: 0 });
        ctn.node().addEventListener("pointerenter", function() {
          marker.update({ opacity: 1 });
        });
        ctn.node().addEventListener("pointerleave", function() {
          marker.update({ opacity: 0 });
        });
      });
    };
    CategoryItem2.prototype.renderPoptip = function(ctn) {
      var _this2 = this;
      var poptip = this.attributes.poptip;
      if (!poptip)
        return;
      var valueNode = ctn.maybeAppendByClassName(CLASS_NAMES$2.value, "g").node();
      var labelNode = ctn.maybeAppendByClassName(CLASS_NAMES$2.label, "g").node();
      [valueNode, labelNode].forEach(function(node) {
        if (node) {
          _this2.bindPoptip(node);
        }
      });
    };
    CategoryItem2.prototype.renderBackground = function(container) {
      var _a3 = this.shape, width2 = _a3.width, height = _a3.height;
      var style = subStyleProps(this.attributes, "background");
      this.background = container.maybeAppendByClassName(CLASS_NAMES$2.backgroundGroup, "g").style("zIndex", -1);
      var backgroundElement = this.background.maybeAppendByClassName(CLASS_NAMES$2.background, "rect");
      backgroundElement.styles(__assign({ width: width2, height }, style));
      var _b = this.attributes.classNamePrefix, classNamePrefix = _b === void 0 ? "" : _b;
      if (classNamePrefix) {
        var backgroundClassName = getLegendClassName(CLASS_NAMES$2.background.name, CLASSNAME_SUFFIX_MAP.background, classNamePrefix);
        backgroundElement.node().setAttribute("class", backgroundClassName);
      }
    };
    CategoryItem2.prototype.adjustLayout = function() {
      var _a3 = this.layout, labelWidth = _a3.labelWidth, valueWidth = _a3.valueWidth, height = _a3.height, _b = __read(_a3.position, 4), markerX = _b[0], labelX = _b[1], valueX = _b[2], focusX = _b[3];
      var halfHeight = height / 2;
      this.markerGroup.styles({
        transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
      });
      this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
      if (this.focusGroup)
        this.focusGroup.styles({ transform: "translate(".concat(focusX, ", ").concat(halfHeight, ")") });
      ellipsisIt(this.labelGroup.select(CLASS_NAMES$2.label.class).node(), Math.ceil(labelWidth));
      if (this.showValue) {
        this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.valueGroup.select(CLASS_NAMES$2.value.class).node(), Math.ceil(valueWidth));
      }
    };
    CategoryItem2.prototype.render = function(attributes, container) {
      var ctn = select(container);
      var _a3 = attributes.x, x2 = _a3 === void 0 ? 0 : _a3, _b = attributes.y, y2 = _b === void 0 ? 0 : _b;
      ctn.styles({ transform: "translate(".concat(x2, ", ").concat(y2, ")") });
      this.renderMarker(ctn);
      this.renderLabel(ctn);
      this.renderValue(ctn);
      this.renderBackground(ctn);
      this.renderPoptip(ctn);
      this.renderFocus(ctn);
      this.adjustLayout();
    };
    return CategoryItem2;
  }(Component)
);
var CLASS_NAMES$1 = classNames({
  page: "item-page",
  navigator: "navigator",
  item: "item"
}, "items");
var ifSatisfied = function(value, rule, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = true;
  }
  if (value) {
    return rule(value);
  }
  return defaultValue;
};
var CategoryItems = (
  /** @class */
  function(_super) {
    __extends$1(CategoryItems2, _super);
    function CategoryItems2(options) {
      var _this2 = _super.call(this, options, {
        data: [],
        gridRow: Infinity,
        gridCol: void 0,
        padding: 0,
        width: 1e3,
        height: 100,
        rowPadding: 0,
        colPadding: 0,
        layout: "flex",
        orientation: "horizontal",
        click: noop$1,
        mouseenter: noop$1,
        mouseleave: noop$1
      }) || this;
      _this2.navigatorShape = [0, 0];
      return _this2;
    }
    Object.defineProperty(CategoryItems2.prototype, "pageViews", {
      get: function() {
        return this.navigator.getContainer();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "grid", {
      get: function() {
        var _a3 = this.attributes, gridRow = _a3.gridRow, gridCol = _a3.gridCol, data2 = _a3.data;
        if (!gridRow && !gridCol)
          throw new Error("gridRow and gridCol can not be set null at the same time");
        if (!!gridRow && !!gridCol)
          return [gridRow, gridCol];
        if (gridRow)
          return [gridRow, data2.length];
        return [data2.length, gridCol];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "renderData", {
      get: function() {
        var _a3 = this.attributes, data2 = _a3.data, layout2 = _a3.layout, poptip = _a3.poptip, focus2 = _a3.focus, focusMarkerSize = _a3.focusMarkerSize, classNamePrefix = _a3.classNamePrefix;
        var style = subStyleProps(this.attributes, "item");
        var d3 = data2.map(function(datum, index2) {
          var _a4 = datum.id, id2 = _a4 === void 0 ? index2 : _a4, labelText = datum.label, valueText = datum.value;
          return {
            id: "".concat(id2),
            index: index2,
            style: __assign({ layout: layout2, labelText, valueText, poptip, focus: focus2, focusMarkerSize, classNamePrefix }, Object.fromEntries(Object.entries(style).map(function(_a5) {
              var _b = __read(_a5, 2), key = _b[0], val = _b[1];
              return [key, getCallbackValue(val, [datum, index2, data2])];
            })))
          };
        });
        return d3;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.getGridLayout = function() {
      var _this2 = this;
      var _a3 = this.attributes, orientation5 = _a3.orientation, width2 = _a3.width, rowPadding = _a3.rowPadding, colPadding = _a3.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var pageSize = gridCol * gridRow;
      var prevOffset = 0;
      return this.pageViews.children.map(function(item, index2) {
        var _a4, _b2;
        var page = Math.floor(index2 / pageSize);
        var pageIndex = index2 % pageSize;
        var dir = _this2.ifHorizontal(gridCol, gridRow);
        var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
        if (orientation5 === "vertical")
          pos.reverse();
        var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
        var colWidth = (width2 - navWidth - (gridCol - 1) * colPadding) / gridCol;
        var rowHeight = item.getBBox().height;
        var _d = __read([0, 0], 2), x2 = _d[0], y2 = _d[1];
        if (orientation5 === "horizontal") {
          _a4 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x2 = _a4[0], y2 = _a4[1];
          prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
        } else {
          _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x2 = _b2[0], y2 = _b2[1];
          prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
        }
        return { page, index: index2, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x2, y: y2 };
      });
    };
    CategoryItems2.prototype.getFlexLayout = function() {
      var _a3 = this.attributes, maxWidth = _a3.width, maxHeight = _a3.height, rowPadding = _a3.rowPadding, cP = _a3.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
      var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x2 = _e[0], y2 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
      return this.pageViews.children.map(function(item, index2) {
        var _a4, _b2, _c2, _d2;
        var _e2 = item.getBBox(), width2 = _e2.width, height = _e2.height;
        var colPadding = prevWidth === 0 ? 0 : cP;
        var nextWidth = prevWidth + colPadding + width2;
        if (nextWidth <= limitWidth && ifSatisfied(col, function(c2) {
          return c2 < gridCol;
        })) {
          _a4 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x2 = _a4[0], y2 = _a4[1], prevWidth = _a4[2];
          return { width: width2, height, x: x2, y: y2, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
        var nextHeight = prevHeight + height;
        if (nextHeight <= limitHeight && ifSatisfied(row2, function(r2) {
          return r2 < gridRow;
        })) {
          _c2 = __read([prevWidth, prevHeight, width2], 3), x2 = _c2[0], y2 = _c2[1], prevWidth = _c2[2];
          return { width: width2, height, x: x2, y: y2, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _d2 = __read([0, 0, width2, 0, page + 1, 0, 0, 0], 8), x2 = _d2[0], y2 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
        return { width: width2, height, x: x2, y: y2, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
      });
    };
    Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
      get: function() {
        this.navigatorShape = [0, 0];
        var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
        var layout2 = cb.call(this);
        if (layout2.slice(-1)[0].page > 0) {
          this.navigatorShape = [55, 0];
          return cb.call(this);
        }
        return layout2;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.ifHorizontal = function(a2, b2) {
      var orientation5 = this.attributes.orientation;
      return ifHorizontal(orientation5, a2, b2);
    };
    CategoryItems2.prototype.flattenPage = function(container) {
      container.querySelectorAll(CLASS_NAMES$1.item.class).forEach(function(item) {
        container.appendChild(item);
      });
      container.querySelectorAll(CLASS_NAMES$1.page.class).forEach(function(page) {
        var removedPage = container.removeChild(page);
        removedPage.destroy();
      });
    };
    CategoryItems2.prototype.renderItems = function(container) {
      var _a3 = this.attributes, click = _a3.click, mouseenter = _a3.mouseenter, mouseleave = _a3.mouseleave, classNamePrefix = _a3.classNamePrefix;
      this.flattenPage(container);
      var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
      var itemClassName = getLegendClassName(CLASS_NAMES$1.item.name, CLASSNAME_SUFFIX_MAP.item, classNamePrefix);
      select(container).selectAll(CLASS_NAMES$1.item.class).data(this.renderData, function(d3) {
        return d3.id;
      }).join(function(enter) {
        return enter.append(function(_a4) {
          var style = _a4.style, rest = __rest$m(_a4, ["style"]);
          return new CategoryItem({ style }, rest);
        }).attr("className", itemClassName).on("click", function() {
          click === null || click === void 0 ? void 0 : click(this);
          dispatchCustomEvent("itemClick", { item: this });
        }).on("pointerenter", function() {
          mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
          dispatchCustomEvent("itemMouseenter", { item: this });
        }).on("pointerleave", function() {
          mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
          dispatchCustomEvent("itemMouseleave", { item: this });
        });
      }, function(update) {
        return update.each(function(_a4) {
          var style = _a4.style;
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    CategoryItems2.prototype.relayoutNavigator = function() {
      var _a3;
      var _b = this.attributes, layout2 = _b.layout, width2 = _b.width;
      var height = ((_a3 = this.pageViews.children[0]) === null || _a3 === void 0 ? void 0 : _a3.getBBox().height) || 0;
      var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
      this.navigator.update(layout2 === "grid" ? { pageWidth: width2 - navWidth, pageHeight: height - navHeight } : {});
    };
    CategoryItems2.prototype.adjustLayout = function() {
      var _this2 = this;
      var itemsLayouts = Object.entries(groupBy(this.itemsLayout, "page")).map(function(_a3) {
        var _b = __read(_a3, 2), page = _b[0], layouts = _b[1];
        return {
          page,
          layouts
        };
      });
      var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
      itemsLayouts.forEach(function(_a3) {
        var layouts = _a3.layouts;
        var page = _this2.pageViews.appendChild(new Group({ className: CLASS_NAMES$1.page.name }));
        layouts.forEach(function(layout2) {
          var x2 = layout2.x, y2 = layout2.y, index2 = layout2.index, width2 = layout2.width, height = layout2.height;
          var item = categoryItems[index2];
          page.appendChild(item);
          set$1(item, "__layout__", layout2);
          item.update({ x: x2, y: y2, width: width2, height });
        });
      });
      this.relayoutNavigator();
    };
    CategoryItems2.prototype.renderNavigator = function(container) {
      var _a3 = this.attributes, orientation5 = _a3.orientation, classNamePrefix = _a3.classNamePrefix;
      var navStyle = subStyleProps(this.attributes, "nav");
      var style = deepAssign({ orientation: orientation5, classNamePrefix }, navStyle);
      var that = this;
      container.selectAll(CLASS_NAMES$1.navigator.class).data(["nav"]).join(function(enter) {
        return enter.append(function() {
          return new Navigator({ style });
        }).attr("className", CLASS_NAMES$1.navigator.name).each(function() {
          that.navigator = this;
        });
      }, function(update) {
        return update.each(function() {
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
      return this.navigator;
    };
    CategoryItems2.prototype.getBBox = function() {
      return this.navigator.getBBox();
    };
    CategoryItems2.prototype.render = function(attributes, container) {
      var data2 = this.attributes.data;
      if (!data2 || data2.length === 0)
        return;
      var navigator = this.renderNavigator(select(container));
      this.renderItems(navigator.getContainer());
      this.adjustLayout();
    };
    CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
      var evt = new CustomEvent(type, {
        detail: payload
      });
      this.dispatchEvent(evt);
    };
    return CategoryItems2;
  }(Component)
);
var HtmlLegend = (
  /** @class */
  function(_super) {
    __extends$1(HtmlLegend2, _super);
    function HtmlLegend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlLegend2.prototype.update = function(options) {
      this.attr(options);
    };
    return HtmlLegend2;
  }(HTML$1)
);
var Category = (
  /** @class */
  function(_super) {
    __extends$1(Category2, _super);
    function Category2(options) {
      return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
    }
    Category2.prototype.renderTitle = function(container, width2, height) {
      var _a3 = this.attributes, showTitle = _a3.showTitle, titleText = _a3.titleText, classNamePrefix = _a3.classNamePrefix;
      var style = subStyleProps(this.attributes, "title");
      var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
      this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES$5.titleGroup, "g").styles(groupStyle);
      var finalTitleStyle = __assign(__assign({ width: width2, height }, titleStyle), { text: showTitle ? titleText : "", classNamePrefix });
      this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES$5.title, function() {
        return new Title$1({ style: finalTitleStyle });
      }).update(finalTitleStyle);
    };
    Category2.prototype.renderCustom = function(container) {
      var data2 = this.attributes.data;
      var style = {
        innerHTML: this.attributes.render(data2),
        pointerEvents: "auto"
      };
      container.maybeAppendByClassName(CLASS_NAMES$5.html, function() {
        return new HtmlLegend({
          className: CLASS_NAMES$5.html.name,
          style
        });
      }).update(style);
    };
    Category2.prototype.renderItems = function(container, bbox) {
      var x2 = bbox.x, y2 = bbox.y, width2 = bbox.width, height = bbox.height;
      var style = subStyleProps(this.attributes, "title", true);
      var _a3 = __read(splitStyle(style), 2), partialItemStyle = _a3[0], groupStyle = _a3[1];
      var itemStyle = __assign(__assign({}, partialItemStyle), { width: width2, height, x: 0, y: 0 });
      this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES$5.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x2, ", ").concat(y2, ")") }));
      var that = this;
      this.itemsGroup.selectAll(CLASS_NAMES$5.items.class).data(["items"]).join(function(enter) {
        return enter.append(function() {
          return new CategoryItems({ style: itemStyle });
        }).attr("className", CLASS_NAMES$5.items.name).each(function() {
          that.items = select(this);
        });
      }, function(update) {
        return update.update(itemStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Category2.prototype.adjustLayout = function() {
      var showTitle = this.attributes.showTitle;
      if (showTitle) {
        var _a3 = this.title.node().getAvailableSpace(), x2 = _a3.x, y2 = _a3.y;
        this.itemsGroup.node().style.transform = "translate(".concat(x2, ", ").concat(y2, ")");
      }
    };
    Object.defineProperty(Category2.prototype, "availableSpace", {
      get: function() {
        var _a3 = this.attributes, showTitle = _a3.showTitle, width2 = _a3.width, height = _a3.height;
        if (!showTitle)
          return new BBox(0, 0, width2, height);
        return this.title.node().getAvailableSpace();
      },
      enumerable: false,
      configurable: true
    });
    Category2.prototype.getBBox = function() {
      var _a3, _b;
      var title = (_a3 = this.title) === null || _a3 === void 0 ? void 0 : _a3.node();
      var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
      if (!title || !items)
        return _super.prototype.getBBox.call(this);
      return getBBox(title, items);
    };
    Category2.prototype.render = function(attributes, container) {
      var _a3 = this.attributes, width2 = _a3.width, height = _a3.height, _b = _a3.x, x2 = _b === void 0 ? 0 : _b, _c = _a3.y, y2 = _c === void 0 ? 0 : _c, classNamePrefix = _a3.classNamePrefix, render = _a3.render;
      var ctn = select(container);
      var baseClassName = container.className || "legend-category";
      if (classNamePrefix) {
        container.attr("className", "".concat(baseClassName, " ").concat(classNamePrefix, "legend"));
      } else if (!container.className) {
        container.attr("className", "legend-category");
      }
      container.style.transform = "translate(".concat(x2, ", ").concat(y2, ")");
      if (render) {
        this.renderCustom(ctn);
      } else {
        this.renderTitle(ctn, width2, height);
        this.renderItems(ctn, this.availableSpace);
        this.adjustLayout();
      }
    };
    return Category2;
  }(Component)
);
var DEFAULT_INDICATOR_STYLE_PROPS = {
  backgroundFill: "#262626",
  backgroundLineCap: "round",
  backgroundLineWidth: 1,
  backgroundStroke: "#333",
  backgroundZIndex: -1,
  formatter: function(val) {
    return val.toString();
  },
  labelFill: "#fff",
  labelFontSize: 12,
  labelTextBaseline: "middle",
  padding: [2, 4],
  position: "right",
  radius: 0,
  zIndex: 999
};
var CLASS_NAMES = classNames({
  background: "background",
  labelGroup: "label-group",
  label: "label"
}, "indicator");
var Indicator = (
  /** @class */
  function(_super) {
    __extends$1(Indicator2, _super);
    function Indicator2(options) {
      var _this2 = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
      _this2.point = [0, 0];
      _this2.group = _this2.appendChild(new Group({}));
      _this2.isMutationObserved = true;
      return _this2;
    }
    Indicator2.prototype.renderBackground = function() {
      if (!this.label)
        return;
      var _a3 = this.attributes, position2 = _a3.position, padding = _a3.padding;
      var _b = __read(parseSeriesAttr(padding), 4), t3 = _b[0], r2 = _b[1], b2 = _b[2], l2 = _b[3];
      var _c = this.label.node().getLocalBounds(), min2 = _c.min, max2 = _c.max;
      var bbox = new BBox(min2[0] - l2, min2[1] - t3, max2[0] + r2 - min2[0] + l2, max2[1] + b2 - min2[1] + t3);
      var path = this.getPath(position2, bbox);
      var style = subStyleProps(this.attributes, "background");
      this.background = select(this.group).maybeAppendByClassName(CLASS_NAMES.background, "path").styles(__assign(__assign({}, style), { d: path }));
      this.group.appendChild(this.label.node());
    };
    Indicator2.prototype.renderLabel = function() {
      var _a3 = this.attributes, formatter2 = _a3.formatter, labelText = _a3.labelText;
      var style = subStyleProps(this.attributes, "label");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1];
      _c.text;
      var textStyle = __rest$m(_c, ["text"]);
      this.label = select(this.group).maybeAppendByClassName(CLASS_NAMES.labelGroup, "g").styles(groupStyle);
      if (!labelText)
        return;
      var text = this.label.maybeAppendByClassName(CLASS_NAMES.label, function() {
        return renderExtDo(formatter2(labelText));
      }).style("text", formatter2(labelText).toString());
      text.selectAll("text").styles(textStyle);
    };
    Indicator2.prototype.adjustLayout = function() {
      var _a3 = __read(this.point, 2), dx = _a3[0], dy = _a3[1];
      var _b = this.attributes, x2 = _b.x, y2 = _b.y;
      this.group.attr("transform", "translate(".concat(x2 - dx, ", ").concat(y2 - dy, ")"));
    };
    Indicator2.prototype.getPath = function(position2, bbox) {
      var r2 = this.attributes.radius;
      var x2 = bbox.x, y2 = bbox.y, width2 = bbox.width, height = bbox.height;
      var pathArray = [
        // 0 
        ["M", x2 + r2, y2],
        // 1 
        ["L", x2 + width2 - r2, y2],
        // 2 
        ["A", r2, r2, 0, 0, 1, x2 + width2, y2 + r2],
        // 3 
        ["L", x2 + width2, y2 + height - r2],
        // 4 
        ["A", r2, r2, 0, 0, 1, x2 + width2 - r2, y2 + height],
        // 5 
        ["L", x2 + r2, y2 + height],
        // 6 
        ["A", r2, r2, 0, 0, 1, x2, y2 + height - r2],
        // 7 
        ["L", x2, y2 + r2],
        // 8 
        ["A", r2, r2, 0, 0, 1, x2 + r2, y2],
        // 9 
        ["Z"]
      ];
      var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
      var index2 = revertPositionMap[position2];
      var newPath = this.createCorner([pathArray[index2].slice(-2), pathArray[index2 + 1].slice(-2)]);
      pathArray.splice.apply(pathArray, __spreadArray([index2 + 1, 1], __read(newPath), false));
      pathArray[0][0] = "M";
      return pathArray;
    };
    Indicator2.prototype.createCorner = function(edge, size) {
      if (size === void 0) {
        size = 10;
      }
      var cornerScale = 0.8;
      var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
      var _a3 = __read(edge, 2), _b = __read(_a3[0], 2), x0 = _b[0], y0 = _b[1], _c = __read(_a3[1], 2), x1 = _c[0], y1 = _c[1];
      var _d = __read(isH ? [x1 - x0, [x0, x1]] : [y1 - y0, [y0, y1]], 2), len2 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
      var hL = len2 / 2;
      var sign = len2 / Math.abs(len2);
      var cL = size * sign;
      var hCL = cL / 2;
      var cS = cL * Math.sqrt(3) / 2 * cornerScale;
      var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a2 = _f[2], a3 = _f[3], a4 = _f[4];
      if (isH) {
        this.point = [a2, y0 - cS];
        return [
          ["L", a0, y0],
          ["L", a1, y0],
          ["L", a2, y0 - cS],
          ["L", a3, y0],
          ["L", a4, y0]
        ];
      }
      this.point = [x0 + cS, a2];
      return [
        ["L", x0, a0],
        ["L", x0, a1],
        ["L", x0 + cS, a2],
        ["L", x0, a3],
        ["L", x0, a4]
      ];
    };
    Indicator2.prototype.applyVisibility = function() {
      var visibility2 = this.attributes.visibility;
      if (visibility2 === "hidden")
        hide(this);
      else
        show(this);
    };
    Indicator2.prototype.bindEvents = function() {
      this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
    };
    Indicator2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
      this.adjustLayout();
      this.applyVisibility();
    };
    return Indicator2;
  }(Component)
);
function getClassNames(prefixCls) {
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  return {
    CONTAINER: "".concat(prefixCls, "tooltip"),
    TITLE: "".concat(prefixCls, "tooltip-title"),
    LIST: "".concat(prefixCls, "tooltip-list"),
    LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
    NAME: "".concat(prefixCls, "tooltip-list-item-name"),
    MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
    NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
    VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
    CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
    CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
  };
}
var TEXT_OVERFLOW_STYLE = {
  overflow: "hidden",
  "white-space": "nowrap",
  "text-overflow": "ellipsis"
};
function getDefaultTooltipStyle(prefixCls) {
  var _a3;
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  var CLASS_NAME2 = getClassNames(prefixCls);
  return _a3 = {}, _a3[".".concat(CLASS_NAME2.CONTAINER)] = {
    position: "absolute",
    visibility: "visible",
    // 'white-space': 'nowrap',
    "z-index": 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    "background-color": "rgba(255, 255, 255, 0.96)",
    "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
    "border-radius": "4px",
    color: "rgba(0, 0, 0, 0.65)",
    "font-size": "12px",
    // 'font-family': ,
    "line-height": "20px",
    padding: "12px",
    "min-width": "120px",
    "max-width": "360px",
    "font-family": "Roboto-Regular"
  }, _a3[".".concat(CLASS_NAME2.TITLE)] = {
    color: "rgba(0, 0, 0, 0.45)"
  }, _a3[".".concat(CLASS_NAME2.LIST)] = {
    margin: "0px",
    "list-style-type": "none",
    padding: "0px"
  }, _a3[".".concat(CLASS_NAME2.LIST_ITEM)] = {
    "list-style-type": "none",
    display: "flex",
    "line-height": "2em",
    "align-items": "center",
    "justify-content": "space-between",
    "white-space": "nowrap"
  }, _a3[".".concat(CLASS_NAME2.MARKER)] = {
    width: "8px",
    height: "8px",
    "border-radius": "50%",
    display: "inline-block",
    "margin-right": "4px"
  }, _a3[".".concat(CLASS_NAME2.NAME)] = {
    display: "flex",
    "align-items": "center",
    "max-width": "216px"
  }, _a3[".".concat(CLASS_NAME2.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a3[".".concat(CLASS_NAME2.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a3[".".concat(CLASS_NAME2.CROSSHAIR_X)] = {
    position: "absolute",
    width: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a3[".".concat(CLASS_NAME2.CROSSHAIR_Y)] = {
    position: "absolute",
    height: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a3;
}
var Tooltip$1 = (
  /** @class */
  function(_super) {
    __extends$1(Tooltip2, _super);
    function Tooltip2(options) {
      var _this2 = this;
      var _a3, _b;
      var prefixCls = (_b = (_a3 = options.style) === null || _a3 === void 0 ? void 0 : _a3.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
      var CLASS_NAME2 = getClassNames(prefixCls);
      _this2 = _super.call(this, options, {
        data: [],
        x: 0,
        y: 0,
        visibility: "visible",
        title: "",
        position: "bottom-right",
        offset: [5, 5],
        enterable: false,
        container: {
          x: 0,
          y: 0
        },
        bounding: null,
        template: {
          prefixCls: "",
          container: '<div class="'.concat(CLASS_NAME2.CONTAINER, '"></div>'),
          title: '<div class="'.concat(CLASS_NAME2.TITLE, '"></div>'),
          item: '<li class="'.concat(CLASS_NAME2.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME2.NAME, '">\n          <span class="').concat(CLASS_NAME2.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME2.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME2.VALUE, '" title="{value}">{value}</span>\n      </li>')
        },
        style: getDefaultTooltipStyle(prefixCls)
      }) || this;
      _this2.timestamp = -1;
      _this2.prevCustomContentKey = _this2.attributes.contentKey;
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Tooltip2.prototype, "HTMLTooltipElement", {
      get: function() {
        return this.element;
      },
      enumerable: false,
      configurable: true
    });
    Tooltip2.prototype.getContainer = function() {
      return this.element;
    };
    Object.defineProperty(Tooltip2.prototype, "elementSize", {
      get: function() {
        var width2 = this.element.offsetWidth;
        var height = this.element.offsetHeight;
        return { width: width2, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "HTMLTooltipItemsElements", {
      get: function() {
        var _a3 = this.attributes, data2 = _a3.data, template = _a3.template;
        return data2.map(function(_a4, idx) {
          var _b = _a4.name, name = _b === void 0 ? "" : _b, _c = _a4.color, color2 = _c === void 0 ? "black" : _c, index2 = _a4.index, rest = __rest$m(_a4, ["name", "color", "index"]);
          var datum = __assign({ name, color: color2, index: index2 !== null && index2 !== void 0 ? index2 : idx }, rest);
          return createDOM(substitute(template.item, datum));
        });
      },
      enumerable: false,
      configurable: true
    });
    Tooltip2.prototype.render = function(attributes, container) {
      this.renderHTMLTooltipElement();
      this.updatePosition();
    };
    Tooltip2.prototype.destroy = function() {
      var _a3;
      (_a3 = this.element) === null || _a3 === void 0 ? void 0 : _a3.remove();
      _super.prototype.destroy.call(this);
    };
    Tooltip2.prototype.show = function(x2, y2) {
      var _this2 = this;
      if (x2 !== void 0 && y2 !== void 0) {
        var isToggle = this.element.style.visibility === "hidden";
        var setPosition = function() {
          _this2.attributes.x = x2 !== null && x2 !== void 0 ? x2 : _this2.attributes.x;
          _this2.attributes.y = y2 !== null && y2 !== void 0 ? y2 : _this2.attributes.y;
          _this2.updatePosition();
        };
        isToggle ? this.closeTransition(setPosition) : setPosition();
      }
      this.element.style.visibility = "visible";
    };
    Tooltip2.prototype.hide = function(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      var enterable = this.attributes.enterable;
      if (enterable && this.isCursorEntered(x2, y2))
        return;
      this.element.style.visibility = "hidden";
    };
    Tooltip2.prototype.initShape = function() {
      var template = this.attributes.template;
      this.element = createDOM(template.container);
      if (this.id)
        this.element.setAttribute("id", this.id);
    };
    Tooltip2.prototype.renderCustomContent = function() {
      if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
        return;
      this.prevCustomContentKey = this.attributes.contentKey;
      var content = this.attributes.content;
      if (!content)
        return;
      if (typeof content === "string")
        this.element.innerHTML = content;
      else
        replaceChildren(this.element, content);
    };
    Tooltip2.prototype.renderHTMLTooltipElement = function() {
      var _a3, _b;
      var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
      var CLASS_NAME2 = getClassNames(template.prefixCls);
      var container = this.element;
      this.element.style.pointerEvents = enterable ? "auto" : "none";
      if (content)
        this.renderCustomContent();
      else {
        if (title) {
          container.innerHTML = template.title;
          container.getElementsByClassName(CLASS_NAME2.TITLE)[0].innerHTML = title;
        } else
          (_b = (_a3 = container.getElementsByClassName(CLASS_NAME2.TITLE)) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.remove();
        var itemsElements = this.HTMLTooltipItemsElements;
        var ul = document.createElement("ul");
        ul.className = CLASS_NAME2.LIST;
        replaceChildren(ul, itemsElements);
        var list2 = this.element.querySelector(".".concat(CLASS_NAME2.LIST));
        if (list2)
          list2.replaceWith(ul);
        else
          container.appendChild(ul);
      }
      applyStyleSheet(container, style);
    };
    Tooltip2.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
      var _a3 = this.attributes, position2 = _a3.position, offset = _a3.offset;
      var interPosition = assignPosition || position2;
      var finalPosition = interPosition.split("-");
      var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
      var _b = this.elementSize, width2 = _b.width, height = _b.height;
      var absolutelyOffset = [-width2 / 2, -height / 2];
      finalPosition.forEach(function(pos) {
        var _a4 = __read(absolutelyOffset, 2), abs1 = _a4[0], abs2 = _a4[1];
        var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
        absolutelyOffset = [abs1 + (width2 / 2 + offset[0]) * pos1, abs2 + (height / 2 + offset[1]) * pos2];
      });
      return absolutelyOffset;
    };
    Tooltip2.prototype.setOffsetPosition = function(_a3) {
      var _b = __read(_a3, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, _d = _c.x, x2 = _d === void 0 ? 0 : _d, _e = _c.y, y2 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
      this.element.style.left = "".concat(+x2 + cx + offsetX, "px");
      this.element.style.top = "".concat(+y2 + cy + offsetY, "px");
    };
    Tooltip2.prototype.updatePosition = function() {
      var _a3 = this.attributes.showDelay, showDelay = _a3 === void 0 ? 60 : _a3;
      var currentTimestamp = Date.now();
      if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
        return;
      this.timestamp = currentTimestamp;
      this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
    };
    Tooltip2.prototype.autoPosition = function(_a3) {
      var _b = __read(_a3, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position2 = _c.position;
      if (!bounding)
        return [offsetX, offsetY];
      var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
      var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
      var inversion = {
        left: "right",
        right: "left",
        top: "bottom",
        bottom: "top"
      };
      var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
      var edgeCompare = {
        left: expectLeft < boundingX,
        right: expectLeft + offsetWidth > boundingX + boundingWidth,
        top: expectTop < boundingY,
        bottom: expectTop + offsetHeight > boundingY + boundingHeight
      };
      var correctivePosition = [];
      position2.split("-").forEach(function(pos) {
        if (edgeCompare[pos])
          correctivePosition.push(inversion[pos]);
        else
          correctivePosition.push(pos);
      });
      var correctedPositionString = correctivePosition.join("-");
      return this.getRelativeOffsetFromCursor(correctedPositionString);
    };
    Tooltip2.prototype.isCursorEntered = function(clientX, clientY) {
      if (this.element) {
        var _a3 = this.element.getBoundingClientRect(), x2 = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height;
        return new BBox(x2, y2, width2, height).isPointIn(clientX, clientY);
      }
      return false;
    };
    Tooltip2.prototype.closeTransition = function(callback) {
      var _this2 = this;
      var transition2 = this.element.style.transition;
      this.element.style.transition = "none";
      callback();
      setTimeout(function() {
        _this2.element.style.transition = transition2;
      }, 10);
    };
    Tooltip2.tag = "tooltip";
    return Tooltip2;
  }(Component)
);
var Option = (
  /** @class */
  function(_super) {
    __extends$1(Option2, _super);
    function Option2(options) {
      var _this2 = _super.call(this, deepAssign({}, Option2.defaultOptions, options)) || this;
      _this2.hoverColor = "#f5f5f5";
      _this2.selectedColor = "#e6f7ff";
      _this2.background = _this2.appendChild(new Rect$1({}));
      _this2.label = _this2.background.appendChild(new Group({}));
      return _this2;
    }
    Object.defineProperty(Option2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.style.padding);
      },
      enumerable: false,
      configurable: true
    });
    Option2.prototype.renderLabel = function() {
      var _a3 = this.style, label = _a3.label, value = _a3.value;
      var labelStyle = subStyleProps(this.attributes, "label");
      select(this.label).maybeAppend(".label", function() {
        return renderExtDo(label);
      }).attr("className", "label").styles(labelStyle);
      this.label.attr("__data__", value);
    };
    Option2.prototype.renderBackground = function() {
      var labelBBox = this.label.getBBox();
      var _a3 = __read(this.padding, 4), top = _a3[0], right = _a3[1], bottom = _a3[2], left = _a3[3];
      var labelWidth = labelBBox.width, labelHeight = labelBBox.height;
      var backgroundWidth = labelWidth + left + right;
      var backgroundHeight = labelHeight + top + bottom;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      var _b = this.style, _c = _b.width, styleWidth = _c === void 0 ? 0 : _c, _d = _b.height, styleHeight = _d === void 0 ? 0 : _d, selected = _b.selected;
      this.background.attr(__assign(__assign({}, backgroundStyle), { width: Math.max(backgroundWidth, styleWidth), height: Math.max(backgroundHeight, styleHeight), fill: selected ? this.selectedColor : "#fff" }));
      this.label.attr({ transform: "translate(".concat(left, ", ").concat((backgroundHeight - labelHeight) / 2, ")") });
    };
    Option2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
    };
    Option2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("pointerenter", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.hoverColor);
      });
      this.addEventListener("pointerleave", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.style.backgroundFill);
      });
      var item = this;
      this.addEventListener("click", function() {
        var _a3 = _this2.style, label = _a3.label, value = _a3.value, onClick = _a3.onClick;
        onClick === null || onClick === void 0 ? void 0 : onClick(value, { label, value }, item);
      });
    };
    Option2.defaultOptions = {
      style: {
        value: "",
        label: "",
        cursor: "pointer"
      }
    };
    return Option2;
  }(Component)
);
var Select = (
  /** @class */
  function(_super) {
    __extends$1(Select2, _super);
    function Select2(options) {
      var _a3, _b;
      var _this2 = _super.call(this, deepAssign({}, Select2.defaultOptions, options)) || this;
      _this2.currentValue = (_a3 = Select2.defaultOptions.style) === null || _a3 === void 0 ? void 0 : _a3.defaultValue;
      _this2.isPointerInSelect = false;
      _this2.select = _this2.appendChild(new Rect$1({
        className: "select",
        style: {
          cursor: "pointer",
          width: 0,
          height: 0
        }
      }));
      _this2.dropdown = _this2.appendChild(new Rect$1({
        className: "dropdown"
      }));
      var defaultValue = _this2.style.defaultValue;
      if (defaultValue && ((_b = _this2.style.options) === null || _b === void 0 ? void 0 : _b.some(function(option) {
        return option.value === defaultValue;
      }))) {
        _this2.currentValue = defaultValue;
      }
      return _this2;
    }
    Select2.prototype.setValue = function(value) {
      this.currentValue = value;
      this.render();
    };
    Select2.prototype.getValue = function() {
      return this.currentValue;
    };
    Object.defineProperty(Select2.prototype, "dropdownPadding", {
      get: function() {
        return parseSeriesAttr(this.style.dropdownPadding);
      },
      enumerable: false,
      configurable: true
    });
    Select2.prototype.renderSelect = function() {
      var _this2 = this;
      var _a3;
      var _b = this.style, x2 = _b.x, y2 = _b.y, width2 = _b.width, height = _b.height, bordered = _b.bordered, showDropdownIcon = _b.showDropdownIcon;
      var selectStyle = subStyleProps(this.attributes, "select");
      var placeholderStyle = subStyleProps(this.attributes, "placeholder");
      this.select.attr(__assign(__assign({ x: x2, y: y2, width: width2, height }, selectStyle), { fill: "#fff", strokeWidth: bordered ? 1 : 0 }));
      var padding = this.dropdownPadding;
      var iconSize = 10;
      if (showDropdownIcon) {
        select(this.select).maybeAppend(".dropdown-icon", "path").style("d", "M-5,-3.5 L0,3.5 L5,-3.5").style("transform", "translate(".concat(x2 + width2 - iconSize - padding[1] - padding[3], ", ").concat(y2 + height / 2, ")")).style("lineWidth", 1).style("stroke", this.select.style.stroke);
      }
      var currentOption = (_a3 = this.style.options) === null || _a3 === void 0 ? void 0 : _a3.find(function(option) {
        return option.value === _this2.currentValue;
      });
      var finalPlaceholderStyle = __assign({ x: x2 + padding[3] }, placeholderStyle);
      select(this.select).selectAll(".placeholder").data(!currentOption ? [1] : []).join(function(enter) {
        return enter.append("text").attr("className", "placeholder").styles(finalPlaceholderStyle).style("y", function() {
          var bbox = this.getBBox();
          return y2 + (height - bbox.height) / 2;
        });
      }, function(update) {
        return update.styles(finalPlaceholderStyle);
      }, function(exit) {
        return exit.remove();
      });
      var labelStyle = subStyleProps(this.attributes, "optionLabel");
      var finalValueStyle = __assign({ x: x2 + padding[3] }, labelStyle);
      select(this.select).selectAll(".value").data(currentOption ? [currentOption] : []).join(function(enter) {
        return enter.append(function(datum) {
          return renderExtDo(datum.label);
        }).attr("className", "value").styles(finalValueStyle).style("y", function() {
          var bbox = this.getBBox();
          return y2 + (height - bbox.height) / 2;
        });
      }, function(update) {
        return update.styles(finalValueStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Select2.prototype.renderDropdown = function() {
      var _this2 = this;
      var _a3, _b;
      var _c = this.style, x2 = _c.x, y2 = _c.y, width2 = _c.width, height = _c.height, options = _c.options, onSelect = _c.onSelect, open = _c.open;
      var dropdownStyle = subStyleProps(this.attributes, "dropdown");
      var optionStyle = subStyleProps(this.attributes, "option");
      var padding = this.dropdownPadding;
      select(this.dropdown).maybeAppend(".dropdown-container", "g").attr("className", "dropdown-container").selectAll(".dropdown-item").data(options, function(datum) {
        return datum.value;
      }).join(function(enter) {
        return enter.append(function(datum) {
          return new Option({
            className: "dropdown-item",
            style: __assign(__assign(__assign({}, datum), optionStyle), { width: width2 - padding[1] - padding[3], selected: datum.value === _this2.currentValue, onClick: function(value, option, item) {
              _this2.setValue(value);
              onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, option, item);
              _this2.dispatchEvent(new CustomEvent("change", { detail: { value, option, item } }));
              hide(_this2.dropdown);
            } })
          });
        }).each(function(datum, i2) {
          var _a4;
          var nodes = (_a4 = this.parentNode) === null || _a4 === void 0 ? void 0 : _a4.children;
          var accHeight = nodes.reduce(function(acc, curr, index2) {
            if (index2 < i2) {
              acc += curr.getBBox().height;
            }
            return acc;
          }, 0);
          this.attr("transform", "translate(".concat(padding[3], ", ").concat(padding[0] + accHeight, ")"));
        });
      }, function(update) {
        return update.update(function(datum) {
          return { selected: datum.value === _this2.currentValue };
        });
      }, function(exit) {
        return exit.remove();
      });
      var bbox = (_b = (_a3 = this.dropdown.getElementsByClassName("dropdown-container")) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.getBBox();
      var spacing = dropdownStyle.spacing;
      this.dropdown.attr(__assign({ transform: "translate(".concat(x2, ", ").concat(y2 + height + spacing, ")"), width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, dropdownStyle));
      !open && hide(this.dropdown);
    };
    Select2.prototype.render = function() {
      this.renderSelect();
      this.renderDropdown();
    };
    Select2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("click", function(e3) {
        e3.stopPropagation();
      });
      this.select.addEventListener("click", function() {
        if (_this2.dropdown.style.visibility === "visible")
          hide(_this2.dropdown);
        else {
          show(_this2.dropdown);
        }
      });
      this.addEventListener("pointerenter", function() {
        _this2.isPointerInSelect = true;
      });
      this.addEventListener("pointerleave", function() {
        _this2.isPointerInSelect = false;
      });
      document === null || document === void 0 ? void 0 : document.addEventListener("click", function() {
        if (!_this2.isPointerInSelect) {
          hide(_this2.dropdown);
        }
      });
    };
    Select2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 140,
        height: 32,
        options: [],
        bordered: true,
        defaultValue: "",
        selectRadius: 8,
        selectStroke: "#d9d9d9",
        showDropdownIcon: true,
        placeholderText: "",
        placeholderFontSize: 12,
        placeholderTextBaseline: "top",
        placeholderFill: "#c2c2c2",
        dropdownFill: "#fff",
        dropdownStroke: "#d9d9d9",
        dropdownRadius: 8,
        dropdownShadowBlur: 4,
        dropdownShadowColor: "rgba(0, 0, 0, 0.08)",
        dropdownPadding: 8,
        dropdownSpacing: 10,
        optionPadding: [8, 12],
        optionFontSize: 12,
        optionTextBaseline: "top",
        optionBackgroundFill: "#fff",
        optionBackgroundRadius: 4,
        optionLabelFontSize: 12,
        optionLabelTextBaseline: "top"
      }
    };
    return Select2;
  }(Component)
);
var IconBase = (
  /** @class */
  function(_super) {
    __extends$1(IconBase2, _super);
    function IconBase2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { backgroundOpacity: IconBase2.backgroundOpacities.default } }, IconBase2.defaultOptions, options)) || this;
      _this2.showBackground = true;
      _this2.background = _this2.appendChild(new Rect$1({}));
      _this2.icon = _this2.appendChild(new Group({}));
      return _this2;
    }
    Object.defineProperty(IconBase2.prototype, "label", {
      get: function() {
        return "BaseIcon";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "lineWidth", {
      get: function() {
        return Math.log10(this.attributes.size);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.size / 5);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "iconSize", {
      get: function() {
        var size = this.attributes.size;
        var _a3 = __read(this.padding, 4), top = _a3[0], right = _a3[1], bottom = _a3[2], left = _a3[3];
        return Math.max(size - Math.max(left + right, top + bottom), this.lineWidth * 2 + 1);
      },
      enumerable: false,
      configurable: true
    });
    IconBase2.prototype.renderBackground = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, size = _a3.size;
      var halfSize = size / 2;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x2 - halfSize, y: y2 - halfSize, width: size, height: size }, backgroundStyle));
    };
    IconBase2.prototype.showIndicator = function() {
      if (!this.label)
        return;
      var size = this.attributes.size;
      var _a3 = this.background.getBBox(), x2 = _a3.x, y2 = _a3.y;
      this.indicator.update({ x: x2 + size / 2, y: y2 - 5, labelText: this.label, visibility: "visible" });
    };
    IconBase2.prototype.hideIndicator = function() {
      this.indicator.update({ visibility: "hidden" });
    };
    IconBase2.prototype.connectedCallback = function() {
      var _a3;
      _super.prototype.connectedCallback.call(this);
      var size = this.attributes.size;
      var _b = this.background.getBBox(), x2 = _b.x, y2 = _b.y;
      var canvas2 = (_a3 = this.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
      if (canvas2) {
        this.indicator = canvas2.appendChild(new Indicator({
          style: {
            x: x2 + size / 2,
            y: y2 - size / 2,
            visibility: "hidden",
            position: "top",
            radius: 3,
            zIndex: 100
          }
        }));
      }
    };
    IconBase2.prototype.disconnectedCallback = function() {
      this.indicator.destroy();
    };
    IconBase2.prototype.render = function() {
      this.renderIcon();
      if (this.showBackground)
        this.renderBackground();
    };
    IconBase2.prototype.bindEvents = function() {
      var _this2 = this;
      var onClick = this.attributes.onClick;
      this.addEventListener("click", function() {
        onClick === null || onClick === void 0 ? void 0 : onClick(_this2);
      });
      if (this.showBackground) {
        var resetBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.default });
        };
        var hoverBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.hover });
        };
        var activeBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.active });
        };
        this.addEventListener("pointerenter", function() {
          hoverBackground_1();
          _this2.showIndicator();
        });
        this.addEventListener("pointerleave", function() {
          resetBackground_1();
          _this2.hideIndicator();
        });
        this.addEventListener("pointerdown", function() {
          activeBackground_1();
        });
        this.addEventListener("pointerup", function() {
          resetBackground_1();
        });
      }
    };
    IconBase2.tag = "IconBase";
    IconBase2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        size: 10,
        color: "#565758",
        backgroundRadius: 4,
        backgroundFill: "#e2e2e2"
      }
    };
    IconBase2.backgroundOpacities = {
      default: 0,
      hover: 0.8,
      active: 1
    };
    return IconBase2;
  }(Component)
);
var arrow = function(size, color2) {
  if (color2 === void 0) {
    color2 = "#565758";
  }
  return new Path({
    style: {
      fill: color2,
      d: "M ".concat(size, ",").concat(size, " L -").concat(size, ",0 L ").concat(size, ",-").concat(size, " Z"),
      transformOrigin: "center"
    }
  });
};
var Reset = (
  /** @class */
  function(_super) {
    __extends$1(Reset2, _super);
    function Reset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Reset2.prototype.arcPath = function(cx, cy, radius) {
      var _a3 = __read([radius, radius], 2), rx = _a3[0], ry = _a3[1];
      var getPosByAngle = function(angle2) {
        return [cx + radius * Math.cos(angle2), cy + radius * Math.sin(angle2)];
      };
      var _b = __read(getPosByAngle(-5 / 4 * Math.PI), 2), x1 = _b[0], y1 = _b[1];
      var _c = __read(getPosByAngle(1 / 4 * Math.PI), 2), x2 = _c[0], y2 = _c[1];
      return "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,1,1,").concat(x2, ",").concat(y2);
    };
    Object.defineProperty(Reset2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Reset2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var size = this.iconSize;
      var lineWidth = this.lineWidth;
      var arrowSize = lineWidth + 0.5;
      select(this.icon).maybeAppend(".reset", "path").styles({
        stroke: color2,
        lineWidth,
        d: this.arcPath(x2, y2, size / 2 - lineWidth),
        markerStart: arrow(arrowSize, color2)
      });
    };
    return Reset2;
  }(IconBase)
);
var Backward = (
  /** @class */
  function(_super) {
    __extends$1(Backward2, _super);
    function Backward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Backward2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Backward2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var size = this.iconSize;
      var deltaX = size / 2;
      var deltaY = size / 2 / Math.pow(3, 0.5);
      var points = [
        [x2, y2],
        [x2, y2 - deltaY],
        [x2 - deltaX, y2],
        [x2, y2 + deltaY],
        [x2, y2],
        [x2 + deltaX, y2 - deltaY],
        [x2 + deltaX, y2 + deltaY],
        [x2, y2]
      ];
      select(this.icon).maybeAppend(".backward", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Backward2;
  }(IconBase)
);
var Forward = (
  /** @class */
  function(_super) {
    __extends$1(Forward2, _super);
    function Forward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Forward2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Forward2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var size = this.iconSize;
      var deltaX = size / 2;
      var deltaY = size / 2 / Math.pow(3, 0.5);
      var points = [
        [x2, y2],
        [x2, y2 - deltaY],
        [x2 + deltaX, y2],
        [x2, y2 + deltaY],
        [x2, y2],
        [x2 - deltaX, y2 - deltaY],
        [x2 - deltaX, y2 + deltaY],
        [x2, y2]
      ];
      select(this.icon).maybeAppend(".forward", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Forward2;
  }(IconBase)
);
var Play = (
  /** @class */
  function(_super) {
    __extends$1(Play2, _super);
    function Play2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Play2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Play2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var size = this.iconSize;
      var deltaX = size / 3 * Math.pow(3, 0.5) * 0.8;
      var points = [
        [x2 + deltaX, y2],
        [x2 - deltaX / 2, y2 - size / 2 * 0.8],
        [x2 - deltaX / 2, y2 + size / 2 * 0.8],
        [x2 + deltaX, y2]
      ];
      select(this.icon).maybeAppend(".play", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Play2;
  }(IconBase)
);
var Pause = (
  /** @class */
  function(_super) {
    __extends$1(Pause2, _super);
    function Pause2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Pause2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Pause2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var size = this.iconSize;
      var deltaX = size / 3;
      var points = [
        [x2 - deltaX, y2 - size / 2],
        [x2 - deltaX, y2 + size / 2],
        [x2 - deltaX / 2, y2 + size / 2],
        [x2 - deltaX / 2, y2 - size / 2],
        [x2 - deltaX, y2 - size / 2],
        [x2 + deltaX / 2, y2 - size / 2],
        [x2 + deltaX / 2, y2 + size / 2],
        [x2 + deltaX, y2 + size / 2],
        [x2 + deltaX, y2 - size / 2]
      ];
      select(this.icon).maybeAppend(".pause", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Pause2;
  }(IconBase)
);
var Range = (
  /** @class */
  function(_super) {
    __extends$1(Range2, _super);
    function Range2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Range2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Range2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var _b = this, size = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      select(this.icon).maybeAppend(".left-line", "line").styles({
        x1: x2 - size / 2,
        y1: y2 - size / 2,
        x2: x2 - size / 2,
        y2: y2 + size / 2,
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".right-line", "line").styles({
        x1: x2 + size / 2,
        y1: y2 - size / 2,
        x2: x2 + size / 2,
        y2: y2 + size / 2,
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x2,
        y1: y2,
        x2: x2 - size / 2 + gap * 2,
        y2,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
      select(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x2,
        y1: y2,
        x2: x2 + size / 2 - gap * 2,
        y2,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
    };
    return Range2;
  }(IconBase)
);
var Value = (
  /** @class */
  function(_super) {
    __extends$1(Value2, _super);
    function Value2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Value2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Value2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var _b = this, size = _b.iconSize, lineWidth = _b.lineWidth;
      select(this.icon).maybeAppend(".line", "line").styles({
        x1: x2,
        y1: y2 - size / 2,
        x2,
        y2: y2 + size / 2,
        stroke: color2,
        lineWidth
      });
      var gap = lineWidth;
      select(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x2 - size / 2 - gap * 2,
        y1: y2,
        x2: x2 - gap * 2,
        y2,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
      select(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x2 + size / 2 + gap * 2,
        y1: y2,
        x2: x2 + gap * 2,
        y2,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
    };
    return Value2;
  }(IconBase)
);
var getCoordinatePoints = function(size) {
  return [
    [-size / 2, -size / 2],
    [-size / 2, size / 2],
    [size / 2, size / 2]
  ];
};
var LineChart = (
  /** @class */
  function(_super) {
    __extends$1(LineChart2, _super);
    function LineChart2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LineChart2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    LineChart2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var _b = this, size = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size - gap * 2 - lineWidth) / 4;
      var deltaY = (size - gap * 2 - lineWidth) / 2;
      var _c = __read([x2 - size / 2 + gap, y2 + size / 2 - gap * 2], 2), ox = _c[0], oy = _c[1];
      select(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size).map(function(_a4) {
          var _b2 = __read(_a4, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x2, py + y2];
        }),
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".line", "polyline").styles({
        points: [
          [ox, oy],
          [ox + deltaX, oy - deltaY],
          [ox + deltaX * 2, oy],
          [ox + deltaX * 4, oy - deltaY * 2]
        ],
        stroke: color2,
        lineWidth
      });
    };
    return LineChart2;
  }(IconBase)
);
var BarChart = (
  /** @class */
  function(_super) {
    __extends$1(BarChart2, _super);
    function BarChart2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BarChart2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BarChart2.prototype, "data", {
      get: function() {
        return [1, 4, 2, 4, 3];
      },
      enumerable: false,
      configurable: true
    });
    BarChart2.prototype.renderIcon = function() {
      var data2 = this.data;
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var _b = this, size = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size - gap) / data2.length;
      var deltaY = (size - gap * 2) / 4;
      var _c = __read([x2 - size / 2 + gap * 2, y2 + size / 2 - gap], 2), ox = _c[0], oy = _c[1];
      select(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size).map(function(_a4) {
          var _b2 = __read(_a4, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x2, py + y2];
        }),
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".bars", "g").selectAll(".column").data(this.data.map(function(value, index2) {
        return { value, index: index2 };
      })).join(function(enter) {
        return enter.append("line").attr("className", "column").style("x1", function(_a4) {
          var index2 = _a4.index;
          return ox + deltaX * index2;
        }).style("y1", oy).style("x2", function(_a4) {
          var index2 = _a4.index;
          return ox + deltaX * index2;
        }).style("y2", function(_a4) {
          var value = _a4.value;
          return oy - deltaY * value;
        }).styles({
          y1: oy,
          stroke: color2,
          lineWidth
        });
      });
    };
    return BarChart2;
  }(IconBase)
);
var Split = (
  /** @class */
  function(_super) {
    __extends$1(Split2, _super);
    function Split2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { color: "#d8d9d9" } }, options)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Split2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, color2 = _a3.color;
      var _b = this, size = _b.iconSize, lineWidth = _b.lineWidth;
      select(this.icon).maybeAppend(".split", "line").styles({
        x1: x2,
        y1: y2 - size / 2,
        x2,
        y2: y2 + size / 2,
        stroke: color2,
        lineWidth
      });
    };
    return Split2;
  }(IconBase)
);
var SpeedSelect = (
  /** @class */
  function(_super) {
    __extends$1(SpeedSelect2, _super);
    function SpeedSelect2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Object.defineProperty(SpeedSelect2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(0);
      },
      enumerable: false,
      configurable: true
    });
    SpeedSelect2.prototype.renderIcon = function() {
      var iconSize = this.iconSize;
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, _b = _a3.speed, speed = _b === void 0 ? 1 : _b;
      var inheritStyle = omit$1(this.attributes, [
        "x",
        "y",
        "transform",
        "transformOrigin",
        "width",
        "height",
        "size",
        "color",
        "speed"
      ]);
      var width2 = clamp$1(iconSize, 20, Infinity);
      var height = 20;
      var style = __assign(__assign({}, inheritStyle), { x: x2 - width2 / 2, y: y2 - height / 2, width: width2, height, defaultValue: speed, bordered: false, showDropdownIcon: false, selectRadius: 2, dropdownPadding: this.padding, dropdownRadius: 2, dropdownSpacing: iconSize / 5, placeholderFontSize: iconSize / 2, optionPadding: 0, optionLabelFontSize: iconSize / 2, optionBackgroundRadius: 1, options: [
        { label: "1x", value: 1 },
        { label: "1.5x", value: 1.5 },
        { label: "2x", value: 2 }
      ] });
      select(this.icon).maybeAppend(".speed", function() {
        return new Select({ style });
      }).attr("className", "speed").each(function() {
        this.update(style);
      });
    };
    SpeedSelect2.tag = "SpeedSelect";
    return SpeedSelect2;
  }(IconBase)
);
var ToggleIcon = (
  /** @class */
  function(_super) {
    __extends$1(ToggleIcon2, _super);
    function ToggleIcon2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.icon = _this2.appendChild(new Group({}));
      _this2.currentType = _this2.attributes.type;
      return _this2;
    }
    ToggleIcon2.prototype.getType = function() {
      return this.currentType;
    };
    ToggleIcon2.prototype.render = function() {
      var _this2 = this;
      var _a3 = this.attributes;
      _a3.onChange;
      var restStyles = __rest$m(_a3, ["onChange"]);
      select(this.icon).selectAll(".icon").data([this.currentType]).join(function(enter) {
        return enter.append(function(type) {
          var _a4;
          var Ctor = (_a4 = _this2.toggles.find(function(_a5) {
            var _b = __read(_a5, 1), key = _b[0];
            return key === type;
          })) === null || _a4 === void 0 ? void 0 : _a4[1];
          if (!Ctor)
            throw new Error("Invalid type: ".concat(type));
          return new Ctor({});
        }).attr("className", "icon").styles(restStyles, false).update({});
      }, function(update) {
        return update.styles({ restStyles }).update({});
      }, function(exit) {
        return exit.remove();
      });
    };
    ToggleIcon2.prototype.bindEvents = function() {
      var _this2 = this;
      var onChange = this.attributes.onChange;
      this.addEventListener("click", function(e3) {
        e3.preventDefault();
        e3.stopPropagation();
        var nextIndex = (_this2.toggles.findIndex(function(_a3) {
          var _b = __read(_a3, 1), key = _b[0];
          return key === _this2.currentType;
        }) + 1) % _this2.toggles.length;
        var nextType = _this2.toggles[nextIndex][0];
        onChange === null || onChange === void 0 ? void 0 : onChange(_this2.currentType);
        _this2.currentType = nextType;
        _this2.render();
      });
    };
    ToggleIcon2.tag = "ToggleIcon";
    return ToggleIcon2;
  }(Component)
);
var PlayPause = (
  /** @class */
  function(_super) {
    __extends$1(PlayPause2, _super);
    function PlayPause2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { type: "play" } }, options)) || this;
      _this2.toggles = [
        ["play", Play],
        ["pause", Pause]
      ];
      return _this2;
    }
    return PlayPause2;
  }(ToggleIcon)
);
var SelectionType = (
  /** @class */
  function(_super) {
    __extends$1(SelectionType2, _super);
    function SelectionType2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { type: "range" } }, options)) || this;
      _this2.toggles = [
        ["range", Range],
        ["value", Value]
      ];
      return _this2;
    }
    return SelectionType2;
  }(ToggleIcon)
);
var ChartType = (
  /** @class */
  function(_super) {
    __extends$1(ChartType2, _super);
    function ChartType2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { type: "column" } }, options)) || this;
      _this2.toggles = [
        ["line", LineChart],
        ["column", BarChart]
      ];
      return _this2;
    }
    return ChartType2;
  }(ToggleIcon)
);
var componentsMap = {
  reset: Reset,
  speed: SpeedSelect,
  backward: Backward,
  playPause: PlayPause,
  forward: Forward,
  selectionType: SelectionType,
  chartType: ChartType,
  split: Split
};
var Controller = (
  /** @class */
  function(_super) {
    __extends$1(Controller2, _super);
    function Controller2(options) {
      var _this2 = _super.call(this, deepAssign({}, Controller2.defaultOptions, options)) || this;
      _this2.background = _this2.appendChild(new Rect$1({}));
      _this2.functions = _this2.appendChild(new Group({}));
      return _this2;
    }
    Object.defineProperty(Controller2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.padding);
      },
      enumerable: false,
      configurable: true
    });
    Controller2.prototype.renderBackground = function() {
      var _a3 = this.style, x2 = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x2, y: y2, width: width2, height }, backgroundStyle));
    };
    Controller2.prototype.renderFunctions = function() {
      var _this2 = this;
      var _a3;
      var _b = this.attributes, functions = _b.functions, iconSize = _b.iconSize, iconSpacing = _b.iconSpacing, x2 = _b.x, y2 = _b.y, width2 = _b.width, height = _b.height, align = _b.align;
      var _c = __read(this.padding, 4), right = _c[1], left = _c[3];
      var components = functions.reduce(function(prev, curr) {
        if (prev.length && curr.length) {
          return prev.concat.apply(prev, __spreadArray(["split"], __read(curr), false));
        }
        return prev.concat.apply(prev, __spreadArray([], __read(curr), false));
      }, []);
      var componentsWidth = components.length * (iconSize + iconSpacing) - iconSpacing;
      var xOffset = {
        left: left + iconSize / 2,
        center: (width2 - componentsWidth) / 2 + iconSize / 2,
        right: width2 - componentsWidth - left - right + iconSize / 2
      }[align] || 0;
      (_a3 = this.speedSelect) === null || _a3 === void 0 ? void 0 : _a3.destroy();
      this.functions.removeChildren();
      components.forEach(function(name, index2) {
        var _a4;
        var Ctor = componentsMap[name];
        var style = {
          x: x2 + index2 * (iconSize + iconSpacing) + xOffset,
          y: y2 + height / 2,
          size: iconSize
        };
        if (Ctor === SpeedSelect) {
          style.speed = _this2.attributes.speed;
          style.onSelect = function(value) {
            return _this2.handleFunctionChange(name, { value });
          };
        } else if ([PlayPause, SelectionType, ChartType].includes(Ctor)) {
          style.onChange = function(value) {
            return _this2.handleFunctionChange(name, { value });
          };
          if (Ctor === PlayPause)
            style.type = _this2.attributes.state === "play" ? "pause" : "play";
          if (Ctor === SelectionType)
            style.type = _this2.attributes.selectionType === "range" ? "value" : "range";
          if (Ctor === ChartType)
            style.type = _this2.attributes.chartType === "line" ? "column" : "line";
        } else {
          style.onClick = function() {
            return _this2.handleFunctionChange(name, { value: name });
          };
        }
        if (Ctor === SpeedSelect) {
          var canvas2 = (_a4 = _this2.ownerDocument) === null || _a4 === void 0 ? void 0 : _a4.defaultView;
          if (canvas2) {
            _this2.speedSelect = new Ctor({ style: __assign(__assign({}, style), { zIndex: 100 }) });
            canvas2.appendChild(_this2.speedSelect);
          }
        } else {
          _this2.functions.appendChild(new Ctor({ style }));
        }
      });
    };
    Controller2.prototype.disconnectedCallback = function() {
      var _a3;
      _super.prototype.disconnectedCallback.call(this);
      (_a3 = this.speedSelect) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    };
    Controller2.prototype.render = function() {
      this.renderBackground();
      this.renderFunctions();
    };
    Controller2.prototype.handleFunctionChange = function(name, value) {
      var onChange = this.attributes.onChange;
      onChange === null || onChange === void 0 ? void 0 : onChange(name, value);
    };
    Controller2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 300,
        height: 40,
        padding: 0,
        align: "center",
        iconSize: 25,
        iconSpacing: 0,
        speed: 1,
        state: "pause",
        chartType: "line",
        selectionType: "range",
        backgroundFill: "#fbfdff",
        backgroundStroke: "#ebedf0",
        functions: [
          ["reset", "speed"],
          ["backward", "playPause", "forward"],
          ["selectionType", "chartType"]
        ]
      }
    };
    return Controller2;
  }(Component)
);
var TimeModeHandle = (
  /** @class */
  function(_super) {
    __extends$1(TimeModeHandle2, _super);
    function TimeModeHandle2(options) {
      var _this2 = _super.call(this, deepAssign({}, TimeModeHandle2.defaultOptions, options)) || this;
      _this2.bindEvents();
      return _this2;
    }
    TimeModeHandle2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("mouseenter", function() {
        _this2.attr("lineWidth", Math.ceil(+(_this2.style.r || 0) / 2));
      });
      this.addEventListener("mouseleave", function() {
        _this2.attr("lineWidth", 0);
      });
    };
    TimeModeHandle2.defaultOptions = {
      style: {
        r: 5,
        fill: "#3f7cf7",
        lineWidth: 0,
        stroke: "#3f7cf7",
        strokeOpacity: 0.5,
        cursor: "pointer"
      }
    };
    return TimeModeHandle2;
  }(Circle$2)
);
var ChartModeHandle = (
  /** @class */
  function(_super) {
    __extends$1(ChartModeHandle2, _super);
    function ChartModeHandle2(options) {
      return _super.call(this, deepAssign({}, ChartModeHandle2.defaultOptions, options)) || this;
    }
    ChartModeHandle2.prototype.renderBackground = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height;
      var style = subStyleProps(this.attributes, "background");
      select(this).maybeAppend("background", "rect").attr("className", "background").styles(__assign({ x: x2 - width2 / 2, y: y2 - height / 2, width: width2, height }, style));
    };
    ChartModeHandle2.prototype.renderIcon = function() {
      var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, iconSize = _a3.iconSize;
      var style = subStyleProps(this.attributes, "icon");
      var diffX = 1;
      var diffY = iconSize / 2;
      select(this).maybeAppend("icon-left-line", "line").attr("className", "icon-left-line").styles(__assign({ x1: x2 - diffX, y1: y2 - diffY, x2: x2 - diffX, y2: y2 + diffY }, style));
      select(this).maybeAppend("icon-right-line", "line").attr("className", "icon-right-line").styles(__assign({ x1: x2 + diffX, y1: y2 - diffY, x2: x2 + diffX, y2: y2 + diffY }, style));
    };
    ChartModeHandle2.prototype.renderBorder = function() {
      var _a3 = this.attributes, xx = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height, type = _a3.type;
      var style = subStyleProps(this.attributes, "border");
      var x2 = type === "start" ? +width2 / 2 : -width2 / 2;
      select(this).maybeAppend("border", "line").attr("className", "border").styles(__assign({ x1: x2 + xx, y1: y2 - height / 2, x2: x2 + xx, y2: y2 + height / 2 }, style));
    };
    ChartModeHandle2.prototype.render = function() {
      this.renderBackground();
      this.renderIcon();
      this.renderBorder();
    };
    ChartModeHandle2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 10,
        height: 50,
        iconSize: 10,
        type: "start",
        backgroundFill: "#fff",
        backgroundFillOpacity: 0.5,
        iconStroke: "#9a9a9a",
        iconLineWidth: 1,
        borderStroke: "#e8e8e8",
        borderLineWidth: 1
      }
    };
    return ChartModeHandle2;
  }(Component)
);
function labelFormatter(time2, interval2) {
  if (typeof time2 === "number") {
    return parseBySeries(time2);
  }
  return parseByTime(time2, interval2);
}
function parseByTime(time2, interval2) {
  var date = new Date(time2);
  switch (interval2) {
    case "half-hour":
    case "hour":
    case "four-hour":
      if ([0, 6, 12, 18].includes(date.getHours()) && date.getMinutes() === 0) {
        return formatTime(date, "HH:mm\nYYYY-MM-DD");
      }
      return formatTime(date, "HH:mm");
    case "half-day":
      if (date.getHours() < 12) {
        return "AM\n".concat(formatTime(date, "YYYY-MM-DD"));
      }
      return "PM";
    case "day":
      if ([1, 10, 20].includes(date.getDate())) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "week":
      if (date.getDate() <= 7) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "month":
      if ([0, 6].includes(date.getMonth())) {
        return formatTime(date, "MM\nYYYY");
      }
      return formatTime(date, "MM");
    case "season":
      if ([0].includes(date.getMonth())) {
        return formatTime(date, "MM\nYYYY");
      }
      return formatTime(date, "MM");
    case "year":
      return formatTime(date, "YYYY");
    default:
      return formatTime(date, "YYYY-MM-DD HH:mm");
  }
}
function parseBySeries(time2) {
  var hours = String(Math.floor(time2 / 3600)).padStart(2, "0");
  var minutes = String(Math.floor(time2 % 3600 / 60)).padStart(2, "0");
  var seconds = String(Math.floor(time2 % 60)).padStart(2, "0");
  if (time2 < 3600) {
    return "".concat(minutes, ":").concat(seconds);
  }
  return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
}
var Timebar$1 = (
  /** @class */
  function(_super) {
    __extends$1(Timebar2, _super);
    function Timebar2(options) {
      var _this2 = _super.call(this, deepAssign({}, Timebar2.defaultOptions, options)) || this;
      _this2.axis = _this2.appendChild(new Axis({
        style: { type: "linear", startPos: [0, 0], endPos: [0, 0], data: [], showArrow: false, animate: false }
      }));
      _this2.timeline = _this2.appendChild(new Slider({
        style: {
          onChange: function(values3) {
            _this2.handleSliderChange(values3);
          }
        }
      }));
      _this2.controller = _this2.appendChild(new Controller({}));
      _this2.states = {};
      _this2.handleSliderChange = function(values3) {
        var prevValues = function() {
          var val = _this2.states.values;
          if (Array.isArray(val))
            return __spreadArray([], __read(val), false);
          return val;
        }();
        _this2.setBySliderValues(values3);
        _this2.dispatchOnChange(prevValues);
      };
      var _a3 = _this2.attributes, selectionType = _a3.selectionType, chartType = _a3.chartType, speed = _a3.speed, state = _a3.state, playMode = _a3.playMode, values2 = _a3.values;
      _this2.states = { chartType, playMode, selectionType, speed, state };
      _this2.setByTimebarValues(values2);
      return _this2;
    }
    Object.defineProperty(Timebar2.prototype, "data", {
      get: function() {
        var data2 = this.attributes.data;
        var compareFn = function(a2, b2) {
          if (a2.time < b2.time)
            return -1;
          if (a2.time > b2.time)
            return 1;
          return 0;
        };
        return data2.sort(compareFn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "space", {
      /**  */
      get: function() {
        var _a3 = this.attributes, x2 = _a3.x, y2 = _a3.y, width2 = _a3.width, height = _a3.height, type = _a3.type, controllerHeight = _a3.controllerHeight;
        var availableTimelineHeight = clamp$1(+height - controllerHeight, 0, +height);
        var controllerBBox = new BBox(x2, y2 + +height - controllerHeight, +width2, controllerHeight);
        var axisBBox;
        var axisHeight = 0;
        if (type === "chart") {
          axisHeight = 35;
          axisBBox = new BBox(x2, y2 + availableTimelineHeight - axisHeight, +width2, axisHeight);
        } else
          axisBBox = new BBox();
        var timelineHeight = type === "time" ? 10 : availableTimelineHeight;
        var timelineBBox = new BBox(x2, y2 + (type === "time" ? availableTimelineHeight : availableTimelineHeight - timelineHeight), +width2, timelineHeight - axisHeight);
        return { axisBBox, controllerBBox, timelineBBox };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.setBySliderValues = function(val) {
      var _a3, _b;
      var data2 = this.data;
      var _c = __read(Array.isArray(val) ? val : [0, val], 2), startRatio = _c[0], endRatio = _c[1];
      var length2 = data2.length;
      var startDatum = data2[Math.floor(startRatio * length2)];
      var endDatum = data2[Math.ceil(endRatio * length2) - (Array.isArray(val) ? 0 : 1)];
      this.states.values = [(_a3 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a3 !== void 0 ? _a3 : data2[0].time, (_b = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _b !== void 0 ? _b : Infinity];
    };
    Timebar2.prototype.setByTimebarValues = function(val) {
      var _a3, _b, _c;
      var data2 = this.data;
      var _d = __read(Array.isArray(val) ? val : [void 0, val], 2), start = _d[0], end = _d[1];
      var startDatum = data2.find(function(_a4) {
        var time2 = _a4.time;
        return time2 === start;
      });
      var endDatum = data2.find(function(_a4) {
        var time2 = _a4.time;
        return time2 === end;
      });
      this.states.values = [(_a3 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a3 !== void 0 ? _a3 : (_b = data2[0]) === null || _b === void 0 ? void 0 : _b.time, (_c = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _c !== void 0 ? _c : Infinity];
    };
    Timebar2.prototype.setByIndex = function(index2) {
      var _a3, _b, _c, _d;
      var data2 = this.data;
      var _e = __read(index2, 2), startIndex = _e[0], endIndex = _e[1];
      this.states.values = [(_b = (_a3 = data2[startIndex]) === null || _a3 === void 0 ? void 0 : _a3.time) !== null && _b !== void 0 ? _b : data2[0].time, (_d = (_c = this.data[endIndex]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : Infinity];
    };
    Object.defineProperty(Timebar2.prototype, "sliderValues", {
      /**
       *  timebar  values
       */
      get: function() {
        var _a3 = this.states, values2 = _a3.values, selectionType = _a3.selectionType;
        var _b = __read(Array.isArray(values2) ? values2 : [void 0, values2], 2), start = _b[0], end = _b[1];
        var data2 = this.data;
        var length2 = data2.length;
        var isValue = selectionType === "value";
        var getStartValue = function() {
          var startDatumIndex = data2.findIndex(function(_a4) {
            var time2 = _a4.time;
            return time2 === start;
          });
          if (isValue)
            return 0;
          if (startDatumIndex > -1)
            return startDatumIndex / length2;
          return 0;
        };
        var getEndValue = function() {
          if (end === Infinity)
            return 1;
          var endDatumIndex = data2.findIndex(function(_a4) {
            var time2 = _a4.time;
            return time2 === end;
          });
          if (endDatumIndex > -1)
            return endDatumIndex / length2;
          if (isValue)
            return 0.5;
          return 1;
        };
        return [getStartValue(), getEndValue()];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "values", {
      get: function() {
        var _a3 = this.states, values2 = _a3.values, selectionType = _a3.selectionType;
        var _b = __read(Array.isArray(values2) ? values2 : [this.data[0].time, values2], 2), start = _b[0], end = _b[1];
        if (selectionType === "value")
          return end;
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getDatumByRatio = function(ratio) {
      var data2 = this.data;
      var length2 = data2.length;
      var index2 = Math.floor(ratio * (length2 - 1));
      return data2[index2];
    };
    Object.defineProperty(Timebar2.prototype, "chartHandleIconShape", {
      get: function() {
        var selectionType = this.states.selectionType;
        var height = this.space.timelineBBox.height;
        if (selectionType === "range")
          return function(type) {
            return new ChartModeHandle({ style: { type, height, iconSize: height / 6 } });
          };
        return function() {
          return new Line$2({ style: { x1: 0, y1: -height / 2, x2: 0, y2: height / 2, lineWidth: 2, stroke: "#c8c8c8" } });
        };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getChartStyle = function(bbox) {
      var _this2 = this;
      var x2 = bbox.x, y2 = bbox.y, width2 = bbox.width, height = bbox.height;
      var _a3 = this.states, selectionType = _a3.selectionType, chartType = _a3.chartType;
      var data2 = this.data;
      var _b = this.attributes, type = _b.type, userDefinedLabelFormatter = _b.labelFormatter;
      var _c = subStyleProps(this.attributes, "chart");
      _c.type;
      var userDefinedChartStyle = __rest$m(_c, ["type"]);
      var isRange = selectionType === "range";
      if (type === "time") {
        return __assign({
          handleIconShape: function() {
            return new TimeModeHandle({});
          },
          selectionFill: "#2e7ff8",
          selectionFillOpacity: 1,
          showLabelOnInteraction: true,
          handleLabelDy: isRange ? -15 : 0,
          autoFitLabel: isRange,
          handleSpacing: isRange ? -15 : 0,
          trackFill: "#edeeef",
          trackLength: width2,
          trackOpacity: 0.5,
          trackRadius: height / 2,
          trackSize: height / 2,
          type: selectionType,
          values: this.sliderValues,
          formatter: function(value) {
            if (userDefinedLabelFormatter)
              return userDefinedLabelFormatter(value);
            var time2 = _this2.getDatumByRatio(value).time;
            if (typeof time2 === "number")
              return parseBySeries(time2);
            return formatTime(time2, "YYYY-MM-DD HH:mm:ss");
          },
          transform: "translate(".concat(x2, ", ").concat(y2, ")"),
          // x,
          // y,
          zIndex: 1
        }, userDefinedChartStyle);
      }
      var handleIconOffset = selectionType === "range" ? 5 : 0;
      var sparklineData = data2.map(function(_a4) {
        var value = _a4.value;
        return value;
      });
      return __assign({
        handleIconOffset,
        handleIconShape: this.chartHandleIconShape,
        selectionFill: "#fff",
        selectionFillOpacity: 0.5,
        selectionType: "invert",
        sparklineSpacing: 0.1,
        sparklineColumnLineWidth: 0,
        sparklineColor: "#d4e5fd",
        sparklineAreaOpacity: 1,
        sparklineAreaLineWidth: 0,
        sparklineData,
        sparklineType: chartType,
        sparklineScale: 0.8,
        trackLength: width2,
        trackSize: height,
        type: selectionType,
        values: this.sliderValues,
        // x,
        // y,
        transform: "translate(".concat(x2, ", ").concat(y2, ")"),
        zIndex: 1
      }, userDefinedChartStyle);
    };
    Timebar2.prototype.renderChart = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.timelineBBox;
      }
      this.timeline.update(this.getChartStyle(bbox));
    };
    Timebar2.prototype.updateSelection = function() {
      this.timeline.setValues(this.sliderValues, true);
      this.handleSliderChange(this.sliderValues);
    };
    Timebar2.prototype.getAxisStyle = function(bbox) {
      var data2 = this.data;
      var _a3 = this.attributes, interval2 = _a3.interval, userDefinedLabelFormatter = _a3.labelFormatter;
      var userDefinedAxisStyle = subStyleProps(this.attributes, "axis");
      var x2 = bbox.x, y2 = bbox.y, width2 = bbox.width;
      var axisData = __spreadArray(__spreadArray([], __read(data2), false), [{ time: 0 }], false).map(function(_a4, index2, arr) {
        var time2 = _a4.time;
        return {
          label: "".concat(time2),
          value: index2 / (arr.length - 1),
          time: time2
        };
      });
      var style = __assign({
        startPos: [x2, y2],
        endPos: [x2 + width2, y2],
        data: axisData,
        // hide last label
        labelFilter: function(_datum, index2) {
          return index2 < axisData.length - 1;
        },
        labelFormatter: function(_a4) {
          var time2 = _a4.time;
          return userDefinedLabelFormatter ? userDefinedLabelFormatter(time2) : labelFormatter(time2, interval2);
        }
      }, userDefinedAxisStyle);
      return style;
    };
    Timebar2.prototype.renderAxis = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.axisBBox;
      }
      var type = this.attributes.type;
      if (type !== "chart")
        return;
      this.axis.update(this.getAxisStyle(bbox));
    };
    Timebar2.prototype.renderController = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.controllerBBox;
      }
      var type = this.attributes.type;
      var _a3 = this.states, state = _a3.state, speed = _a3.speed, selectionType = _a3.selectionType, chartType = _a3.chartType;
      var userDefinedControllerStyle = subStyleProps(this.attributes, "controller");
      var that = this;
      var style = __assign(__assign(__assign({}, bbox), { iconSize: 20, speed, state, selectionType, chartType, onChange: function(type2, _a4) {
        var value = _a4.value;
        switch (type2) {
          case "reset":
            that.internalReset();
            break;
          case "speed":
            that.handleSpeedChange(value);
            break;
          case "backward":
            that.internalBackward();
            break;
          case "playPause":
            if (value === "play")
              that.internalPlay();
            else
              that.internalPause();
            break;
          case "forward":
            that.internalForward();
            break;
          case "selectionType":
            that.handleSelectionTypeChange(value);
            break;
          case "chartType":
            that.handleChartTypeChange(value);
            break;
        }
      } }), userDefinedControllerStyle);
      if (type === "time") {
        style.functions = [["reset", "speed"], ["backward", "playPause", "forward"], ["selectionType"]];
      }
      this.controller.update(style);
    };
    Timebar2.prototype.dispatchOnChange = function(prevValues) {
      var data2 = this.data;
      var onChange = this.attributes.onChange;
      var _a3 = this.states, values2 = _a3.values, selectionType = _a3.selectionType;
      var _b = __read(values2, 2), start = _b[0], end = _b[1];
      var endTime = end === Infinity ? data2.at(-1).time : end;
      var newValues = selectionType === "range" ? [start, endTime] : endTime;
      var isEqual2 = function(val1, val2) {
        if (Array.isArray(val1)) {
          if (!Array.isArray(val2))
            return false;
          if (val1[0] === val2[0]) {
            if (val1[1] === val2[1])
              return true;
            if (val1[1] === Infinity || val2[1] === Infinity)
              return true;
          }
          return false;
        }
        if (Array.isArray(val2))
          return false;
        return val1 === val2;
      };
      if (!prevValues || !isEqual2(prevValues, newValues)) {
        onChange === null || onChange === void 0 ? void 0 : onChange(selectionType === "range" ? [start, endTime] : endTime);
      }
    };
    Timebar2.prototype.internalReset = function(preventEvent) {
      var _a3, _b;
      var selectionType = this.states.selectionType;
      this.internalPause();
      this.setBySliderValues(selectionType === "range" ? [0, 1] : [0, 0]);
      this.renderController();
      this.updateSelection();
      if (!preventEvent) {
        (_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onReset) === null || _b === void 0 ? void 0 : _b.call(_a3);
        this.dispatchOnChange();
      }
    };
    Timebar2.prototype.reset = function() {
      this.internalReset();
    };
    Timebar2.prototype.moveSelection = function(direction2, preventEvent) {
      var data2 = this.data;
      var length2 = data2.length;
      var _a3 = this.states, values2 = _a3.values, selectionType = _a3.selectionType, playMode = _a3.playMode;
      var _b = __read(values2, 2), startTime = _b[0], endTime = _b[1];
      var startIndex = data2.findIndex(function(_a4) {
        var time2 = _a4.time;
        return time2 === startTime;
      });
      var endIndex = data2.findIndex(function(_a4) {
        var time2 = _a4.time;
        return time2 === endTime;
      });
      if (endIndex === -1)
        endIndex = length2;
      var diff = direction2 === "backward" ? -1 : 1;
      var currentIndexes;
      if (selectionType === "range") {
        if (playMode === "acc") {
          currentIndexes = [startIndex, endIndex + diff];
          if (diff === -1 && startIndex === endIndex) {
            currentIndexes = [startIndex, length2];
          }
        } else
          currentIndexes = [startIndex + diff, endIndex + diff];
      } else
        currentIndexes = [startIndex, endIndex + diff];
      var normalizeIndexes = function(indexes) {
        var _a4 = __read(indexes.sort(function(a2, b2) {
          return a2 - b2;
        }), 2), start = _a4[0], end = _a4[1];
        var clampIndex = function(index2) {
          return clamp$1(index2, 0, length2);
        };
        if (end > length2) {
          if (selectionType === "value")
            return [0, 0];
          if (playMode === "acc")
            return [clampIndex(start), clampIndex(start)];
          return [0, clampIndex(end - start)];
        }
        if (start < 0) {
          if (playMode === "acc")
            return [0, clampIndex(end)];
          return [clampIndex(start + length2 - end), length2];
        }
        return [clampIndex(start), clampIndex(end)];
      };
      var normalizedIndexes = normalizeIndexes(currentIndexes);
      this.setByIndex(normalizedIndexes);
      this.updateSelection();
      return normalizedIndexes;
    };
    Timebar2.prototype.internalBackward = function(preventEvent) {
      var _a3, _b;
      var indexes = this.moveSelection("backward", preventEvent);
      if (!preventEvent) {
        (_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onBackward) === null || _b === void 0 ? void 0 : _b.call(_a3);
        this.dispatchOnChange();
      }
      return indexes;
    };
    Timebar2.prototype.backward = function() {
      this.internalBackward();
    };
    Timebar2.prototype.internalPlay = function(preventEvent) {
      var _this2 = this;
      var _a3, _b;
      var data2 = this.data;
      var loop = this.attributes.loop;
      var _c = this.states.speed, speed = _c === void 0 ? 1 : _c;
      this.playInterval = window.setInterval(function() {
        var indexes = _this2.internalForward();
        if (indexes[1] === data2.length && !loop) {
          _this2.internalPause();
          _this2.renderController();
        }
      }, 1e3 / speed);
      this.states.state = "play";
      !preventEvent && ((_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onPlay) === null || _b === void 0 ? void 0 : _b.call(_a3));
    };
    Timebar2.prototype.play = function() {
      this.internalPlay();
    };
    Timebar2.prototype.internalPause = function(preventEvent) {
      var _a3, _b;
      clearInterval(this.playInterval);
      this.states.state = "pause";
      !preventEvent && ((_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onPause) === null || _b === void 0 ? void 0 : _b.call(_a3));
    };
    Timebar2.prototype.pause = function() {
      this.internalPause();
    };
    Timebar2.prototype.internalForward = function(preventEvent) {
      var _a3, _b;
      var indexes = this.moveSelection("forward", preventEvent);
      if (!preventEvent) {
        (_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onForward) === null || _b === void 0 ? void 0 : _b.call(_a3);
        this.dispatchOnChange();
      }
      return indexes;
    };
    Timebar2.prototype.forward = function() {
      this.internalForward();
    };
    Timebar2.prototype.handleSpeedChange = function(value) {
      var _a3, _b;
      this.states.speed = value;
      var state = this.states.state;
      if (state === "play") {
        this.internalPause(true);
        this.internalPlay(true);
      }
      (_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onSpeedChange) === null || _b === void 0 ? void 0 : _b.call(_a3, value);
    };
    Timebar2.prototype.handleSelectionTypeChange = function(type) {
      var _a3, _b;
      this.states.selectionType = type;
      this.renderChart();
      (_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onSelectionTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a3, type);
    };
    Timebar2.prototype.handleChartTypeChange = function(type) {
      var _a3, _b;
      this.states.chartType = type;
      this.renderChart();
      (_b = (_a3 = this.attributes) === null || _a3 === void 0 ? void 0 : _a3.onChartTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a3, type);
    };
    Timebar2.prototype.render = function() {
      var _a3 = this.space, axisBBox = _a3.axisBBox, controllerBBox = _a3.controllerBBox, timelineBBox = _a3.timelineBBox;
      this.renderController(controllerBBox);
      this.renderAxis(axisBBox);
      this.renderChart(timelineBBox);
      if (this.states.state === "play")
        this.internalPlay();
    };
    Timebar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.internalPause(true);
    };
    Timebar2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        axisLabelFill: "#6e6e6e",
        axisLabelTextAlign: "left",
        axisLabelTextBaseline: "top",
        axisLabelTransform: "translate(5, -12)",
        axisLineLineWidth: 1,
        axisLineStroke: "#cacdd1",
        axisTickLength: 15,
        axisTickLineWidth: 1,
        axisTickStroke: "#cacdd1",
        chartShowLabel: false,
        chartType: "line",
        controllerAlign: "center",
        controllerHeight: 40,
        data: [],
        interval: "day",
        loop: false,
        playMode: "acc",
        selectionType: "range",
        type: "time"
      }
    };
    return Timebar2;
  }(Component)
);
function createPluginCanvas(options) {
  const { width: width2, height, renderer } = options;
  const $container = getContainer(options);
  const canvas2 = new Canvas$1({
    width: width2,
    height,
    container: $container,
    renderer: renderer || new Renderer()
  });
  return [$container, canvas2];
}
function getContainer(options) {
  var _a3;
  const { container, className, graphCanvas } = options;
  if (container) {
    return typeof container === "string" ? document.getElementById(container) : container;
  }
  const $container = createPluginContainer(className, false);
  const { width: width2, height, containerStyle } = options;
  const [x2, y2] = computePosition(options);
  Object.assign($container.style, Object.assign({ position: "absolute", left: x2 + "px", top: y2 + "px", width: width2 + "px", height: height + "px" }, containerStyle));
  (_a3 = graphCanvas.getContainer()) === null || _a3 === void 0 ? void 0 : _a3.appendChild($container);
  return $container;
}
function computePosition(options) {
  const { width: width2, height, placement, graphCanvas } = options;
  const [W2, H4] = graphCanvas.getSize();
  const [xRatio, yRatio] = parsePlacement(placement);
  return [xRatio * (W2 - width2), yRatio * (H4 - height)];
}
var __rest$6 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class Legend extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Legend.defaultOptions, options));
    this.typePrefix = "__data__";
    this.draw = false;
    this.fieldMap = {
      node: /* @__PURE__ */ new Map(),
      edge: /* @__PURE__ */ new Map(),
      combo: /* @__PURE__ */ new Map()
    };
    this.selectedItems = [];
    this.bindEvents = () => {
      const { graph: graph2 } = this.context;
      graph2.on(GraphEvent.AFTER_DRAW, this.createElement);
    };
    this.changeState = (el, state) => {
      const { graph: graph2 } = this.context;
      const { typePrefix } = this;
      const composeId = get$1(el, [typePrefix, "id"]);
      const category = get$1(el, [typePrefix, "style", "labelText"]);
      const [type] = composeId.split("__");
      const ids = this.fieldMap[type].get(category) || [];
      graph2.setElementState(Object.fromEntries(ids === null || ids === void 0 ? void 0 : ids.map((id2) => [id2, state])));
    };
    this.click = (event) => {
      if (this.options.trigger === "hover")
        return;
      const composeId = get$1(event, [this.typePrefix, "id"]);
      if (!this.selectedItems.includes(composeId)) {
        this.selectedItems.push(composeId);
        this.changeState(event, "selected");
      } else {
        this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
        this.changeState(event, []);
      }
    };
    this.mouseleave = (event) => {
      if (this.options.trigger === "click")
        return;
      this.selectedItems = [];
      this.changeState(event, []);
    };
    this.mouseenter = (event) => {
      if (this.options.trigger === "click")
        return;
      const composeId = get$1(event, [this.typePrefix, "id"]);
      if (!this.selectedItems.includes(composeId)) {
        this.selectedItems.push(composeId);
        this.changeState(event, "active");
      } else {
        this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
      }
    };
    this.setFieldMap = (field, id2, type) => {
      if (!field)
        return;
      const map2 = this.fieldMap[type];
      if (!map2)
        return;
      if (!map2.has(field)) {
        map2.set(field, [id2]);
      } else {
        const ids = map2.get(field);
        if (ids) {
          ids.push(id2);
          map2.set(field, ids);
        }
      }
    };
    this.getEvents = () => {
      return {
        mouseenter: this.mouseenter,
        mouseleave: this.mouseleave,
        click: this.click
      };
    };
    this.getMarkerData = (field, elementType) => {
      if (!field)
        return [];
      const { model, element } = this.context;
      const { nodes, edges, combos } = model.getData();
      const items = {};
      const getField = (item) => {
        if (isFunction$1(field))
          return field(item);
        return field;
      };
      const defaultType = {
        node: "circle",
        edge: "line",
        combo: "rect"
      };
      const markerMapping = {
        circle: "circle",
        ellipse: "circle",
        //  components  ellipse
        image: "bowtie",
        rect: "square",
        star: "cross",
        triangle: "triangle",
        diamond: "diamond",
        cubic: "dot",
        line: "hyphen",
        polyline: "hyphen",
        quadratic: "hv",
        "cubic-horizontal": "hyphen",
        "cubic-vertical": "line"
      };
      const getElementStyle = (type, datum) => {
        const style = element === null || element === void 0 ? void 0 : element.getElementComputedStyle(type, datum);
        return style;
      };
      const getElementModel = (data2, type) => {
        data2.forEach((item) => {
          const { id: id2 } = item;
          const value = get$1(item, ["data", getField(item)]);
          const marker = (element === null || element === void 0 ? void 0 : element.getElementType(type, item)) || "circle";
          const style = getElementStyle(type, item);
          const color2 = (type === "edge" ? style === null || style === void 0 ? void 0 : style.stroke : style === null || style === void 0 ? void 0 : style.fill) || "#1783ff";
          if (id2 && value && value.replace(/\s+/g, "")) {
            this.setFieldMap(value, id2, type);
            if (!items[value]) {
              items[value] = {
                id: `${type}__${id2}`,
                label: value,
                marker: markerMapping[marker] || defaultType[type],
                elementType: type,
                lineWidth: 1,
                stroke: color2,
                fill: color2
              };
            }
          }
        });
      };
      switch (elementType) {
        case "node":
          getElementModel(nodes, "node");
          break;
        case "edge":
          getElementModel(edges, "edge");
          break;
        case "combo":
          getElementModel(combos, "combo");
          break;
        default:
          return [];
      }
      return Object.values(items);
    };
    this.createElement = () => {
      if (this.draw) {
        this.updateElement();
        return;
      }
      const _a3 = this.options, { width: width2, height, nodeField, edgeField, comboField, trigger, position: position2, container, containerStyle, className } = _a3, rest = __rest$6(_a3, ["width", "height", "nodeField", "edgeField", "comboField", "trigger", "position", "container", "containerStyle", "className"]);
      const nodeItems = this.getMarkerData(nodeField, "node");
      const edgeItems = this.getMarkerData(edgeField, "edge");
      const comboItems = this.getMarkerData(comboField, "combo");
      const items = [...nodeItems, ...comboItems, ...edgeItems];
      const categoryStyle = Object.assign({
        width: width2,
        height,
        data: items,
        itemMarkerLineWidth: ({ lineWidth }) => lineWidth,
        itemMarker: ({ marker }) => marker,
        itemMarkerStroke: ({ stroke }) => stroke,
        itemMarkerFill: ({ fill }) => fill,
        gridCol: nodeItems.length
      }, rest, this.getEvents());
      const category = new Category({
        className: "legend",
        style: categoryStyle
      });
      this.category = category;
      const canvas2 = this.upsertCanvas();
      canvas2.appendChild(category);
      this.draw = true;
    };
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update the legend configuration
   * @param options - <zh/>  | <en/> Legend options
   * @internal
   */
  update(options) {
    super.update(options);
    this.clear();
    this.createElement();
  }
  clear() {
    var _a3, _b;
    (_a3 = this.canvas) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    (_b = this.container) === null || _b === void 0 ? void 0 : _b.remove();
    this.canvas = void 0;
    this.container = void 0;
    this.draw = false;
  }
  /**
   * <zh/> 
   *
   * <en/> Refresh the status of the legend element
   */
  updateElement() {
    if (!this.category)
      return;
    this.category.update({
      itemMarkerOpacity: ({ id: id2 }) => {
        if (!this.selectedItems.length || this.selectedItems.includes(id2))
          return 1;
        return 0.5;
      },
      itemLabelOpacity: ({ id: id2 }) => {
        if (!this.selectedItems.length || this.selectedItems.includes(id2))
          return 1;
        return 0.5;
      }
    });
  }
  upsertCanvas() {
    if (this.canvas)
      return this.canvas;
    const graphCanvas = this.context.canvas;
    const [canvasWidth, canvasHeight] = graphCanvas.getSize();
    const { width: width2 = canvasWidth, height = canvasHeight, position: position2, container, containerStyle, className } = this.options;
    const [$container, canvas2] = createPluginCanvas({
      width: width2,
      height,
      graphCanvas,
      container,
      containerStyle,
      placement: position2,
      className: "legend"
    });
    this.container = $container;
    if (className)
      $container.classList.add(className);
    this.canvas = canvas2;
    return this.canvas;
  }
  /**
   * <zh/>
   *
   * <en/> Destroy the legend
   * @internal
   */
  destroy() {
    this.clear();
    this.context.graph.off(GraphEvent.AFTER_DRAW, this.createElement);
    super.destroy();
  }
}
Legend.defaultOptions = {
  position: "bottom",
  trigger: "hover",
  orientation: "horizontal",
  layout: "flex",
  itemSpacing: 4,
  rowPadding: 10,
  colPadding: 10,
  itemMarkerSize: 16,
  itemLabelFontSize: 16,
  width: 240,
  height: 160
};
class Minimap extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Minimap.defaultOptions, options));
    this.onDraw = (event) => {
      var _a3;
      if ((_a3 = event === null || event === void 0 ? void 0 : event.data) === null || _a3 === void 0 ? void 0 : _a3.render)
        return;
      this.onRender();
    };
    this.landmarkMap = /* @__PURE__ */ new Map();
    this.mask = null;
    this.isMaskDragging = false;
    this.onMaskDragStart = (event) => {
      if (!this.mask)
        return;
      this.isMaskDragging = true;
      this.mask.setPointerCapture(event.pointerId);
      this.mask.addEventListener("pointermove", this.onMaskDrag);
      this.mask.addEventListener("pointerup", this.onMaskDragEnd);
      this.mask.addEventListener("pointercancel", this.onMaskDragEnd);
    };
    this.onMaskDrag = (event) => {
      if (!this.mask || !this.isMaskDragging)
        return;
      const { size: [minimapWidth, minimapHeight] } = this.options;
      const { movementX, movementY } = event;
      const { left, top, width: w2, height: h2 } = this.mask.style;
      const [, , fullWidth, fullHeight] = this.maskBBox;
      let x2 = parseInt(left) + movementX;
      let y2 = parseInt(top) + movementY;
      let width2 = parseInt(w2);
      let height = parseInt(h2);
      if (x2 < 0)
        x2 = 0;
      if (y2 < 0)
        y2 = 0;
      if (x2 + width2 > minimapWidth)
        x2 = lower(minimapWidth - width2, 0);
      if (y2 + height > minimapHeight)
        y2 = lower(minimapHeight - height, 0);
      if (width2 < fullWidth) {
        if (movementX > 0) {
          x2 = lower(x2 - movementX, 0);
          width2 = upper(width2 + movementX, minimapWidth);
        } else if (movementX < 0)
          width2 = upper(width2 - movementX, minimapWidth);
      }
      if (height < fullHeight) {
        if (movementY > 0) {
          y2 = lower(y2 - movementY, 0);
          height = upper(height + movementY, minimapHeight);
        } else if (movementY < 0)
          height = upper(height - movementY, minimapHeight);
      }
      Object.assign(this.mask.style, {
        left: x2 + "px",
        top: y2 + "px",
        width: width2 + "px",
        height: height + "px"
      });
      const deltaX = parseInt(left) - x2;
      const deltaY = parseInt(top) - y2;
      if (deltaX === 0 && deltaY === 0)
        return;
      const zoom1 = this.context.canvas.getCamera().getZoom();
      const zoom2 = this.canvas.getCamera().getZoom();
      const ratio = zoom1 / zoom2;
      this.context.graph.translateBy([deltaX * ratio, deltaY * ratio], false);
    };
    this.onMaskDragEnd = (event) => {
      if (!this.mask)
        return;
      this.isMaskDragging = false;
      this.mask.releasePointerCapture(event.pointerId);
      this.mask.removeEventListener("pointermove", this.onMaskDrag);
      this.mask.removeEventListener("pointerup", this.onMaskDragEnd);
      this.mask.removeEventListener("pointercancel", this.onMaskDragEnd);
    };
    this.onTransform = throttle(() => {
      if (this.isMaskDragging)
        return;
      this.updateMask();
      this.setCamera();
    }, 32, { leading: true });
    this.setOnRender();
    this.bindEvents();
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    if ("delay" in options)
      this.setOnRender();
    this.bindEvents();
  }
  setOnRender() {
    this.onRender = debounce(() => {
      this.renderMinimap();
      this.renderMask();
    }, this.options.delay);
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.AFTER_DRAW, this.onDraw);
    graph2.on(GraphEvent.AFTER_RENDER, this.onRender);
    graph2.on(GraphEvent.AFTER_ANIMATE, this.onRender);
    graph2.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.AFTER_DRAW, this.onDraw);
    graph2.off(GraphEvent.AFTER_RENDER, this.onRender);
    graph2.off(GraphEvent.AFTER_ANIMATE, this.onRender);
    graph2.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  /**
   * <zh/> 
   *
   * <en/> Create or update the minimap
   */
  renderMinimap() {
    const data2 = this.getElements();
    const canvas2 = this.initCanvas();
    this.setShapes(canvas2, data2);
  }
  getElements() {
    const { filter: filter2 } = this.options;
    const { model, element } = this.context;
    const originData = model.getData();
    const data2 = {
      nodes: originData.nodes.filter((node) => element === null || element === void 0 ? void 0 : element.getElement(idOf(node))),
      edges: originData.edges.filter((edge) => {
        const edgeElement = element === null || element === void 0 ? void 0 : element.getElement(idOf(edge));
        return edgeElement && isVisible(edgeElement);
      }),
      combos: originData.combos.filter((combo) => element === null || element === void 0 ? void 0 : element.getElement(idOf(combo)))
    };
    if (!filter2)
      return data2;
    const { nodes, edges, combos } = data2;
    return {
      nodes: nodes.filter((node) => filter2(idOf(node), "node")),
      edges: edges.filter((edge) => filter2(idOf(edge), "edge")),
      combos: combos.filter((combo) => filter2(idOf(combo), "combo"))
    };
  }
  setShapes(canvas2, data2) {
    const { nodes, edges, combos } = data2;
    const { shape } = this.options;
    const { element } = this.context;
    const iterate = (datum, elType) => {
      const id2 = idOf(datum);
      const target = element === null || element === void 0 ? void 0 : element.getElement(id2);
      if (!target)
        return;
      const keyShape = target.getShape("key");
      let cloneShape;
      if (typeof shape === "string") {
        const shapeName = shape;
        const miniShape = target.getShape(shapeName);
        cloneShape = miniShape.cloneNode();
      } else {
        const miniShape = shape(id2, elType, target);
        if (miniShape === target) {
          cloneShape = miniShape.cloneNode(true);
        } else {
          cloneShape = miniShape;
        }
      }
      cloneShape.setPosition(keyShape.getPosition());
      if (target.style.zIndex)
        cloneShape.style.zIndex = target.style.zIndex;
      cloneShape.id = target.id;
      canvas2.appendChild(cloneShape);
    };
    canvas2.removeChildren();
    edges.forEach((datum) => iterate(datum, "edge"));
    combos.forEach((datum) => iterate(datum, "combo"));
    nodes.forEach((datum) => iterate(datum, "node"));
  }
  initCanvas() {
    const { renderer, size: [width2, height] } = this.options;
    if (this.canvas) {
      const { width: w2, height: h2 } = this.canvas.getConfig();
      if (width2 !== w2 || height !== h2)
        this.canvas.resize(width2, height);
      if (renderer)
        this.canvas.setRenderer(renderer);
    } else {
      const { className, position: position2, container, containerStyle } = this.options;
      const [$container, canvas2] = createPluginCanvas({
        renderer,
        width: width2,
        height,
        placement: position2,
        className: "minimap",
        container,
        containerStyle,
        graphCanvas: this.context.canvas
      });
      if (className)
        $container.classList.add(className);
      this.container = $container;
      this.canvas = canvas2;
    }
    this.setCamera();
    return this.canvas;
  }
  createLandmark(position2, focalPoint, zoom) {
    const key = `${position2.join(",")}-${focalPoint.join(",")}-${zoom}`;
    if (this.landmarkMap.has(key))
      return this.landmarkMap.get(key);
    const camera = this.canvas.getCamera();
    const landmark = camera.createLandmark(key, {
      position: position2,
      focalPoint,
      zoom
    });
    this.landmarkMap.set(key, landmark);
    return landmark;
  }
  setCamera() {
    var _a3;
    const { canvas: canvas2 } = this.context;
    const camera = (_a3 = this.canvas) === null || _a3 === void 0 ? void 0 : _a3.getCamera();
    if (!camera)
      return;
    const { size: [minimapWidth, minimapHeight], padding } = this.options;
    const [top, right, bottom, left] = parsePadding(padding);
    const { min: boundsMin, max: boundsMax, center } = canvas2.getBounds("elements");
    const boundsWidth = boundsMax[0] - boundsMin[0];
    const boundsHeight = boundsMax[1] - boundsMin[1];
    const availableWidth = minimapWidth - left - right;
    const availableHeight = minimapHeight - top - bottom;
    const scaleX2 = availableWidth / boundsWidth;
    const scaleY2 = availableHeight / boundsHeight;
    const scale3 = Math.min(scaleX2, scaleY2);
    const landmark = this.createLandmark(center, center, scale3);
    camera.gotoLandmark(landmark, 0);
  }
  get maskBBox() {
    const { canvas: graphCanvas } = this.context;
    const canvasSize = graphCanvas.getSize();
    const canvasMin = graphCanvas.getCanvasByViewport([0, 0]);
    const canvasMax = graphCanvas.getCanvasByViewport(canvasSize);
    const maskMin = this.canvas.canvas2Viewport(toPointObject(canvasMin));
    const maskMax = this.canvas.canvas2Viewport(toPointObject(canvasMax));
    const width2 = maskMax.x - maskMin.x;
    const height = maskMax.y - maskMin.y;
    return [maskMin.x, maskMin.y, width2, height];
  }
  /**
   * <zh/> 
   *
   * <en/> Calculate the bounding box of the mask
   * @returns <zh/>  | <en/> Mask bounding box
   */
  calculateMaskBBox() {
    const { size: [minimapWidth, minimapHeight] } = this.options;
    let [x2, y2, width2, height] = this.maskBBox;
    if (x2 < 0) {
      width2 = upper(width2 + x2, minimapWidth);
      x2 = 0;
    }
    if (y2 < 0) {
      height = upper(height + y2, minimapHeight);
      y2 = 0;
    }
    if (x2 + width2 > minimapWidth)
      width2 = lower(minimapWidth - x2, 0);
    if (y2 + height > minimapHeight)
      height = lower(minimapHeight - y2, 0);
    return [upper(x2, minimapWidth), upper(y2, minimapHeight), lower(width2, 0), lower(height, 0)];
  }
  /**
   * <zh/> 
   *
   * <en/> Create or update the mask
   */
  renderMask() {
    const { maskStyle } = this.options;
    if (!this.mask) {
      this.mask = document.createElement("div");
      this.mask.addEventListener("pointerdown", this.onMaskDragStart);
      this.mask.draggable = true;
      this.mask.addEventListener("dragstart", (event) => event.preventDefault && event.preventDefault());
    }
    this.container.appendChild(this.mask);
    Object.assign(this.mask.style, Object.assign(Object.assign({}, maskStyle), { cursor: "move", position: "absolute", pointerEvents: "auto" }));
    this.updateMask();
  }
  updateMask() {
    if (!this.mask)
      return;
    const [x2, y2, width2, height] = this.calculateMaskBBox();
    Object.assign(this.mask.style, {
      top: y2 + "px",
      left: x2 + "px",
      width: width2 + "px",
      height: height + "px"
    });
  }
  destroy() {
    var _a3, _b, _c;
    this.unbindEvents();
    (_a3 = this.canvas) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    (_b = this.mask) === null || _b === void 0 ? void 0 : _b.remove();
    (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();
    super.destroy();
  }
}
Minimap.defaultOptions = {
  size: [240, 160],
  shape: "key",
  padding: 10,
  position: "right-bottom",
  maskStyle: {
    border: "1px solid #ddd",
    background: "rgba(0, 0, 0, 0.1)"
  },
  containerStyle: {
    border: "1px solid #ddd",
    background: "#fff"
  },
  delay: 128
};
const upper = (value, max2) => Math.min(value, max2);
const lower = (value, min2) => Math.max(value, min2);
var __awaiter$a = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const defaultLineStyle = { x1: 0, y1: 0, x2: 0, y2: 0, visibility: "hidden" };
class Snapline extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Snapline.defaultOptions, options));
    this.initSnapline = () => {
      const canvas2 = this.context.canvas.getLayer("transient");
      if (!this.horizontalLine) {
        this.horizontalLine = canvas2.appendChild(new Line$2({ style: Object.assign(Object.assign({}, defaultLineStyle), this.options.horizontalLineStyle) }));
      }
      if (!this.verticalLine) {
        this.verticalLine = canvas2.appendChild(new Line$2({ style: Object.assign(Object.assign({}, defaultLineStyle), this.options.verticalLineStyle) }));
      }
    };
    this.isHorizontalSticking = false;
    this.isVerticalSticking = false;
    this.enableStick = true;
    this.autoSnapToLine = (nodeId, bbox, metadata) => __awaiter$a(this, void 0, void 0, function* () {
      const { verticalX, horizontalY } = metadata;
      const { tolerance: tolerance2 } = this.options;
      const { min: [nodeMinX, nodeMinY], max: [nodeMaxX, nodeMaxY], center: [nodeCenterX, nodeCenterY] } = bbox;
      let dx = 0;
      let dy = 0;
      if (verticalX !== null) {
        if (distance(nodeMaxX, verticalX) < tolerance2)
          dx = verticalX - nodeMaxX;
        if (distance(nodeMinX, verticalX) < tolerance2)
          dx = verticalX - nodeMinX;
        if (distance(nodeCenterX, verticalX) < tolerance2)
          dx = verticalX - nodeCenterX;
        if (dx !== 0)
          this.isVerticalSticking = true;
      }
      if (horizontalY !== null) {
        if (distance(nodeMaxY, horizontalY) < tolerance2)
          dy = horizontalY - nodeMaxY;
        if (distance(nodeMinY, horizontalY) < tolerance2)
          dy = horizontalY - nodeMinY;
        if (distance(nodeCenterY, horizontalY) < tolerance2)
          dy = horizontalY - nodeCenterY;
        if (dy !== 0)
          this.isHorizontalSticking = true;
      }
      if (dx !== 0 || dy !== 0) {
        yield this.context.graph.translateElementBy({ [nodeId]: [dx, dy] }, false);
      }
    });
    this.enableSnap = (event) => {
      const { target } = event;
      const threshold = 0.5;
      if (this.isHorizontalSticking || this.isVerticalSticking) {
        const [dx, dy] = this.getDelta(event);
        if (this.isHorizontalSticking && this.isVerticalSticking && Math.abs(dx) <= threshold && Math.abs(dy) <= threshold) {
          this.context.graph.translateElementBy({ [target.id]: [-dx, -dy] }, false);
          return false;
        } else if (this.isHorizontalSticking && Math.abs(dy) <= threshold) {
          this.context.graph.translateElementBy({ [target.id]: [0, -dy] }, false);
          return false;
        } else if (this.isVerticalSticking && Math.abs(dx) <= threshold) {
          this.context.graph.translateElementBy({ [target.id]: [-dx, 0] }, false);
          return false;
        } else {
          this.isHorizontalSticking = false;
          this.isVerticalSticking = false;
          this.enableStick = false;
          setTimeout(() => {
            this.enableStick = true;
          }, 200);
        }
      }
      return this.enableStick;
    };
    this.calcSnaplineMetadata = (target, nodeBBox) => {
      const { tolerance: tolerance2, shape } = this.options;
      const { min: [nodeMinX, nodeMinY], max: [nodeMaxX, nodeMaxY], center: [nodeCenterX, nodeCenterY] } = nodeBBox;
      let verticalX = null;
      let verticalMinY = null;
      let verticalMaxY = null;
      let horizontalY = null;
      let horizontalMinX = null;
      let horizontalMaxX = null;
      this.getNodes().some((snapNode) => {
        if (isEqual$1(target.id, snapNode.id))
          return false;
        const snapBBox = getShape(snapNode, shape).getRenderBounds();
        const { min: [snapMinX, snapMinY], max: [snapMaxX, snapMaxY], center: [snapCenterX, snapCenterY] } = snapBBox;
        if (verticalX === null) {
          if (distance(snapCenterX, nodeCenterX) < tolerance2) {
            verticalX = snapCenterX;
          } else if (distance(snapMinX, nodeMinX) < tolerance2) {
            verticalX = snapMinX;
          } else if (distance(snapMinX, nodeMaxX) < tolerance2) {
            verticalX = snapMinX;
          } else if (distance(snapMaxX, nodeMaxX) < tolerance2) {
            verticalX = snapMaxX;
          } else if (distance(snapMaxX, nodeMinX) < tolerance2) {
            verticalX = snapMaxX;
          }
          if (verticalX !== null) {
            verticalMinY = Math.min(snapMinY, nodeMinY);
            verticalMaxY = Math.max(snapMaxY, nodeMaxY);
          }
        }
        if (horizontalY === null) {
          if (distance(snapCenterY, nodeCenterY) < tolerance2) {
            horizontalY = snapCenterY;
          } else if (distance(snapMinY, nodeMinY) < tolerance2) {
            horizontalY = snapMinY;
          } else if (distance(snapMinY, nodeMaxY) < tolerance2) {
            horizontalY = snapMinY;
          } else if (distance(snapMaxY, nodeMaxY) < tolerance2) {
            horizontalY = snapMaxY;
          } else if (distance(snapMaxY, nodeMinY) < tolerance2) {
            horizontalY = snapMaxY;
          }
          if (horizontalY !== null) {
            horizontalMinX = Math.min(snapMinX, nodeMinX);
            horizontalMaxX = Math.max(snapMaxX, nodeMaxX);
          }
        }
        return verticalX !== null && horizontalY !== null;
      });
      return { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX };
    };
    this.onDragStart = () => {
      this.initSnapline();
    };
    this.onDrag = (event) => __awaiter$a(this, void 0, void 0, function* () {
      const { target } = event;
      if (this.options.autoSnap) {
        const enable = this.enableSnap(event);
        if (!enable)
          return;
      }
      const nodeBBox = getShape(target, this.options.shape).getRenderBounds();
      const metadata = this.calcSnaplineMetadata(target, nodeBBox);
      this.hideSnapline();
      if (metadata.verticalX !== null || metadata.horizontalY !== null) {
        this.updateSnapline(metadata);
      }
      if (this.options.autoSnap) {
        yield this.autoSnapToLine(target.id, nodeBBox, metadata);
      }
    });
    this.onDragEnd = () => {
      this.hideSnapline();
    };
    this.bindEvents();
  }
  getNodes() {
    var _a3;
    const { filter: filter2 } = this.options;
    const allNodes = ((_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getNodes()) || [];
    const nodes = allNodes.filter((node) => {
      var _a4;
      return isVisible(node) && ((_a4 = this.context.viewport) === null || _a4 === void 0 ? void 0 : _a4.isInViewport(node.getRenderBounds()));
    });
    if (!filter2)
      return nodes;
    return nodes.filter((node) => filter2(node));
  }
  hideSnapline() {
    this.horizontalLine.style.visibility = "hidden";
    this.verticalLine.style.visibility = "hidden";
  }
  getLineWidth(direction2) {
    const { lineWidth } = this.options[`${direction2}LineStyle`];
    return +(lineWidth || defaultLineStyle.lineWidth || 1) / this.context.graph.getZoom();
  }
  updateSnapline(metadata) {
    const { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX } = metadata;
    const [canvasWidth, canvasHeight] = this.context.canvas.getSize();
    const { offset } = this.options;
    if (horizontalY !== null) {
      Object.assign(this.horizontalLine.style, {
        x1: offset === Infinity ? 0 : horizontalMinX - offset,
        y1: horizontalY,
        x2: offset === Infinity ? canvasWidth : horizontalMaxX + offset,
        y2: horizontalY,
        visibility: "visible",
        lineWidth: this.getLineWidth("horizontal")
      });
    } else {
      this.horizontalLine.style.visibility = "hidden";
    }
    if (verticalX !== null) {
      Object.assign(this.verticalLine.style, {
        x1: verticalX,
        y1: offset === Infinity ? 0 : verticalMinY - offset,
        x2: verticalX,
        y2: offset === Infinity ? canvasHeight : verticalMaxY + offset,
        visibility: "visible",
        lineWidth: this.getLineWidth("vertical")
      });
    } else {
      this.verticalLine.style.visibility = "hidden";
    }
  }
  /**
   * Get the delta of the drag
   * @param event - drag event object
   * @returns delta
   * @internal
   */
  getDelta(event) {
    const zoom = this.context.graph.getZoom();
    return divide([event.dx, event.dy], zoom);
  }
  bindEvents() {
    return __awaiter$a(this, void 0, void 0, function* () {
      const { graph: graph2 } = this.context;
      graph2.on(NodeEvent.DRAG_START, this.onDragStart);
      graph2.on(NodeEvent.DRAG, this.onDrag);
      graph2.on(NodeEvent.DRAG_END, this.onDragEnd);
    });
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(NodeEvent.DRAG_START, this.onDragStart);
    graph2.off(NodeEvent.DRAG, this.onDrag);
    graph2.off(NodeEvent.DRAG_END, this.onDragEnd);
  }
  destroyElements() {
    var _a3, _b;
    (_a3 = this.horizontalLine) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    (_b = this.verticalLine) === null || _b === void 0 ? void 0 : _b.destroy();
  }
  destroy() {
    this.destroyElements();
    this.unbindEvents();
    super.destroy();
  }
}
Snapline.defaultOptions = {
  tolerance: 5,
  offset: 20,
  autoSnap: true,
  shape: "key",
  verticalLineStyle: { stroke: "#1783FF" },
  horizontalLineStyle: { stroke: "#1783FF" },
  filter: () => true
};
const distance = (a2, b2) => Math.abs(a2 - b2);
const getShape = (node, shapeFilter) => {
  return typeof shapeFilter === "function" ? shapeFilter(node) : node.getShape(shapeFilter);
};
var __awaiter$9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$5 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
const prospectiveTimeKeys = ["timestamp", "time", "date", "datetime"];
class Timebar extends BasePlugin {
  get padding() {
    return parsePadding(this.options.padding);
  }
  constructor(context, options) {
    super(context, Object.assign({}, Timebar.defaultOptions, options));
    this.backup();
    this.upsertTimebar();
  }
  /**
   * <zh/> 
   *
   * <en/> Play
   */
  play() {
    var _a3;
    (_a3 = this.timebar) === null || _a3 === void 0 ? void 0 : _a3.play();
  }
  /**
   * <zh/> 
   *
   * <en/> Pause
   */
  pause() {
    var _a3;
    (_a3 = this.timebar) === null || _a3 === void 0 ? void 0 : _a3.pause();
  }
  /**
   * <zh/> 
   *
   * <en/> Forward
   */
  forward() {
    var _a3;
    (_a3 = this.timebar) === null || _a3 === void 0 ? void 0 : _a3.forward();
  }
  /**
   * <zh/> 
   *
   * <en/> Backward
   */
  backward() {
    var _a3;
    (_a3 = this.timebar) === null || _a3 === void 0 ? void 0 : _a3.backward();
  }
  /**
   * <zh/> 
   *
   * <en/> Reset
   */
  reset() {
    var _a3;
    (_a3 = this.timebar) === null || _a3 === void 0 ? void 0 : _a3.reset();
  }
  /**
   * <zh/> 
   *
   * <en/> Update timebar configuration options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    super.update(options);
    this.backup();
    this.upsertTimebar();
  }
  /**
   * <zh/> 
   *
   * <en/> Backup data
   */
  backup() {
    this.originalData = shallowCopy(this.context.graph.getData());
  }
  upsertTimebar() {
    const { canvas: canvas2 } = this.context;
    const _a3 = this.options, { onChange, timebarType, data: data2, x: x2, y: y2, width: width2, height, mode } = _a3, restOptions = __rest$5(_a3, ["onChange", "timebarType", "data", "x", "y", "width", "height", "mode"]);
    const canvasSize = canvas2.getSize();
    const [top] = this.padding;
    this.upsertCanvas().ready.then(() => {
      var _a4;
      const style = Object.assign(Object.assign({ x: canvasSize[0] / 2 - width2 / 2, y: top, onChange: (value) => {
        const range = (isArray$2(value) ? value : [value, value]).map((time2) => isDate(time2) ? time2.getTime() : time2);
        if (this.options.mode === "modify")
          this.filterElements(range);
        else
          this.hiddenElements(range);
        onChange === null || onChange === void 0 ? void 0 : onChange(range);
      } }, restOptions), {
        data: data2.map((datum) => isNumber(datum) ? { time: datum, value: 0 } : datum),
        width: width2,
        height,
        type: timebarType
      });
      if (!this.timebar) {
        this.timebar = new Timebar$1({ style });
        (_a4 = this.canvas) === null || _a4 === void 0 ? void 0 : _a4.appendChild(this.timebar);
      } else {
        this.timebar.update(style);
      }
    });
  }
  upsertCanvas() {
    if (this.canvas)
      return this.canvas;
    const { className, height, position: position2 } = this.options;
    const graphCanvas = this.context.canvas;
    const [width2] = graphCanvas.getSize();
    const [top, , bottom] = this.padding;
    const [$container, canvas2] = createPluginCanvas({
      width: width2,
      height: height + top + bottom,
      graphCanvas,
      className: "timebar",
      placement: position2
    });
    this.container = $container;
    if (className)
      $container.classList.add(className);
    this.canvas = canvas2;
    return this.canvas;
  }
  filterElements(range) {
    return __awaiter$9(this, void 0, void 0, function* () {
      var _a3;
      if (!this.originalData)
        return;
      const { elementTypes, getTime } = this.options;
      const { graph: graph2, element } = this.context;
      const newData = shallowCopy(this.originalData);
      elementTypes.forEach((type) => {
        const key = `${type}s`;
        newData[key] = (this.originalData[key] || []).filter((datum) => {
          const time2 = getTime(datum);
          if (match(time2, range))
            return true;
          return false;
        });
      });
      const nodeLikeIds = [...newData.nodes, ...newData.combos].map((datum) => idOf(datum));
      newData.edges = newData.edges.filter((edge) => {
        const source = edge.source;
        const target = edge.target;
        return nodeLikeIds.includes(source) && nodeLikeIds.includes(target);
      });
      graph2.setData(newData);
      yield (_a3 = element.draw({ animation: false, silence: true })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  hiddenElements(range) {
    const { graph: graph2 } = this.context;
    const { elementTypes, getTime } = this.options;
    const hideElementId = [];
    const showElementId = [];
    elementTypes.forEach((elementType) => {
      var _a3;
      const key = `${elementType}s`;
      const elementData = ((_a3 = this.originalData) === null || _a3 === void 0 ? void 0 : _a3[key]) || [];
      elementData.forEach((elementDatum) => {
        const id2 = idOf(elementDatum);
        const time2 = getTime(elementDatum);
        if (match(time2, range))
          showElementId.push(id2);
        else
          hideElementId.push(id2);
      });
    });
    graph2.hideElement(hideElementId, false);
    graph2.showElement(showElementId, false);
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the timebar
   * @internal
   */
  destroy() {
    var _a3, _b, _c;
    const { graph: graph2 } = this.context;
    this.originalData && graph2.setData(Object.assign({}, this.originalData));
    (_a3 = this.timebar) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    (_b = this.canvas) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();
    this.originalData = void 0;
    this.container = void 0;
    this.timebar = void 0;
    this.canvas = void 0;
    super.destroy();
  }
}
Timebar.defaultOptions = {
  position: "bottom",
  enable: true,
  timebarType: "time",
  className: "g6-timebar",
  width: 450,
  height: 60,
  zIndex: 3,
  elementTypes: ["node"],
  padding: 10,
  mode: "modify",
  getTime: (datum) => inferTime(datum, prospectiveTimeKeys, void 0),
  loop: false
};
const shallowCopy = (data2) => {
  const { nodes = [], edges = [], combos = [] } = data2;
  return {
    nodes: [...nodes],
    edges: [...edges],
    combos: [...combos]
  };
};
const match = (time2, range) => {
  if (isNumber(range))
    return time2 === range;
  const [start, end] = range;
  return time2 >= start && time2 <= end;
};
const inferTime = (datum, optionsKeys, defaultValue) => {
  var _a3;
  for (let i2 = 0; i2 < optionsKeys.length; i2++) {
    const key = optionsKeys[i2];
    const val = (_a3 = datum.data) === null || _a3 === void 0 ? void 0 : _a3[key];
    if (val)
      return val;
  }
  return defaultValue;
};
var __rest$4 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
const commonStyle = {
  fill: "#1D2129",
  wordWrap: true,
  // 
  maxLines: 1,
  // 
  textOverflow: "ellipsis",
  // 
  textBaseline: "top",
  /**
   * textAlign  x 
   * : :  width = 600
   * - textAlign: 'start' | 'left
   *     x = 0
   * - textAlign: 'end' | 'right'
   *     x = 600 ()
   * - textAlign: 'center'
   *     x = 300 ( / 2)
   */
  textAlign: "start",
  x: 0
};
const defaultTitleStyle = Object.assign(Object.assign({}, commonStyle), { fillOpacity: 0.9, fontSize: 16, fontWeight: "bold" });
const defaultSubTitleStyle = Object.assign(Object.assign({}, commonStyle), { fillOpacity: 0.65, fontSize: 12, fontWeight: "normal" });
const defaultOptions = {
  align: "left",
  spacing: 8,
  size: 44,
  padding: [16, 24, 0, 24]
};
const titleKey = "title";
const subtitleKey = "subtitle";
class Title extends BasePlugin {
  get padding() {
    return parsePadding(this.options.padding);
  }
  constructor(context, options) {
    const combineOption = Object.assign({}, defaultOptions, options);
    super(context, combineOption);
    this.onRender = () => {
      const canvas2 = this.updateCanvas();
      this.renderTitle(canvas2);
    };
    this.bindEvents();
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    graph2.on(GraphEvent.AFTER_RENDER, this.onRender);
    graph2.on(GraphEvent.AFTER_ANIMATE, this.onRender);
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    graph2.off(GraphEvent.AFTER_RENDER, this.onRender);
    graph2.off(GraphEvent.AFTER_ANIMATE, this.onRender);
  }
  destroy() {
    var _a3, _b;
    this.unbindEvents();
    (_a3 = this.canvas) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    (_b = this.container) === null || _b === void 0 ? void 0 : _b.remove();
    super.destroy();
  }
  updateCanvas() {
    const { size, className, align } = this.options;
    const [width2] = this.context.canvas.getSize();
    const [pt = 0, , pb = 0] = this.padding;
    const height = size + pt + pb;
    if (this.canvas) {
      const { width: w2, height: h2 } = this.canvas.getConfig();
      if (width2 !== w2 || height !== h2)
        this.canvas.resize(width2, height);
    } else {
      const positions = {
        left: "left-top",
        center: "top",
        right: "right-top"
      };
      const [$container, canvas2] = createPluginCanvas({
        width: width2,
        height,
        placement: positions[align] || positions.left,
        className: "title-canvas",
        graphCanvas: this.context.canvas
      });
      if (className)
        $container.classList.add(className);
      this.container = $container;
      this.canvas = canvas2;
    }
    return this.canvas;
  }
  renderTitle(canvas2) {
    const titles = new TitleComponent({
      options: this.options,
      ctx: this.context
    });
    canvas2.removeChildren();
    titles.getTitle().forEach((label) => {
      if (label)
        canvas2.appendChild(label);
    });
  }
}
class TitleComponent {
  get padding() {
    return parsePadding(this.options.padding);
  }
  constructor(props) {
    const { options, ctx: ctx2 } = props;
    this.options = options;
    this.context = ctx2;
  }
  getTitle() {
    const _a3 = this.options, _b = titleKey, propsTitle = _a3[_b], _c = subtitleKey, propsSubtitle = _a3[_c], { spacing = 44, padding, align } = _a3, style = __rest$4(_a3, [_b + "", _c + "", "spacing", "padding", "align"]);
    const titleText = propsTitle;
    const subTitleText = propsSubtitle;
    const titleStyle = subStyleProps$1(style, titleKey);
    const subtitleStyle = subStyleProps$1(style, subtitleKey);
    const [topGraphWidth] = this.context.graph.getSize();
    const [pt = 0, pr = 0, , pl = 0] = this.padding;
    const canvasWidth = topGraphWidth;
    const textWidth = canvasWidth - pl - pr;
    let subTitle = null;
    let alignX = pl;
    let textAlign2 = "left";
    switch (align) {
      case "left":
        alignX = pl;
        textAlign2 = "left";
        break;
      case "center":
        alignX = canvasWidth / 2;
        textAlign2 = "center";
        break;
      case "right":
        alignX = canvasWidth - pr;
        textAlign2 = "right";
        break;
      default:
        alignX = pl;
        textAlign2 = "left";
    }
    const title = new Label({
      className: titleKey,
      style: Object.assign(Object.assign(Object.assign(Object.assign({}, defaultTitleStyle), { wordWrapWidth: textWidth - 5, x: alignX, y: pt, textAlign: textAlign2 }), titleStyle), { text: titleText })
    });
    const titleBBox = title.getBBox();
    if (subTitleText) {
      subTitle = new Label({
        className: "subTitle",
        style: Object.assign(Object.assign(Object.assign(Object.assign({}, defaultSubTitleStyle), { wordWrapWidth: textWidth - 5, x: alignX, y: titleBBox.height + spacing + pt, textAlign: textAlign2 }), subtitleStyle), { text: subTitleText })
      });
    }
    return [title, subTitle];
  }
}
function parsePositionToStyle(position2) {
  const style = {
    top: "unset",
    right: "unset",
    bottom: "unset",
    left: "unset"
  };
  const directions2 = position2.split("-");
  directions2.forEach((d3) => {
    style[d3] = "8px";
  });
  style.flexDirection = position2.startsWith("top") || position2.startsWith("bottom") ? "row" : "column";
  return style;
}
const TOOLBAR_CSS = `
  .g6-toolbar {
    position: absolute;
    z-index: 100;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.1);
    opacity: 0.65;
  }
  .g6-toolbar .g6-toolbar-item {
    display: inline-block;
    width: 16px;
    height: 16px;
    padding: 4px;
    cursor: pointer;
    box-sizing: content-box;
  }

  .g6-toolbar .g6-toolbar-item:hover {
    background-color: #f0f0f0;
  }

  .g6-toolbar .g6-toolbar-item svg {
    display: inline-block;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
`;
const BUILD_IN_SVG_ICON = `
  <svg>
    <symbol id="zoom-in" viewBox="64 64 896 896">
      <path d="M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"></path>
    </symbol>
    <symbol id="zoom-out" viewBox="64 64 896 896">
      <path d="M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"></path>
    </symbol>
    <symbol id="edit" viewBox="64 64 896 896">
      <path d="M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"></path>
    </symbol>
    <symbol id="delete" viewBox="64 64 896 896">
      <path d="M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"></path>
    </symbol>
    <symbol id="redo" viewBox="64 64 896 896">
      <path d="M758.2 839.1C851.8 765.9 912 651.9 912 523.9 912 303 733.5 124.3 512.6 124 291.4 123.7 112 302.8 112 523.9c0 125.2 57.5 236.9 147.6 310.2 3.5 2.8 8.6 2.2 11.4-1.3l39.4-50.5c2.7-3.4 2.1-8.3-1.2-11.1-8.1-6.6-15.9-13.7-23.4-21.2a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-9.3 9.3-19.1 18-29.3 26L668.2 724a8 8 0 00-14.1 3l-39.6 162.2c-1.2 5 2.6 9.9 7.7 9.9l167 .8c6.7 0 10.5-7.7 6.3-12.9l-37.3-47.9z"></path>
    </symbol>
    <symbol id="undo" viewBox="64 64 896 896">
      <path d="M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 00-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 00-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z"></path>
    </symbol>
    <symbol id="export" viewBox="64 64 896 896">
      <path d="M880 912H144c-17.7 0-32-14.3-32-32V144c0-17.7 14.3-32 32-32h360c4.4 0 8 3.6 8 8v56c0 4.4-3.6 8-8 8H184v656h656V520c0-4.4 3.6-8 8-8h56c4.4 0 8 3.6 8 8v360c0 17.7-14.3 32-32 32zM770.87 199.13l-52.2-52.2a8.01 8.01 0 014.7-13.6l179.4-21c5.1-.6 9.5 3.7 8.9 8.9l-21 179.4c-.8 6.6-8.9 9.4-13.6 4.7l-52.4-52.4-256.2 256.2a8.03 8.03 0 01-11.3 0l-42.4-42.4a8.03 8.03 0 010-11.3l256.1-256.3z"></path>
    </symbol>
    <symbol id="auto-fit" viewBox="64 64 896 896">
      <path d="M952 474H829.8C812.5 327.6 696.4 211.5 550 194.2V72c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v122.2C327.6 211.5 211.5 327.6 194.2 474H72c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h122.2C211.5 696.4 327.6 812.5 474 829.8V952c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V829.8C696.4 812.5 812.5 696.4 829.8 550H952c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zM512 756c-134.8 0-244-109.2-244-244s109.2-244 244-244 244 109.2 244 244-109.2 244-244 244z"></path>
      <path d="M512 392c-32.1 0-62.1 12.4-84.8 35.2-22.7 22.7-35.2 52.7-35.2 84.8s12.5 62.1 35.2 84.8C449.9 619.4 480 632 512 632s62.1-12.5 84.8-35.2C619.4 574.1 632 544 632 512s-12.5-62.1-35.2-84.8A118.57 118.57 0 00512 392z"></path>
    </symbol>
    <symbol id="reset" viewBox="64 64 896 896">
      <path d="M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z"></path>
    </symbol>
    <symbol id="exit-fullscreen" viewBox="0 0 1024 1024">
      <path d="M418.13333333 361.43786666c0 0.2048-0.13653333 0.4096-0.13653334 0.68266667C417.99679999 362.32533333 418.13333333 362.53013333 418.13333333 362.73493333 418.13333333 371.54133333 414.44693333 379.392 408.78079999 385.39946666 408.43946666 385.7408 408.30293333 386.21866666 408.02986666 386.49173333c-1.09226667 1.09226667-2.59413333 1.77493333-3.82293333 2.73066667C398.40426666 393.65973333 391.64586666 396.8 383.93173333 396.8 383.72693333 396.8 383.59039999 396.73173333 383.38559999 396.73173333S382.97599999 396.8 382.77119999 396.8L112.29866666 396.8C92.50133333 396.8 76.79999999 381.50826666 76.79999999 362.66666666 76.66346666 343.89333333 92.63786666 328.53333333 112.16213333 328.53333333l189.44 0L87.44959999 114.51733333C73.59146666 100.59093333 73.25013333 78.5408 86.63039999 65.29706666c13.17546667-13.44853333 35.36213333-12.97066667 49.152 0.88746667l214.08426667 214.08426667L349.86666666 90.89706666C349.79839999 71.23626666 365.22666666 55.46666666 383.99999999 55.46666666 402.77333333 55.33013333 418.13333333 71.30453333 418.13333333 90.8288L418.13333333 361.43786666zM928.90453333 328.53333333l-189.44 0 214.15253333-214.08426667c13.85813333-13.9264 14.19946667-35.90826667 0.88746667-49.22026666-13.17546667-13.44853333-35.36213333-12.97066667-49.152 0.88746666l-214.08426667 214.08426667L691.26826666 90.89706666C691.26826666 71.23626666 675.83999999 55.46666666 657.06666666 55.46666666 638.29333333 55.33013333 622.93333333 71.30453333 622.93333333 90.8288l0 270.60906666c0 0.2048 0.13653333 0.4096 0.13653333 0.68266667C623.06986666 362.32533333 622.93333333 362.53013333 622.93333333 362.73493333 622.93333333 371.54133333 626.61973333 379.392 632.28586666 385.39946666c0.34133333 0.34133333 0.47786667 0.8192 0.8192 1.09226667 1.09226667 1.09226667 2.59413333 1.77493333 3.8912 2.73066667C642.66239999 393.65973333 649.42079999 396.8 657.13493333 396.8c0.2048 0 0.34133333-0.06826667 0.54613333-0.06826667S658.09066666 396.8 658.29546666 396.8l270.5408 0C948.56533333 396.8 964.26666666 381.50826666 964.26666666 362.66666666 964.40319999 343.89333333 948.42879999 328.53333333 928.90453333 328.53333333zM418.13333333 635.73333333c0-8.8064-3.6864-16.5888-9.35253334-22.66453333C408.43946666 612.72746666 408.30293333 612.2496 408.02986666 611.90826666 406.86933333 610.88426666 405.43573333 610.2016 404.20693333 609.24586666 398.47253333 604.80853333 391.64586666 601.6 383.93173333 601.6 383.72693333 601.6 383.59039999 601.73653333 383.38559999 601.73653333S382.97599999 601.6 382.77119999 601.6L112.29866666 601.6C92.50133333 601.6 76.79999999 616.96 76.79999999 635.73333333 76.66346666 654.50666666 92.63786666 669.86666666 112.16213333 669.86666666l189.44 0-214.15253334 214.15253334c-13.85813333 13.85813333-14.19946667 35.84-0.88746666 49.22026666 13.17546667 13.44853333 35.36213333 12.9024 49.152-0.95573333l214.08426666-214.08426667 0 189.37173334c0 19.59253333 15.42826667 35.49866667 34.2016 35.36213333C402.77333333 943.2064 418.13333333 927.232 418.13333333 907.5712L418.13333333 637.09866666c0-0.27306667-0.13653333-0.47786667-0.13653334-0.68266666C417.99679999 636.14293333 418.13333333 635.93813333 418.13333333 635.73333333zM739.46453333 669.86666666l189.44 0c19.456 0 35.49866667-15.36 35.36213333-34.13333333C964.26666666 616.96 948.56533333 601.6 928.76799999 601.6L658.29546666 601.6C658.09066666 601.6 657.88586666 601.73653333 657.68106666 601.73653333S657.33973333 601.6 657.13493333 601.6C649.42079999 601.6 642.59413333 604.80853333 636.85973333 609.24586666 635.63093333 610.2016 634.19733333 610.88426666 633.03679999 611.90826666 632.76373333 612.2496 632.62719999 612.72746666 632.28586666 613.0688 626.61973333 619.14453333 622.93333333 626.92693333 622.93333333 635.73333333c0 0.2048 0.13653333 0.4096 0.13653333 0.68266667C623.06986666 636.6208 622.93333333 636.8256 622.93333333 637.09866666l0 270.5408C622.93333333 927.232 638.29333333 943.2064 657.06666666 942.93333333c18.77333333 0.13653333 34.2016-15.70133333 34.2016-35.36213333l0-189.37173334 214.08426667 214.08426667c13.78986667 13.85813333 35.90826667 14.40426667 49.152 0.95573333 13.312-13.312 12.97066667-35.36213333-0.88746667-49.22026666L739.46453333 669.86666666z"  ></path></symbol>
    <symbol id="request-fullscreen" viewBox="0 0 1024 1024">
      <path d="M69.818182 87.598545v273.128728a34.909091 34.909091 0 0 0 69.818182 0V163.653818l221.928727 222.021818a33.512727 33.512727 0 0 0 47.383273-47.383272L186.926545 116.363636h197.073455a34.909091 34.909091 0 0 0 0-69.818181H110.871273C85.364364 46.545455 69.818182 59.671273 69.818182 87.598545zM938.542545 46.545455H665.413818a34.909091 34.909091 0 0 0 0 69.818181h197.073455L640.465455 338.292364a33.512727 33.512727 0 0 0 47.383272 47.383272l221.928728-222.021818v197.073455a34.909091 34.909091 0 0 0 69.818181 0V87.598545c0-27.927273-15.453091-41.053091-40.96-41.05309z m-827.671272 907.636363h273.128727a34.909091 34.909091 0 0 0 0-69.818182H186.926545l222.021819-221.928727a33.512727 33.512727 0 0 0-47.383273-47.383273L139.636364 837.073455V640a34.909091 34.909091 0 0 0-69.818182 0v273.128727c0 27.927273 15.546182 41.053091 41.053091 41.053091z m868.724363-41.053091V640a34.909091 34.909091 0 0 0-69.818181 0v197.073455L687.941818 615.051636a33.512727 33.512727 0 0 0-47.383273 47.383273L862.487273 884.363636H665.413818a34.909091 34.909091 0 0 0 0 69.818182h273.128727c25.6 0 41.053091-13.125818 41.053091-41.053091z"  ></path></symbol>
  </svg>
`;
var __awaiter$8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Toolbar extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Toolbar.defaultOptions, options));
    this.$element = createPluginContainer("toolbar", false);
    this.onToolbarItemClick = (e3) => {
      const { onClick } = this.options;
      if (e3.target instanceof Element) {
        if (e3.target.className.includes("g6-toolbar-item")) {
          const v2 = e3.target.getAttribute("value");
          onClick === null || onClick === void 0 ? void 0 : onClick(v2, e3.target);
        }
      }
    };
    const $container = this.context.canvas.getContainer();
    this.$element.style.display = "flex";
    $container.appendChild(this.$element);
    insertDOM("g6-toolbar-css", "style", {}, TOOLBAR_CSS, document.head);
    insertDOM("g6-toolbar-svgicon", "div", { display: "none" }, BUILD_IN_SVG_ICON);
    this.$element.addEventListener("click", this.onToolbarItemClick);
    this.update(options);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the configuration of the toolbar
   * @param options - <zh/>  | <en/> The options of the toolbar
   * @internal
   */
  update(options) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter$8(this, void 0, void 0, function* () {
      _super.update.call(this, options);
      const { className, position: position2, style } = this.options;
      this.$element.className = `g6-toolbar ${className || ""}`;
      Object.assign(this.$element.style, style, parsePositionToStyle(position2));
      this.$element.innerHTML = yield this.getDOMContent();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the toolbar
   * @internal
   */
  destroy() {
    this.$element.removeEventListener("click", this.onToolbarItemClick);
    this.$element.remove();
    super.destroy();
  }
  getDOMContent() {
    return __awaiter$8(this, void 0, void 0, function* () {
      const items = yield this.options.getItems();
      return items.map((item) => {
        var _a3;
        return `
          <div class="g6-toolbar-item" value="${item.value}" title="${(_a3 = item.title) !== null && _a3 !== void 0 ? _a3 : ""}">
            <svg aria-hidden="true" focusable="false">
              <use xlink:href="#${item.id}"></use>
            </svg>
          </div>`;
      }).join("");
    });
  }
}
Toolbar.defaultOptions = {
  position: "top-left"
};
var __awaiter$7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Tooltip extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Tooltip.defaultOptions, options));
    this.currentTarget = null;
    this.tooltipElement = null;
    this.container = null;
    this.isEnable = (event, items) => {
      const { enable } = this.options;
      if (typeof enable === "function") {
        return enable(event, items);
      }
      return enable;
    };
    this.onClick = (event) => {
      const { target: { id: id2 } } = event;
      if (this.currentTarget === id2) {
        this.hide(event);
      } else {
        this.show(event);
      }
    };
    this.onPointerMove = (event) => {
      const { target } = event;
      if (!this.currentTarget || target.id === this.currentTarget) {
        return;
      }
      this.show(event);
    };
    this.onPointerLeave = (event) => {
      this.hide(event);
    };
    this.onCanvasMove = (event) => {
      this.hide(event);
    };
    this.onPointerOver = (event) => {
      this.show(event);
    };
    this.showById = (id2) => __awaiter$7(this, void 0, void 0, function* () {
      const event = {
        target: { id: id2 }
      };
      yield this.show(event);
    });
    this.getElementData = (id2, targetType) => {
      const { model } = this.context;
      switch (targetType) {
        case "node":
          return model.getNodeData([id2]);
        case "edge":
          return model.getEdgeData([id2]);
        case "combo":
          return model.getComboData([id2]);
        default:
          return [];
      }
    };
    this.show = (event) => __awaiter$7(this, void 0, void 0, function* () {
      var _a3, _b;
      const { client, target: { id: id2 } } = event;
      if (isToBeDestroyed(event.target))
        return;
      const targetType = this.context.graph.getElementType(id2);
      const { getContent, title } = this.options;
      const items = this.getElementData(id2, targetType);
      if (!this.tooltipElement)
        return;
      if (!this.isEnable(event, items)) {
        this.hide(event);
        return;
      }
      let tooltipContent = {};
      if (getContent) {
        tooltipContent.content = yield getContent(event, items);
        if (!tooltipContent.content)
          return;
      } else {
        const style = this.context.graph.getElementRenderStyle(id2);
        const color2 = targetType === "node" ? style.fill : style.stroke;
        tooltipContent = {
          title: title || targetType,
          data: items.map((item) => {
            return {
              name: "ID",
              value: item.id || `${item.source} -> ${item.target}`,
              color: color2
            };
          })
        };
      }
      this.currentTarget = id2;
      let x2;
      let y2;
      if (client) {
        x2 = client.x;
        y2 = client.y;
      } else {
        const style = get$1(items, "0.style", { x: 0, y: 0 });
        x2 = style.x;
        y2 = style.y;
      }
      (_b = (_a3 = this.options).onOpenChange) === null || _b === void 0 ? void 0 : _b.call(_a3, true);
      this.tooltipElement.update(Object.assign(Object.assign(Object.assign({}, this.tooltipStyleProps), {
        x: x2,
        y: y2,
        style: {
          ".tooltip": {
            visibility: "visible"
          }
        }
      }), tooltipContent));
    });
    this.hide = (event) => {
      var _a3, _b, _c, _d, _e;
      if (!event) {
        (_b = (_a3 = this.options).onOpenChange) === null || _b === void 0 ? void 0 : _b.call(_a3, false);
        (_c = this.tooltipElement) === null || _c === void 0 ? void 0 : _c.hide();
        this.currentTarget = null;
        return;
      }
      if (!this.tooltipElement)
        return;
      if (!this.currentTarget)
        return;
      const { client: { x: x2, y: y2 } } = event;
      (_e = (_d = this.options).onOpenChange) === null || _e === void 0 ? void 0 : _e.call(_d, false);
      this.tooltipElement.hide(x2, y2);
      this.currentTarget = null;
    };
    this.initTooltip = () => {
      var _a3;
      const tooltipElement = new Tooltip$1({
        className: "tooltip",
        style: this.tooltipStyleProps
      });
      (_a3 = this.container) === null || _a3 === void 0 ? void 0 : _a3.appendChild(tooltipElement.HTMLTooltipElement);
      return tooltipElement;
    };
    this.render();
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Get event and handle event methods
   * @returns <zh/>  | <en/> Event and handling event methods
   */
  getEvents() {
    if (this.options.trigger === "click") {
      return {
        "node:click": this.onClick,
        "edge:click": this.onClick,
        "combo:click": this.onClick,
        "canvas:click": this.onPointerLeave,
        contextmenu: this.onPointerLeave,
        drag: this.onPointerLeave
      };
    }
    return {
      "node:pointerover": this.onPointerOver,
      "node:pointermove": this.onPointerMove,
      "canvas:pointermove": this.onCanvasMove,
      "edge:pointerover": this.onPointerOver,
      "edge:pointermove": this.onPointerMove,
      "combo:pointerover": this.onPointerOver,
      "combo:pointermove": this.onPointerMove,
      contextmenu: this.onPointerLeave,
      "node:drag": this.onPointerLeave
    };
  }
  /**
   * <zh/> tooltip
   *
   * <en/> Update the tooltip configuration
   * @param options - <zh/>  | <en/> options
   * @internal
   */
  update(options) {
    var _a3;
    this.unbindEvents();
    super.update(options);
    if (this.tooltipElement) {
      (_a3 = this.container) === null || _a3 === void 0 ? void 0 : _a3.removeChild(this.tooltipElement.HTMLTooltipElement);
    }
    this.tooltipElement = this.initTooltip();
    this.bindEvents();
  }
  render() {
    const { canvas: canvas2 } = this.context;
    const $container = canvas2.getContainer();
    if (!$container)
      return;
    this.container = $container;
    this.tooltipElement = this.initTooltip();
  }
  unbindEvents() {
    const { graph: graph2 } = this.context;
    const events = this.getEvents();
    Object.keys(events).forEach((eventName) => {
      graph2.off(eventName, events[eventName]);
    });
  }
  bindEvents() {
    const { graph: graph2 } = this.context;
    const events = this.getEvents();
    Object.keys(events).forEach((eventName) => {
      graph2.on(eventName, events[eventName]);
    });
  }
  get tooltipStyleProps() {
    const { canvas: canvas2 } = this.context;
    const { center } = canvas2.getBounds();
    const $container = canvas2.getContainer();
    const { top, left } = $container.getBoundingClientRect();
    const { style, position: position2, enterable, container = { x: -left, y: -top }, title, offset } = this.options;
    const [x2, y2] = center;
    const [width2, height] = canvas2.getSize();
    return {
      x: x2,
      y: y2,
      container,
      title,
      bounding: { x: 0, y: 0, width: width2, height },
      position: position2,
      enterable,
      offset,
      style
    };
  }
  /**
   * <zh/> tooltip
   *
   * <en/> Destroy tooltip
   * @internal
   */
  destroy() {
    var _a3;
    this.unbindEvents();
    if (this.tooltipElement) {
      (_a3 = this.container) === null || _a3 === void 0 ? void 0 : _a3.removeChild(this.tooltipElement.HTMLTooltipElement);
    }
    super.destroy();
  }
}
Tooltip.defaultOptions = {
  trigger: "hover",
  position: "top-right",
  enterable: false,
  enable: true,
  offset: [10, 10],
  style: {
    ".tooltip": {
      visibility: "hidden"
    }
  }
};
var __awaiter$6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let canvas;
function createCanvas(width2, height) {
  if (!canvas) {
    canvas = document.createElement("canvas");
  }
  canvas.width = width2;
  canvas.height = height;
  const ctx2 = canvas.getContext("2d");
  ctx2.clearRect(0, 0, width2, height);
  return canvas;
}
function getTextWatermark(width2, height, text, style) {
  return __awaiter$6(this, void 0, void 0, function* () {
    const canvas2 = createCanvas(width2, height);
    const ctx2 = canvas2.getContext("2d");
    const { rotate: rotate3, opacity: opacity2, textFill, textFontSize, textFontFamily, textFontVariant, textFontWeight, textAlign: textAlign2, textBaseline } = style;
    ctx2.textAlign = textAlign2;
    ctx2.textBaseline = textBaseline;
    ctx2.translate(width2 / 2, height / 2);
    ctx2.font = `${textFontSize}px ${textFontFamily} ${textFontVariant} ${textFontWeight}`;
    rotate3 && ctx2.rotate(rotate3);
    opacity2 && (ctx2.globalAlpha = opacity2);
    if (textFill) {
      ctx2.fillStyle = textFill;
      ctx2.fillText(`${text}`, 0, 0);
    }
    return canvas2.toDataURL();
  });
}
function getImageWatermark(width2, height, imageURL, style) {
  return __awaiter$6(this, void 0, void 0, function* () {
    const canvas2 = createCanvas(width2, height);
    const ctx2 = canvas2.getContext("2d");
    const { rotate: rotate3, opacity: opacity2 } = style;
    rotate3 && ctx2.rotate(rotate3);
    opacity2 && (ctx2.globalAlpha = opacity2);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageURL;
    return new Promise((resolve) => {
      img.onload = function() {
        const sepX = width2 > img.width ? (width2 - img.width) / 2 : 0;
        const sepY = height > img.height ? (height - img.height) / 2 : 0;
        ctx2.drawImage(img, 0, 0, img.width, img.height, sepX, sepY, width2 - sepX * 2, height - sepY * 2);
        resolve(canvas2.toDataURL());
      };
    });
  });
}
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$3 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class Watermark extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, Watermark.defaultOptions, options));
    this.$element = createPluginContainer("watermark");
    const $container = this.context.canvas.getContainer();
    $container.appendChild(this.$element);
    this.update(options);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the watermark configuration
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter$5(this, void 0, void 0, function* () {
      _super.update.call(this, options);
      const _a3 = this.options, { width: width2, height, text, imageURL } = _a3, rest = __rest$3(_a3, ["width", "height", "text", "imageURL"]);
      Object.keys(rest).forEach((key) => {
        if (key.startsWith("background")) {
          this.$element.style[key] = options[key];
        }
      });
      const base642 = imageURL ? yield getImageWatermark(width2, height, imageURL, rest) : yield getTextWatermark(width2, height, text, rest);
      this.$element.style.backgroundImage = `url(${base642})`;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the watermark
   * @internal
   */
  destroy() {
    super.destroy();
    this.$element.remove();
  }
}
Watermark.defaultOptions = {
  width: 200,
  height: 100,
  opacity: 0.2,
  rotate: Math.PI / 12,
  text: "",
  textFill: "#000",
  textFontSize: 16,
  textAlign: "center",
  textBaseline: "middle",
  backgroundRepeat: "repeat"
};
const BADGE_PALETTE = ["#7E92B5", "#F4664A", "#FFBE3A"];
const NODE_PALETTE_OPTIONS = {
  type: "group",
  color: ["#1783FF", "#00C9C9", "#F08F56", "#D580FF", "#7863FF", "#DB9D0D", "#60C42D", "#FF80CA", "#2491B3", "#17C76F"]
};
const EDGE_PALETTE_OPTIONS$1 = {
  type: "group",
  color: [
    "#99ADD1",
    "#1783FF",
    "#00C9C9",
    "#F08F56",
    "#D580FF",
    "#7863FF",
    "#DB9D0D",
    "#60C42D",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ]
};
function create(tokens2) {
  const { bgColor, textColor, nodeColor, nodeColorDisabled, nodeStroke, nodeHaloStrokeOpacityActive = 0.15, nodeHaloStrokeOpacitySelected = 0.25, nodeOpacityDisabled = 0.06, nodeIconOpacityInactive = 0.85, nodeOpacityInactive = 0.25, nodeBadgePalette = BADGE_PALETTE, nodePaletteOptions = NODE_PALETTE_OPTIONS, edgeColor, edgeColorDisabled, edgePaletteOptions = EDGE_PALETTE_OPTIONS$1, comboColor, comboColorDisabled, comboStroke, comboStrokeDisabled, edgeColorInactive } = tokens2;
  return {
    background: bgColor,
    node: {
      palette: nodePaletteOptions,
      style: {
        donutOpacity: 1,
        badgeBackgroundOpacity: 1,
        badgeFill: "#fff",
        badgeFontSize: 8,
        badgePadding: [0, 4],
        badgePalette: nodeBadgePalette,
        fill: nodeColor,
        fillOpacity: 1,
        halo: false,
        iconFill: "#fff",
        iconOpacity: 1,
        labelBackground: false,
        labelBackgroundFill: bgColor,
        labelBackgroundLineWidth: 0,
        labelBackgroundOpacity: 0.75,
        labelFill: textColor,
        labelFillOpacity: 0.85,
        labelLineHeight: 16,
        labelPadding: [0, 2],
        labelFontSize: 12,
        labelFontWeight: 400,
        labelOpacity: 1,
        labelOffsetY: 2,
        lineWidth: 0,
        portFill: nodeColor,
        portLineWidth: 1,
        portStroke: nodeStroke,
        portStrokeOpacity: 0.65,
        size: 32,
        stroke: nodeStroke,
        strokeOpacity: 1,
        zIndex: 2
      },
      state: {
        selected: {
          halo: true,
          haloLineWidth: 24,
          haloStrokeOpacity: nodeHaloStrokeOpacitySelected,
          labelFontSize: 12,
          labelFontWeight: "bold",
          lineWidth: 4,
          stroke: nodeStroke
        },
        active: {
          halo: true,
          haloLineWidth: 12,
          haloStrokeOpacity: nodeHaloStrokeOpacityActive
        },
        highlight: {
          labelFontWeight: "bold",
          lineWidth: 4,
          stroke: nodeStroke,
          strokeOpacity: 0.85
        },
        inactive: {
          badgeBackgroundOpacity: nodeOpacityInactive,
          donutOpacity: nodeOpacityInactive,
          fillOpacity: nodeOpacityInactive,
          iconOpacity: nodeIconOpacityInactive,
          labelFill: textColor,
          labelFillOpacity: nodeOpacityInactive,
          strokeOpacity: nodeOpacityInactive
        },
        disabled: {
          badgeBackgroundOpacity: 0.25,
          donutOpacity: nodeOpacityDisabled,
          fill: nodeColorDisabled,
          fillOpacity: nodeOpacityDisabled,
          iconFill: nodeColorDisabled,
          iconOpacity: 0.25,
          labelFill: textColor,
          labelFillOpacity: 0.25,
          strokeOpacity: nodeOpacityDisabled
        }
      },
      animation: {
        enter: "fade",
        exit: "fade",
        show: "fade",
        hide: "fade",
        expand: "node-expand",
        collapse: "node-collapse",
        update: [{ fields: ["x", "y", "fill", "stroke"] }],
        translate: [{ fields: ["x", "y"] }]
      }
    },
    edge: {
      palette: edgePaletteOptions,
      style: {
        badgeBackgroundFill: edgeColor,
        badgeFill: "#fff",
        badgeFontSize: 8,
        badgeOffsetX: 10,
        badgeBackgroundOpacity: 1,
        fillOpacity: 1,
        halo: false,
        haloLineWidth: 12,
        haloStrokeOpacity: 1,
        increasedLineWidthForHitTesting: 2,
        labelBackground: false,
        labelBackgroundFill: bgColor,
        labelBackgroundLineWidth: 0,
        labelBackgroundOpacity: 0.75,
        labelBackgroundPadding: [4, 4, 4, 4],
        labelFill: textColor,
        labelFontSize: 12,
        labelFontWeight: 400,
        labelOpacity: 1,
        labelPlacement: "center",
        labelTextBaseline: "middle",
        lineWidth: 1,
        stroke: edgeColor,
        strokeOpacity: 1,
        zIndex: 1
      },
      state: {
        selected: {
          halo: true,
          haloStrokeOpacity: 0.25,
          labelFontSize: 14,
          labelFontWeight: "bold",
          lineWidth: 3
        },
        active: {
          halo: true,
          haloStrokeOpacity: 0.15
        },
        highlight: {
          labelFontWeight: "bold",
          lineWidth: 3
        },
        inactive: {
          stroke: edgeColorInactive,
          fillOpacity: 0.08,
          labelOpacity: 0.25,
          strokeOpacity: 0.08,
          badgeBackgroundOpacity: 0.25
        },
        disabled: {
          stroke: edgeColorDisabled,
          fillOpacity: 0.45,
          strokeOpacity: 0.45,
          labelOpacity: 0.25,
          badgeBackgroundOpacity: 0.45
        }
      },
      animation: {
        enter: "fade",
        exit: "fade",
        expand: "path-in",
        collapse: "path-out",
        show: "fade",
        hide: "fade",
        update: [{ fields: ["sourceNode", "targetNode"] }, { fields: ["stroke"], shape: "key" }],
        translate: [{ fields: ["sourceNode", "targetNode"] }]
      }
    },
    combo: {
      style: {
        collapsedMarkerFill: bgColor,
        collapsedMarkerFontSize: 12,
        collapsedMarkerFillOpacity: 1,
        collapsedSize: 32,
        collapsedFillOpacity: 1,
        fill: comboColor,
        halo: false,
        haloLineWidth: 12,
        haloStroke: comboStroke,
        haloStrokeOpacity: 0.25,
        labelBackground: false,
        labelBackgroundFill: bgColor,
        labelBackgroundLineWidth: 0,
        labelBackgroundOpacity: 0.75,
        labelBackgroundPadding: [2, 4, 2, 4],
        labelFill: textColor,
        labelFontSize: 12,
        labelFontWeight: 400,
        labelOpacity: 1,
        lineDash: 0,
        lineWidth: 1,
        fillOpacity: 0.04,
        strokeOpacity: 1,
        padding: 10,
        stroke: comboStroke
      },
      state: {
        selected: {
          halo: true,
          labelFontSize: 14,
          labelFontWeight: 700,
          lineWidth: 4
        },
        active: {
          halo: true
        },
        highlight: {
          labelFontWeight: 700,
          lineWidth: 4
        },
        inactive: {
          fillOpacity: 0.65,
          labelOpacity: 0.25,
          strokeOpacity: 0.65
        },
        disabled: {
          fill: comboColorDisabled,
          fillOpacity: 0.25,
          labelOpacity: 0.25,
          stroke: comboStrokeDisabled,
          strokeOpacity: 0.25
        }
      },
      animation: {
        enter: "fade",
        exit: "fade",
        show: "fade",
        hide: "fade",
        expand: "combo-expand",
        collapse: "combo-collapse",
        update: [{ fields: ["x", "y"] }, { fields: ["fill", "stroke", "lineWidth"], shape: "key" }],
        translate: [{ fields: ["x", "y"] }]
      }
    }
  };
}
const EDGE_PALETTE_OPTIONS = {
  type: "group",
  color: [
    "#637088",
    "#0F55A6",
    "#008383",
    "#9C5D38",
    "#8B53A6",
    "#4E40A6",
    "#8F6608",
    "#3E801D",
    "#A65383",
    "#175E75",
    "#0F8248"
  ]
};
const tokens$1 = {
  bgColor: "#000000",
  comboColor: "#fdfdfd",
  comboColorDisabled: "#d0e4ff",
  comboStroke: "#99add1",
  comboStrokeDisabled: "#969696",
  edgeColor: "#637088",
  edgeColorDisabled: "#637088",
  edgeColorInactive: "#D0E4FF",
  edgePaletteOptions: EDGE_PALETTE_OPTIONS,
  nodeColor: "#1783ff",
  nodeColorDisabled: "#D0E4FF",
  nodeHaloStrokeOpacityActive: 0.25,
  nodeHaloStrokeOpacitySelected: 0.45,
  nodeIconOpacityInactive: 0.45,
  nodeOpacityDisabled: 0.25,
  nodeOpacityInactive: 0.45,
  nodeStroke: "#d0e4ff",
  textColor: "#ffffff"
};
const dark = create(tokens$1);
const tokens = {
  bgColor: "#ffffff",
  comboColor: "#99ADD1",
  comboColorDisabled: "#f0f0f0",
  comboStroke: "#99add1",
  comboStrokeDisabled: "#d9d9d9",
  edgeColor: "#99add1",
  edgeColorDisabled: "#d9d9d9",
  edgeColorInactive: "#1B324F",
  nodeColor: "#1783ff",
  nodeColorDisabled: "#1B324F",
  nodeHaloStrokeOpacityActive: 0.15,
  nodeHaloStrokeOpacitySelected: 0.25,
  nodeIconOpacityInactive: 0.85,
  nodeOpacityDisabled: 0.06,
  nodeOpacityInactive: 0.25,
  nodeStroke: "#000000",
  textColor: "#000000"
};
const light = create(tokens);
class BaseTransform extends BaseExtension {
  beforeDraw(data2, context) {
    return data2;
  }
  afterLayout(type, data2) {
  }
}
class ArrangeDrawOrder extends BaseTransform {
  beforeDraw(input) {
    const { model } = this.context;
    const combosToAdd = input.add.combos;
    const arrangeCombo = (combos) => {
      const order2 = [];
      combos.forEach((combo, id2) => {
        const ancestors = model.getAncestorsData(id2, "combo");
        const path = ancestors.map((ancestor) => idOf(ancestor)).reverse();
        order2.push([id2, combo, path.length]);
      });
      return new Map(order2.sort(([, , zIndex1], [, , zIndex2]) => zIndex2 - zIndex1).map(([id2, datum]) => [id2, datum]));
    };
    input.add.combos = arrangeCombo(combosToAdd);
    input.update.combos = arrangeCombo(input.update.combos);
    return input;
  }
}
function reassignTo(input, type, elementType, datum, overwrite) {
  const id2 = idOf(datum);
  const typeName = `${elementType}s`;
  const exitsDatum = overwrite ? datum : input.add[typeName].get(id2) || input.update[typeName].get(id2) || input.remove[typeName].get(id2) || datum;
  Object.entries(input).forEach(([_type, value]) => {
    if (type === _type)
      value[typeName].set(id2, exitsDatum);
    else
      value[typeName].delete(id2);
  });
}
function isStyleEqual(style, originalStyle) {
  return Object.keys(style).every((key) => style[key] === originalStyle[key]);
}
class CollapseExpandCombo extends BaseTransform {
  beforeDraw(input, context) {
    if (context.stage === "visibility")
      return input;
    if (!this.context.model.model.hasTreeStructure(COMBO_KEY))
      return input;
    const { model } = this.context;
    const { add: add2, update } = input;
    const combos = [...input.update.combos.entries(), ...input.add.combos.entries()];
    while (combos.length) {
      const [id2, combo] = combos.pop();
      if (isCollapsed(combo)) {
        const descendants = model.getDescendantsData(id2);
        const descendantIds = descendants.map(idOf);
        const { internal, external } = getSubgraphRelatedEdges(descendantIds, (id3) => model.getRelatedEdgesData(id3));
        descendants.forEach((descendant) => {
          const descendantId = idOf(descendant);
          const comboIndex = combos.findIndex(([id3]) => id3 === descendantId);
          if (comboIndex !== -1)
            combos.splice(comboIndex, 1);
          const elementType = model.getElementType(descendantId);
          reassignTo(input, "remove", elementType, descendant);
        });
        internal.forEach((edge) => reassignTo(input, "remove", "edge", edge));
        external.forEach((edge) => {
          var _a3;
          const id3 = idOf(edge);
          const edgeElement = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(id3);
          if (edgeElement)
            update.edges.set(id3, edge);
          else
            add2.edges.set(id3, edge);
        });
      } else {
        const children = model.getChildrenData(id2);
        const childrenIds = children.map(idOf);
        const { edges } = getSubgraphRelatedEdges(childrenIds, (id3) => model.getRelatedEdgesData(id3));
        [...children, ...edges].forEach((descendant) => {
          var _a3;
          const id3 = idOf(descendant);
          const elementType = model.getElementType(id3);
          const element = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(id3);
          if (element)
            reassignTo(input, "update", elementType, descendant);
          else
            reassignTo(input, "add", elementType, descendant);
          if (elementType === "combo")
            combos.push([id3, descendant]);
        });
      }
    }
    return input;
  }
}
const weakAssignTo = (input, type, elementType, datum) => {
  const typeName = `${elementType}s`;
  const id2 = idOf(datum);
  if (!input.add[typeName].has(id2) && !input.update[typeName].has(id2)) {
    input[type][typeName].set(idOf(datum), datum);
  }
};
class CollapseExpandNode extends BaseTransform {
  getElement(id2) {
    return this.context.element.getElement(id2);
  }
  handleExpand(node, input) {
    weakAssignTo(input, "add", "node", node);
    if (isCollapsed(node))
      return;
    const id2 = idOf(node);
    weakAssignTo(input, "add", "node", node);
    const relatedEdges = this.context.model.getRelatedEdgesData(id2);
    relatedEdges.forEach((edge) => {
      reassignTo(input, "add", "edge", edge);
    });
    const children = this.context.model.getChildrenData(id2);
    children.forEach((child) => {
      this.handleExpand(child, input);
    });
  }
  beforeDraw(input) {
    const { graph: graph2, model } = this.context;
    if (!model.model.hasTreeStructure(TREE_KEY))
      return input;
    const { add: { nodes: nodesToAdd, edges: edgesToAdd }, update: { nodes: nodesToUpdate } } = input;
    const nodesToCollapse = /* @__PURE__ */ new Map();
    const nodesToExpand = /* @__PURE__ */ new Map();
    nodesToAdd.forEach((node, id2) => {
      if (isCollapsed(node))
        nodesToCollapse.set(id2, node);
    });
    edgesToAdd.forEach((edge) => {
      if (graph2.getElementType(edge.source) !== "node")
        return;
      const source = graph2.getNodeData(edge.source);
      if (isCollapsed(source))
        nodesToCollapse.set(edge.source, source);
    });
    nodesToUpdate.forEach((node, id2) => {
      const nodeElement = this.getElement(id2);
      if (!nodeElement)
        return;
      const isCurrentCollapsed = nodeElement.attributes.collapsed;
      if (isCollapsed(node)) {
        if (!isCurrentCollapsed)
          nodesToCollapse.set(id2, node);
      } else {
        if (isCurrentCollapsed)
          nodesToExpand.set(id2, node);
      }
    });
    const handledNodes = /* @__PURE__ */ new Set();
    nodesToCollapse.forEach((node, id2) => {
      const descendants = model.getDescendantsData(id2);
      descendants.forEach((descendant) => {
        const id3 = idOf(descendant);
        if (handledNodes.has(id3))
          return;
        reassignTo(input, "remove", "node", descendant);
        const relatedEdges = model.getRelatedEdgesData(id3);
        relatedEdges.forEach((edge) => {
          reassignTo(input, "remove", "edge", edge);
        });
        handledNodes.add(id3);
      });
    });
    nodesToExpand.forEach((node, id2) => {
      const ancestors = model.getAncestorsData(id2, TREE_KEY);
      if (ancestors.some(isCollapsed)) {
        reassignTo(input, "remove", "node", node);
        return;
      }
      this.handleExpand(node, input);
    });
    return input;
  }
}
function register(category, type, Ctor) {
  const ext = EXTENSION_REGISTRY[category][type];
  if (ext) {
    print.warn(`The extension ${type} of ${category} has been registered before, and will be overridden.`);
  }
  Object.assign(EXTENSION_REGISTRY[category], { [type]: Ctor });
}
/*!
 * @antv/g-plugin-dragndrop
 * @description A G plugin for Drag n Drop implemented with PointerEvents
 * @version 2.1.1
 * @date 12/24/2025, 11:56:44 AM
 * @author AntVis
 * @docs https://g.antv.antgroup.com/
 */
var DragndropPlugin = /* @__PURE__ */ function() {
  function DragndropPlugin2(dragndropPluginOptions) {
    _classCallCheck(this, DragndropPlugin2);
    this.dragndropPluginOptions = dragndropPluginOptions;
  }
  return _createClass(DragndropPlugin2, [{
    key: "apply",
    value: function apply2(context) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      var document2 = renderingContext.root.ownerDocument;
      var canvas2 = document2.defaultView;
      var handlePointerdown = function handlePointerdown2(event) {
        var target = event.target;
        var isDocument = target === document2;
        var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
        if (draggableEventTarget) {
          var dragstartTriggered = false;
          var dragstartTimeStamp = event.timeStamp;
          var dragstartClientCoordinates = [event.clientX, event.clientY];
          var currentDroppable = null;
          var lastDragClientCoordinates = [event.clientX, event.clientY];
          var handlePointermove = /* @__PURE__ */ function() {
            var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(event2) {
              var timeElapsed, distanceMoved, point2, elementsBelow, elementBelow, droppableBelow;
              return _regeneratorRuntime().wrap(function(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (dragstartTriggered) {
                      _context.next = 2;
                      break;
                    }
                    timeElapsed = event2.timeStamp - dragstartTimeStamp;
                    distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                    if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                      _context.next = 1;
                      break;
                    }
                    return _context.abrupt("return");
                  case 1:
                    event2.type = "dragstart";
                    draggableEventTarget.dispatchEvent(event2);
                    dragstartTriggered = true;
                  case 2:
                    event2.type = "drag";
                    event2.dx = event2.clientX - lastDragClientCoordinates[0];
                    event2.dy = event2.clientY - lastDragClientCoordinates[1];
                    draggableEventTarget.dispatchEvent(event2);
                    lastDragClientCoordinates = [event2.clientX, event2.clientY];
                    if (isDocument) {
                      _context.next = 4;
                      break;
                    }
                    point2 = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                    _context.next = 3;
                    return document2.elementsFromPoint(point2[0], point2[1]);
                  case 3:
                    elementsBelow = _context.sent;
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                    if (currentDroppable !== droppableBelow) {
                      if (currentDroppable) {
                        event2.type = "dragleave";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                      if (droppableBelow) {
                        event2.type = "dragenter";
                        event2.target = droppableBelow;
                        droppableBelow.dispatchEvent(event2);
                      }
                      currentDroppable = droppableBelow;
                      if (currentDroppable) {
                        event2.type = "dragover";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                    }
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function handlePointermove2(_x) {
              return _ref.apply(this, arguments);
            };
          }();
          canvas2.addEventListener("pointermove", handlePointermove);
          var stopDragging = function stopDragging2(originalPointerUpEvent) {
            if (dragstartTriggered) {
              originalPointerUpEvent.detail = {
                preventClick: true
              };
              var _event = originalPointerUpEvent.clone();
              if (currentDroppable) {
                _event.type = "drop";
                _event.target = currentDroppable;
                currentDroppable.dispatchEvent(_event);
              }
              _event.type = "dragend";
              draggableEventTarget.dispatchEvent(_event);
              dragstartTriggered = false;
            }
            canvas2.removeEventListener("pointermove", handlePointermove);
          };
          target.addEventListener("pointerup", stopDragging, {
            once: true
          });
          target.addEventListener("pointerupoutside", stopDragging, {
            once: true
          });
        }
      };
      renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
        canvas2.addEventListener("pointerdown", handlePointerdown);
      });
      renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
        canvas2.removeEventListener("pointerdown", handlePointerdown);
      });
    }
  }]);
}();
DragndropPlugin.tag = "Dragndrop";
var Plugin = /* @__PURE__ */ function(_AbstractRendererPlug) {
  function Plugin2() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin2);
    _this2 = _callSuper(this, Plugin2);
    _this2.name = "dragndrop";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin2, _AbstractRendererPlug);
  return _createClass(Plugin2, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DragndropPlugin(_objectSpread2({
        overlap: "pointer",
        isDocumentDraggable: false,
        isDocumentDroppable: false,
        dragstartDistanceThreshold: 0,
        dragstartTimeThreshold: 0
      }, this.options)));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this.plugins[0].dragndropPluginOptions, options);
    }
  }]);
}(AbstractRendererPlugin);
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$2 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
const SINGLE_LAYER_NAME = ["main"];
const MULTI_LAYER_NAME = ["background", "main", "label", "transient"];
function getMainLayerOf(layers) {
  return layers.main;
}
class Canvas {
  getConfig() {
    return this.config;
  }
  getLayer(layer = "main") {
    return this.extends.layers[layer] || getMainLayerOf(this.getLayers());
  }
  /**
   * <zh/> 
   *
   * <en/> Get all layers
   * @returns <zh/>  <en/> Layer
   */
  getLayers() {
    return this.extends.layers;
  }
  /**
   * <zh/> 
   *
   * <en/> Get renderer
   * @param layer - <zh/>  <en/> Layer
   * @returns <zh/>  <en/> Renderer
   */
  getRenderer(layer) {
    return this.extends.renderers[layer];
  }
  /**
   * <zh/> 
   *
   * <en/> Get camera
   * @param layer - <zh/>  <en/> Layer
   * @returns <zh/>  <en/> Camera
   */
  getCamera(layer = "main") {
    return this.getLayer(layer).getCamera();
  }
  getRoot(layer = "main") {
    return this.getLayer(layer).getRoot();
  }
  getContextService(layer = "main") {
    return this.getLayer(layer).getContextService();
  }
  setCursor(cursor) {
    this.config.cursor = cursor;
    this.getLayer().setCursor(cursor);
  }
  get document() {
    return this.getLayer().document;
  }
  get context() {
    return this.getLayer().context;
  }
  constructor(config) {
    this.config = {
      enableMultiLayer: true
    };
    Object.assign(this.config, config);
    const _a3 = this.config, { renderer, background, cursor, enableMultiLayer } = _a3, restConfig = __rest$2(_a3, ["renderer", "background", "cursor", "enableMultiLayer"]);
    const layersName = enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME;
    const renderers = createRenderers(renderer, layersName);
    const layers = Object.fromEntries(layersName.map((layer) => {
      const canvas2 = new Canvas$1(Object.assign(Object.assign({}, restConfig), { supportsMutipleCanvasesInOneContainer: enableMultiLayer, renderer: renderers[layer], background: enableMultiLayer ? layer === "background" ? background : void 0 : background }));
      return [layer, canvas2];
    }));
    configCanvasDom(layers);
    this.extends = {
      config: this.config,
      renderer,
      renderers,
      layers
    };
  }
  get ready() {
    return Promise.all(Object.entries(this.getLayers()).map(([, canvas2]) => canvas2.ready));
  }
  resize(width2, height) {
    Object.assign(this.extends.config, { width: width2, height });
    Object.values(this.getLayers()).forEach((canvas2) => {
      const camera = canvas2.getCamera();
      const position2 = camera.getPosition();
      const focalPoint = camera.getFocalPoint();
      canvas2.resize(width2, height);
      camera.setPosition(position2);
      camera.setFocalPoint(focalPoint);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get canvas boundary
   * @param group
   * <zh/> 
   * - undefined: 
   * - 'elements': 
   * - 'plugins': 
   *
   * <en/> Element group
   * - undefined: Get the entire canvas boundary
   * - 'elements': Get only the element boundary
   * - 'plugins': Get only the plugin boundary
   * @returns <zh/>  <en/> Boundary
   */
  getBounds(group2) {
    return getCombinedBBox(Object.values(this.getLayers()).map((canvas2) => {
      const g2 = group2 ? canvas2.getRoot().childNodes.find((node) => node.classList.includes(group2)) : canvas2.getRoot();
      return g2;
    }).filter((el) => (el === null || el === void 0 ? void 0 : el.childNodes.length) > 0).map((el) => el.getBounds()));
  }
  getContainer() {
    const container = this.extends.config.container;
    return typeof container === "string" ? document.getElementById(container) : container;
  }
  getSize() {
    return [this.extends.config.width || 0, this.extends.config.height || 0];
  }
  appendChild(child, index2) {
    var _a3;
    const layer = ((_a3 = child.style) === null || _a3 === void 0 ? void 0 : _a3.$layer) || "main";
    return this.getLayer(layer).appendChild(child, index2);
  }
  setRenderer(renderer) {
    if (renderer === this.extends.renderer)
      return;
    const renderers = createRenderers(renderer, this.config.enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME);
    this.extends.renderers = renderers;
    Object.entries(renderers).forEach(([layer, instance]) => this.getLayer(layer).setRenderer(instance));
    configCanvasDom(this.getLayers());
  }
  getCanvasByViewport(point2) {
    return parsePoint(this.getLayer().viewport2Canvas(toPointObject(point2)));
  }
  getViewportByCanvas(point2) {
    return parsePoint(this.getLayer().canvas2Viewport(toPointObject(point2)));
  }
  getViewportByClient(point2) {
    return parsePoint(this.getLayer().client2Viewport(toPointObject(point2)));
  }
  getClientByViewport(point2) {
    return parsePoint(this.getLayer().viewport2Client(toPointObject(point2)));
  }
  getClientByCanvas(point2) {
    return this.getClientByViewport(this.getViewportByCanvas(point2));
  }
  getCanvasByClient(point2) {
    const main = this.getLayer();
    const viewportPoint = main.client2Viewport(toPointObject(point2));
    return parsePoint(main.viewport2Canvas(viewportPoint));
  }
  toDataURL() {
    return __awaiter$4(this, arguments, void 0, function* (options = {}) {
      const devicePixelRatio = globalThis.devicePixelRatio || 1;
      const { mode = "viewport" } = options, restOptions = __rest$2(options, ["mode"]);
      let [startX, startY, width2, height] = [0, 0, 0, 0];
      if (mode === "viewport") {
        [width2, height] = this.getSize();
      } else if (mode === "overall") {
        const bounds = this.getBounds();
        const size = getBBoxSize$1(bounds);
        [startX, startY] = bounds.min;
        [width2, height] = size;
      }
      const container = createDOM('<div id="virtual-image"></div>');
      const offscreenCanvas = new Canvas$1({
        width: width2,
        height,
        renderer: new Renderer(),
        devicePixelRatio,
        container,
        background: this.extends.config.background
      });
      yield offscreenCanvas.ready;
      offscreenCanvas.appendChild(this.getLayer("background").getRoot().cloneNode(true));
      offscreenCanvas.appendChild(this.getRoot().cloneNode(true));
      const label = this.getLayer("label").getRoot().cloneNode(true);
      const originCanvasPosition = offscreenCanvas.viewport2Canvas({ x: 0, y: 0 });
      const currentCanvasPosition = this.getCanvasByViewport([0, 0]);
      label.translate([
        currentCanvasPosition[0] - originCanvasPosition.x,
        currentCanvasPosition[1] - originCanvasPosition.y
      ]);
      label.scale(1 / this.getCamera().getZoom());
      offscreenCanvas.appendChild(label);
      offscreenCanvas.appendChild(this.getLayer("transient").getRoot().cloneNode(true));
      const camera = this.getCamera();
      const offscreenCamera = offscreenCanvas.getCamera();
      if (mode === "viewport") {
        offscreenCamera.setZoom(camera.getZoom());
        offscreenCamera.setPosition(camera.getPosition());
        offscreenCamera.setFocalPoint(camera.getFocalPoint());
      } else if (mode === "overall") {
        const [x2, y2, z2] = offscreenCamera.getPosition();
        const [fx, fy, fz] = offscreenCamera.getFocalPoint();
        offscreenCamera.setPosition([x2 + startX, y2 + startY, z2]);
        offscreenCamera.setFocalPoint([fx + startX, fy + startY, fz]);
      }
      const contextService = offscreenCanvas.getContextService();
      return new Promise((resolve) => {
        offscreenCanvas.addEventListener(CanvasEvent$1.RERENDER, () => __awaiter$4(this, void 0, void 0, function* () {
          yield new Promise((r2) => setTimeout(r2, 300));
          const url = yield contextService.toDataURL(restOptions);
          resolve(url);
        }));
      });
    });
  }
  destroy() {
    Object.values(this.getLayers()).forEach((canvas2) => {
      const camera = canvas2.getCamera();
      camera.cancelLandmarkAnimation();
      canvas2.destroy();
    });
  }
}
function createRenderers(renderer, layersName) {
  return Object.fromEntries(layersName.map((layer) => {
    const instance = (renderer === null || renderer === void 0 ? void 0 : renderer(layer)) || new Renderer();
    if (instance instanceof Renderer) {
      instance.setConfig({ enableDirtyRectangleRendering: false });
    }
    if (layer === "main") {
      instance.registerPlugin(new Plugin({
        isDocumentDraggable: true,
        isDocumentDroppable: true,
        dragstartDistanceThreshold: 10,
        dragstartTimeThreshold: 100
      }));
    } else {
      instance.unregisterPlugin(instance.getPlugin("dom-interaction"));
    }
    return [layer, instance];
  }));
}
function configCanvasDom(layers) {
  Object.entries(layers).forEach(([layer, canvas2]) => {
    const domElement = canvas2.getContextService().getDomElement();
    if (domElement === null || domElement === void 0 ? void 0 : domElement.style) {
      domElement.style.gridArea = "1 / 1 / 2 / 2";
      domElement.style.outline = "none";
      domElement.tabIndex = 1;
      if (layer !== "main")
        domElement.style.pointerEvents = "none";
    }
    if (domElement === null || domElement === void 0 ? void 0 : domElement.parentElement) {
      domElement.parentElement.style.display = "grid";
      domElement.parentElement.style.isolation = "isolate";
    }
  });
}
const parseInt10 = (d3) => d3 ? parseInt(d3) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return [wrapperWidth - widthPadding, wrapperHeight - heightPadding];
}
function sizeOf(container) {
  if (!container)
    return [0, 0];
  let effectiveWidth = 640;
  let effectiveHeight = 480;
  const [containerWidth, containerHeight] = getContainerSize(container);
  effectiveWidth = containerWidth || effectiveWidth;
  effectiveHeight = containerHeight || effectiveHeight;
  const MIN_CHART_WIDTH = 1;
  const MIN_CHART_HEIGHT = 1;
  return [
    Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  ];
}
class BaseEvent {
  constructor(type) {
    this.type = type;
  }
}
class GraphLifeCycleEvent extends BaseEvent {
  constructor(type, data2) {
    super(type);
    this.data = data2;
  }
}
class AnimateEvent extends BaseEvent {
  constructor(type, animationType, animation, data2) {
    super(type);
    this.animationType = animationType;
    this.animation = animation;
    this.data = data2;
  }
}
class ElementLifeCycleEvent extends BaseEvent {
  constructor(type, elementType, data2) {
    super(type);
    this.elementType = elementType;
    this.data = data2;
  }
}
class ViewportEvent extends BaseEvent {
  constructor(type, data2) {
    super(type);
    this.data = data2;
  }
}
function emit(emitter, event) {
  emitter.emit(event.type, event);
}
function eventTargetOf(shape) {
  if (!shape)
    return null;
  if (shape instanceof Document$1) {
    return { type: "canvas", element: shape };
  }
  let element = shape;
  while (element) {
    if (isNode(element))
      return { type: "node", element };
    if (isEdge(element))
      return { type: "edge", element };
    if (isCombo(element))
      return { type: "combo", element };
    element = element.parentElement;
  }
  return null;
}
function getZIndexOf(datum) {
  var _a3;
  return ((_a3 = datum === null || datum === void 0 ? void 0 : datum.style) === null || _a3 === void 0 ? void 0 : _a3.zIndex) || 0;
}
const CacheTargetKey = "cachedStyle";
const getStyleCacheKey = (name) => `__${name}__`;
function cacheStyle(element, name) {
  const names = Array.isArray(name) ? name : [name];
  if (!get$1(element, CacheTargetKey))
    set$1(element, CacheTargetKey, {});
  names.forEach((n2) => {
    set$1(get$1(element, CacheTargetKey), getStyleCacheKey(n2), element.attributes[n2]);
  });
}
function getCachedStyle(element, name) {
  return get$1(element, [CacheTargetKey, getStyleCacheKey(name)]);
}
function hasCachedStyle(element, name) {
  return getStyleCacheKey(name) in (get$1(element, CacheTargetKey) || {});
}
class Animation {
  constructor(context) {
    this.tasks = [];
    this.animations = /* @__PURE__ */ new Set();
    this.context = context;
  }
  getTasks() {
    const tasks2 = [...this.tasks];
    this.tasks = [];
    return tasks2;
  }
  add(context, callbacks) {
    this.tasks.push([context, callbacks]);
  }
  animate(localAnimation, callbacks, extendOptions) {
    var _a3, _b, _c;
    (_a3 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.before) === null || _a3 === void 0 ? void 0 : _a3.call(callbacks);
    const animations = this.getTasks().map(([context, cb]) => {
      var _a4, _b2, _c2;
      const { element, elementType, stage } = context;
      const options = getElementAnimationOptions(this.context.options, elementType, stage, localAnimation);
      (_a4 = cb === null || cb === void 0 ? void 0 : cb.before) === null || _a4 === void 0 ? void 0 : _a4.call(cb);
      const animation2 = options.length ? executor(element, this.inferStyle(context, extendOptions), options) : null;
      if (animation2) {
        (_b2 = cb === null || cb === void 0 ? void 0 : cb.beforeAnimate) === null || _b2 === void 0 ? void 0 : _b2.call(cb, animation2);
        animation2.finished.then(() => {
          var _a5, _b3;
          (_a5 = cb === null || cb === void 0 ? void 0 : cb.afterAnimate) === null || _a5 === void 0 ? void 0 : _a5.call(cb, animation2);
          (_b3 = cb === null || cb === void 0 ? void 0 : cb.after) === null || _b3 === void 0 ? void 0 : _b3.call(cb);
          this.animations.delete(animation2);
        });
      } else
        (_c2 = cb === null || cb === void 0 ? void 0 : cb.after) === null || _c2 === void 0 ? void 0 : _c2.call(cb);
      return animation2;
    }).filter(Boolean);
    animations.forEach((animation2) => this.animations.add(animation2));
    const animation = createAnimationsProxy(animations);
    if (animation) {
      (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.beforeAnimate) === null || _b === void 0 ? void 0 : _b.call(callbacks, animation);
      animation.finished.then(() => {
        var _a4, _b2;
        (_a4 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.afterAnimate) === null || _a4 === void 0 ? void 0 : _a4.call(callbacks, animation);
        (_b2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _b2 === void 0 ? void 0 : _b2.call(callbacks);
        this.release();
      });
    } else
      (_c = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _c === void 0 ? void 0 : _c.call(callbacks);
    return animation;
  }
  /**
   * <zh/> 
   *
   * <en/> Infer additional animation styles
   * @param context - <zh/>  | <en/> Animation context
   * @param options - <zh/>  | <en/> Extend options
   * @returns <zh/>  | <en/> Initial style and final style
   */
  inferStyle(context, options) {
    var _a3, _b;
    const { element, elementType, stage, originalStyle, updatedStyle = {} } = context;
    if (!context.modifiedStyle)
      context.modifiedStyle = Object.assign(Object.assign({}, originalStyle), updatedStyle);
    const { modifiedStyle } = context;
    const fromStyle = {};
    const toStyle = {};
    if (stage === "enter") {
      Object.assign(fromStyle, { opacity: 0 });
    } else if (stage === "exit") {
      Object.assign(toStyle, { opacity: 0 });
    } else if (stage === "show") {
      Object.assign(fromStyle, { opacity: 0 });
      Object.assign(toStyle, { opacity: (_a3 = getCachedStyle(element, "opacity")) !== null && _a3 !== void 0 ? _a3 : inferDefaultValue("opacity") });
    } else if (stage === "hide") {
      Object.assign(fromStyle, { opacity: (_b = getCachedStyle(element, "opacity")) !== null && _b !== void 0 ? _b : inferDefaultValue("opacity") });
      Object.assign(toStyle, { opacity: 0 });
    } else if (stage === "collapse") {
      const { collapse } = options || {};
      const { target, descendants, position: position2 } = collapse;
      if (elementType === "node") {
        if (descendants.includes(element.id)) {
          const [x2, y2, z2] = position2;
          Object.assign(toStyle, { x: x2, y: y2, z: z2 });
        }
      } else if (elementType === "combo") {
        if (element.id === target || descendants.includes(element.id)) {
          const [x2, y2] = position2;
          Object.assign(toStyle, { x: x2, y: y2, childrenNode: originalStyle.childrenNode });
        }
      } else if (elementType === "edge") {
        Object.assign(toStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });
      }
    } else if (stage === "expand") {
      const { expand } = options || {};
      const { target, descendants, position: position2 } = expand;
      if (elementType === "node") {
        if (element.id === target || descendants.includes(element.id)) {
          const [x2, y2, z2] = position2;
          Object.assign(fromStyle, { x: x2, y: y2, z: z2 });
        }
      } else if (elementType === "combo") {
        if (element.id === target || descendants.includes(element.id)) {
          const [x2, y2, z2] = position2;
          Object.assign(fromStyle, { x: x2, y: y2, z: z2, childrenNode: modifiedStyle.childrenNode });
        }
      } else if (elementType === "edge") {
        Object.assign(fromStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });
      }
    }
    return [
      Object.keys(fromStyle).length > 0 ? Object.assign({}, originalStyle, fromStyle) : originalStyle,
      Object.keys(toStyle).length > 0 ? Object.assign({}, modifiedStyle, toStyle) : modifiedStyle
    ];
  }
  stop() {
    this.animations.forEach((animation) => animation.cancel());
  }
  clear() {
    this.tasks = [];
  }
  /**
   * <zh/> 
   *
   * <en/> Release stock animation objects
   * @description see: https://github.com/antvis/G/issues/1731
   */
  release() {
    var _a3, _b;
    const { canvas: canvas2 } = this.context;
    const animationsWithPromises = (_b = (_a3 = canvas2.document) === null || _a3 === void 0 ? void 0 : _a3.timeline) === null || _b === void 0 ? void 0 : _b.animationsWithPromises;
    if (animationsWithPromises) {
      canvas2.document.timeline.animationsWithPromises = animationsWithPromises.filter((animation) => animation.playState !== "finished");
    }
  }
  destroy() {
    this.stop();
    this.animations.clear();
    this.tasks = [];
  }
}
class BatchController {
  constructor(context) {
    this.batchCount = 0;
    this.context = context;
  }
  emit(event) {
    const { graph: graph2 } = this.context;
    graph2.emit(event.type, event);
  }
  startBatch(initiate = true) {
    this.batchCount++;
    if (this.batchCount === 1)
      this.emit(new GraphLifeCycleEvent(GraphEvent.BATCH_START, { initiate }));
  }
  endBatch() {
    this.batchCount--;
    if (this.batchCount === 0)
      this.emit(new GraphLifeCycleEvent(GraphEvent.BATCH_END));
  }
  get isBatching() {
    return this.batchCount > 0;
  }
  destroy() {
    this.context = null;
  }
}
class BehaviorController extends ExtensionController {
  constructor(context) {
    super(context);
    this.currentTarget = null;
    this.currentTargetType = null;
    this.category = "behavior";
    this.forwardCanvasEvents = (event) => {
      const { target: originalTarget } = event;
      const target = eventTargetOf(originalTarget);
      if (!target)
        return;
      const { graph: graph2, canvas: canvas2 } = this.context;
      const { type: targetType, element: targetElement } = target;
      if ("destroyed" in targetElement && (isToBeDestroyed(targetElement) || targetElement.destroyed))
        return;
      const { type, detail, button: button2 } = event;
      const stdEvent = Object.assign(Object.assign({}, event), { target: targetElement, targetType, originalTarget });
      if (type === CommonEvent.POINTER_MOVE) {
        if (this.currentTarget !== targetElement) {
          if (this.currentTarget) {
            graph2.emit(`${this.currentTargetType}:${CommonEvent.POINTER_LEAVE}`, Object.assign(Object.assign({}, stdEvent), { type: CommonEvent.POINTER_LEAVE, target: this.currentTarget, targetType: this.currentTargetType }));
          }
          if (targetElement) {
            Object.assign(stdEvent, { type: CommonEvent.POINTER_ENTER });
            graph2.emit(`${targetType}:${CommonEvent.POINTER_ENTER}`, stdEvent);
          }
        }
        this.currentTarget = targetElement;
        this.currentTargetType = targetType;
      }
      if (!(type === CommonEvent.CLICK && button2 === 2)) {
        graph2.emit(`${targetType}:${type}`, stdEvent);
        graph2.emit(type, stdEvent);
      }
      if (type === CommonEvent.CLICK && detail === 2) {
        Object.assign(stdEvent, { type: CommonEvent.DBLCLICK });
        graph2.emit(`${targetType}:${CommonEvent.DBLCLICK}`, stdEvent);
        graph2.emit(CommonEvent.DBLCLICK, stdEvent);
      }
      if (type === CommonEvent.POINTER_DOWN && button2 === 2) {
        Object.assign(stdEvent, {
          type: CommonEvent.CONTEXT_MENU,
          preventDefault: () => {
            var _a3;
            (_a3 = canvas2.getContainer()) === null || _a3 === void 0 ? void 0 : _a3.addEventListener(CommonEvent.CONTEXT_MENU, (e3) => e3.preventDefault(), {
              once: true
            });
          }
        });
        graph2.emit(`${targetType}:${CommonEvent.CONTEXT_MENU}`, stdEvent);
        graph2.emit(CommonEvent.CONTEXT_MENU, stdEvent);
      }
    };
    this.forwardContainerEvents = (event) => {
      this.context.graph.emit(event.type, event);
    };
    this.forwardEvents();
    this.setBehaviors(this.context.options.behaviors || []);
  }
  setBehaviors(behaviors) {
    this.setExtensions(behaviors);
  }
  forwardEvents() {
    const container = this.context.canvas.getContainer();
    if (container) {
      [ContainerEvent.KEY_DOWN, ContainerEvent.KEY_UP].forEach((name) => {
        container.addEventListener(name, this.forwardContainerEvents);
      });
    }
    const canvas2 = this.context.canvas.document;
    if (canvas2) {
      [
        CommonEvent.CLICK,
        CommonEvent.DBLCLICK,
        CommonEvent.POINTER_OVER,
        CommonEvent.POINTER_LEAVE,
        CommonEvent.POINTER_ENTER,
        CommonEvent.POINTER_MOVE,
        CommonEvent.POINTER_OUT,
        CommonEvent.POINTER_DOWN,
        CommonEvent.POINTER_UP,
        CommonEvent.CONTEXT_MENU,
        CommonEvent.DRAG_START,
        CommonEvent.DRAG,
        CommonEvent.DRAG_END,
        CommonEvent.DRAG_ENTER,
        CommonEvent.DRAG_OVER,
        CommonEvent.DRAG_LEAVE,
        CommonEvent.DROP,
        CommonEvent.WHEEL
      ].forEach((name) => {
        canvas2.addEventListener(name, this.forwardCanvasEvents);
      });
    }
  }
  destroy() {
    const container = this.context.canvas.getContainer();
    if (container) {
      [ContainerEvent.KEY_DOWN, ContainerEvent.KEY_UP].forEach((name) => {
        container.removeEventListener(name, this.forwardContainerEvents);
      });
    }
    this.context.canvas.document.removeAllEventListeners();
    super.destroy();
  }
}
var __rest$1 = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
function toGraphlibData(data2) {
  const { id: id2 = idOf(data2), style, data: customData } = data2, rest = __rest$1(data2, ["id", "style", "data"]);
  const _data = Object.assign(Object.assign({}, data2), { style: Object.assign({}, style), data: Object.assign({}, customData) });
  if (isEdgeData(data2))
    return Object.assign({ id: id2, data: _data }, rest);
  return { id: id2, data: _data };
}
function toG6Data(data2) {
  return data2.data;
}
function createTreeStructure(model) {
  if (model.hasTreeStructure(TREE_KEY))
    return;
  model.attachTreeStructure(TREE_KEY);
  const edges = model.getAllEdges();
  for (const edge of edges) {
    const { source, target } = edge;
    model.setParent(target, source, TREE_KEY);
  }
}
class DataController {
  constructor() {
    this.latestRemovedComboIds = /* @__PURE__ */ new Set();
    this.comboIds = /* @__PURE__ */ new Set();
    this.changes = [];
    this.batchCount = 0;
    this.isTraceless = false;
    this.enableUpdateNodeLikeHierarchy = true;
    this.model = new Graph$9();
  }
  pushChange(change) {
    if (this.isTraceless)
      return;
    const { type } = change;
    if (type === ChangeType.NodeUpdated || type === ChangeType.EdgeUpdated || type === ChangeType.ComboUpdated) {
      const { value, original } = change;
      this.changes.push({ value: cloneElementData(value), original: cloneElementData(original), type });
    } else {
      this.changes.push({ value: cloneElementData(change.value), type });
    }
  }
  getChanges() {
    return this.changes;
  }
  clearChanges() {
    this.changes = [];
  }
  batch(callback) {
    this.batchCount++;
    this.model.batch(callback);
    this.batchCount--;
  }
  isBatching() {
    return this.batchCount > 0;
  }
  /**
   * <zh/> 
   *
   * <en/> Perform operations without leaving records
   * @param callback - <zh/>  | <en/> callback function
   * @remarks
   * <zh/> 
   *
   * <en/> Usually used to adjust elements at runtime and synchronize data to avoid triggering data changes and causing redraws
   */
  silence(callback) {
    this.isTraceless = true;
    callback();
    this.isTraceless = false;
  }
  isCombo(id2) {
    return this.comboIds.has(id2) || this.latestRemovedComboIds.has(id2);
  }
  getData() {
    return {
      nodes: this.getNodeData(),
      edges: this.getEdgeData(),
      combos: this.getComboData()
    };
  }
  getNodeData(ids) {
    return this.model.getAllNodes().reduce((acc, node) => {
      const data2 = toG6Data(node);
      if (this.isCombo(idOf(data2)))
        return acc;
      if (ids === void 0)
        acc.push(data2);
      else
        ids.includes(idOf(data2)) && acc.push(data2);
      return acc;
    }, []);
  }
  getEdgeDatum(id2) {
    return toG6Data(this.model.getEdge(id2));
  }
  getEdgeData(ids) {
    return this.model.getAllEdges().reduce((acc, edge) => {
      const data2 = toG6Data(edge);
      if (ids === void 0)
        acc.push(data2);
      else
        ids.includes(idOf(data2)) && acc.push(data2);
      return acc;
    }, []);
  }
  getComboData(ids) {
    return this.model.getAllNodes().reduce((acc, combo) => {
      const data2 = toG6Data(combo);
      if (!this.isCombo(idOf(data2)))
        return acc;
      if (ids === void 0)
        acc.push(data2);
      else
        ids.includes(idOf(data2)) && acc.push(data2);
      return acc;
    }, []);
  }
  getRootsData(hierarchyKey = TREE_KEY) {
    return this.model.getRoots(hierarchyKey).map(toG6Data);
  }
  getAncestorsData(id2, hierarchyKey) {
    const { model } = this;
    if (!model.hasNode(id2) || !model.hasTreeStructure(hierarchyKey))
      return [];
    return model.getAncestors(id2, hierarchyKey).map(toG6Data);
  }
  getDescendantsData(id2) {
    const root2 = this.getElementDataById(id2);
    const data2 = [];
    dfs$3(root2, (node) => {
      if (node !== root2)
        data2.push(node);
    }, (node) => this.getChildrenData(idOf(node)), "TB");
    return data2;
  }
  getParentData(id2, hierarchyKey) {
    const { model } = this;
    if (!hierarchyKey) {
      print.warn("The hierarchy structure key is not specified");
      return void 0;
    }
    if (!model.hasNode(id2) || !model.hasTreeStructure(hierarchyKey))
      return void 0;
    const parent = model.getParent(id2, hierarchyKey);
    return parent ? toG6Data(parent) : void 0;
  }
  getChildrenData(id2) {
    const structureKey = this.getElementType(id2) === "node" ? TREE_KEY : COMBO_KEY;
    const { model } = this;
    if (!model.hasNode(id2) || !model.hasTreeStructure(structureKey))
      return [];
    return model.getChildren(id2, structureKey).map(toG6Data);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the data of the specified type of element
   * @param elementType - <zh/>  | <en/> element type
   * @returns <zh/>  | <en/> element data
   */
  getElementsDataByType(elementType) {
    if (elementType === "node")
      return this.getNodeData();
    if (elementType === "edge")
      return this.getEdgeData();
    if (elementType === "combo")
      return this.getComboData();
    return [];
  }
  /**
   * <zh/>  ID 
   *
   * <en/> Get the data of the element by ID, no need to care about the type of the element
   * @param id - <zh/>  ID  | <en/> element ID array
   * @returns <zh/>  | <en/> data of the element
   */
  getElementDataById(id2) {
    const type = this.getElementType(id2);
    if (type === "edge")
      return this.getEdgeDatum(id2);
    return this.getNodeLikeDatum(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get node data
   * @param id - <zh/>  ID | <en/> node ID
   * @returns <zh/>  | <en/> node data
   */
  getNodeLikeDatum(id2) {
    const data2 = this.model.getNode(id2);
    return toG6Data(data2);
  }
  /**
   * <zh/>  combo 
   *
   * <en/> Get all node and combo data
   * @param ids - <zh/>  combo ID  | <en/> node and combo ID array
   * @returns <zh/>  combo  | <en/> node and combo data
   */
  getNodeLikeData(ids) {
    return this.model.getAllNodes().reduce((acc, node) => {
      const data2 = toG6Data(node);
      if (ids)
        ids.includes(idOf(data2)) && acc.push(data2);
      else
        acc.push(data2);
      return acc;
    }, []);
  }
  getElementDataByState(elementType, state) {
    const elementData = this.getElementsDataByType(elementType);
    return elementData.filter((datum) => {
      var _a3;
      return (_a3 = datum.states) === null || _a3 === void 0 ? void 0 : _a3.includes(state);
    });
  }
  getElementState(id2) {
    var _a3;
    return ((_a3 = this.getElementDataById(id2)) === null || _a3 === void 0 ? void 0 : _a3.states) || [];
  }
  hasNode(id2) {
    return this.model.hasNode(id2) && !this.isCombo(id2);
  }
  hasEdge(id2) {
    return this.model.hasEdge(id2);
  }
  hasCombo(id2) {
    return this.model.hasNode(id2) && this.isCombo(id2);
  }
  getRelatedEdgesData(id2, direction2 = "both") {
    return this.model.getRelatedEdges(id2, direction2).map(toG6Data);
  }
  getNeighborNodesData(id2) {
    return this.model.getNeighbors(id2).map(toG6Data);
  }
  setData(data2) {
    const { nodes: modifiedNodes = [], edges: modifiedEdges = [], combos: modifiedCombos = [] } = data2;
    const { nodes: originalNodes, edges: originalEdges, combos: originalCombos } = this.getData();
    const nodeDiff = arrayDiff(originalNodes, modifiedNodes, (node) => idOf(node), isElementDataEqual);
    const edgeDiff = arrayDiff(originalEdges, modifiedEdges, (edge) => idOf(edge), isElementDataEqual);
    const comboDiff = arrayDiff(originalCombos, modifiedCombos, (combo) => idOf(combo), isElementDataEqual);
    this.batch(() => {
      const dataToAdd = {
        nodes: nodeDiff.enter,
        edges: edgeDiff.enter,
        combos: comboDiff.enter
      };
      this.addData(dataToAdd);
      this.computeZIndex(dataToAdd, "add", true);
      const dataToUpdate = {
        nodes: nodeDiff.update,
        edges: edgeDiff.update,
        combos: comboDiff.update
      };
      this.updateData(dataToUpdate);
      this.computeZIndex(dataToUpdate, "update", true);
      const dataToRemove = {
        nodes: nodeDiff.exit.map(idOf),
        edges: edgeDiff.exit.map(idOf),
        combos: comboDiff.exit.map(idOf)
      };
      this.removeData(dataToRemove);
    });
  }
  addData(data2) {
    const { nodes, edges, combos } = data2;
    this.batch(() => {
      this.addComboData(combos);
      this.addNodeData(nodes);
      this.addEdgeData(edges);
    });
    this.computeZIndex(data2, "add");
  }
  addNodeData(nodes = []) {
    if (!nodes.length)
      return;
    this.model.addNodes(nodes.map((node) => {
      this.pushChange({ value: node, type: ChangeType.NodeAdded });
      return toGraphlibData(node);
    }));
    this.updateNodeLikeHierarchy(nodes);
    this.computeZIndex({ nodes }, "add");
  }
  addEdgeData(edges = []) {
    if (!edges.length)
      return;
    this.model.addEdges(edges.map((edge) => {
      this.pushChange({ value: edge, type: ChangeType.EdgeAdded });
      return toGraphlibData(edge);
    }));
    this.computeZIndex({ edges }, "add");
  }
  addComboData(combos = []) {
    if (!combos.length)
      return;
    const { model } = this;
    if (!model.hasTreeStructure(COMBO_KEY)) {
      model.attachTreeStructure(COMBO_KEY);
    }
    model.addNodes(combos.map((combo) => {
      this.comboIds.add(idOf(combo));
      this.pushChange({ value: combo, type: ChangeType.ComboAdded });
      return toGraphlibData(combo);
    }));
    this.updateNodeLikeHierarchy(combos);
    this.computeZIndex({ combos }, "add");
  }
  addChildrenData(parentId, childrenData) {
    const parentData = this.getNodeLikeDatum(parentId);
    const childrenId = childrenData.map(idOf);
    this.addNodeData(childrenData);
    this.updateNodeData([{ id: parentId, children: [...parentData.children || [], ...childrenId] }]);
    this.addEdgeData(childrenId.map((childId) => ({ source: parentId, target: childId })));
  }
  /**
   * <zh/>  zIndex
   *
   * <en/> Calculate zIndex
   * @param data - <zh/>  | <en/> newly added data
   * @param type - <zh/>  | <en/> operation type
   * @param force - <zh/>  | <en/> ignore batch processing
   * @remarks
   * <zh/> 
   * - 
   * - / combo
   * -  children
   *
   * <en/> The situation of calling this function:
   * - Add element
   * - Update the combo of the node/combo
   * - Update the children of the node
   */
  computeZIndex(data2, type, force = false) {
    if (!force && this.isBatching())
      return;
    this.batch(() => {
      const { nodes = [], edges = [], combos = [] } = data2;
      combos.forEach((combo) => {
        var _a3, _b, _c;
        const id2 = idOf(combo);
        if (type === "add" && isNumber((_a3 = combo.style) === null || _a3 === void 0 ? void 0 : _a3.zIndex))
          return;
        if (type === "update" && !("combo" in combo))
          return;
        const parent = this.getParentData(id2, COMBO_KEY);
        const zIndex2 = parent ? ((_c = (_b = parent.style) === null || _b === void 0 ? void 0 : _b.zIndex) !== null && _c !== void 0 ? _c : 0) + 1 : 0;
        this.preventUpdateNodeLikeHierarchy(() => {
          this.updateComboData([{ id: id2, style: { zIndex: zIndex2 } }]);
        });
      });
      nodes.forEach((node) => {
        var _a3, _b, _c;
        const id2 = idOf(node);
        if (type === "add" && isNumber((_a3 = node.style) === null || _a3 === void 0 ? void 0 : _a3.zIndex))
          return;
        if (type === "update" && !("combo" in node) && !("children" in node))
          return;
        let zIndex2 = 0;
        const comboParent = this.getParentData(id2, COMBO_KEY);
        if (comboParent) {
          zIndex2 = (((_b = comboParent.style) === null || _b === void 0 ? void 0 : _b.zIndex) || 0) + 1;
        } else {
          const nodeParent = this.getParentData(id2, TREE_KEY);
          if (nodeParent)
            zIndex2 = ((_c = nodeParent === null || nodeParent === void 0 ? void 0 : nodeParent.style) === null || _c === void 0 ? void 0 : _c.zIndex) || 0;
        }
        this.preventUpdateNodeLikeHierarchy(() => {
          this.updateNodeData([{ id: id2, style: { zIndex: zIndex2 } }]);
        });
      });
      edges.forEach((edge) => {
        var _a3, _b, _c, _d, _e;
        if (isNumber((_a3 = edge.style) === null || _a3 === void 0 ? void 0 : _a3.zIndex))
          return;
        let { id: id2, source, target } = edge;
        if (!id2)
          id2 = idOf(edge);
        else {
          const datum = this.getEdgeDatum(id2);
          source = datum.source;
          target = datum.target;
        }
        if (!source || !target)
          return;
        const sourceZIndex = ((_c = (_b = this.getNodeLikeDatum(source)) === null || _b === void 0 ? void 0 : _b.style) === null || _c === void 0 ? void 0 : _c.zIndex) || 0;
        const targetZIndex = ((_e = (_d = this.getNodeLikeDatum(target)) === null || _d === void 0 ? void 0 : _d.style) === null || _e === void 0 ? void 0 : _e.zIndex) || 0;
        this.updateEdgeData([{ id: idOf(edge), style: { zIndex: Math.max(sourceZIndex, targetZIndex) - 1 } }]);
      });
    });
  }
  /**
   * <zh/>  zIndex
   *
   * <en/> Calculate the zIndex after the element is placed on top
   * @param id - <zh/>  ID | <en/> ID of the element
   * @returns <zh/> zIndex | <en/> zIndex
   */
  getFrontZIndex(id2) {
    var _a3;
    const elementType = this.getElementType(id2);
    const elementData = this.getElementDataById(id2);
    const data2 = this.getData();
    Object.assign(data2, {
      [`${elementType}s`]: data2[`${elementType}s`].filter((element) => idOf(element) !== id2)
    });
    if (elementType === "combo") {
      if (!isCollapsed(elementData)) {
        const ancestorIds = new Set(this.getAncestorsData(id2, COMBO_KEY).map(idOf));
        data2.nodes = data2.nodes.filter((element) => !ancestorIds.has(idOf(element)));
        data2.combos = data2.combos.filter((element) => !ancestorIds.has(idOf(element)));
        data2.edges = data2.edges.filter(({ source, target }) => !ancestorIds.has(source) && !ancestorIds.has(target));
      }
    }
    return Math.max(((_a3 = elementData.style) === null || _a3 === void 0 ? void 0 : _a3.zIndex) || 0, 0, ...Object.values(data2).flat().map((datum) => {
      var _a4;
      return (((_a4 = datum === null || datum === void 0 ? void 0 : datum.style) === null || _a4 === void 0 ? void 0 : _a4.zIndex) || 0) + 1;
    }));
  }
  updateNodeLikeHierarchy(data2) {
    if (!this.enableUpdateNodeLikeHierarchy)
      return;
    const { model } = this;
    data2.forEach((datum) => {
      const id2 = idOf(datum);
      const parent = parentIdOf(datum);
      if (parent !== void 0) {
        if (!model.hasTreeStructure(COMBO_KEY))
          model.attachTreeStructure(COMBO_KEY);
        if (parent === null) {
          this.refreshComboData(id2);
        }
        this.setParent(id2, parentIdOf(datum), COMBO_KEY);
      }
      const children = datum.children || [];
      if (children.length) {
        if (!model.hasTreeStructure(TREE_KEY))
          model.attachTreeStructure(TREE_KEY);
        const _children = children.filter((child) => model.hasNode(child));
        _children.forEach((child) => this.setParent(child, id2, TREE_KEY));
        if (_children.length !== children.length) {
          this.updateNodeData([{ id: id2, children: _children }]);
        }
      }
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Do not update the node hierarchy when executing changes
   * @param callback - <zh/>  | <en/> change function
   */
  preventUpdateNodeLikeHierarchy(callback) {
    this.enableUpdateNodeLikeHierarchy = false;
    callback();
    this.enableUpdateNodeLikeHierarchy = true;
  }
  updateData(data2) {
    const { nodes, edges, combos } = data2;
    this.batch(() => {
      this.updateNodeData(nodes);
      this.updateComboData(combos);
      this.updateEdgeData(edges);
    });
    this.computeZIndex(data2, "update");
  }
  updateNodeData(nodes = []) {
    if (!nodes.length)
      return;
    const { model } = this;
    this.batch(() => {
      const modifiedNodes = [];
      nodes.forEach((modifiedNode) => {
        const id2 = idOf(modifiedNode);
        const originalNode = toG6Data(model.getNode(id2));
        if (isElementDataEqual(originalNode, modifiedNode))
          return;
        const value = mergeElementsData(originalNode, modifiedNode);
        this.pushChange({ value, original: originalNode, type: ChangeType.NodeUpdated });
        model.mergeNodeData(id2, value);
        modifiedNodes.push(value);
      });
      this.updateNodeLikeHierarchy(modifiedNodes);
    });
    this.computeZIndex({ nodes }, "update");
  }
  /**
   * <zh/> 
   *
   * <en/> Submit all data to the change record for redrawing
   */
  refreshData() {
    const { nodes, edges, combos } = this.getData();
    nodes.forEach((node) => {
      this.pushChange({ value: node, original: node, type: ChangeType.NodeUpdated });
    });
    edges.forEach((edge) => {
      this.pushChange({ value: edge, original: edge, type: ChangeType.EdgeUpdated });
    });
    combos.forEach((combo) => {
      this.pushChange({ value: combo, original: combo, type: ChangeType.ComboUpdated });
    });
  }
  syncNodeLikeDatum(datum) {
    const { model } = this;
    const id2 = idOf(datum);
    if (!model.hasNode(id2))
      return;
    const original = toG6Data(model.getNode(id2));
    const value = mergeElementsData(original, datum);
    model.mergeNodeData(id2, value);
  }
  syncEdgeDatum(datum) {
    const { model } = this;
    const id2 = idOf(datum);
    if (!model.hasEdge(id2))
      return;
    const original = toG6Data(model.getEdge(id2));
    const value = mergeElementsData(original, datum);
    model.mergeEdgeData(id2, value);
  }
  updateEdgeData(edges = []) {
    if (!edges.length)
      return;
    const { model } = this;
    this.batch(() => {
      edges.forEach((modifiedEdge) => {
        const id2 = idOf(modifiedEdge);
        const originalEdge = toG6Data(model.getEdge(id2));
        if (isElementDataEqual(originalEdge, modifiedEdge))
          return;
        if (modifiedEdge.source && originalEdge.source !== modifiedEdge.source) {
          model.updateEdgeSource(id2, modifiedEdge.source);
        }
        if (modifiedEdge.target && originalEdge.target !== modifiedEdge.target) {
          model.updateEdgeTarget(id2, modifiedEdge.target);
        }
        const updatedData = mergeElementsData(originalEdge, modifiedEdge);
        this.pushChange({ value: updatedData, original: originalEdge, type: ChangeType.EdgeUpdated });
        model.mergeEdgeData(id2, updatedData);
      });
    });
    this.computeZIndex({ edges }, "update");
  }
  updateComboData(combos = []) {
    if (!combos.length)
      return;
    const { model } = this;
    model.batch(() => {
      const modifiedCombos = [];
      combos.forEach((modifiedCombo) => {
        const id2 = idOf(modifiedCombo);
        const originalCombo = toG6Data(model.getNode(id2));
        if (isElementDataEqual(originalCombo, modifiedCombo))
          return;
        const value = mergeElementsData(originalCombo, modifiedCombo);
        this.pushChange({ value, original: originalCombo, type: ChangeType.ComboUpdated });
        model.mergeNodeData(id2, value);
        modifiedCombos.push(value);
      });
      this.updateNodeLikeHierarchy(modifiedCombos);
    });
    this.computeZIndex({ combos }, "update");
  }
  /**
   * <zh/> 
   *
   * <en/> Set the parent node of the node
   * @param id - <zh/>  ID | <en/> node ID
   * @param parent - <zh/>  ID | <en/> parent node ID
   * @param hierarchyKey - <zh/>  | <en/> hierarchy type
   * @param update - <zh/> / | <en/> add new/old parent node data update record
   */
  setParent(id2, parent, hierarchyKey, update = true) {
    if (id2 === parent)
      return;
    const elementData = this.getNodeLikeDatum(id2);
    const originalParentId = parentIdOf(elementData);
    if (originalParentId !== parent && hierarchyKey === COMBO_KEY) {
      const modifiedDatum = { id: id2, combo: parent };
      if (this.isCombo(id2))
        this.syncNodeLikeDatum(modifiedDatum);
      else
        this.syncNodeLikeDatum(modifiedDatum);
    }
    this.model.setParent(id2, parent, hierarchyKey);
    if (update && hierarchyKey === COMBO_KEY) {
      uniq([originalParentId, parent]).forEach((pId) => {
        if (pId !== void 0)
          this.refreshComboData(pId);
      });
    }
  }
  /**
   * <zh/>  combo 
   *
   * <en/> Refresh combo data
   * @param id - <zh/> combo ID | <en/> combo ID
   * @remarks
   * <zh/> 
   *
   * <en/> Will not change the data, but will trigger data change events
   */
  refreshComboData(id2) {
    const combo = this.getComboData([id2])[0];
    const ancestors = this.getAncestorsData(id2, COMBO_KEY);
    if (combo)
      this.pushChange({ value: combo, original: combo, type: ChangeType.ComboUpdated });
    ancestors.forEach((value) => {
      this.pushChange({ value, original: value, type: ChangeType.ComboUpdated });
    });
  }
  getElementPosition(id2) {
    const datum = this.getElementDataById(id2);
    return positionOf(datum);
  }
  translateNodeLikeBy(id2, offset) {
    if (this.isCombo(id2))
      this.translateComboBy(id2, offset);
    else
      this.translateNodeBy(id2, offset);
  }
  translateNodeLikeTo(id2, position2) {
    if (this.isCombo(id2))
      this.translateComboTo(id2, position2);
    else
      this.translateNodeTo(id2, position2);
  }
  translateNodeBy(id2, offset) {
    const curr = this.getElementPosition(id2);
    const position2 = add$4(curr, [...offset, 0].slice(0, 3));
    this.translateNodeTo(id2, position2);
  }
  translateNodeTo(id2, position2) {
    const [x2 = 0, y2 = 0, z2 = 0] = position2;
    this.preventUpdateNodeLikeHierarchy(() => {
      this.updateNodeData([{ id: id2, style: { x: x2, y: y2, z: z2 } }]);
    });
  }
  translateComboBy(id2, offset) {
    const [dx = 0, dy = 0, dz = 0] = offset;
    if ([dx, dy, dz].some(isNaN) || [dx, dy, dz].every((o2) => o2 === 0))
      return;
    const combo = this.getComboData([id2])[0];
    if (!combo)
      return;
    const seenNodeLikeIds = /* @__PURE__ */ new Set();
    dfs$3(combo, (succeed) => {
      const succeedID = idOf(succeed);
      if (seenNodeLikeIds.has(succeedID))
        return;
      seenNodeLikeIds.add(succeedID);
      const [x2, y2, z2] = positionOf(succeed);
      const value = mergeElementsData(succeed, {
        style: { x: x2 + dx, y: y2 + dy, z: z2 + dz }
      });
      this.pushChange({
        value,
        // @ts-ignore
        original: succeed,
        type: this.isCombo(succeedID) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
      });
      this.model.mergeNodeData(succeedID, value);
    }, (node) => this.getChildrenData(idOf(node)), "BT");
  }
  translateComboTo(id2, position2) {
    var _a3;
    if (position2.some(isNaN))
      return;
    const [tx = 0, ty = 0, tz = 0] = position2;
    const combo = (_a3 = this.getComboData([id2])) === null || _a3 === void 0 ? void 0 : _a3[0];
    if (!combo)
      return;
    const [comboX, comboY, comboZ] = positionOf(combo);
    const dx = tx - comboX;
    const dy = ty - comboY;
    const dz = tz - comboZ;
    dfs$3(combo, (succeed) => {
      const succeedId = idOf(succeed);
      const [x2, y2, z2] = positionOf(succeed);
      const value = mergeElementsData(succeed, {
        style: { x: x2 + dx, y: y2 + dy, z: z2 + dz }
      });
      this.pushChange({
        value,
        // @ts-ignore
        original: succeed,
        type: this.isCombo(succeedId) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
      });
      this.model.mergeNodeData(succeedId, value);
    }, (node) => this.getChildrenData(idOf(node)), "BT");
  }
  removeData(data2) {
    const { nodes, edges, combos } = data2;
    this.batch(() => {
      this.removeEdgeData(edges);
      this.removeNodeData(nodes);
      this.removeComboData(combos);
      this.latestRemovedComboIds = new Set(combos);
    });
  }
  removeNodeData(ids = []) {
    if (!ids.length)
      return;
    this.batch(() => {
      ids.forEach((id2) => {
        this.removeEdgeData(this.getRelatedEdgesData(id2).map(idOf));
        this.pushChange({ value: this.getNodeData([id2])[0], type: ChangeType.NodeRemoved });
        this.removeNodeLikeHierarchy(id2);
      });
      this.model.removeNodes(ids);
    });
  }
  removeEdgeData(ids = []) {
    if (!ids.length)
      return;
    ids.forEach((id2) => this.pushChange({ value: this.getEdgeData([id2])[0], type: ChangeType.EdgeRemoved }));
    this.model.removeEdges(ids);
  }
  removeComboData(ids = []) {
    if (!ids.length)
      return;
    this.batch(() => {
      ids.forEach((id2) => {
        this.pushChange({ value: this.getComboData([id2])[0], type: ChangeType.ComboRemoved });
        this.removeNodeLikeHierarchy(id2);
        this.comboIds.delete(id2);
      });
      this.model.removeNodes(ids);
    });
  }
  /**
   * <zh/>  children 
   *
   * <en/> Remove the node hierarchy and move its child nodes to the parent node's children list
   * @param id - <zh/>  | <en/> node to be processed
   */
  removeNodeLikeHierarchy(id2) {
    if (this.model.hasTreeStructure(COMBO_KEY)) {
      const grandParent = parentIdOf(this.getNodeLikeDatum(id2));
      this.setParent(id2, void 0, COMBO_KEY, false);
      this.model.getChildren(id2, COMBO_KEY).forEach((child) => {
        const childData = toG6Data(child);
        const childId = idOf(childData);
        this.setParent(idOf(childData), grandParent, COMBO_KEY, false);
        const value = mergeElementsData(childData, {
          id: idOf(childData),
          combo: grandParent
        });
        this.pushChange({
          value,
          original: childData,
          type: this.isCombo(childId) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
        });
        this.model.mergeNodeData(idOf(childData), value);
      });
      if (!isNil(grandParent))
        this.refreshComboData(grandParent);
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Get the type of the element
   * @param id - <zh/>  ID | <en/> ID of the element
   * @returns <zh/>  | <en/> type of the element
   */
  getElementType(id2) {
    if (this.model.hasNode(id2)) {
      if (this.isCombo(id2))
        return "combo";
      return "node";
    }
    if (this.model.hasEdge(id2))
      return "edge";
    throw new Error(format(`Unknown element type of id: ${id2}`));
  }
  destroy() {
    const { model } = this;
    const nodes = model.getAllNodes();
    const edges = model.getAllEdges();
    model.removeEdges(edges.map((edge) => edge.id));
    model.removeNodes(nodes.map((node) => node.id));
    this.context = {};
  }
}
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ElementController {
  constructor(context) {
    this.elementMap = {};
    this.shapeTypeMap = {};
    this.paletteStyle = {};
    this.defaultStyle = {};
    this.stateStyle = {};
    this.visibilityCache = /* @__PURE__ */ new WeakMap();
    this.context = context;
  }
  init() {
    this.initContainer();
  }
  initContainer() {
    if (!this.container || this.container.destroyed) {
      const { canvas: canvas2 } = this.context;
      this.container = canvas2.appendChild(new Group({ className: "elements" }));
    }
  }
  emit(event, context) {
    if (context.silence)
      return;
    emit(this.context.graph, event);
  }
  forEachElementData(callback) {
    ELEMENT_TYPES.forEach((elementType) => {
      const elementData = this.context.model.getElementsDataByType(elementType);
      callback(elementType, elementData);
    });
  }
  getElementType(elementType, datum) {
    var _a3;
    const { options, graph: graph2 } = this.context;
    const userDefinedType = isOverridable(datum) ? ((_a3 = options[elementType]) === null || _a3 === void 0 ? void 0 : _a3.type) || datum.type : datum.type;
    if (!userDefinedType) {
      if (elementType === "edge")
        return "line";
      else
        return "circle";
    }
    if (typeof userDefinedType === "string")
      return userDefinedType;
    return userDefinedType.call(graph2, datum);
  }
  getTheme(elementType) {
    return themeOf(this.context.options)[elementType] || {};
  }
  getThemeStyle(elementType) {
    return this.getTheme(elementType).style || {};
  }
  getThemeStateStyle(elementType, states) {
    const { state = {} } = this.getTheme(elementType);
    return Object.assign({}, ...states.map((name) => state[name] || {}));
  }
  computePaletteStyle() {
    const { options } = this.context;
    this.paletteStyle = {};
    this.forEachElementData((elementType, elementData) => {
      var _a3, _b;
      const palette = Object.assign({}, parsePalette((_a3 = this.getTheme(elementType)) === null || _a3 === void 0 ? void 0 : _a3.palette), parsePalette((_b = options[elementType]) === null || _b === void 0 ? void 0 : _b.palette));
      if (palette === null || palette === void 0 ? void 0 : palette.field) {
        Object.assign(this.paletteStyle, assignColorByPalette(elementData, palette));
      }
    });
  }
  getPaletteStyle(elementType, id2) {
    const color2 = this.paletteStyle[id2];
    if (!color2)
      return {};
    if (elementType === "edge")
      return { stroke: color2 };
    return { fill: color2 };
  }
  /**
   * <zh/> 
   *
   * <en/> compute default style of single element
   */
  computeElementDefaultStyle(elementType, context) {
    var _a3;
    const { options } = this.context;
    const defaultStyle = ((_a3 = options[elementType]) === null || _a3 === void 0 ? void 0 : _a3.style) || {};
    if ("transform" in defaultStyle && Array.isArray(defaultStyle.transform)) {
      defaultStyle.transform = [...defaultStyle.transform];
    }
    this.defaultStyle[idOf(context.datum)] = computeElementCallbackStyle(defaultStyle, context);
  }
  computeElementsDefaultStyle(ids) {
    const { graph: graph2 } = this.context;
    this.forEachElementData((elementType, elementData) => {
      const length2 = elementData.length;
      for (let i2 = 0; i2 < length2; i2++) {
        const datum = elementData[i2];
        if (ids === void 0 || ids.includes(idOf(datum))) {
          this.computeElementDefaultStyle(elementType, { datum, graph: graph2 });
        }
      }
    });
  }
  getDefaultStyle(id2) {
    return this.defaultStyle[id2] || {};
  }
  getElementState(id2) {
    try {
      const { model } = this.context;
      return model.getElementState(id2);
    } catch (_a3) {
      return [];
    }
  }
  /**
   * <zh/> 
   *
   * <en/> get single state style of single element
   */
  getElementStateStyle(elementType, state, context) {
    var _a3, _b;
    const { options } = this.context;
    const stateStyle = ((_b = (_a3 = options[elementType]) === null || _a3 === void 0 ? void 0 : _a3.state) === null || _b === void 0 ? void 0 : _b[state]) || {};
    return computeElementCallbackStyle(stateStyle, context);
  }
  /**
   * <zh/> 
   *
   * <en/> compute merged state style of single element
   */
  computeElementStatesStyle(elementType, states, context) {
    this.stateStyle[idOf(context.datum)] = Object.assign({}, ...states.map((state) => this.getElementStateStyle(elementType, state, context)));
  }
  /**
   * <zh/> 
   *
   * <en/> compute state style of all elements
   * @param ids - <zh/>  | <en/> compute state style of specified elements
   */
  computeElementsStatesStyle(ids) {
    const { graph: graph2 } = this.context;
    this.forEachElementData((elementType, elementData) => {
      const length2 = elementData.length;
      for (let i2 = 0; i2 < length2; i2++) {
        const datum = elementData[i2];
        if (ids === void 0 || ids.includes(idOf(datum))) {
          const states = this.getElementState(idOf(datum));
          this.computeElementStatesStyle(elementType, states, { datum, graph: graph2 });
        }
      }
    });
  }
  getStateStyle(id2) {
    return this.stateStyle[id2] || {};
  }
  computeStyle(stage, ids) {
    const skip = ["translate", "zIndex"];
    if (stage && skip.includes(stage))
      return;
    this.computePaletteStyle();
    this.computeElementsDefaultStyle(ids);
    this.computeElementsStatesStyle(ids);
  }
  getElement(id2) {
    return this.elementMap[id2];
  }
  getNodes() {
    return this.context.model.getNodeData().map(({ id: id2 }) => this.elementMap[id2]);
  }
  getEdges() {
    return this.context.model.getEdgeData().map((edge) => this.elementMap[idOf(edge)]);
  }
  getCombos() {
    return this.context.model.getComboData().map(({ id: id2 }) => this.elementMap[id2]);
  }
  getElementComputedStyle(elementType, datum) {
    const id2 = idOf(datum);
    const themeStyle = this.getThemeStyle(elementType);
    const paletteStyle = this.getPaletteStyle(elementType, id2);
    const dataStyle = datum.style || {};
    const defaultStyle = this.getDefaultStyle(id2);
    const themeStateStyle = this.getThemeStateStyle(elementType, this.getElementState(id2));
    const stateStyle = this.getStateStyle(id2);
    const style = isOverridable(datum) ? Object.assign({}, themeStyle, paletteStyle, dataStyle, defaultStyle, themeStateStyle, stateStyle) : Object.assign({}, dataStyle);
    if (elementType === "combo") {
      const childrenData = this.context.model.getChildrenData(id2);
      const isCollapsed2 = !!style.collapsed;
      const childrenNode = isCollapsed2 ? [] : childrenData.map(idOf).filter((id3) => this.getElement(id3));
      Object.assign(style, { childrenNode, childrenData });
    }
    return style;
  }
  getDrawData(context) {
    this.init();
    const data2 = this.computeChangesAndDrawData(context);
    if (!data2)
      return null;
    const { type = "draw", stage = type } = context;
    this.markDestroyElement(data2.drawData);
    this.computeStyle(stage);
    return { type, stage, data: data2 };
  }
  /**
   * <zh/> 
   *
   * <en/> start render process
   */
  draw(context = { animation: true }) {
    const drawData = this.getDrawData(context);
    if (!drawData)
      return;
    const { data: { drawData: { add: add2, update, remove } } } = drawData;
    this.destroyElements(remove, context);
    this.createElements(add2, context);
    this.updateElements(update, context);
    return this.setAnimationTask(context, drawData);
  }
  preLayoutDraw() {
    return __awaiter$3(this, arguments, void 0, function* (context = { animation: true }) {
      var _a3, _b;
      const preResult = this.getDrawData(context);
      if (!preResult)
        return;
      const { data: { drawData } } = preResult;
      yield (_b = (_a3 = this.context.layout) === null || _a3 === void 0 ? void 0 : _a3.preLayout) === null || _b === void 0 ? void 0 : _b.call(_a3, drawData);
      const { add: add2, update, remove } = drawData;
      this.destroyElements(remove, context);
      this.createElements(add2, context);
      this.updateElements(update, context);
      return this.setAnimationTask(context, preResult);
    });
  }
  setAnimationTask(context, data2) {
    const { animation, silence } = context;
    const { data: { dataChanges, drawData }, stage, type } = data2;
    return this.context.animation.animate(animation, silence ? {} : {
      before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {
        dataChanges,
        animation,
        stage,
        render: type === "render"
      }), context),
      beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.DRAW, animation2, drawData), context),
      afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.DRAW, animation2, drawData), context),
      after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {
        dataChanges,
        animation,
        stage,
        render: type === "render",
        firstRender: this.context.graph.rendered === false
      }), context)
    });
  }
  computeChangesAndDrawData(context) {
    const { model } = this.context;
    const dataChanges = model.getChanges();
    const tasks2 = reduceDataChanges(dataChanges);
    if (tasks2.length === 0)
      return null;
    const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [] } = groupBy$1(tasks2, (change) => change.type);
    const moveToAddedIfUnrendered = (updated, added) => {
      const keptUpdates = [];
      updated.forEach((change) => {
        const id2 = idOf(change.value);
        if (!this.getElement(id2)) {
          added.push(change);
        } else {
          keptUpdates.push(change);
        }
      });
      return keptUpdates;
    };
    const finalNodeUpdated = moveToAddedIfUnrendered(NodeUpdated, NodeAdded);
    const finalEdgeUpdated = moveToAddedIfUnrendered(EdgeUpdated, EdgeAdded);
    const finalComboUpdated = moveToAddedIfUnrendered(ComboUpdated, ComboAdded);
    const dataOf = (data2) => new Map(data2.map((datum) => {
      const data3 = datum.value;
      return [idOf(data3), data3];
    }));
    const input = {
      add: {
        nodes: dataOf(NodeAdded),
        edges: dataOf(EdgeAdded),
        combos: dataOf(ComboAdded)
      },
      update: {
        nodes: dataOf(finalNodeUpdated),
        edges: dataOf(finalEdgeUpdated),
        combos: dataOf(finalComboUpdated)
      },
      remove: {
        nodes: dataOf(NodeRemoved),
        edges: dataOf(EdgeRemoved),
        combos: dataOf(ComboRemoved)
      }
    };
    const drawData = this.transformData(input, context);
    model.clearChanges();
    return { dataChanges, drawData };
  }
  transformData(input, context) {
    const transforms = this.context.transform.getTransformInstance();
    return Object.values(transforms).reduce((data2, transform2) => transform2.beforeDraw(data2, context), input);
  }
  createElement(elementType, datum, context) {
    var _a3;
    const id2 = idOf(datum);
    const currentElement = this.getElement(id2);
    if (currentElement)
      return;
    const type = this.getElementType(elementType, datum);
    const style = this.getElementComputedStyle(elementType, datum);
    const Ctor = getExtension(elementType, type);
    if (!Ctor)
      return print.warn(`The element ${type} of ${elementType} is not registered.`);
    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_CREATE, elementType, datum), context);
    const element = this.container.appendChild(new Ctor({
      id: id2,
      context: this.context,
      style
    }));
    this.shapeTypeMap[id2] = type;
    this.elementMap[id2] = element;
    const { stage = "enter" } = context;
    (_a3 = this.context.animation) === null || _a3 === void 0 ? void 0 : _a3.add({
      element,
      elementType,
      stage,
      originalStyle: Object.assign({}, element.attributes),
      updatedStyle: style
    }, {
      after: () => {
        var _a4;
        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_CREATE, elementType, datum), context);
        (_a4 = element.onCreate) === null || _a4 === void 0 ? void 0 : _a4.call(element);
      }
    });
  }
  createElements(data2, context) {
    const { nodes, edges, combos } = data2;
    const iteration = [
      ["node", nodes],
      ["combo", combos],
      ["edge", edges]
    ];
    iteration.forEach(([elementType, elementData]) => {
      elementData.forEach((datum) => this.createElement(elementType, datum, context));
    });
  }
  getUpdateStageStyle(elementType, datum, context) {
    const { stage = "update" } = context;
    if (stage === "translate") {
      if (elementType === "node" || elementType === "combo") {
        const { style: { x: x2 = 0, y: y2 = 0, z: z2 = 0 } = {} } = datum;
        return { x: x2, y: y2, z: z2 };
      } else
        return {};
    }
    return this.getElementComputedStyle(elementType, datum);
  }
  updateElement(elementType, datum, context) {
    var _a3;
    const id2 = idOf(datum);
    const { stage = "update" } = context;
    const element = this.getElement(id2);
    if (!element)
      return () => null;
    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_UPDATE, elementType, datum), context);
    const type = this.getElementType(elementType, datum);
    const style = this.getUpdateStageStyle(elementType, datum, context);
    if (this.shapeTypeMap[id2] !== type) {
      element.destroy();
      delete this.shapeTypeMap[id2];
      delete this.elementMap[id2];
      this.createElement(elementType, datum, { animation: false, silence: true });
    }
    const exactStage = stage !== "visibility" ? stage : style.visibility === "hidden" ? "hide" : "show";
    if (exactStage === "hide")
      delete style["visibility"];
    (_a3 = this.context.animation) === null || _a3 === void 0 ? void 0 : _a3.add({
      element,
      elementType,
      stage: exactStage,
      originalStyle: Object.assign({}, element.attributes),
      updatedStyle: style
    }, {
      before: () => {
        const element2 = this.elementMap[id2];
        if (stage !== "collapse")
          updateStyle(element2, style);
        if (stage === "visibility") {
          if (!hasCachedStyle(element2, "opacity"))
            cacheStyle(element2, "opacity");
          this.visibilityCache.set(element2, exactStage === "show" ? "visible" : "hidden");
          if (exactStage === "show")
            setVisibility(element2, "visible");
        }
      },
      after: () => {
        var _a4;
        const element2 = this.elementMap[id2];
        if (stage === "collapse")
          updateStyle(element2, style);
        if (exactStage === "hide")
          setVisibility(element2, this.visibilityCache.get(element2));
        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_UPDATE, elementType, datum), context);
        (_a4 = element2.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(element2);
      }
    });
  }
  updateElements(data2, context) {
    const { nodes, edges, combos } = data2;
    const iteration = [
      ["node", nodes],
      ["combo", combos],
      ["edge", edges]
    ];
    iteration.forEach(([elementType, elementData]) => {
      elementData.forEach((datum) => this.updateElement(elementType, datum, context));
    });
  }
  /**
   * <zh/> 
   *
   * <en/> mark destroy element
   * @param data - <zh/>  | <en/> draw data
   */
  markDestroyElement(data2) {
    Object.values(data2.remove).forEach((elementData) => {
      elementData.forEach((datum) => {
        const id2 = idOf(datum);
        const element = this.getElement(id2);
        if (element)
          markToBeDestroyed(element);
      });
    });
  }
  destroyElement(elementType, datum, context) {
    var _a3;
    const { stage = "exit" } = context;
    const id2 = idOf(datum);
    const element = this.elementMap[id2];
    if (!element)
      return () => null;
    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_DESTROY, elementType, datum), context);
    (_a3 = this.context.animation) === null || _a3 === void 0 ? void 0 : _a3.add({
      element,
      elementType,
      stage,
      originalStyle: Object.assign({}, element.attributes),
      updatedStyle: {}
    }, {
      after: () => {
        var _a4;
        this.clearElement(id2);
        element.destroy();
        (_a4 = element.onDestroy) === null || _a4 === void 0 ? void 0 : _a4.call(element);
        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_DESTROY, elementType, datum), context);
      }
    });
  }
  destroyElements(data2, context) {
    const { nodes, edges, combos } = data2;
    const iteration = [
      ["combo", combos],
      ["edge", edges],
      ["node", nodes]
    ];
    iteration.forEach(([elementType, elementData]) => {
      elementData.forEach((datum) => this.destroyElement(elementType, datum, context));
    });
  }
  clearElement(id2) {
    delete this.paletteStyle[id2];
    delete this.defaultStyle[id2];
    delete this.stateStyle[id2];
    delete this.elementMap[id2];
    delete this.shapeTypeMap[id2];
  }
  /**
   * <zh/> 
   *
   * <en/> Align the layout result to the element to avoid view offset. Will modify the layout result
   * @param layoutResult - <zh/>  | <en/> layout result
   * @param id - <zh/>  ID | <en/> element ID
   */
  alignLayoutResultToElement(layoutResult, id2) {
    var _a3, _b;
    const target = (_a3 = layoutResult.nodes) === null || _a3 === void 0 ? void 0 : _a3.find((node) => idOf(node) === id2);
    if (target) {
      const originalPosition = positionOf(this.context.model.getNodeLikeDatum(id2));
      const modifiedPosition = positionOf(target);
      const delta = subtract(originalPosition, modifiedPosition);
      (_b = layoutResult.nodes) === null || _b === void 0 ? void 0 : _b.forEach((node) => {
        var _a4, _b2, _c;
        if ((_a4 = node.style) === null || _a4 === void 0 ? void 0 : _a4.x)
          node.style.x += delta[0];
        if ((_b2 = node.style) === null || _b2 === void 0 ? void 0 : _b2.y)
          node.style.y += delta[1];
        if ((_c = node.style) === null || _c === void 0 ? void 0 : _c.z)
          node.style.z += delta[2] || 0;
      });
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Sync layout result
   * @param id - <zh/>  ID | <en/> element ID
   * @param align - <zh/>  | <en/> whether to align
   */
  syncLayoutResult(id2, align) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const { layout: layout2, model } = this.context;
      if (!layout2)
        return;
      const layoutOptions = this.context.options.layout;
      const forcePreLayout = (opts) => {
        if (Array.isArray(opts)) {
          return opts.map((o2) => Object.assign(Object.assign({}, o2), { preLayout: true }));
        }
        return Object.assign(Object.assign({}, opts), { preLayout: true });
      };
      const layoutResult = yield layout2.simulate(layoutOptions ? forcePreLayout(layoutOptions) : void 0);
      if (align)
        this.alignLayoutResultToElement(layoutResult, id2);
      model.updateData(layoutResult);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> collapse node
   * @param id - <zh/>  ID | <en/> element ID
   * @param options - <zh/>  | <en/> options
   */
  collapseNode(id2, options) {
    return __awaiter$3(this, void 0, void 0, function* () {
      var _a3;
      const { animation, align } = options;
      yield this.syncLayoutResult(id2, align);
      const data2 = this.computeChangesAndDrawData({ stage: "collapse", animation });
      if (!data2)
        return;
      const { drawData } = data2;
      const { add: add2, remove, update } = drawData;
      this.markDestroyElement(drawData);
      const context = { animation, stage: "collapse", data: drawData };
      this.destroyElements(remove, context);
      this.createElements(add2, context);
      this.updateElements(update, context);
      yield (_a3 = this.context.animation.animate(animation, {
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context)
      }, {
        collapse: {
          target: id2,
          descendants: Array.from(remove.nodes).map(([, node]) => idOf(node)),
          position: positionOf(update.nodes.get(id2))
        }
      })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> expand node
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  true | <en/> Whether to use animation, default is true
   */
  expandNode(id2, options) {
    return __awaiter$3(this, void 0, void 0, function* () {
      var _a3;
      const { model } = this.context;
      const { animation, align } = options;
      const position2 = positionOf(model.getNodeData([id2])[0]);
      yield this.syncLayoutResult(id2, align);
      const data2 = this.computeChangesAndDrawData({ stage: "expand", animation });
      this.createElements(data2.drawData.add, { animation: false, stage: "expand", target: id2 });
      this.context.animation.clear();
      this.computeStyle("expand");
      if (!data2)
        return;
      const { drawData } = data2;
      const { update, add: add2 } = drawData;
      const context = { animation, stage: "expand", data: drawData };
      add2.edges.forEach((edge) => update.edges.set(idOf(edge), edge));
      add2.nodes.forEach((node) => update.nodes.set(idOf(node), node));
      this.updateElements(update, context);
      yield (_a3 = this.context.animation.animate(animation, {
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation2, drawData), context)
      }, {
        expand: {
          target: id2,
          descendants: Array.from(add2.nodes).map(([, node]) => idOf(node)),
          position: position2
        }
      })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  collapseCombo(id2, animation) {
    return __awaiter$3(this, void 0, void 0, function* () {
      var _a3;
      const { model, element } = this.context;
      if (model.getAncestorsData(id2, COMBO_KEY).some((datum) => isCollapsed(datum)))
        return;
      const combo = element.getElement(id2);
      const position2 = combo.getComboPosition(Object.assign(Object.assign({}, combo.attributes), { collapsed: true }));
      const data2 = this.computeChangesAndDrawData({ stage: "collapse", animation });
      if (!data2)
        return;
      const { dataChanges, drawData } = data2;
      this.markDestroyElement(drawData);
      const { update, remove } = drawData;
      const context = { animation, stage: "collapse", data: drawData };
      this.destroyElements(remove, context);
      this.updateElements(update, context);
      const idsOf2 = (data3) => Array.from(data3).map(([, node]) => idOf(node));
      yield (_a3 = this.context.animation.animate(animation, {
        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context)
      }, {
        collapse: {
          target: id2,
          descendants: [...idsOf2(remove.nodes), ...idsOf2(remove.combos)],
          position: position2
        }
      })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  expandCombo(id2, animation) {
    return __awaiter$3(this, void 0, void 0, function* () {
      var _a3;
      const { model } = this.context;
      const position2 = positionOf(model.getComboData([id2])[0]);
      this.computeStyle("expand");
      const data2 = this.computeChangesAndDrawData({ stage: "expand", animation });
      if (!data2)
        return;
      const { dataChanges, drawData } = data2;
      const { add: add2, update } = drawData;
      const context = { animation, stage: "expand", data: drawData, target: id2 };
      this.createElements(add2, context);
      this.updateElements(update, context);
      const idsOf2 = (data3) => Array.from(data3).map(([, node]) => idOf(node));
      yield (_a3 = this.context.animation.animate(animation, {
        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context)
      }, {
        expand: {
          target: id2,
          descendants: [...idsOf2(add2.nodes), ...idsOf2(add2.combos)],
          position: position2
        }
      })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> clear all elements
   */
  clear() {
    this.container.destroy();
    this.initContainer();
    this.elementMap = {};
    this.shapeTypeMap = {};
    this.defaultStyle = {};
    this.stateStyle = {};
    this.paletteStyle = {};
  }
  destroy() {
    this.clear();
    this.container.destroy();
    this.context = {};
  }
}
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
};
class LayoutController {
  get presetOptions() {
    return {
      animation: !!getAnimationOptions(this.context.options, true)
    };
  }
  get options() {
    const { options } = this.context;
    return options.layout;
  }
  constructor(context) {
    this.instances = [];
    this.context = context;
  }
  getLayoutInstance() {
    return this.instances;
  }
  /**
   * <zh/> 
   *
   * <en/> Pre-layout, that is, perform layout before drawing
   * @param data - <zh/>  | <en/> Draw data
   * @remarks
   * <zh/> 
   *
   * <en/> Pre-layout should only be executed before the first drawing, and subsequent updates will not trigger
   */
  preLayout(data2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      var _a3, _b, _c, _d;
      const { graph: graph2, model } = this.context;
      const { add: add2 } = data2;
      emit(graph2, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: "pre" }));
      const simulate = yield (_a3 = this.context.layout) === null || _a3 === void 0 ? void 0 : _a3.simulate();
      (_b = simulate === null || simulate === void 0 ? void 0 : simulate.nodes) === null || _b === void 0 ? void 0 : _b.forEach((l2) => {
        const id2 = idOf(l2);
        const node = add2.nodes.get(id2);
        model.syncNodeLikeDatum(l2);
        if (node)
          Object.assign(node.style, l2.style);
      });
      (_c = simulate === null || simulate === void 0 ? void 0 : simulate.edges) === null || _c === void 0 ? void 0 : _c.forEach((l2) => {
        const id2 = idOf(l2);
        const edge = add2.edges.get(id2);
        model.syncEdgeDatum(l2);
        if (edge)
          Object.assign(edge.style, l2.style);
      });
      (_d = simulate === null || simulate === void 0 ? void 0 : simulate.combos) === null || _d === void 0 ? void 0 : _d.forEach((l2) => {
        const id2 = idOf(l2);
        const combo = add2.combos.get(id2);
        model.syncNodeLikeDatum(l2);
        if (combo)
          Object.assign(combo.style, l2.style);
      });
      emit(graph2, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: "pre" }));
      this.transformDataAfterLayout("pre", data2);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Post layout, that is, perform layout after drawing
   * @param layoutOptions - <zh/>  | <en/> Layout options
   */
  postLayout() {
    return __awaiter$2(this, arguments, void 0, function* (layoutOptions = this.options) {
      if (!layoutOptions)
        return;
      const pipeline = Array.isArray(layoutOptions) ? layoutOptions : [layoutOptions];
      const { graph: graph2 } = this.context;
      emit(graph2, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: "post" }));
      for (let index2 = 0; index2 < pipeline.length; index2++) {
        const options = pipeline[index2];
        const data2 = this.getLayoutData(options);
        const opts = Object.assign(Object.assign({}, this.presetOptions), options);
        emit(graph2, new GraphLifeCycleEvent(GraphEvent.BEFORE_STAGE_LAYOUT, { options: opts, index: index2 }));
        const result = yield this.stepLayout(data2, opts, index2);
        emit(graph2, new GraphLifeCycleEvent(GraphEvent.AFTER_STAGE_LAYOUT, { options: opts, index: index2 }));
        if (!options.animation) {
          this.updateElementPosition(result, false);
        }
      }
      emit(graph2, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: "post" }));
      this.transformDataAfterLayout("post");
    });
  }
  transformDataAfterLayout(type, data2) {
    const transforms = this.context.transform.getTransformInstance();
    Object.values(transforms).forEach((transform2) => transform2.afterLayout(type, data2));
  }
  /**
   * <zh/> 
   *
   * <en/> Simulate layout
   * @param options - <zh/>  | <en/> Layout options
   * @returns <zh/>  | <en/> Simulated layout result
   */
  simulate() {
    return __awaiter$2(this, arguments, void 0, function* (options = this.options) {
      if (!options)
        return {};
      const pipeline = Array.isArray(options) ? options : [options];
      let simulation = {};
      for (let index2 = 0; index2 < pipeline.length; index2++) {
        const options2 = pipeline[index2];
        const data2 = this.getLayoutData(options2);
        const result = yield this.stepLayout(data2, Object.assign(Object.assign(Object.assign({}, this.presetOptions), options2), { animation: false }), index2);
        simulation = result;
      }
      return simulation;
    });
  }
  stepLayout(data2, options, index2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (isTreeLayout(options))
        return yield this.treeLayout(data2, options, index2);
      return yield this.graphLayout(data2, options, index2);
    });
  }
  graphLayout(data2, options, index2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const { animation, enableWorker, iterations = 300 } = options;
      const layout2 = this.initGraphLayout(options);
      if (!layout2)
        return {};
      this.instances[index2] = layout2;
      this.instance = layout2;
      if (enableWorker) {
        const rawLayout = layout2;
        this.supervisor = new Supervisor(rawLayout.graphData2LayoutModel(data2), rawLayout.instance, { iterations });
        return layoutMapping2GraphData(yield this.supervisor.execute());
      }
      if (isLayoutWithIterations(layout2)) {
        if (animation) {
          return yield layout2.execute(data2, {
            onTick: (tickData) => {
              this.updateElementPosition(tickData, false);
            }
          });
        }
        layout2.execute(data2);
        layout2.stop();
        return layout2.tick(iterations);
      }
      const layoutResult = yield layout2.execute(data2);
      if (animation) {
        const animationResult = this.updateElementPosition(layoutResult, animation);
        yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;
      }
      return layoutResult;
    });
  }
  treeLayout(data2, options, index2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const { type, animation } = options;
      const layout2 = getExtension("layout", type);
      if (!layout2)
        return {};
      const { nodes = [], edges = [] } = data2;
      const model = new Graph$9({
        nodes: nodes.map((node) => ({ id: idOf(node), data: node.data || {} })),
        edges: edges.map((edge) => ({ id: idOf(edge), source: edge.source, target: edge.target, data: edge.data || {} }))
      });
      createTreeStructure(model);
      const layoutPreset = { nodes: [], edges: [] };
      const layoutResult = { nodes: [], edges: [] };
      const roots = model.getRoots(TREE_KEY);
      roots.forEach((root2) => {
        dfs$3(root2, (node) => {
          node.children = model.getSuccessors(node.id);
        }, (node) => model.getSuccessors(node.id), "TB");
        const result = layout2(root2, options);
        const { x: rx, y: ry, z: rz = 0 } = result;
        dfs$3(result, (node) => {
          const { id: id2, x: x2, y: y2, z: z2 = 0 } = node;
          layoutPreset.nodes.push({ id: id2, style: { x: rx, y: ry, z: rz } });
          layoutResult.nodes.push({ id: id2, style: { x: x2, y: y2, z: z2 } });
        }, (node) => node.children, "TB");
      });
      const offset = this.inferTreeLayoutOffset(layoutResult);
      applyTreeLayoutOffset(layoutResult, offset);
      if (animation) {
        applyTreeLayoutOffset(layoutPreset, offset);
        this.updateElementPosition(layoutPreset, false);
        const animationResult = this.updateElementPosition(layoutResult, animation);
        yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;
      }
      return layoutResult;
    });
  }
  inferTreeLayoutOffset(data2) {
    var _a3;
    let [minX, maxX] = [Infinity, -Infinity];
    let [minY, maxY] = [Infinity, -Infinity];
    (_a3 = data2.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((node) => {
      const { x: x3 = 0, y: y3 = 0 } = node.style || {};
      minX = Math.min(minX, x3);
      maxX = Math.max(maxX, x3);
      minY = Math.min(minY, y3);
      maxY = Math.max(maxY, y3);
    });
    const { canvas: canvas2 } = this.context;
    const canvasSize = canvas2.getSize();
    const [x1, y1] = canvas2.getCanvasByViewport([0, 0]);
    const [x2, y2] = canvas2.getCanvasByViewport(canvasSize);
    if (minX >= x1 && maxX <= x2 && minY >= y1 && maxY <= y2)
      return [0, 0];
    const cx = (x1 + x2) / 2;
    const cy = (y1 + y2) / 2;
    return [cx - (minX + maxX) / 2, cy - (minY + maxY) / 2];
  }
  stopLayout() {
    if (this.instance && isLayoutWithIterations(this.instance)) {
      this.instance.stop();
      this.instance = void 0;
    }
    if (this.supervisor) {
      this.supervisor.stop();
      this.supervisor = void 0;
    }
    if (this.animationResult) {
      this.animationResult.finish();
      this.animationResult = void 0;
    }
  }
  getLayoutData(options) {
    const { nodeFilter = () => true, comboFilter = () => true, preLayout = false, isLayoutInvisibleNodes = false } = options;
    const { nodes, edges, combos } = this.context.model.getData();
    const { element, model } = this.context;
    const getElement = (id2) => element.getElement(id2);
    const filterFn = preLayout ? (node) => {
      var _a3;
      if (!isLayoutInvisibleNodes) {
        if (((_a3 = node.style) === null || _a3 === void 0 ? void 0 : _a3.visibility) === "hidden")
          return false;
        if (model.getAncestorsData(node.id, TREE_KEY).some(isCollapsed))
          return false;
        if (model.getAncestorsData(node.id, COMBO_KEY).some(isCollapsed))
          return false;
      }
      return nodeFilter(node);
    } : (node) => {
      const id2 = idOf(node);
      const element2 = getElement(id2);
      if (!element2)
        return false;
      if (isToBeDestroyed(element2))
        return false;
      return nodeFilter(node);
    };
    const nodesToLayout = nodes.filter(filterFn);
    const combosToLayout = combos.filter(comboFilter);
    const nodeLikeIdsMap = new Map(nodesToLayout.map((node) => [idOf(node), node]));
    combosToLayout.forEach((combo) => nodeLikeIdsMap.set(idOf(combo), combo));
    const edgesToLayout = edges.filter(({ source, target }) => {
      return nodeLikeIdsMap.has(source) && nodeLikeIdsMap.has(target);
    });
    return {
      nodes: nodesToLayout,
      edges: edgesToLayout,
      combos: combosToLayout
    };
  }
  /**
   * <zh/> 
   *
   * <en/> Create layout instance
   * @param options - <zh/>  | <en/> Layout options
   * @returns <zh/>  | <en/> Layout object
   */
  initGraphLayout(options) {
    var _a3;
    const { element, viewport } = this.context;
    const { type, enableWorker, animation, iterations } = options, restOptions = __rest(options, ["type", "enableWorker", "animation", "iterations"]);
    const [width2, height] = viewport.getCanvasSize();
    const center = [width2 / 2, height / 2];
    const nodeSize = (_a3 = options === null || options === void 0 ? void 0 : options.nodeSize) !== null && _a3 !== void 0 ? _a3 : (node) => {
      const nodeElement = element === null || element === void 0 ? void 0 : element.getElement(node.id);
      if (nodeElement)
        return nodeElement.attributes.size;
      return element === null || element === void 0 ? void 0 : element.getElementComputedStyle("node", node).size;
    };
    const Ctor = getExtension("layout", type);
    if (!Ctor)
      return print.warn(`The layout of ${type} is not registered.`);
    const STDCtor = Object.getPrototypeOf(Ctor.prototype) === BaseLayout.prototype ? Ctor : layoutAdapter(Ctor, this.context);
    const layout2 = new STDCtor(this.context);
    const config = { nodeSize, width: width2, height, center };
    switch (layout2.id) {
      case "d3-force":
      case "d3-force-3d":
        Object.assign(config, {
          center: { x: width2 / 2, y: height / 2, z: 0 }
        });
        break;
    }
    deepMix(layout2.options, config, restOptions);
    return layout2;
  }
  updateElementPosition(layoutResult, animation) {
    const { model, element } = this.context;
    if (!element)
      return null;
    model.updateData(layoutResult);
    return element.draw({ animation, silence: true });
  }
  destroy() {
    var _a3;
    this.stopLayout();
    this.context = {};
    (_a3 = this.supervisor) === null || _a3 === void 0 ? void 0 : _a3.kill();
    this.supervisor = void 0;
    this.instance = void 0;
    this.instances = [];
    this.animationResult = void 0;
  }
}
const applyTreeLayoutOffset = (data2, offset) => {
  var _a3;
  const [ox, oy] = offset;
  (_a3 = data2.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((node) => {
    if (node.style) {
      const { x: x2 = 0, y: y2 = 0 } = node.style;
      node.style.x = x2 + ox;
      node.style.y = y2 + oy;
    } else {
      node.style = { x: ox, y: oy };
    }
  });
};
function inferOptions(options) {
  const flow = [inferLayoutOptions];
  return flow.reduce((acc, infer) => infer(acc), options);
}
function inferLayoutOptions(options) {
  if (!options.layout)
    return options;
  if (Array.isArray(options.layout))
    return options;
  if ("preLayout" in options.layout)
    return options;
  if ([
    "antv-dagre",
    "combo-combined",
    "compact-box",
    "circular",
    "concentric",
    "dagre",
    "fishbone",
    "grid",
    "indented",
    "mds",
    "radial",
    "random",
    "snake",
    // <zh/>  preLayout false
    // <en/> The label position of the following layouts needs to be adapted, and preLayout needs to be manually configured as false
    "dendrogram",
    "mindmap"
  ].includes(options.layout.type)) {
    options.layout.preLayout = true;
  }
  return options;
}
class PluginController extends ExtensionController {
  constructor(context) {
    super(context);
    this.category = "plugin";
    this.setPlugins(this.context.options.plugins || []);
  }
  setPlugins(plugins) {
    this.setExtensions(plugins);
  }
  getPluginInstance(key) {
    const exactly = this.extensionMap[key];
    if (exactly)
      return exactly;
    print.warn(`Cannot find the plugin ${key}, will try to find it by type.`);
    const fussily = this.extensions.find((extension) => extension.type === key);
    if (fussily)
      return this.extensionMap[fussily.key];
  }
}
const REQUIRED_TRANSFORMS = [
  "update-related-edges",
  "collapse-expand-node",
  "collapse-expand-combo",
  "get-edge-actual-ends",
  "arrange-draw-order"
];
class TransformController extends ExtensionController {
  constructor(context) {
    super(context);
    this.category = "transform";
    this.setTransforms(this.context.options.transforms || []);
  }
  getTransforms() {
  }
  setTransforms(transforms) {
    this.setExtensions([
      ...REQUIRED_TRANSFORMS.slice(0, REQUIRED_TRANSFORMS.length - 1),
      ...transforms,
      REQUIRED_TRANSFORMS[REQUIRED_TRANSFORMS.length - 1]
    ]);
  }
  getTransformInstance(key) {
    return key ? this.extensionMap[key] : this.extensionMap;
  }
}
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ViewportController {
  get padding() {
    return parsePadding(this.context.options.padding);
  }
  get paddingOffset() {
    const [top, right, bottom, left] = this.padding;
    const [offsetX, offsetY, offsetZ] = [(left - right) / 2, (top - bottom) / 2, 0];
    return [offsetX, offsetY, offsetZ];
  }
  constructor(context) {
    this.landmarkCounter = 0;
    this.context = context;
    const [px2, py] = this.paddingOffset;
    const { zoom, rotation, x: x2 = px2, y: y2 = py } = context.options;
    this.transform({ mode: "absolute", scale: zoom, translate: [x2, y2], rotate: rotation }, false);
  }
  get camera() {
    const { canvas: canvas2 } = this.context;
    return new Proxy(canvas2.getCamera(), {
      get: (target, prop) => {
        const layers = Object.entries(canvas2.getLayers()).filter(([name]) => !["main"].includes(name));
        const cameras = layers.map(([, layer]) => layer.getCamera());
        const value = target[prop];
        if (typeof value === "function") {
          return (...args) => {
            const result = value.apply(target, args);
            cameras.forEach((camera) => {
              camera[prop].apply(camera, args);
            });
            return result;
          };
        }
      }
    });
  }
  createLandmark(options) {
    return this.camera.createLandmark(`landmark-${this.landmarkCounter++}`, options);
  }
  getAnimation(animation) {
    const finalAnimation = getAnimationOptions(this.context.options, animation);
    if (!finalAnimation)
      return false;
    return pick(Object.assign({}, finalAnimation), ["easing", "duration"]);
  }
  getCanvasSize() {
    const { canvas: canvas2 } = this.context;
    const { width: width2 = 0, height = 0 } = canvas2.getConfig();
    return [width2, height];
  }
  /**
   * <zh/> 
   *
   * <en/> Get the center coordinates of the canvas
   * @returns - <zh/>  | <en/> Center coordinates of the canvas
   * @remarks
   * <zh/> 
   *
   * <en/> Calculate the center coordinates based on the width and height of the canvas, not affected by the viewport transformation
   */
  getCanvasCenter() {
    const { canvas: canvas2 } = this.context;
    const { width: width2 = 0, height = 0 } = canvas2.getConfig();
    return [width2 / 2, height / 2, 0];
  }
  /**
   * <zh/> 
   *
   * <en/> Current viewport center coordinates
   * @returns - <zh/>  | <en/> Viewport center coordinates
   * @remarks
   * <zh/> 
   *
   * <en/> With the origin of the canvas as the origin, affected by the viewport transformation
   */
  getViewportCenter() {
    const [x2, y2] = this.camera.getPosition();
    return [x2, y2, 0];
  }
  getGraphCenter() {
    return this.context.graph.getViewportByCanvas(this.getCanvasCenter());
  }
  getZoom() {
    return this.camera.getZoom();
  }
  getRotation() {
    return this.camera.getRoll();
  }
  getTranslateOptions(options) {
    const { camera } = this;
    const { mode, translate: translate4 = [] } = options;
    const currentZoom = this.getZoom();
    const position2 = camera.getPosition();
    const focalPoint = camera.getFocalPoint();
    const [cx, cy] = this.getCanvasCenter();
    const [x2 = 0, y2 = 0, z2 = 0] = translate4;
    const delta = divide([-x2, -y2, -z2], currentZoom);
    return mode === "relative" ? {
      position: add$4(position2, delta),
      focalPoint: add$4(focalPoint, delta)
    } : {
      position: add$4([cx, cy, position2[2]], delta),
      focalPoint: add$4([cx, cy, focalPoint[2]], delta)
    };
  }
  getRotateOptions(options) {
    const { mode, rotate: rotate3 = 0 } = options;
    const roll = mode === "relative" ? this.camera.getRoll() + rotate3 : rotate3;
    return { roll };
  }
  getZoomOptions(options) {
    const { zoomRange } = this.context.options;
    const currentZoom = this.camera.getZoom();
    const { mode, scale: scale3 = 1 } = options;
    return clamp$1(mode === "relative" ? currentZoom * scale3 : scale3, ...zoomRange);
  }
  transform(options, animation) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const { graph: graph2 } = this.context;
      const { translate: translate4, rotate: rotate3, scale: scale3, origin } = options;
      this.cancelAnimation();
      const _animation = this.getAnimation(animation);
      emit(graph2, new ViewportEvent(GraphEvent.BEFORE_TRANSFORM, options));
      if (!rotate3 && scale3 && !translate4 && origin && !_animation) {
        this.camera.setZoomByViewportPoint(this.getZoomOptions(options), origin);
        emit(graph2, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
        return;
      }
      const landmarkOptions = {};
      if (translate4)
        Object.assign(landmarkOptions, this.getTranslateOptions(options));
      if (isNumber(rotate3))
        Object.assign(landmarkOptions, this.getRotateOptions(options));
      if (isNumber(scale3))
        Object.assign(landmarkOptions, { zoom: this.getZoomOptions(options) });
      if (_animation) {
        emit(graph2, new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.TRANSFORM, null, options));
        return new Promise((resolve) => {
          this.transformResolver = resolve;
          this.camera.gotoLandmark(this.createLandmark(landmarkOptions), Object.assign(Object.assign({}, _animation), { onfinish: () => {
            emit(graph2, new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.TRANSFORM, null, options));
            emit(graph2, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
            this.transformResolver = void 0;
            resolve();
          } }));
        });
      } else {
        this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {
          duration: 0
        });
        emit(graph2, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
      }
    });
  }
  fitView(options, animation) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [top, right, bottom, left] = this.padding;
      const { when = "always", direction: direction2 = "both" } = options || {};
      const [width2, height] = this.context.canvas.getSize();
      const innerWidth = width2 - left - right;
      const innerHeight = height - top - bottom;
      const canvasBounds = this.context.canvas.getBounds();
      const bboxInViewPort = this.getBBoxInViewport(canvasBounds);
      const [contentWidth, contentHeight] = getBBoxSize$1(bboxInViewPort);
      const isOverflow = direction2 === "x" && contentWidth >= innerWidth || direction2 === "y" && contentHeight >= innerHeight || direction2 === "both" && contentWidth >= innerWidth && contentHeight >= innerHeight;
      if (when === "overflow" && !isOverflow)
        return yield this.fitCenter({ animation });
      const scaleX2 = innerWidth / contentWidth;
      const scaleY2 = innerHeight / contentHeight;
      const scale3 = direction2 === "x" ? scaleX2 : direction2 === "y" ? scaleY2 : Math.min(scaleX2, scaleY2);
      const _animation = this.getAnimation(animation);
      if (!Number.isFinite(scale3)) {
        return;
      }
      yield this.transform({
        mode: "relative",
        scale: scale3,
        translate: add$4(subtract(this.getCanvasCenter(), this.getBBoxInViewport(canvasBounds).center), divide(this.paddingOffset, scale3))
      }, _animation);
    });
  }
  fitCenter(options) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const canvasBounds = this.context.canvas.getBounds();
      yield this.focus(canvasBounds, options);
    });
  }
  focusElements(ids_1) {
    return __awaiter$1(this, arguments, void 0, function* (ids, options = {}) {
      const { element } = this.context;
      if (!element)
        return;
      const getBoundsOf = (el) => options.shapes ? el.getShape(options.shapes).getRenderBounds() : el.getRenderBounds();
      const elementsBounds = getCombinedBBox(ids.map((id2) => getBoundsOf(element.getElement(id2))));
      yield this.focus(elementsBounds, options);
    });
  }
  focus(bbox, options) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const center = this.context.graph.getViewportByCanvas(bbox.center);
      const position2 = options.position || this.getCanvasCenter();
      const delta = subtract(position2, center);
      yield this.transform({ mode: "relative", translate: add$4(delta, this.paddingOffset) }, options.animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the bounding box of the canvas element in the viewport
   * @param bbox - <zh/>  | <en/> Canvas element bounding box
   * @returns - <zh/>  | <en/> Bounding box in the viewport
   */
  getBBoxInViewport(bbox) {
    const { min: min2, max: max2 } = bbox;
    const { graph: graph2 } = this.context;
    const [x1, y1] = graph2.getViewportByCanvas(min2);
    const [x2, y2] = graph2.getViewportByCanvas(max2);
    const bboxInViewport = new AABB();
    bboxInViewport.setMinMax([x1, y1, 0], [x2, y2, 0]);
    return bboxInViewport;
  }
  /**
   * <zh/> 
   *
   * <en/> Determine whether the point or bounding box is in the viewport
   * @param target - <zh/>  | <en/> Point or bounding box
   * @param complete - <zh/>  | <en/> Whether it is completely in the viewport
   * @param tolerance - <zh/>  | <en/> Tolerance outside the viewport
   * @returns - <zh/>  | <en/> Whether it is in the viewport
   */
  isInViewport(target, complete = false, tolerance2 = 0) {
    const { graph: graph2 } = this.context;
    const size = this.getCanvasSize();
    const [x1, y1] = graph2.getCanvasByViewport([0, 0]);
    const [x2, y2] = graph2.getCanvasByViewport(size);
    let viewportBBox = new AABB();
    viewportBBox.setMinMax([x1, y1, 0], [x2, y2, 0]);
    if (tolerance2) {
      viewportBBox = getExpandedBBox(viewportBBox, tolerance2);
    }
    return isPoint(target) ? isPointInBBox(target, viewportBBox) : !complete ? viewportBBox.intersects(target) : isBBoxInside(target, viewportBBox);
  }
  cancelAnimation() {
    var _a3, _b;
    if ((_a3 = this.camera.landmarks) === null || _a3 === void 0 ? void 0 : _a3.length) {
      this.camera.cancelLandmarkAnimation();
    }
    (_b = this.transformResolver) === null || _b === void 0 ? void 0 : _b.call(this);
  }
}
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Graph2 extends EventEmitter {
  constructor(options) {
    var _a3;
    super();
    this.options = {};
    this.rendered = false;
    this.destroyed = false;
    this.context = {
      model: new DataController()
    };
    this.isCollapsingExpanding = false;
    this.onResize = debounce(() => {
      this.resize();
    }, 300);
    this._setOptions(Object.assign({}, Graph2.defaultOptions, options), true);
    this.context.graph = this;
    this.options.autoResize && ((_a3 = globalThis.addEventListener) === null || _a3 === void 0 ? void 0 : _a3.call(globalThis, "resize", this.onResize));
  }
  /**
   * <zh/> 
   *
   * <en/> Get options
   * @returns <zh/>  | <en/> options
   * @apiCategory option
   */
  getOptions() {
    return this.options;
  }
  /**
   * <zh/> 
   *
   * <en/> Set options
   * @param options - <zh/>  | <en/> options
   * @remarks
   * <zh/>  devicePixelRatiocontainer 
   *
   * <en/> To update devicePixelRatio and container properties, please destroy and recreate the instance
   * @apiCategory option
   */
  setOptions(options) {
    this._setOptions(options, false);
  }
  _setOptions(options, isInit) {
    this.updateCanvas(options);
    Object.assign(this.options, inferOptions(options));
    if (isInit) {
      const { data: data3 } = options;
      if (data3)
        this.addData(data3);
      return;
    }
    const { behaviors, combo, data: data2, edge, layout: layout2, node, plugins, theme, transforms } = options;
    if (behaviors)
      this.setBehaviors(behaviors);
    if (data2)
      this.setData(data2);
    if (node)
      this.setNode(node);
    if (edge)
      this.setEdge(edge);
    if (combo)
      this.setCombo(combo);
    if (layout2)
      this.setLayout(layout2);
    if (theme)
      this.setTheme(theme);
    if (plugins)
      this.setPlugins(plugins);
    if (transforms)
      this.setTransforms(transforms);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the size of the current canvas container
   * @returns <zh/>  | <en/> canvas size
   * @apiCategory canvas
   */
  getSize() {
    if (this.context.canvas)
      return this.context.canvas.getSize();
    return [this.options.width || 0, this.options.height || 0];
  }
  /**
   * <zh/> 
   *
   * <en/> Set the size of the current canvas container
   * @param width - <zh/>  | <en/> canvas width
   * @param height - <zh/>  | <en/> canvas height
   * @apiCategory canvas
   */
  setSize(width2, height) {
    if (width2)
      this.options.width = width2;
    if (height)
      this.options.height = height;
    this.resize(width2, height);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the zoom range of the current graph
   * @param zoomRange - <zh/>  | <en/> zoom range
   * @apiCategory viewport
   */
  setZoomRange(zoomRange) {
    this.options.zoomRange = zoomRange;
  }
  /**
   * <zh/> 
   *
   * <en/> Get the zoom range of the current graph
   * @returns <zh/>  | <en/> zoom range
   * @apiCategory viewport
   */
  getZoomRange() {
    return this.options.zoomRange;
  }
  /**
   * <zh/> 
   *
   * <en/> Set node mapper
   * @param node - <zh/>  | <en/> node options
   * @remarks
   * <zh/>  `options.node` 
   *
   * <en/> The value of `options.node`
   * @apiCategory element
   */
  setNode(node) {
    this.options.node = node;
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Set edge mapper
   * @param edge - <zh/>  | <en/> edge options
   * @remarks
   * <zh/>  `options.edge` 
   *
   * <en/> The value of `options.edge`
   * @apiCategory element
   */
  setEdge(edge) {
    this.options.edge = edge;
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Set combo mapper
   * @param combo - <zh/>  | <en/> combo options
   * @remarks
   * <zh/>  `options.combo` 
   *
   * <en/> The value of `options.combo`
   * @apiCategory element
   */
  setCombo(combo) {
    this.options.combo = combo;
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Get theme
   * @returns <zh/>  | <en/> current theme
   * @apiCategory theme
   */
  getTheme() {
    return this.options.theme;
  }
  /**
   * <zh/> 
   *
   * <en/> Set theme
   * @param theme - <zh/>  | <en/> theme name
   * @example
   * ```ts
   * graph.setTheme('dark');
   * ```
   * @apiCategory theme
   */
  setTheme(theme) {
    this.options.theme = isFunction$1(theme) ? theme(this.getTheme()) : theme;
  }
  /**
   * <zh/> 
   *
   * <en/> Set layout
   * @param layout - <zh/>  | <en/> layout options
   * @example
   * ```ts
   * graph.setLayout({
   *  type: 'dagre',
   * })
   * ```
   * @apiCategory layout
   */
  setLayout(layout2) {
    this.options.layout = isFunction$1(layout2) ? layout2(this.getLayout()) : layout2;
  }
  /**
   * <zh/> 
   *
   * <en/> Get layout options
   * @returns <zh/>  | <en/> layout options
   * @apiCategory layout
   */
  getLayout() {
    return this.options.layout;
  }
  /**
   * <zh/> 
   *
   * <en/> Set behaviors
   * @param behaviors - <zh/>  | <en/> behavior options
   * @remarks
   * <zh/> 
   *
   * <en/> The set behavior will completely replace the original behavior. If you need to add behavior, you can use the following method:
   *
   * ```ts
   * graph.setBehaviors((behaviors) => [...behaviors, { type: 'zoom-canvas' }])
   * ```
   * @apiCategory behavior
   */
  setBehaviors(behaviors) {
    var _a3;
    this.options.behaviors = isFunction$1(behaviors) ? behaviors(this.getBehaviors()) : behaviors;
    (_a3 = this.context.behavior) === null || _a3 === void 0 ? void 0 : _a3.setBehaviors(this.options.behaviors);
  }
  /**
   * <zh/> 
   *
   * <en/> Update specified behavior options
   * @param behavior - <zh/>  | <en/> behavior options
   * @remarks
   * <zh/>  key 
   *
   * <en/> If you want to update a behavior, you must specify the key field in the behavior options, for example:
   * ```ts
   * {
   *   behaviors: [{ type: 'zoom-canvas', key: 'zoom-canvas' }]
   * }
   *
   * graph.updateBehavior({ key: 'zoom-canvas', enable: false })
   * ```
   * @apiCategory behavior
   */
  updateBehavior(behavior) {
    this.setBehaviors((behaviors) => behaviors.map((_behavior) => {
      if (typeof _behavior === "object" && _behavior.key === behavior.key) {
        return Object.assign(Object.assign({}, _behavior), behavior);
      }
      return _behavior;
    }));
  }
  /**
   * <zh/> 
   *
   * <en/> Get behaviors options
   * @returns <zh/>  | <en/> behavior options
   * @apiCategory behavior
   */
  getBehaviors() {
    return this.options.behaviors || [];
  }
  /**
   * <zh/> 
   *
   * <en/> Set plugins options
   * @param plugins - <zh/>  | <en/> plugin options
   * @remarks
   * <zh/> 
   *
   * <en/> The set plugin will completely replace the original plugin configuration. If you need to add a plugin, you can use the following method:
   * ```ts
   * graph.setPlugins((plugins) => [...plugins, { key: 'grid-line' }])
   * ```
   * @apiCategory plugin
   */
  setPlugins(plugins) {
    var _a3;
    this.options.plugins = isFunction$1(plugins) ? plugins(this.getPlugins()) : plugins;
    (_a3 = this.context.plugin) === null || _a3 === void 0 ? void 0 : _a3.setPlugins(this.options.plugins);
  }
  /**
   * <zh/> 
   *
   * <en/> Update plugin options
   * @param plugin - <zh/>  | <en/> plugin options
   * @remarks
   * <zh/>  key 
   *
   * <en/> If you want to update a plugin, you must specify the key field in the plugin options, for example:
   * ```ts
   * {
   *   plugins: [{ key: 'grid-line' }]
   * }
   *
   * graph.updatePlugin({ key: 'grid-line', follow: true })
   * ```
   * @apiCategory plugin
   */
  updatePlugin(plugin) {
    this.setPlugins((plugins) => plugins.map((_plugin) => {
      if (typeof _plugin === "object" && _plugin.key === plugin.key) {
        return Object.assign(Object.assign({}, _plugin), plugin);
      }
      return _plugin;
    }));
  }
  /**
   * <zh/> 
   *
   * <en/> Get plugins options
   * @returns <zh/>  | <en/> plugin options
   * @apiCategory plugin
   */
  getPlugins() {
    return this.options.plugins || [];
  }
  /**
   * <zh/> 
   *
   * <en/> Get plugin instance
   * @param key - <zh/>  key plugin  | <en/> plugin key(need to be specified manually when configuring plugin)
   * @returns <zh/>  | <en/> plugin instance
   * @remarks
   * <zh/>  API  `request`  `exit` 
   *
   * <en/> Some plugins provide API methods for calling, such as the full-screen plugin can call the `request` and `exit` methods to request and exit full-screen
   * ```ts
   * const fullscreen = graph.getPluginInstance('fullscreen');
   *
   * fullscreen.request();
   *
   * fullscreen.exit();
   * ```
   * @apiCategory plugin
   */
  getPluginInstance(key) {
    return this.context.plugin.getPluginInstance(key);
  }
  /**
   * <zh/> 
   *
   * <en/> Set data transforms
   * @param transforms - <zh/>  | <en/> data transform options
   * @remarks
   * <zh/> 
   *
   * <en/> Data transforms can perform data transformation during the rendering process of the graph. Currently, it supports transforming the drawing data before rendering.
   * @apiCategory transform
   */
  setTransforms(transforms) {
    var _a3;
    this.options.transforms = isFunction$1(transforms) ? transforms(this.getTransforms()) : transforms;
    (_a3 = this.context.transform) === null || _a3 === void 0 ? void 0 : _a3.setTransforms(this.options.transforms);
  }
  /**
   * <zh/> 
   *
   * <en/> Update data transform
   * @param transform - <zh/>  | <en/> data transform options
   * @apiCategory transform
   */
  updateTransform(transform2) {
    this.setTransforms((transforms) => transforms.map((_transform) => {
      if (typeof _transform === "object" && _transform.key === transform2.key) {
        return Object.assign(Object.assign({}, _transform), transform2);
      }
      return _transform;
    }));
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Get data transforms options
   * @returns <zh/>  | <en/> data transform options
   * @apiCategory transform
   */
  getTransforms() {
    return this.options.transforms || [];
  }
  /**
   * <zh/> 
   *
   * <en/> Get graph data
   * @returns <zh/>  | <en/> Graph data
   * <zh/> 
   *
   * <en/> Get the data of the current graph, including node, edge, and combo data
   * @apiCategory data
   */
  getData() {
    return this.context.model.getData();
  }
  /**
   * <zh/> 
   * <en/> Determine whether a specified node exists in the graph
   * @param {ID} id
   * @returns {boolean}
   * @remarks <zh/> ,
   * <en/> Determine whether a specified node exists in the graph and avoid operating on non-existent nodes
   */
  hasNode(id2) {
    return this.context.model.hasNode(id2);
  }
  /**
   * <zh/> 
   * <en/> Determine whether a specified edge exists in the graph
   * @param {ID} id
   * @returns  {boolean}
   * @remarks <zh/> ,
   * <en/> Determine whether a specified edge exists in the graph and avoid operating on non-existent edges
   */
  hasEdge(id2) {
    return this.context.model.hasEdge(id2);
  }
  /**
   * <zh/> 
   * <en/> Determine whether a specified combo exists in the graph
   * @param {ID} id
   * @returns  {boolean}
   * @remarks <zh/> ,
   * <en/> Determine whether a specified combo exists in the graph and avoid operating on non-existent combos
   */
  hasCombo(id2) {
    return this.context.model.hasCombo(id2);
  }
  getElementData(ids) {
    if (Array.isArray(ids))
      return ids.map((id2) => this.context.model.getElementDataById(id2));
    return this.context.model.getElementDataById(ids);
  }
  getNodeData(id2) {
    if (id2 === void 0)
      return this.context.model.getNodeData();
    if (Array.isArray(id2))
      return this.context.model.getNodeData(id2);
    return this.context.model.getNodeLikeDatum(id2);
  }
  getEdgeData(id2) {
    if (id2 === void 0)
      return this.context.model.getEdgeData();
    if (Array.isArray(id2))
      return this.context.model.getEdgeData(id2);
    return this.context.model.getEdgeDatum(id2);
  }
  getComboData(id2) {
    if (id2 === void 0)
      return this.context.model.getComboData();
    if (Array.isArray(id2))
      return this.context.model.getComboData(id2);
    return this.context.model.getNodeLikeDatum(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Set full data
   * @param data - <zh/>  | <en/> data
   * @remarks
   * <zh/> G6 
   *
   * <en/> Setting full data will replace all data in the current graph, and G6 will automatically calculate the data difference
   * @apiCategory data
   */
  setData(data2) {
    this.context.model.setData(isFunction$1(data2) ? data2(this.getData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Add element data
   * @param data - <zh/>  | <en/> element data
   * @example
   * ```ts
   * graph.addData({
   *  nodes: [{ id: 'node-1' }, { id: 'node-2' }],
   *  edges: [{ source: 'node-1', target: 'node-2' }],
   * });
   * ```
   * @apiCategory data
   */
  addData(data2) {
    this.context.model.addData(isFunction$1(data2) ? data2(this.getData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Add node data
   * @param data - <zh/>  | <en/> node data
   * @example
   * ```ts
   * graph.addNodeData([{ id: 'node-1' }, { id: 'node-2' }]);
   * ```
   * @apiCategory data
   */
  addNodeData(data2) {
    this.context.model.addNodeData(isFunction$1(data2) ? data2(this.getNodeData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Add edge data
   * @param data - <zh/>  | <en/> edge data
   * @example
   * ```ts
   * graph.addEdgeData([{ source: 'node-1', target: 'node-2' }]);
   * ```
   * @apiCategory data
   */
  addEdgeData(data2) {
    this.context.model.addEdgeData(isFunction$1(data2) ? data2(this.getEdgeData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Add combo data
   * @param data - <zh/>  | <en/> combo data
   * @example
   * ```ts
   * graph.addComboData([{ id: 'combo-1' }]);
   * ```
   * @apiCategory data
   */
  addComboData(data2) {
    this.context.model.addComboData(isFunction$1(data2) ? data2(this.getComboData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Add child node data to the tree node
   * @param parentId - <zh/>  ID | <en/> parent node ID
   * @param childrenData - <zh/>  | <en/> child node data
   * @remarks
   * <zh/>  addNodeData / addComboData 
   *
   * <en/> Use addNodeData / addComboData method to add child nodes to the combo
   * @apiCategory data
   */
  addChildrenData(parentId, childrenData) {
    this.context.model.addChildrenData(parentId, childrenData);
  }
  /**
   * <zh/> 
   *
   * <en/> Update element data
   * @param data - <zh/>  | <en/> element data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateData({
   *   nodes: [{ id: 'node-1', style: { x: 100, y: 100 } }],
   *   edges: [{ id: 'edge-1', style: { lineWidth: 2 } }]
   * });
   * ```
   * @apiCategory data
   */
  updateData(data2) {
    this.context.model.updateData(isFunction$1(data2) ? data2(this.getData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Update node data
   * @param data - <zh/>  | <en/> node data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateNodeData([{ id: 'node-1', style: { x: 100, y: 100 } }]);
   * ```
   * @apiCategory data
   */
  updateNodeData(data2) {
    this.context.model.updateNodeData(isFunction$1(data2) ? data2(this.getNodeData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Update edge data
   * @param data - <zh/>  | <en/> edge data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateEdgeData([{ id: 'edge-1', style: { lineWidth: 2 } }]);
   * ```
   * @apiCategory data
   */
  updateEdgeData(data2) {
    this.context.model.updateEdgeData(isFunction$1(data2) ? data2(this.getEdgeData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Update combo data
   * @param data - <zh/>  | <en/> combo data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateComboData([{ id: 'combo-1', style: { x: 100, y: 100 } }]);
   * ```
   * @apiCategory data
   */
  updateComboData(data2) {
    this.context.model.updateComboData(isFunction$1(data2) ? data2(this.getComboData()) : data2);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove element data
   * @param ids - <zh/>  ID  | <en/> element ID array
   * @example
   * ```ts
   * graph.removeData({
   *   nodes: ['node-1', 'node-2'],
   *   edges: ['edge-1'],
   * });
   * ```
   * @apiCategory data
   */
  removeData(ids) {
    this.context.model.removeData(isFunction$1(ids) ? ids(this.getData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove node data
   * @param ids - <zh/>  ID  | <en/> node ID array
   * @example
   * ```ts
   * graph.removeNodeData(['node-1', 'node-2']);
   * ```
   * @apiCategory data
   */
  removeNodeData(ids) {
    this.context.model.removeNodeData(isFunction$1(ids) ? ids(this.getNodeData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove edge data
   * @param ids - <zh/>  ID  | <en/> edge ID array
   * @remarks
   * <zh/>  source  target `idOf`  ID
   *
   * <en/> If only the source and target are provided when passing in the edge data, you need to get the actual ID of the edge through the `idOf` method
   * @example
   * ```ts
   * graph.removeEdgeData(['edge-1']);
   * ```
   * @apiCategory data
   */
  removeEdgeData(ids) {
    this.context.model.removeEdgeData(isFunction$1(ids) ? ids(this.getEdgeData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove combo data
   * @param ids - <zh/>  ID  | <en/>  ID array
   * @example
   * ```ts
   * graph.removeComboData(['combo-1']);
   * ```
   * @apiCategory data
   */
  removeComboData(ids) {
    this.context.model.removeComboData(isFunction$1(ids) ? ids(this.getComboData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Get element type
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element type
   * @apiCategory element
   */
  getElementType(id2) {
    return this.context.model.getElementType(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get edge data related to the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @param direction - <zh/>  | <en/> edge direction
   * @returns <zh/>  | <en/> edge data
   * @apiCategory data
   */
  getRelatedEdgesData(id2, direction2 = "both") {
    return this.context.model.getRelatedEdgesData(id2, direction2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the one-hop neighbor node data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @returns <zh/>  | <en/> neighbor node data
   * @apiCategory data
   */
  getNeighborNodesData(id2) {
    return this.context.model.getNeighborNodesData(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the ancestor element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @param hierarchy - <zh/>  | <en/> specify tree or combo hierarchy relationship
   * @returns <zh/>  | <en/> ancestor element data
   * @remarks
   * <zh/> 
   *
   * <en/> The order in the array is from the parent node to the ancestor node
   * @apiCategory data
   */
  getAncestorsData(id2, hierarchy) {
    return this.context.model.getAncestorsData(id2, hierarchy);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the parent element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @param hierarchy - <zh/>  | <en/> specify tree or combo hierarchy relationship
   * @returns <zh/>  | <en/> parent element data
   * @apiCategory data
   */
  getParentData(id2, hierarchy) {
    return this.context.model.getParentData(id2, hierarchy);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the child element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @returns <zh/>  | <en/> child element data
   * @apiCategory data
   */
  getChildrenData(id2) {
    return this.context.model.getChildrenData(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the descendant element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @returns <zh/>  | <en/> descendant element data
   * @apiCategory data
   */
  getDescendantsData(id2) {
    return this.context.model.getDescendantsData(id2);
  }
  getElementDataByState(elementType, state) {
    return this.context.model.getElementDataByState(elementType, state);
  }
  initCanvas() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (this.context.canvas)
        return yield this.context.canvas.ready;
      const { container = "container", width: width2, height, renderer, cursor, background, canvas: canvasOptions, devicePixelRatio = (_a3 = globalThis.devicePixelRatio) !== null && _a3 !== void 0 ? _a3 : 1 } = this.options;
      if (container instanceof Canvas) {
        this.context.canvas = container;
        if (cursor)
          container.setCursor(cursor);
        if (renderer)
          container.setRenderer(renderer);
        yield container.ready;
      } else {
        const $container = isString$1(container) ? document.getElementById(container) : container;
        const containerSize = sizeOf($container);
        this.emit(GraphEvent.BEFORE_CANVAS_INIT, { container: $container, width: width2, height });
        const options = Object.assign(Object.assign({}, canvasOptions), {
          container: $container,
          width: width2 || containerSize[0],
          height: height || containerSize[1],
          background,
          renderer,
          cursor,
          devicePixelRatio
        });
        const canvas2 = new Canvas(options);
        this.context.canvas = canvas2;
        yield canvas2.ready;
        this.emit(GraphEvent.AFTER_CANVAS_INIT, { canvas: canvas2 });
      }
    });
  }
  updateCanvas(options) {
    var _a3, _b;
    const { renderer, cursor, height, width: width2 } = options;
    const canvas2 = this.context.canvas;
    if (!canvas2)
      return;
    if (renderer) {
      this.emit(GraphEvent.BEFORE_RENDERER_CHANGE, { renderer: this.options.renderer });
      canvas2.setRenderer(renderer);
      this.emit(GraphEvent.AFTER_RENDERER_CHANGE, { renderer });
    }
    if (cursor)
      canvas2.setCursor(cursor);
    if (isNumber(width2) || isNumber(height))
      this.setSize((_a3 = width2 !== null && width2 !== void 0 ? width2 : this.options.width) !== null && _a3 !== void 0 ? _a3 : 0, (_b = height !== null && height !== void 0 ? height : this.options.height) !== null && _b !== void 0 ? _b : 0);
  }
  initRuntime() {
    this.context.options = this.options;
    if (!this.context.batch)
      this.context.batch = new BatchController(this.context);
    if (!this.context.plugin)
      this.context.plugin = new PluginController(this.context);
    if (!this.context.viewport)
      this.context.viewport = new ViewportController(this.context);
    if (!this.context.transform)
      this.context.transform = new TransformController(this.context);
    if (!this.context.element)
      this.context.element = new ElementController(this.context);
    if (!this.context.animation)
      this.context.animation = new Animation(this.context);
    if (!this.context.layout)
      this.context.layout = new LayoutController(this.context);
    if (!this.context.behavior)
      this.context.behavior = new BehaviorController(this.context);
  }
  prepare() {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.resolve();
      if (this.destroyed) {
        console.error(format("The graph instance has been destroyed"));
        return;
      }
      yield this.initCanvas();
      this.initRuntime();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Render
   * @remarks
   * <zh/> 
   *
   * >  render  render  `await graph.render()`  GraphEvent.AFTER_RENDER 
   *
   * <en/> This process will execute data update, element rendering, and layout execution
   *
   * >  render is an asynchronous method. If you need to perform some operations after render, you can use `await graph.render()` or listen to the GraphEvent.AFTER_RENDER event
   * @apiCategory render
   */
  render() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.prepare();
      emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_RENDER));
      if (!this.options.layout) {
        const animation = this.context.element.draw({ type: "render" });
        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);
      } else if (!this.rendered && isPreLayout(this.options.layout)) {
        const animation = yield this.context.element.preLayoutDraw({ type: "render" });
        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);
      } else {
        const animation = this.context.element.draw({ type: "render" });
        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.context.layout.postLayout()]);
        yield this.autoFit();
      }
      this.rendered = true;
      emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_RENDER));
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Draw elements
   * @returns <zh/>  | <en/> draw result
   * @remarks
   * <zh/> 
   *
   * <zh/>  draw  draw  `await graph.draw()`  GraphEvent.AFTER_DRAW 
   *
   * <en/> Only execute element drawing, no re-layout
   *
   * <en/>  draw is an asynchronous method. If you need to perform some operations after draw, you can use `await graph.draw()` or listen to the GraphEvent.AFTER_DRAW event
   * @apiCategory render
   */
  draw() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield this.prepare();
      yield (_a3 = this.context.element.draw()) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Execute layout
   * @param layoutOptions - <zh/>  | <en/> Layout options
   * @apiCategory layout
   */
  layout(layoutOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.layout.postLayout(layoutOptions);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Stop layout
   * @remarks
   * <zh/>  `force` /
   *
   * <en/> Suitable for layouts with iterative animations. Currently, `force` belongs to this type of layout, that is, stop the iteration of the force-directed layout. It is generally used to manually stop the iteration animation when the layout iteration time is too long, such as calling in the click canvas/node listener
   * @apiCategory layout
   */
  stopLayout() {
    this.context.layout.stopLayout();
  }
  /**
   * <zh/> 
   *
   * <en/> Clear canvas elements
   * @apiCategory canvas
   */
  clear() {
    return __awaiter(this, void 0, void 0, function* () {
      const { model, element } = this.context;
      model.setData({});
      model.clearChanges();
      element === null || element === void 0 ? void 0 : element.clear();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the current graph instance
   * @remarks
   * <zh/> 
   *
   * <en/> After destruction, no operations can be performed. If you need to reuse it, you need to create a new graph instance
   * @apiCategory instance
   */
  destroy() {
    var _a3;
    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_DESTROY));
    const { layout: layout2, animation, element, model, canvas: canvas2, behavior, plugin } = this.context;
    plugin === null || plugin === void 0 ? void 0 : plugin.destroy();
    behavior === null || behavior === void 0 ? void 0 : behavior.destroy();
    layout2 === null || layout2 === void 0 ? void 0 : layout2.destroy();
    animation === null || animation === void 0 ? void 0 : animation.destroy();
    element === null || element === void 0 ? void 0 : element.destroy();
    model.destroy();
    canvas2 === null || canvas2 === void 0 ? void 0 : canvas2.destroy();
    this.options = {};
    this.context = {};
    this.off();
    (_a3 = globalThis.removeEventListener) === null || _a3 === void 0 ? void 0 : _a3.call(globalThis, "resize", this.onResize);
    this.destroyed = true;
    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_DESTROY));
  }
  /**
   * <zh/> 
   *
   * <en/> Get canvas instance
   * @returns - <zh/>  | <en/> canvas instance
   * @apiCategory canvas
   */
  getCanvas() {
    return this.context.canvas;
  }
  resize(width2, height) {
    var _a3;
    const containerSize = sizeOf((_a3 = this.context.canvas) === null || _a3 === void 0 ? void 0 : _a3.getContainer());
    const specificSize = [width2 || containerSize[0], height || containerSize[1]];
    if (!this.context.canvas)
      return;
    const canvasSize = this.context.canvas.getSize();
    if (isEqual$1(specificSize, canvasSize))
      return;
    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_SIZE_CHANGE, { size: specificSize }));
    this.context.canvas.resize(...specificSize);
    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_SIZE_CHANGE, { size: specificSize }));
  }
  /**
   * <zh/> 
   *
   * <en/> Zoom the graph to fit the viewport and move it to the center of the viewport
   * @param options - <zh/>  | <en/> fit options
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  fitView(options, animation) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield (_a3 = this.context.viewport) === null || _a3 === void 0 ? void 0 : _a3.fitView(options, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Move the graph to the center of the viewport
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  fitCenter(animation) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield (_a3 = this.context.viewport) === null || _a3 === void 0 ? void 0 : _a3.fitCenter({ animation });
    });
  }
  autoFit() {
    return __awaiter(this, void 0, void 0, function* () {
      const { autoFit } = this.context.options;
      if (!autoFit)
        return;
      if (isString$1(autoFit)) {
        if (autoFit === "view")
          yield this.fitView();
        else if (autoFit === "center")
          yield this.fitCenter();
      } else {
        const { type, animation } = autoFit;
        if (type === "view")
          yield this.fitView(autoFit.options, animation);
        else if (type === "center")
          yield this.fitCenter(animation);
      }
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Focus on element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> animation options
   * @remarks
   * <zh/> 
   *
   * <en/> Move the graph so that the element is aligned to the center of the viewport
   * @apiCategory viewport
   */
  focusElement(id2, animation) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield (_a3 = this.context.viewport) === null || _a3 === void 0 ? void 0 : _a3.focusElements(Array.isArray(id2) ? id2 : [id2], { animation });
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Zoom based on the current zoom ratio (relative zoom)
   * @param ratio - <zh/>  | <en/> zoom ratio
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> zoom center(viewport coordinates)
   * @remarks
   * <zh/>
   * - ratio > 1 
   * - ratio < 1 
   *
   * <en/>
   * - ratio > 1 zoom in
   * - ratio < 1 zoom out
   * @apiCategory viewport
   */
  zoomBy(ratio, animation, origin) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "relative", scale: ratio, origin }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Zoom the canvas to the specified ratio (absolute zoom)
   * @param zoom - <zh/>  | <en/> specified zoom ratio
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> zoom center(viewport coordinates)
   * @remarks
   * <zh/>
   * - zoom = 1 
   * - zoom > 1 
   * - zoom < 1 
   *
   * <en/>
   * - zoom = 1 default size
   * - zoom > 1 zoom in
   * - zoom < 1 zoom out
   * @apiCategory viewport
   */
  zoomTo(zoom, animation, origin) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "absolute", scale: zoom, origin }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the current zoom ratio
   * @returns <zh/>  | <en/> zoom ratio
   * @apiCategory viewport
   */
  getZoom() {
    return this.context.viewport.getZoom();
  }
  /**
   * <zh/> 
   *
   * <en/> Rotate based on the current rotation angle (relative rotation)
   * @param angle - <zh/>  | <en/> rotation angle
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> rotation center(viewport coordinates)
   * @apiCategory viewport
   */
  rotateBy(angle2, animation, origin) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "relative", rotate: angle2, origin }, animation);
    });
  }
  /**
   * <zh/>  ()
   *
   * <en/> Rotate the canvas to the specified angle (absolute rotation)
   * @param angle - <zh/>  | <en/> target angle
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> rotation center(viewport coordinates)
   * @apiCategory viewport
   */
  rotateTo(angle2, animation, origin) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "absolute", rotate: angle2, origin }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the current rotation angle
   * @returns <zh/>  | <en/> rotation angle
   * @apiCategory viewport
   */
  getRotation() {
    return this.context.viewport.getRotation();
  }
  /**
   * <zh/>  ()
   *
   * <en/> Translate the graph by the specified distance (relative translation)
   * @param offset - <zh/>  | <en/> offset
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  translateBy(offset, animation) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "relative", translate: offset }, animation);
    });
  }
  /**
   * <zh/>  ()
   *
   * <en/> Translate the graph to the specified position (absolute translation)
   * @param position - <zh/>  | <en/> specified position
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  translateTo(position2, animation) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "absolute", translate: position2 }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the position of the graph
   * @returns <zh/>  | <en/> position of the graph
   * @remarks
   * <zh/>  [0, 0]
   *
   * <en/> That is, the position of the canvas origin in the viewport coordinate system. By default, the position of the graph is [0, 0]
   * @apiCategory viewport
   */
  getPosition() {
    return subtract([0, 0], this.getCanvasByViewport([0, 0]));
  }
  translateElementBy(args1_1, args2_1) {
    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a3, _b;
      const [config, animation] = isObject$2(args1) ? [args1, (_a3 = args2) !== null && _a3 !== void 0 ? _a3 : true] : [{ [args1]: args2 }, args3];
      Object.entries(config).forEach(([id2, offset]) => this.context.model.translateNodeLikeBy(id2, offset));
      yield (_b = this.context.element.draw({ animation, stage: "translate" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  translateElementTo(args1_1, args2_1) {
    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a3, _b;
      const [config, animation] = isObject$2(args1) ? [args1, (_a3 = args2) !== null && _a3 !== void 0 ? _a3 : true] : [{ [args1]: args2 }, args3];
      Object.entries(config).forEach(([id2, position2]) => this.context.model.translateNodeLikeTo(id2, position2));
      yield (_b = this.context.element.draw({ animation, stage: "translate" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element position
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element position
   * @apiCategory element
   */
  getElementPosition(id2) {
    return this.context.model.getElementPosition(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get element rendering style
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element rendering style
   * @apiCategory element
   */
  getElementRenderStyle(id2) {
    return omit$1(this.context.element.getElement(id2).attributes, ["context"]);
  }
  setElementVisibility(args1_1, args2_1) {
    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a3, _b;
      const [config, animation] = isObject$2(args1) ? [args1, (_a3 = args2) !== null && _a3 !== void 0 ? _a3 : true] : [{ [args1]: args2 }, args3];
      const dataToUpdate = { nodes: [], edges: [], combos: [] };
      Object.entries(config).forEach(([id2, value]) => {
        const elementType = this.getElementType(id2);
        dataToUpdate[`${elementType}s`].push({ id: id2, style: { visibility: value } });
      });
      const { model, element } = this.context;
      model.preventUpdateNodeLikeHierarchy(() => {
        model.updateData(dataToUpdate);
      });
      yield (_b = element.draw({ animation, stage: "visibility" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Show element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> whether to enable animation
   * @apiCategory element
   */
  showElement(id2, animation) {
    return __awaiter(this, void 0, void 0, function* () {
      const ids = Array.isArray(id2) ? id2 : [id2];
      yield this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, "visible"])), animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Hide element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> whether to enable animation
   * @apiCategory element
   */
  hideElement(id2, animation) {
    return __awaiter(this, void 0, void 0, function* () {
      const ids = Array.isArray(id2) ? id2 : [id2];
      yield this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, "hidden"])), animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element visibility
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element visibility
   * @apiCategory element
   */
  getElementVisibility(id2) {
    var _a3, _b;
    const element = this.context.element.getElement(id2);
    return (_b = (_a3 = element === null || element === void 0 ? void 0 : element.style) === null || _a3 === void 0 ? void 0 : _a3.visibility) !== null && _b !== void 0 ? _b : "visible";
  }
  setElementZIndex(args1, args2) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const dataToUpdate = { nodes: [], edges: [], combos: [] };
      const config = isObject$2(args1) ? args1 : { [args1]: args2 };
      Object.entries(config).forEach(([id2, value]) => {
        const elementType = this.getElementType(id2);
        dataToUpdate[`${elementType}s`].push({ id: id2, style: { zIndex: value } });
      });
      const { model, element } = this.context;
      model.preventUpdateNodeLikeHierarchy(() => model.updateData(dataToUpdate));
      yield (_a3 = element.draw({ animation: false, stage: "zIndex" })) === null || _a3 === void 0 ? void 0 : _a3.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Bring the element to the front
   * @param id - <zh/>  ID | <en/> element ID
   * @apiCategory element
   */
  frontElement(id2) {
    return __awaiter(this, void 0, void 0, function* () {
      const ids = Array.isArray(id2) ? id2 : [id2];
      const { model } = this.context;
      const zIndexes = {};
      ids.map((_id) => {
        const zIndex2 = model.getFrontZIndex(_id);
        const elementType = model.getElementType(_id);
        if (elementType === "combo") {
          const ancestor = model.getAncestorsData(_id, COMBO_KEY).at(-1) || this.getComboData(_id);
          const descendants = [ancestor, ...model.getDescendantsData(idOf(ancestor))];
          const delta = zIndex2 - getZIndexOf(ancestor);
          descendants.forEach((combo) => {
            zIndexes[idOf(combo)] = this.getElementZIndex(idOf(combo)) + delta;
          });
          const { internal } = getSubgraphRelatedEdges(descendants.map(idOf), (id3) => model.getRelatedEdgesData(id3));
          internal.forEach((edge) => {
            const edgeId = idOf(edge);
            zIndexes[edgeId] = this.getElementZIndex(edgeId) + delta;
          });
        } else
          zIndexes[_id] = zIndex2;
      });
      yield this.setElementZIndex(zIndexes);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element z-index
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element z-index
   * @apiCategory element
   */
  getElementZIndex(id2) {
    return getZIndexOf(this.context.model.getElementDataById(id2));
  }
  setElementState(args1_1, args2_1) {
    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a3, _b;
      const [config, animation] = isObject$2(args1) ? [args1, (_a3 = args2) !== null && _a3 !== void 0 ? _a3 : true] : [{ [args1]: args2 }, args3];
      const parseState = (state) => {
        if (!state)
          return [];
        return Array.isArray(state) ? state : [state];
      };
      const dataToUpdate = { nodes: [], edges: [], combos: [] };
      Object.entries(config).forEach(([id2, value]) => {
        const elementType = this.getElementType(id2);
        dataToUpdate[`${elementType}s`].push({ id: id2, states: parseState(value) });
      });
      this.updateData(dataToUpdate);
      yield (_b = this.context.element.draw({ animation, stage: "state" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element state
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element state
   * @apiCategory element
   */
  getElementState(id2) {
    return this.context.model.getElementState(id2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the rendering bounding box of the element itself and its child nodes in the world coordinate system
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> render bounding box
   * @apiCategory element
   */
  getElementRenderBounds(id2) {
    return this.context.element.getElement(id2).getRenderBounds();
  }
  /**
   * <zh/> 
   *
   * <en/> Collapse element
   * @param id - <zh/>  ID | <en/> element ID
   * @param options - <zh/>  | <en/> whether to enable animation or the options of collapsing node
   * @apiCategory element
   */
  collapseElement(id_1) {
    return __awaiter(this, arguments, void 0, function* (id2, options = true) {
      const { model, element } = this.context;
      if (isCollapsed(model.getNodeLikeData([id2])[0]))
        return;
      if (this.isCollapsingExpanding)
        return;
      if (typeof options === "boolean")
        options = { animation: options, align: false };
      const elementType = model.getElementType(id2);
      yield this.frontElement(id2);
      this.isCollapsingExpanding = true;
      model.updateData(elementType === "node" ? {
        nodes: [{ id: id2, style: { collapsed: true } }]
      } : {
        combos: [{ id: id2, style: { collapsed: true } }]
      });
      if (elementType === "node")
        yield element.collapseNode(id2, options);
      else if (elementType === "combo")
        yield element.collapseCombo(id2, !!options.animation);
      this.isCollapsingExpanding = false;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Expand Element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> whether to enable animation or the options of collapsing node
   * @param options
   * @apiCategory element
   */
  expandElement(id_1) {
    return __awaiter(this, arguments, void 0, function* (id2, options = true) {
      const { model, element } = this.context;
      if (!isCollapsed(model.getNodeLikeData([id2])[0]))
        return;
      if (this.isCollapsingExpanding)
        return;
      if (typeof options === "boolean")
        options = { animation: options, align: false };
      const elementType = model.getElementType(id2);
      this.isCollapsingExpanding = true;
      model.updateData(elementType === "node" ? {
        nodes: [{ id: id2, style: { collapsed: false } }]
      } : {
        combos: [{ id: id2, style: { collapsed: false } }]
      });
      if (elementType === "node")
        yield element.expandNode(id2, options);
      else if (elementType === "combo")
        yield element.expandCombo(id2, !!options.animation);
      this.isCollapsingExpanding = false;
    });
  }
  setElementCollapsibility(id2, collapsed) {
    const elementType = this.getElementType(id2);
    if (elementType === "node")
      this.updateNodeData([{ id: id2, style: { collapsed } }]);
    else if (elementType === "combo")
      this.updateComboData([{ id: id2, style: { collapsed } }]);
  }
  /**
   * <zh/>  DataURL
   *
   * <en/> Export canvas content as DataURL
   * @param options - <zh/>  | <en/> export options
   * @returns <zh/> DataURL | <en/> DataURL
   * @apiCategory exportImage
   */
  toDataURL() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return this.context.canvas.toDataURL(options);
    });
  }
  /**
   * <zh/>  DOM 
   *
   * <en/> Convert the given viewport DOM coordinates to the drawing coordinates on the canvas
   * @param point - <zh/>  | <en/> viewport coordinates
   * @returns <zh/>  | <en/> drawing coordinates on the canvas
   * @apiCategory viewport
   */
  getCanvasByViewport(point2) {
    return this.context.canvas.getCanvasByViewport(point2);
  }
  /**
   * <zh/>  DOM 
   *
   * <en/> Convert the given drawing coordinates on the canvas to the coordinates of the viewport DOM
   * @param point - <zh/>  | <en/> canvas coordinates
   * @returns <zh/>  DOM  | <en/> coordinates of the viewport DOM
   * @apiCategory viewport
   */
  getViewportByCanvas(point2) {
    return this.context.canvas.getViewportByCanvas(point2);
  }
  /**
   * <zh/> 
   *
   * <en/> Convert the given drawing coordinates on the canvas to browser coordinates
   * @param point - <zh/>  | <en/> canvas coordinates
   * @returns <zh/>  | <en/> browser coordinates
   * @apiCategory viewport
   */
  getClientByCanvas(point2) {
    return this.context.canvas.getClientByCanvas(point2);
  }
  /**
   * <zh/> 
   *
   * <en/> Convert the given browser coordinates to drawing coordinates on the canvas
   * @param point - <zh/>  | <en/> browser coordinates
   * @returns <zh/>  | <en/> drawing coordinates on the canvas
   * @apiCategory viewport
   */
  getCanvasByClient(point2) {
    return this.context.canvas.getCanvasByClient(point2);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the canvas coordinates of the viewport center
   * @returns <zh/>  | <en/> Canvas coordinates of the viewport center
   * @apiCategory viewport
   */
  getViewportCenter() {
    return this.context.viewport.getViewportCenter();
  }
  /**
   * <zh/> 
   *
   * <en/> Get the viewport coordinates of the viewport center
   * @returns <zh/>  | <en/> Viewport coordinates of the viewport center
   * @apiCategory viewport
   */
  getCanvasCenter() {
    return this.context.viewport.getCanvasCenter();
  }
  /**
   * <zh/> 
   *
   * <en/> Listen to events
   * @param eventName - <zh/>  | <en/> event name
   * @param callback - <zh/>  | <en/> callback function
   * @param once - <zh/>  | <en/> whether to listen only once
   * @returns <zh/> Graph  | <en/> Graph instance
   * @apiCategory event
   */
  on(eventName, callback, once) {
    return super.on(eventName, callback, once);
  }
  /**
   * <zh/> 
   *
   * <en/> Listen to events once
   * @param eventName - <zh/>  | <en/> event name
   * @param callback - <zh/>  | <en/> callback function
   * @returns <zh/> Graph  | <en/> Graph instance
   * @apiCategory event
   */
  once(eventName, callback) {
    return super.once(eventName, callback);
  }
  off(eventName, callback) {
    return super.off(eventName, callback);
  }
}
Graph2.defaultOptions = {
  autoResize: false,
  theme: "light",
  rotation: 0,
  zoom: 1,
  zoomRange: [0.01, 10]
};
(function(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
});
class GetEdgeActualEnds extends BaseTransform {
  beforeDraw(input) {
    const { add: add2, update } = input;
    const { model } = this.context;
    [...add2.edges.entries(), ...update.edges.entries()].forEach(([, edge]) => {
      getEdgeEndsContext(model, edge);
    });
    return input;
  }
}
const getEdgeEndsContext = (model, edge) => {
  const { source, target } = edge;
  const sourceNodeData = model.getElementDataById(source);
  const targetNodeData = model.getElementDataById(target);
  const actualSourceNode = findActualConnectNodeData(sourceNodeData, (id2) => model.getParentData(id2, COMBO_KEY));
  const actualTargetNode = findActualConnectNodeData(targetNodeData, (id2) => model.getParentData(id2, COMBO_KEY));
  const sourceNode = idOf(actualSourceNode);
  const targetNode = idOf(actualTargetNode);
  const ends = { sourceNode, targetNode };
  if (edge.style) {
    Object.assign(edge.style, ends);
  } else
    edge.style = ends;
  return edge;
};
const linear3 = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  if (d1 === d0)
    return r0;
  const ratio = (value - d0) / (d1 - d0);
  return r0 + ratio * (r1 - r0);
};
const log = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.log(value - d0 + 1) / Math.log(d1 - d0 + 1);
  return r0 + ratio * (r1 - r0);
};
const pow = (value, domain, range, exponent = 2) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.pow((value - d0) / (d1 - d0), exponent);
  return r0 + ratio * (r1 - r0);
};
const sqrt = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.sqrt((value - d0) / (d1 - d0));
  return r0 + ratio * (r1 - r0);
};
class MapNodeSize extends BaseTransform {
  constructor(context, options) {
    super(context, deepMix({}, MapNodeSize.defaultOptions, options));
    this.assignSizeByCentrality = (centrality, minCentrality, maxCentrality, minSize, maxSize, scale3) => {
      const domain = [minCentrality, maxCentrality];
      const rangeX = [minSize[0], maxSize[0]];
      const rangeY = [minSize[1], maxSize[1]];
      const rangeZ = [minSize[2], maxSize[2]];
      const interpolate2 = (centrality2, range) => {
        if (typeof scale3 === "function") {
          return scale3(centrality2, domain, range);
        }
        switch (scale3) {
          case "linear":
            return linear3(centrality2, domain, range);
          case "log":
            return log(centrality2, domain, range);
          case "pow":
            return pow(centrality2, domain, range, 2);
          case "sqrt":
            return sqrt(centrality2, domain, range);
          default:
            return range[0];
        }
      };
      return [interpolate2(centrality, rangeX), interpolate2(centrality, rangeY), interpolate2(centrality, rangeZ)];
    };
  }
  beforeDraw(input) {
    const { model } = this.context;
    const nodes = model.getNodeData();
    const maxSize = parseSize$1(this.options.maxSize);
    const minSize = parseSize$1(this.options.minSize);
    const centralities = this.getCentralities(this.options.centrality);
    const maxCentrality = centralities.size > 0 ? Math.max(...centralities.values()) : 0;
    const minCentrality = centralities.size > 0 ? Math.min(...centralities.values()) : 0;
    nodes.forEach((datum) => {
      var _a3;
      const size = this.assignSizeByCentrality(centralities.get(idOf(datum)) || 0, minCentrality, maxCentrality, minSize, maxSize, this.options.scale);
      const element = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(idOf(datum));
      const style = { size };
      this.assignLabelStyle(style, size, datum, element);
      if (!element || !isStyleEqual(style, element.attributes)) {
        reassignTo(input, element ? "update" : "add", "node", deepMix(datum, { style }), true);
      }
    });
    return input;
  }
  assignLabelStyle(style, size, datum, element) {
    var _a3;
    const configStyle = element ? element.config.style : (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElementComputedStyle("node", datum);
    Object.assign(style, pick(configStyle, ["labelFontSize", "labelLineHeight"]));
    if (this.options.mapLabelSize) {
      const fontSize2 = this.getLabelSizeByNodeSize(size, Infinity, Number(style.labelFontSize));
      Object.assign(style, {
        labelFontSize: fontSize2,
        labelLineHeight: fontSize2 + getVerticalPadding(style.labelPadding)
      });
    }
    return style;
  }
  getLabelSizeByNodeSize(size, defaultMaxFontSize, defaultMinFontSize) {
    const fontSize2 = Math.min(...size) / 2;
    const [minFontSize, maxFontSize] = !Array.isArray(this.options.mapLabelSize) ? [defaultMinFontSize, defaultMaxFontSize] : this.options.mapLabelSize;
    return Math.min(maxFontSize, Math.max(fontSize2, minFontSize));
  }
  getCentralities(centrality) {
    const { model } = this.context;
    const graphData = model.getData();
    if (typeof centrality === "function")
      return centrality(graphData);
    const getRelatedEdgesData = model.getRelatedEdgesData.bind(model);
    return getNodeCentralities(graphData, getRelatedEdgesData, centrality);
  }
}
MapNodeSize.defaultOptions = {
  centrality: { type: "degree" },
  maxSize: 80,
  minSize: 20,
  scale: "linear",
  mapLabelSize: false
};
class PlaceRadialLabels extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, PlaceRadialLabels.defaultOptions, options));
  }
  get ref() {
    return this.context.model.getRootsData()[0];
  }
  afterLayout() {
    var _a3;
    const refPoint = positionOf(this.ref);
    const { graph: graph2, model } = this.context;
    const data2 = model.getData();
    (_a3 = data2.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach((datum) => {
      var _a4;
      if (idOf(datum) === idOf(this.ref))
        return;
      const radian = rad2(subtract(positionOf(datum), refPoint));
      const isLeft = Math.abs(radian) > Math.PI / 2;
      const isLeaf = !datum.children || datum.children.length === 0;
      const nodeId = idOf(datum);
      const node = (_a4 = this.context.element) === null || _a4 === void 0 ? void 0 : _a4.getElement(nodeId);
      if (!node || !node.isVisible())
        return;
      const nodeHalfWidth = parseSize$1(graph2.getElementRenderStyle(nodeId).size)[0] / 2;
      const offset = (isLeaf ? 1 : -1) * (nodeHalfWidth + this.options.offset);
      const labelTransform = [
        ["translate", offset * Math.cos(radian), offset * Math.sin(radian)],
        ["rotate", isLeft ? rad2deg(radian) + 180 : rad2deg(radian)]
      ];
      model.updateNodeData([
        {
          id: idOf(datum),
          style: {
            labelTextAlign: isLeft === isLeaf ? "right" : "left",
            labelTextBaseline: "middle",
            labelTransform
          }
        }
      ]);
    });
    graph2.draw();
  }
}
PlaceRadialLabels.defaultOptions = {
  offset: 5
};
const CUBIC_EDGE_TYPE = "quadratic";
const CUBIC_LOOP_PLACEMENTS = [
  "top",
  "top-right",
  "right",
  "right-bottom",
  "bottom",
  "bottom-left",
  "left",
  "left-top"
];
class ProcessParallelEdges extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, ProcessParallelEdges.defaultOptions, options));
    this.cacheMergeStyle = /* @__PURE__ */ new Map();
    this.getAffectedParallelEdges = (input) => {
      const { add: { edges: edgesToAdd }, update: { nodes: nodesToUpdate, edges: edgesToUpdate, combos: combosToUpdate }, remove: { edges: edgesToRemove } } = input;
      const { model } = this.context;
      const edges = /* @__PURE__ */ new Map();
      const addRelatedEdges = (_2, id2) => {
        const relatedEdgesData = model.getRelatedEdgesData(id2);
        relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));
      };
      nodesToUpdate.forEach(addRelatedEdges);
      combosToUpdate.forEach(addRelatedEdges);
      const pushParallelEdges = (edge) => {
        const removedEdgeIds = new Set(input.remove.edges.keys());
        const validEdgeData = model.getEdgeData().filter((edge2) => !removedEdgeIds.has(idOf(edge2))).map((edge2) => getEdgeEndsContext(model, edge2));
        getParallelEdges(edge, validEdgeData).forEach((e3) => {
          const id2 = idOf(e3);
          if (!edges.has(id2))
            edges.set(id2, e3);
        });
      };
      if (edgesToRemove.size)
        edgesToRemove.forEach(pushParallelEdges);
      if (edgesToAdd.size)
        edgesToAdd.forEach(pushParallelEdges);
      if (edgesToUpdate.size) {
        const changes = groupByChangeType(reduceDataChanges(model.getChanges())).update.edges;
        edgesToUpdate.forEach((edge) => {
          var _a3;
          pushParallelEdges(edge);
          const originalEdge = (_a3 = changes.find((e3) => idOf(e3.value) === idOf(edge))) === null || _a3 === void 0 ? void 0 : _a3.original;
          if (originalEdge && !isParallelEdges(edge, originalEdge)) {
            pushParallelEdges(originalEdge);
          }
        });
      }
      if (!isEmpty(this.options.edges)) {
        edges.forEach((_2, id2) => !this.options.edges.includes(id2) && edges.delete(id2));
      }
      const edgeIds = model.getEdgeData().map(idOf);
      return new Map([...edges].sort((a2, b2) => edgeIds.indexOf(a2[0]) - edgeIds.indexOf(b2[0])));
    };
    this.applyBundlingStyle = (input, edges, distance2) => {
      const { edgeMap, reverses } = groupByEndpoints(edges);
      edgeMap.forEach((arcEdges) => {
        arcEdges.forEach((edge, i2, edgeArr) => {
          var _a3;
          const length2 = edgeArr.length;
          const style = edge.style || {};
          if (edge.source === edge.target) {
            const len2 = CUBIC_LOOP_PLACEMENTS.length;
            style.loopPlacement = CUBIC_LOOP_PLACEMENTS[i2 % len2];
            style.loopDist = Math.floor(i2 / len2) * distance2 + 50;
          } else if (length2 === 1) {
            style.curveOffset = 0;
          } else {
            const sign = (i2 % 2 === 0 ? 1 : -1) * (reverses[`${edge.source}|${edge.target}|${i2}`] ? -1 : 1);
            style.curveOffset = length2 % 2 === 1 ? sign * Math.ceil(i2 / 2) * distance2 * 2 : sign * (Math.floor(i2 / 2) * distance2 * 2 + distance2);
          }
          const mergedEdgeData = Object.assign(edge, { type: CUBIC_EDGE_TYPE, style });
          const element = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(idOf(edge));
          if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {
            reassignTo(input, element ? "update" : "add", "edge", mergedEdgeData, true);
          }
        });
      });
    };
    this.resetEdgeStyle = (edge) => {
      const style = edge.style || {};
      const cacheStyle2 = this.cacheMergeStyle.get(idOf(edge)) || {};
      Object.keys(cacheStyle2).forEach((key) => {
        if (isEqual$1(style[key], cacheStyle2[key])) {
          if (edge[key]) {
            style[key] = edge[key];
          } else {
            delete style[key];
          }
        }
      });
      return Object.assign(edge, { style });
    };
    this.applyMergingStyle = (input, edges) => {
      const { edgeMap, reverses } = groupByEndpoints(edges);
      edgeMap.forEach((edges2) => {
        var _a3;
        if (edges2.length === 1) {
          const edge = edges2[0];
          const element = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(idOf(edge));
          const edgeStyle = this.resetEdgeStyle(edge);
          if (!element || !isStyleEqual(edgeStyle, element.attributes)) {
            reassignTo(input, element ? "update" : "add", "edge", edgeStyle);
          }
          return;
        }
        const mergedStyle = edges2.map(({ source, target, style = {} }, i2) => {
          const { startArrow, endArrow } = style;
          const newStyle = {};
          const [start, end] = reverses[`${source}|${target}|${i2}`] ? ["endArrow", "startArrow"] : ["startArrow", "endArrow"];
          if (isBoolean(startArrow))
            newStyle[start] = startArrow;
          if (isBoolean(endArrow))
            newStyle[end] = endArrow;
          return newStyle;
        }).reduce((acc, style) => Object.assign(Object.assign({}, acc), style), {});
        edges2.forEach((edge, i2, edges3) => {
          var _a4;
          if (i2 !== 0) {
            reassignTo(input, "remove", "edge", edge);
            return;
          }
          const parsedStyle = Object.assign({}, isFunction$1(this.options.style) ? this.options.style(edges3) : this.options.style, { childrenData: edges3 });
          this.cacheMergeStyle.set(idOf(edge), parsedStyle);
          const mergedEdgeData = Object.assign(Object.assign({}, edge), { type: "line", style: Object.assign(Object.assign(Object.assign({}, edge.style), mergedStyle), parsedStyle) });
          const element = (_a4 = this.context.element) === null || _a4 === void 0 ? void 0 : _a4.getElement(idOf(edge));
          if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {
            reassignTo(input, element ? "update" : "add", "edge", mergedEdgeData, true);
          }
        });
      });
    };
  }
  /**
   * <zh/> 
   *
   * <en/> Process parallel edges before each drawing
   * @param input
   */
  beforeDraw(input) {
    const edges = this.getAffectedParallelEdges(input);
    if (edges.size === 0)
      return input;
    this.options.mode === "bundle" ? this.applyBundlingStyle(input, edges, this.options.distance) : this.applyMergingStyle(input, edges);
    return input;
  }
}
ProcessParallelEdges.defaultOptions = {
  mode: "bundle",
  distance: 15
  // only valid for bundling mode
};
const groupByEndpoints = (edges) => {
  const edgeMap = /* @__PURE__ */ new Map();
  const processedEdgesSet = /* @__PURE__ */ new Set();
  const reverses = {};
  const includedEdgesInGroup = /* @__PURE__ */ new Map();
  for (const [id2, edge] of edges) {
    if (processedEdgesSet.has(id2))
      continue;
    const { source, target } = edge;
    const sourceTarget = `${source}-${target}`;
    if (!edgeMap.has(sourceTarget)) {
      edgeMap.set(sourceTarget, []);
      includedEdgesInGroup.set(sourceTarget, /* @__PURE__ */ new Set());
    }
    const sourceTargetEdges = edgeMap.get(sourceTarget);
    const includedEdges = includedEdgesInGroup.get(sourceTarget);
    if (sourceTargetEdges && includedEdges && !includedEdges.has(id2)) {
      sourceTargetEdges.push(edge);
      includedEdges.add(id2);
      processedEdgesSet.add(id2);
    }
    for (const [otherId, sedge] of edges) {
      if (processedEdgesSet.has(otherId) || otherId === id2)
        continue;
      if (isParallelEdges(edge, sedge)) {
        const groupEdges = edgeMap.get(sourceTarget);
        const includedGroupEdges = includedEdgesInGroup.get(sourceTarget);
        if (groupEdges && includedGroupEdges && !includedGroupEdges.has(otherId)) {
          groupEdges.push(sedge);
          includedGroupEdges.add(otherId);
          if (source === sedge.target && target === sedge.source) {
            reverses[`${sedge.source}|${sedge.target}|${groupEdges.length - 1}`] = true;
          }
          processedEdgesSet.add(otherId);
        }
      }
    }
  }
  return { edgeMap, reverses };
};
const getParallelEdges = (edge, edges, containsSelf) => {
  return edges.filter((e3) => isParallelEdges(e3, edge));
};
const isParallelEdges = (edge1, edge2) => {
  const { sourceNode: src1, targetNode: tgt1 } = edge1.style || {};
  const { sourceNode: src2, targetNode: tgt2 } = edge2.style || {};
  return src1 === src2 && tgt1 === tgt2 || src1 === tgt2 && tgt1 === src2;
};
class UpdateRelatedEdge extends BaseTransform {
  beforeDraw(input, context) {
    const { stage } = context;
    if (stage === "visibility")
      return input;
    const { model } = this.context;
    const { update: { nodes, edges, combos } } = input;
    const addRelatedEdges = (_2, id2) => {
      const relatedEdgesData = model.getRelatedEdgesData(id2);
      relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));
    };
    nodes.forEach(addRelatedEdges);
    combos.forEach(addRelatedEdges);
    return input;
  }
}
const BUILT_IN_EXTENSIONS = {
  animation: {
    "combo-collapse": ComboCollapse,
    "combo-expand": ComboExpand,
    "node-collapse": NodeCollapse,
    "node-expand": NodeExpand,
    "path-in": PathIn,
    "path-out": PathOut,
    fade: Fade,
    translate: Translate
  },
  behavior: {
    "brush-select": BrushSelect,
    "click-select": ClickSelect,
    "collapse-expand": CollapseExpand,
    "create-edge": CreateEdge,
    "drag-canvas": DragCanvas,
    "drag-element-force": DragElementForce,
    "drag-element": DragElement,
    "fix-element-size": FixElementSize,
    "focus-element": FocusElement,
    "hover-activate": HoverActivate,
    "lasso-select": LassoSelect,
    "auto-adapt-label": AutoAdaptLabel,
    "optimize-viewport-transform": OptimizeViewportTransform,
    "scroll-canvas": ScrollCanvas,
    "zoom-canvas": ZoomCanvas
  },
  combo: {
    circle: CircleCombo,
    rect: RectCombo
  },
  edge: {
    cubic: Cubic2,
    line: Line$1,
    polyline: Polyline,
    quadratic: Quadratic,
    "cubic-horizontal": CubicHorizontal,
    "cubic-radial": CubicRadial,
    "cubic-vertical": CubicVertical
  },
  layout: {
    "antv-dagre": AntVDagreLayout,
    "combo-combined": ComboCombinedLayout,
    "compact-box": H,
    "d3-force": D3ForceLayout,
    "force-atlas2": ForceAtlas2Layout,
    circular: CircularLayout,
    concentric: ConcentricLayout,
    dagre: DagreLayout,
    dendrogram: S$1,
    fishbone: FishboneLayout,
    force: ForceLayout,
    fruchterman: FruchtermanLayout,
    grid: GridLayout,
    indented: C2,
    mds: MDSLayout,
    mindmap: F,
    radial: RadialLayout,
    random: RandomLayout,
    snake: SnakeLayout
  },
  node: {
    circle: Circle$1,
    diamond: Diamond,
    ellipse: Ellipse,
    hexagon: Hexagon,
    html: HTML,
    image: Image$1,
    rect: Rect,
    star: Star,
    donut: Donut,
    triangle: Triangle
  },
  palette: {
    spectral,
    tableau,
    oranges,
    greens,
    blues
  },
  theme: {
    dark,
    light
  },
  plugin: {
    "bubble-sets": BubbleSets2,
    "edge-bundling": EdgeBundling,
    "edge-filter-lens": EdgeFilterLens,
    "grid-line": GridLine,
    background: Background,
    contextmenu: Contextmenu,
    fisheye: Fisheye,
    fullscreen: Fullscreen,
    history: History,
    hull: Hull,
    legend: Legend,
    minimap: Minimap,
    snapline: Snapline,
    timebar: Timebar,
    title: Title,
    toolbar: Toolbar,
    tooltip: Tooltip,
    watermark: Watermark
  },
  transform: {
    "arrange-draw-order": ArrangeDrawOrder,
    "collapse-expand-combo": CollapseExpandCombo,
    "collapse-expand-node": CollapseExpandNode,
    "get-edge-actual-ends": GetEdgeActualEnds,
    "map-node-size": MapNodeSize,
    "place-radial-labels": PlaceRadialLabels,
    "process-parallel-edges": ProcessParallelEdges,
    "update-related-edges": UpdateRelatedEdge
  },
  shape: {
    circle: Circle$2,
    ellipse: Ellipse$1,
    group: Group,
    html: HTML$1,
    image: Image$2,
    line: Line$2,
    path: Path,
    polygon: Polygon$1,
    polyline: Polyline$1,
    rect: Rect$1,
    text: Text$1,
    label: Label,
    badge: Badge
  }
};
function registerBuiltInExtensions() {
  Object.entries(BUILT_IN_EXTENSIONS).forEach(([category, extensions]) => {
    Object.entries(extensions).forEach(([type, extension]) => {
      register(category, type, extension);
    });
  });
}
registerBuiltInExtensions();
export {
  Graph2 as G,
  _setPrototypeOf as _,
  timeout as a,
  forceSimulation as b,
  forceLink as c,
  dispatch as d,
  forceManyBody as e,
  forceRadial as f,
  forceCenter as g,
  forceManyBody$1 as h,
  forceLink$1 as i,
  forceCollide as j,
  _isNativeReflectConstruct as k,
  _getPrototypeOf as l,
  _assertThisInitialized as m,
  now as n,
  timer as t
};
